<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<rules>
   <builtin>
      <category description="DISA ASD STIG" name="APSC_DV">
         <category description="APSC_DV-002550 应用程序不能受到面向 XML 的攻击。" name="002550">
            <rule header="禁止使用来自不信任用户的未经过滤的数据作为格式化参数" id="d" impl="SECURITY-36" originalId="SECURITY-36" quickfix="false" scope="line" severity="1">
               <file path="SECURITY\SECURITY-36.rule"/>
            </rule>
            <rule header="不可信任数据用作循环边界" id="k" impl="SECURITY-38" originalId="SECURITY-38" quickfix="false" scope="line" severity="1">
               <file path="SECURITY\SECURITY-38.rule"/>
            </rule>
         </category>
         <category description="APSC_DV-002560 应用程序不得受到输入处理漏洞的影响。" name="002560">
            <rule header="禁止使用来自不信任用户的未经过滤的数据作为格式化参数" id="d" impl="SECURITY-36" originalId="SECURITY-36" quickfix="false" scope="line" severity="1">
               <file path="SECURITY\SECURITY-36.rule"/>
            </rule>
            <rule header="不可信任数据用作循环边界" id="k" impl="SECURITY-38" originalId="SECURITY-38" quickfix="false" scope="line" severity="1">
               <file path="SECURITY\SECURITY-38.rule"/>
            </rule>
         </category>
         <category description="APSC_DV-003110 应用程序不得包含嵌入的身份验证数据。" name="003110">
            <rule header="不要硬编码字符串字面量" id="a" impl="CODSTA-203" originalId="CODSTA-203" quickfix="false" scope="line" severity="1">
               <file path="CODSTA\CODSTA-203.rule"/>
            </rule>
         </category>
         <category description="APSC_DV-000160 应用程序必须实施 DoD 批准的加密，以保护远程访问会话的机密性。" name="000160">
            <rule header="请勿使用弱加密功能" id="a" impl="SECURITY-37" originalId="SECURITY-37" quickfix="false" scope="line" severity="2">
               <file path="SECURITY\SECURITY-37.rule"/>
            </rule>
         </category>
         <category description="APSC_DV-000170 应用程序必须实施加密机制来保护远程访问会话的完整性。" name="000170">
            <rule header="请勿使用弱加密功能" id="a" impl="SECURITY-37" originalId="SECURITY-37" quickfix="false" scope="line" severity="2">
               <file path="SECURITY\SECURITY-37.rule"/>
            </rule>
         </category>
         <category description="APSC_DV-000500 应用程序必须防止非特权用户执行特权功能，包括禁用、规避或更改已实施的安全保护措施/对策。" name="000500">
            <rule header="在放弃特权时遵守正确的撤销命令" id="a" impl="SECURITY-44" originalId="SECURITY-44" quickfix="false" scope="line" severity="2">
               <file path="SECURITY\SECURITY-44.rule"/>
            </rule>
         </category>
         <category description="APSC_DV-000650 应用程序不得将敏感数据写入应用程序日志。" name="000650">
            <rule header="不要将应用程序错误导致的潜在敏感信息打印到异常消息中" id="a" impl="SECURITY-15" originalId="SECURITY-15" quickfix="false" scope="line" severity="2">
               <file path="SECURITY\SECURITY-15.rule"/>
            </rule>
         </category>
         <category description="APSC_DV-001290 应用程序必须保护审查信息免受未经授权的修改。" name="001290">
            <rule header="不可信任数据用作循环边界" id="b" impl="SECURITY-38" originalId="SECURITY-38" quickfix="false" scope="line" severity="2">
               <file path="SECURITY\SECURITY-38.rule"/>
            </rule>
            <rule header="避免将用户的输入作为参数传递给方法" id="c" impl="SECURITY-20" originalId="SECURITY-20" quickfix="false" scope="line" severity="2">
               <file path="SECURITY\SECURITY-20.rule"/>
            </rule>
            <rule header="避免使用可能受到 shell 元字符影响的不安全 shell 函数" id="d" impl="SECURITY-11" originalId="SECURITY-11" quickfix="false" scope="line" severity="2">
               <file path="SECURITY\SECURITY-11.rule"/>
            </rule>
         </category>
         <category description="APSC_DV-001860 应用程序必须使用满足适用联邦法律、执行命令、指令、政策、法规、标准和指南要求的机制，以对加密模块进行身份验证。" name="001860">
            <rule header="请勿使用弱加密功能" id="a" impl="SECURITY-37" originalId="SECURITY-37" quickfix="false" scope="line" severity="2">
               <file path="SECURITY\SECURITY-37.rule"/>
            </rule>
         </category>
         <category description="APSC_DV-001995 应用程序不受竞争条件的影响。" name="001995">
            <rule header="避免使用对线程不安全(thread-unsafe)的函数" id="f" impl="SECURITY-25" originalId="SECURITY-25" quickfix="false" scope="line" severity="2">
               <file path="SECURITY\SECURITY-25.rule"/>
            </rule>
            <rule header="不允许使用容易发生竞争的功能" id="g" impl="SECURITY-19" originalId="SECURITY-19" quickfix="false" scope="line" severity="2">
               <file path="SECURITY\SECURITY-19.rule"/>
            </rule>
            <rule header="避免使用 'vfork()' 函数" id="h" impl="SECURITY-10" originalId="SECURITY-10" quickfix="false" scope="line" severity="2">
               <file path="SECURITY\SECURITY-10.rule"/>
            </rule>
         </category>
         <category description="APSC_DV-002010 应用程序必须实施 NSA 批准的加密技术，以根据适用的联邦法律、执行命令、指令、政策、法规和标准保护机密信息。" name="002010">
            <rule header="请勿使用弱加密功能" id="a" impl="SECURITY-37" originalId="SECURITY-37" quickfix="false" scope="line" severity="2">
               <file path="SECURITY\SECURITY-37.rule"/>
            </rule>
         </category>
         <category description="APSC_DV-002290 如果应用程序实现加密、密钥交换、数字签名和哈希功能，则应用程序必须使用联邦信息处理标准 (FIPS) 140-2 验证的加密模块和随机数生成器。" name="002290">
            <rule header="不要使用 rand() 函数来生成伪随机数" id="a" impl="SECURITY-02_b" originalId="SECURITY-02_b" quickfix="false" scope="line" severity="2">
               <file path="SECURITY\SECURITY-02_b.rule"/>
            </rule>
            <rule header="不应该使用 'random_shuffle' 标识符" id="c" impl="CODSTA-MCPP-41" originalId="CODSTA-MCPP-41" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-41.rule"/>
            </rule>
            <rule header="不应使用随机数函数'rand()'和'srand()'" id="d" impl="SECURITY-02" originalId="SECURITY-02" quickfix="false" scope="line" severity="2">
               <file path="SECURITY\SECURITY-02.rule"/>
            </rule>
         </category>
         <category description="APSC_DV-002350 当信息所有者或国防部政策要求时，应用程序必须使用适当的密码术来保护存储的国防部信息。" name="002350">
            <rule header="请勿使用弱加密功能" id="a" impl="SECURITY-37" originalId="SECURITY-37" quickfix="false" scope="line" severity="2">
               <file path="SECURITY\SECURITY-37.rule"/>
            </rule>
         </category>
         <category description="APSC_DV-002390 XML-基于应用程序的应用程序必须通过使用 XML 过滤器、解析器选项或网关来缓解 DoS 攻击。" name="002390">
            <rule header="不以本机方式处理结构化文本数据" id="b" impl="CODSTA-201" originalId="CODSTA-201" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-201.rule"/>
            </rule>
            <rule header="不要在不指定可变大小的格式字符串的情况下使用 scanf 和 fscanf 函数" id="c" impl="SECURITY-14" originalId="SECURITY-14" quickfix="false" scope="line" severity="2">
               <file path="SECURITY\SECURITY-14.rule"/>
            </rule>
            <rule header="不要使用 mbstowcs() 函数" id="d" impl="SECURITY-22" originalId="SECURITY-22" quickfix="false" scope="line" severity="2">
               <file path="SECURITY\SECURITY-22.rule"/>
            </rule>
         </category>
         <category description="APSC_DV-002400 应用程序必须限制对自身或其他信息系统发起拒绝服务 (DoS) 攻击的能力。" name="002400">
            <rule header="使用 'std::atexit()' 或 'std::at_quick_exit()' 注册函数的执行不应异常退出" id="b" impl="PB-44" originalId="PB-44" quickfix="false" scope="line" severity="2">
               <file path="PB\PB-44.rule"/>
            </rule>
            <rule header="避免使用 'vfork()' 函数" id="c" impl="SECURITY-10" originalId="SECURITY-10" quickfix="false" scope="line" severity="2">
               <file path="SECURITY\SECURITY-10.rule"/>
            </rule>
            <rule header="避免使用对线程不安全(thread-unsafe)的函数" id="d" impl="SECURITY-25" originalId="SECURITY-25" quickfix="false" scope="line" severity="2">
               <file path="SECURITY\SECURITY-25.rule"/>
            </rule>
         </category>
         <category description="APSC_DV-002480 应用程序不得向用户暴露不必要的信息。" name="002480">
            <rule header="不要将应用程序错误导致的潜在敏感信息打印到异常消息中" id="a" impl="SECURITY-15" originalId="SECURITY-15" quickfix="false" scope="line" severity="2">
               <file path="SECURITY\SECURITY-15.rule"/>
            </rule>
         </category>
         <category description="APSC_DV-002520 应用程序必须防止规范表示漏洞。" name="002520">
            <rule header="禁止使用来自不信任用户的未经过滤的数据作为格式化参数" id="d" impl="SECURITY-36" originalId="SECURITY-36" quickfix="false" scope="line" severity="2">
               <file path="SECURITY\SECURITY-36.rule"/>
            </rule>
            <rule header="不可信任数据用作循环边界" id="k" impl="SECURITY-38" originalId="SECURITY-38" quickfix="false" scope="line" severity="2">
               <file path="SECURITY\SECURITY-38.rule"/>
            </rule>
         </category>
         <category description="APSC_DV-002530 应用程序必须验证所有输入。" name="002530">
            <rule header="禁止使用来自不信任用户的未经过滤的数据作为格式化参数" id="d" impl="SECURITY-36" originalId="SECURITY-36" quickfix="false" scope="line" severity="2">
               <file path="SECURITY\SECURITY-36.rule"/>
            </rule>
            <rule header="不可信任数据用作循环边界" id="k" impl="SECURITY-38" originalId="SECURITY-38" quickfix="false" scope="line" severity="2">
               <file path="SECURITY\SECURITY-38.rule"/>
            </rule>
         </category>
         <category description="APSC_DV-002570 应用程序必须生成提供纠正措施所需的错误消息，而不会泄露可能被对手利用的信息。" name="002570">
            <rule header="不要将应用程序错误导致的潜在敏感信息打印到异常消息中" id="b" impl="SECURITY-15" originalId="SECURITY-15" quickfix="false" scope="line" severity="2">
               <file path="SECURITY\SECURITY-15.rule"/>
            </rule>
         </category>
      </category>
      <category description="SEI CERT C" name="CERT_C">
         <category description="CERT-ARR01_C (REC) 在获取数组大小时，不对指针应用sizeof运算符" name="ARR01">
            <rule header="不要在指针类型上调用'sizeof'" id="a" impl="PB-32" originalId="PB-32" quickfix="false" scope="line" severity="1">
               <file path="PB\PB-32.rule"/>
            </rule>
         </category>
         <category description="CERT-DCL20_C (REC) 当函数无参数时显式地指定void" name="DCL20">
            <rule header="传递给函数的参数个数必须与函数定义的参数一致" id="a" impl="MISRA2004-16_6" originalId="MISRA2004-16_6" quickfix="false" scope="line" severity="1">
               <file path="MISRA2004\MISRA2004-16_6.rule"/>
            </rule>
         </category>
         <category description="CERT-ENV01_C (REC) 不要假设环境变量的大小" name="ENV01">
            <rule header="不要使用不安全的 C 函数来写入未检查范围的缓冲区" id="a" impl="SECURITY-07" originalId="SECURITY-07" quickfix="false" scope="line" severity="1">
               <file path="SECURITY\SECURITY-07.rule"/>
            </rule>
            <rule header="避免使用可能导致缓冲区溢出的不安全字符串函数" id="b" impl="SECURITY-12" originalId="SECURITY-12" quickfix="false" scope="line" severity="1">
               <file path="SECURITY\SECURITY-12.rule"/>
            </rule>
         </category>
         <category description="CERT-ENV33_C (RULE) 不要调用system()函数" name="ENV33">
            <rule header="不要调用 'stdlib.h' 或 'cstdlib' 库中参数不为 '0'（空指针）的 'system()' 函数" id="a" impl="SECURITY-48" originalId="SECURITY-48" quickfix="false" scope="line" severity="1">
               <file path="SECURITY\SECURITY-48.rule"/>
            </rule>
         </category>
         <category description="CERT-ERR33_C (RULE) 检测和处理标准库错误" name="ERR33">
            <rule header="应使用可能返回错误的标准库函数所返回的值" id="a" impl="CODSTA-226_a" originalId="CODSTA-226_a" quickfix="false" scope="line" severity="1">
               <file path="CODSTA\CODSTA-226_a.rule"/>
            </rule>
            <rule header="不需要检查返回值的标准库函数应该被转换为 'void'" id="b" impl="CODSTA-226_b" originalId="CODSTA-226_b" quickfix="false" scope="line" severity="1">
               <file path="CODSTA\CODSTA-226_b.rule"/>
            </rule>
         </category>
         <category description="CERT-EXP20_C (REC) 执行显式测试以确定成功（success）、正确（ true）、错误（false）和相等（equality）" name="EXP20">
            <rule header="避免使用相等运算符 (&quot;==&quot;, &quot;!=&quot;) 来对 TRUE 宏/枚举(enum)常量进行值比较" id="a" impl="CODSTA-60" originalId="CODSTA-60" quickfix="false" scope="line" severity="1">
               <file path="CODSTA\CODSTA-60.rule"/>
            </rule>
            <rule header="测试一个值是否为零应该是显式的，除非操作数实际上是布尔值" id="b" impl="MISRA2004-13_2" originalId="MISRA2004-13_2" quickfix="false" scope="line" severity="1">
               <file path="MISRA2004\MISRA2004-13_2.rule"/>
            </rule>
         </category>
         <category description="CERT-FIO01_C (REC) 使用文件名作为函数的标识时要小心" name="FIO01">
            <rule header="不要使用 chmod(), chown(), chgrp()" id="a" impl="SECURITY-27" originalId="SECURITY-27" quickfix="false" scope="line" severity="1">
               <file path="SECURITY\SECURITY-27.rule"/>
            </rule>
            <rule header="不允许使用容易发生竞争的功能" id="b" impl="SECURITY-19" originalId="SECURITY-19" quickfix="false" scope="line" severity="1">
               <file path="SECURITY\SECURITY-19.rule"/>
            </rule>
         </category>
         <category description="CERT-FIO30_C (RULE) 从格式字符串中排除用户输入" name="FIO30">
            <rule header="避免调用只有一个参数而不是字符串常量的函数 printf/wprintf" id="a" impl="SECURITY-05" originalId="SECURITY-05" quickfix="false" scope="line" severity="1">
               <file path="SECURITY\SECURITY-05.rule"/>
            </rule>
            <rule header="当第二个参数是变量时，避免使用只有两个参数的函数 fprintf/fwprintf" id="b" impl="SECURITY-08" originalId="SECURITY-08" quickfix="false" scope="line" severity="1">
               <file path="SECURITY\SECURITY-08.rule"/>
            </rule>
            <rule header="禁止使用来自不信任用户的未经过滤的数据作为格式化参数" id="c" impl="SECURITY-36" originalId="SECURITY-36" quickfix="false" scope="line" severity="1">
               <file path="SECURITY\SECURITY-36.rule"/>
            </rule>
         </category>
         <category description="CERT-INT18_C (REC) 在比较或指定整数表达式的大小之前，先计算较大的整数表达式" name="INT18">
            <rule header="避免将表达式的结果赋给更大整数类型的变量，这可能出现整数溢出" id="a" impl="PB-65" originalId="PB-65" quickfix="false" scope="line" severity="1">
               <file path="PB\PB-65.rule"/>
            </rule>
            <rule header="避免将表达式的结果与更广泛的整数类型的表达式进行比较，可能会整数溢出" id="b" impl="PB-65_b" originalId="PB-65_b" quickfix="false" scope="line" severity="1">
               <file path="PB\PB-65_b.rule"/>
            </rule>
            <rule header="避免在将结果转换为更广泛的整数类型的表达式中可能出现的整数溢出" id="c" impl="MISRA-048_a" originalId="MISRA-048_a" quickfix="false" scope="line" severity="1">
               <file path="MISRA\MISRA-048_a.rule"/>
            </rule>
         </category>
         <category description="CERT-MEM00_C (REC) 在相同抽象级别的相同模块中分配和释放内存" name="MEM00">
            <rule header="不要分配内存后期望其他人稍后去释放" id="a" impl="MRM-18" originalId="MRM-18" quickfix="false" scope="line" severity="1">
               <file path="MRM\MRM-18.rule"/>
            </rule>
            <rule header="不要分配内存后期望其他人稍后去释放" id="b" impl="MRM-19" originalId="MRM-19" quickfix="false" scope="line" severity="1">
               <file path="MRM\MRM-19.rule"/>
            </rule>
            <rule header="不要分配内存后期望其他人稍后去释放它" id="c" impl="MRM-20" originalId="MRM-20" quickfix="false" scope="line" severity="1">
               <file path="MRM\MRM-20.rule"/>
            </rule>
         </category>
         <category description="CERT-MSC15_C (REC) 不要依赖于未定义的行为" name="MSC15">
            <rule header="对常量无符号整数表达式的求值不应该导致循环" id="a" impl="PB-73" originalId="PB-73" quickfix="false" scope="line" severity="1">
               <file path="PB\PB-73.rule"/>
            </rule>
         </category>
         <category description="CERT-MSC17_C (REC) 用break语句结束与case标签相关联的每一组语句" name="MSC17">
            <rule header="switch 语句中各 case 之间缺失 break 语句" id="a" impl="CODSTA-149" originalId="CODSTA-149" quickfix="false" scope="line" severity="1">
               <file path="CODSTA\CODSTA-149.rule"/>
            </rule>
         </category>
         <category description="CERT-MSC33_C (RULE) 不要将无效数据传递给 asctime() 函数" name="MSC33">
            <rule header="不应使用函数 'asctime()' 和 'asctime_r()'" id="a" impl="SECURITY-01" originalId="SECURITY-01" quickfix="false" scope="line" severity="1">
               <file path="SECURITY\SECURITY-01.rule"/>
            </rule>
         </category>
         <category description="CERT-MSC41_C (RULE) 不硬编码敏感信息" name="MSC41">
            <rule header="不要硬编码字符串字面量" id="a" impl="CODSTA-203" originalId="CODSTA-203" quickfix="false" scope="line" severity="1">
               <file path="CODSTA\CODSTA-203.rule"/>
            </rule>
         </category>
         <category description="CERT-POS30_C (RULE) 正确使用 readlink() 函数" name="POS30">
            <rule header="应当使用函数 'read' 和 'readlink' 返回的值" id="b" impl="CODSTA-144" originalId="CODSTA-144" quickfix="false" scope="line" severity="1">
               <file path="CODSTA\CODSTA-144.rule"/>
            </rule>
            <rule header="在期望有空终止的字符串的函数中使用可能没有空终止的字符串" id="c" impl="CODSTA-145" originalId="CODSTA-145" quickfix="false" scope="line" severity="1">
               <file path="CODSTA\CODSTA-145.rule"/>
            </rule>
         </category>
         <category description="CERT-POS36_C (RULE) 在放弃特权的同时遵守正确的撤销命令" name="POS36">
            <rule header="在放弃特权时遵守正确的撤销命令" id="a" impl="SECURITY-44" originalId="SECURITY-44" quickfix="false" scope="line" severity="1">
               <file path="SECURITY\SECURITY-44.rule"/>
            </rule>
         </category>
         <category description="CERT-POS37_C (RULE) 确保特权的放弃是成功的" name="POS37">
            <rule header="确保成功地放弃特权" id="a" impl="SECURITY-45" originalId="SECURITY-45" quickfix="false" scope="line" severity="1">
               <file path="SECURITY\SECURITY-45.rule"/>
            </rule>
         </category>
         <category description="CERT-POS47_C (RULE) 不要使用可以异步取消的线程" name="POS47">
            <rule header="不应该使用 'PTHREAD_CANCEL_ASYNCHRONOUS'参数来调用函数'pthread_setcanceltype()'" id="a" impl="SECURITY-43" originalId="SECURITY-43" quickfix="false" scope="line" severity="1">
               <file path="SECURITY\SECURITY-43.rule"/>
            </rule>
         </category>
         <category description="CERT-POS54_C (RULE) 检测和处理 POSIX 库错误" name="POS54">
            <rule header="应该使用可能返回错误的POSIX库函数所返回的值" id="a" impl="CODSTA-227" originalId="CODSTA-227" quickfix="false" scope="line" severity="1">
               <file path="CODSTA\CODSTA-227.rule"/>
            </rule>
         </category>
         <category description="CERT-PRE01_C (REC) 在宏中的参数名周围使用括号" name="PRE01">
            <rule header="在类函数宏指令的定义中，参数的每个实例都应该用圆括号括起来，除非它用作 # 或者 ## 的运算对象" id="a" impl="MISRA2004-19_10" originalId="MISRA2004-19_10" quickfix="false" scope="line" severity="1">
               <file path="MISRA2004\MISRA2004-19_10.rule"/>
            </rule>
         </category>
         <category description="CERT-PRE02_C (REC) 宏替换列表应该被圆括弧括起" name="PRE02">
            <rule header="必须把类函数形式的宏定义放进括号中" id="a" impl="MISRA-096" originalId="MISRA-096" quickfix="false" scope="line" severity="1">
               <file path="MISRA\MISRA-096.rule"/>
            </rule>
         </category>
         <category description="CERT-SIG02_C (REC) 避免使用信号来实现正常功能" name="SIG02">
            <rule header="不应使用 &lt;signal.h&gt; 的信号处理工具" id="a" impl="MISRA2004-20_8_b" originalId="MISRA2004-20_8_b" quickfix="false" scope="line" severity="1">
               <file path="MISRA2004\MISRA2004-20_8_b.rule"/>
            </rule>
         </category>
         <category description="CERT-STR00_C (REC) 使用适当的类型表示字符" name="STR00">
            <rule header="普通字符(plain char)类型只能用于存储和使用字符值" id="a" impl="MISRA2004-6_1" originalId="MISRA2004-6_1" quickfix="false" scope="line" severity="1">
               <file path="MISRA2004\MISRA2004-6_1.rule"/>
            </rule>
         </category>
         <category description="CERT-STR07_C (REC) 为现有的字符串操作使用边界检查接口" name="STR07">
            <rule header="避免使用不安全的不检查界限的字符串函数" id="a" impl="SECURITY-13" originalId="SECURITY-13" quickfix="false" scope="line" severity="1">
               <file path="SECURITY\SECURITY-13.rule"/>
            </rule>
         </category>
         <category description="CERT-STR31_C (RULE) 保证字符串存储有足够容纳字符数据和空终止符的空间" name="STR31">
            <rule header="避免使用可能导致缓冲区溢出的不安全字符串函数" id="e" impl="SECURITY-12" originalId="SECURITY-12" quickfix="false" scope="line" severity="1">
               <file path="SECURITY\SECURITY-12.rule"/>
            </rule>
         </category>
         <category description="CERT-STR38_C (RULE) 不混淆窄字符和宽字符的字符串和函数" name="STR38">
            <rule header="不要混淆窄字符串、宽字符串和函数" id="a" impl="CODSTA-188" originalId="CODSTA-188" quickfix="false" scope="line" severity="1">
               <file path="CODSTA\CODSTA-188.rule"/>
            </rule>
         </category>
         <category description="CERT-API02_C (REC) 对数组进行读写操作的函数应该使用一个参数来指定源文件或目标的大小" name="API02">
            <rule header="避免使用可能导致缓冲区溢出的不安全字符串函数" id="a" impl="SECURITY-12" originalId="SECURITY-12" quickfix="false" scope="line" severity="2">
               <file path="SECURITY\SECURITY-12.rule"/>
            </rule>
            <rule header="不要使用不安全的 C 函数来写入未检查范围的缓冲区" id="b" impl="SECURITY-07" originalId="SECURITY-07" quickfix="false" scope="line" severity="2">
               <file path="SECURITY\SECURITY-07.rule"/>
            </rule>
         </category>
         <category description="CERT-ARR02_C (REC) 显式地指定数组界限，即使由初始化器隐式定义" name="ARR02">
            <rule header="使用初始化器显式指定数组声明中的数组大小" id="a" impl="CODSTA-200" originalId="CODSTA-200" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-200.rule"/>
            </rule>
         </category>
         <category description="CERT-ARR37_C (RULE) 不要向非数组对象的指针添加或减去一个整数" name="ARR37">
            <rule header="指针运算不得用于指向非数组类型变量的指针" id="a" impl="PB-51" originalId="PB-51" quickfix="false" scope="line" severity="2">
               <file path="PB\PB-51.rule"/>
            </rule>
         </category>
         <category description="CERT-ARR39_C (RULE) 不要向指针添加或减去缩放的整数" name="ARR39">
            <rule header="不应该使用指针算法" id="b" impl="MISRA-101" originalId="MISRA-101" quickfix="false" scope="line" severity="2">
               <file path="MISRA\MISRA-101.rule"/>
            </rule>
            <rule header="不要拿整型和指针做加减运算" id="c" impl="CODSTA-189" originalId="CODSTA-189" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-189.rule"/>
            </rule>
         </category>
         <category description="CERT-CON02_C (REC) 不使用volatile关键字作为同步基元" name="CON02">
            <rule header="不要使用 volatile 关键字" id="a" impl="MISRA-046_a" originalId="MISRA-046_a" quickfix="false" scope="line" severity="2">
               <file path="MISRA\MISRA-046_a.rule"/>
            </rule>
         </category>
         <category description="CERT-CON37_C (RULE) 不要在多线程程序中调用signal()" name="CON37">
            <rule header="不应使用 &lt;signal.h&gt; 的信号处理工具" id="a" impl="MISRA2004-20_8_b" originalId="MISRA2004-20_8_b" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-20_8_b.rule"/>
            </rule>
         </category>
         <category description="CERT-CON40_C (RULE) 不要在表达式中两次引用原子变量" name="CON40">
            <rule header="不要在表达式中两次引用原子变量" id="a" impl="CODSTA-195" originalId="CODSTA-195" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-195.rule"/>
            </rule>
         </category>
         <category description="CERT-DCL10_C (REC) 在可变函数的写入(writer)和调用(caller)函数之间保持一致" name="DCL10">
            <rule header="格式字符串中的格式说明符的数量和调用字符串格式化函数时相应的参数的数量应该相等" id="a" impl="PB-50" originalId="PB-50" quickfix="false" scope="line" severity="2">
               <file path="PB\PB-50.rule"/>
            </rule>
         </category>
         <category description="CERT-DCL11_C (REC) 理解与可变函数相关的类型问题" name="DCL11">
            <rule header="格式字符串中的 '%s' 和 '%c' 格式说明符与其在调用字符串格式化函数时的相应参数之间不应存在不匹配" id="a" impl="PB-45" originalId="PB-45" quickfix="false" scope="line" severity="2">
               <file path="PB\PB-45.rule"/>
            </rule>
            <rule header="格式字符串中的'％f'格式说明符与调用字符串格式函数的相应参数之间不应存在不匹配" id="b" impl="PB-46" originalId="PB-46" quickfix="false" scope="line" severity="2">
               <file path="PB\PB-46.rule"/>
            </rule>
            <rule header="格式字符串中的'％f'格式说明符与调用字符串格式函数的相应参数之间不应存在不匹配" id="c" impl="PB-47" originalId="PB-47" quickfix="false" scope="line" severity="2">
               <file path="PB\PB-47.rule"/>
            </rule>
            <rule header="在调用字符串格式化函数时，格式字符串中的'%u'格式说明符及其对应的参数之间不应存在不匹配" id="d" impl="PB-48" originalId="PB-48" quickfix="false" scope="line" severity="2">
               <file path="PB\PB-48.rule"/>
            </rule>
            <rule header="在调用字符串格式化函数时，格式字符串中的'%p'格式说明符及其对应的参数之间不应存在不匹配" id="e" impl="PB-49" originalId="PB-49" quickfix="false" scope="line" severity="2">
               <file path="PB\PB-49.rule"/>
            </rule>
            <rule header="格式字符串中的格式说明符的数量和调用字符串格式化函数时相应的参数的数量应该相等" id="f" impl="PB-50" originalId="PB-50" quickfix="false" scope="line" severity="2">
               <file path="PB\PB-50.rule"/>
            </rule>
         </category>
         <category description="CERT-DCL30_C (RULE) 声明具有适当存储时间的对象" name="DCL30">
            <rule header="不得从函数中返回具有自动存储的对象的地址" id="a" impl="MISRA2004-17_6_a" originalId="MISRA2004-17_6_a" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-17_6_a.rule"/>
            </rule>
            <rule header="自动存储对象的地址不应分配给在第一个对象不再存在后可能持久存在的另一个对象" id="b" impl="MISRA2004-17_6_b" originalId="MISRA2004-17_6_b" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-17_6_b.rule"/>
            </rule>
         </category>
         <category description="CERT-DCL36_C (RULE) 不要声明具有冲突链接分类的标识符" name="DCL36">
            <rule header="标识符在同一编译单元中不能同时具有内部和外部链接" id="a" impl="MISRA-024" originalId="MISRA-024" quickfix="false" scope="line" severity="2">
               <file path="MISRA\MISRA-024.rule"/>
            </rule>
         </category>
         <category description="CERT-ERR01_C (REC) 使用 ferror()而不是errno检查文件流错误" name="ERR01">
            <rule header="不得使用错误指示符 'errno'" id="a" impl="MISRA2004-20_5" originalId="MISRA2004-20_5" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-20_5.rule"/>
            </rule>
         </category>
         <category description="CERT-ERR07_C (REC) 选择支持错误检查的函数，而不是不支持错误检查的等效函数" name="ERR07">
            <rule header="不得使用库stdlib.h中的库函数atof，atoi和atol" id="a" impl="MISRA2004-20_10" originalId="MISRA2004-20_10" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-20_10.rule"/>
            </rule>
            <rule header="不得使用标准的库的 input/output 函数" id="b" impl="CODSTA-110" originalId="CODSTA-110" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-110.rule"/>
            </rule>
         </category>
         <category description="CERT-ERR30_C (RULE) 在调用已知设置errno的库函数之前，将errno设置为零，并仅在函数返回一个指示失败的值之后检查errno" name="ERR30">
            <rule header="在调用fopen函数的附近提供文件打开错误的错误处理机制" id="b" impl="MRM-39" originalId="MRM-39" quickfix="false" scope="line" severity="2">
               <file path="MRM\MRM-39.rule"/>
            </rule>
         </category>
         <category description="CERT-EXP05_C (REC) 不要舍弃 const 修饰符" name="EXP05">
            <rule header="强制转换不得从指针或引用类型中删除任何“const”或“volatile”限定条件" id="a" impl="MISRA2004-11_5" originalId="MISRA2004-11_5" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-11_5.rule"/>
            </rule>
         </category>
         <category description="CERT-EXP08_C (REC) 确保正确使用指针算法" name="EXP08">
            <rule header="不应该使用指针算法" id="a" impl="MISRA-101" originalId="MISRA-101" quickfix="false" scope="line" severity="2">
               <file path="MISRA\MISRA-101.rule"/>
            </rule>
         </category>
         <category description="CERT-EXP10_C (REC) 不依赖于子表达式的评价顺序或副作用发生的顺序" name="EXP10">
            <rule header="表达式的值应该在任何标准允许的赋值顺序下是一样的" id="a" impl="MISRA2004-12_2_a" originalId="MISRA2004-12_2_a" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-12_2_a.rule"/>
            </rule>
            <rule header="不要编写依赖于函数参数求值顺序的代码" id="b" impl="MISRA2004-12_2_b" originalId="MISRA2004-12_2_b" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-12_2_b.rule"/>
            </rule>
            <rule header="不要编写依赖于函数标志符和函数参数的求值顺序的代码" id="c" impl="MISRA2004-12_2_c" originalId="MISRA2004-12_2_c" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-12_2_c.rule"/>
            </rule>
            <rule header="涉及一个函数调用时，不要编写依赖表达式求值顺序的代码" id="d" impl="MISRA2004-12_2_d" originalId="MISRA2004-12_2_d" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-12_2_d.rule"/>
            </rule>
         </category>
         <category description="CERT-EXP16_C (REC) 不要将函数指针与常数值进行比较" name="EXP16">
            <rule header="函数地址不应与零相比较" id="a" impl="PB-63" originalId="PB-63" quickfix="false" scope="line" severity="2">
               <file path="PB\PB-63.rule"/>
            </rule>
         </category>
         <category description="CERT-EXP19_C (REC) 对if、for或while语句的主体使用花括号" name="EXP19">
            <rule header="'switch', 'while', 'do...while' 或 'for' 语句的主体应该是复合语句" id="a" impl="MISRA2004-14_8" originalId="MISRA2004-14_8" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-14_8.rule"/>
            </rule>
         </category>
         <category description="CERT-EXP30_C (RULE) 不依赖于副作用的评估顺序" name="EXP30">
            <rule header="表达式的值应该在任何标准允许的赋值顺序下是一样的" id="a" impl="MISRA2004-12_2_a" originalId="MISRA2004-12_2_a" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-12_2_a.rule"/>
            </rule>
            <rule header="不要编写依赖于函数参数求值顺序的代码" id="b" impl="MISRA2004-12_2_b" originalId="MISRA2004-12_2_b" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-12_2_b.rule"/>
            </rule>
            <rule header="不要编写依赖于函数标志符和函数参数的求值顺序的代码" id="c" impl="MISRA2004-12_2_c" originalId="MISRA2004-12_2_c" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-12_2_c.rule"/>
            </rule>
            <rule header="涉及一个函数调用时，不要编写依赖表达式求值顺序的代码" id="d" impl="MISRA2004-12_2_d" originalId="MISRA2004-12_2_d" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-12_2_d.rule"/>
            </rule>
         </category>
         <category description="CERT-EXP32_C (RULE) 不要通过非易失性引用（nonvolatile reference）访问易失性对象（volatile object）" name="EXP32">
            <rule header="强制转换不得从指针或引用类型中删除任何“const”或“volatile”限定条件" id="a" impl="MISRA2004-11_5" originalId="MISRA2004-11_5" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-11_5.rule"/>
            </rule>
         </category>
         <category description="CERT-EXP42_C (RULE) 不要比较填充数据" name="EXP42">
            <rule header="不能对非 POD 使用 memcpy 或 memcmp" id="a" impl="MRM-07" originalId="MRM-07" quickfix="false" scope="line" severity="2">
               <file path="MRM\MRM-07.rule"/>
            </rule>
         </category>
         <category description="CERT-EXP45_C (RULE) 不要在选择语句中执行任务" name="EXP45">
            <rule header="赋值操作符不得使用在没有括号的条件中" id="b" impl="PB-35" originalId="PB-35" quickfix="false" scope="line" severity="2">
               <file path="PB\PB-35.rule"/>
            </rule>
            <rule header="禁止在产生布尔值的表达式中使用赋值运算符" id="d" impl="MISRA2004-13_1" originalId="MISRA2004-13_1" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-13_1.rule"/>
            </rule>
         </category>
         <category description="CERT-EXP46_C (RULE) 不要将位操作符与类似于boolean的操作数一起使用" name="EXP46">
            <rule header="有效布尔值的表达式不应该用作除 (&amp;&amp;, ||, !, =, ==, !=, ?:) 之外的运算符的操作数。" id="b" impl="MISRA2004-12_6_b" originalId="MISRA2004-12_6_b" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-12_6_b.rule"/>
            </rule>
         </category>
         <category description="CERT-EXP47_C (RULE) 不要使用不正确类型的参数调用va_arg" name="EXP47">
            <rule header="不要使用错误的参数类型调用va_arg" id="a" impl="PB-72" originalId="PB-72" quickfix="false" scope="line" severity="2">
               <file path="PB\PB-72.rule"/>
            </rule>
         </category>
         <category description="CERT-FIO21_C (REC) 不要在共享目录中创建临时文件" name="FIO21">
            <rule header="不允许使用容易发生竞争的功能" id="a" impl="SECURITY-19" originalId="SECURITY-19" quickfix="false" scope="line" severity="2">
               <file path="SECURITY\SECURITY-19.rule"/>
            </rule>
         </category>
         <category description="CERT-FIO47_C (RULE) 使用有效的格式字符串" name="FIO47">
            <rule header="格式字符串中的 '%s' 和 '%c' 格式说明符与其在调用字符串格式化函数时的相应参数之间不应存在不匹配" id="a" impl="PB-45" originalId="PB-45" quickfix="false" scope="line" severity="2">
               <file path="PB\PB-45.rule"/>
            </rule>
            <rule header="格式字符串中的'％f'格式说明符与调用字符串格式函数的相应参数之间不应存在不匹配" id="b" impl="PB-46" originalId="PB-46" quickfix="false" scope="line" severity="2">
               <file path="PB\PB-46.rule"/>
            </rule>
            <rule header="格式字符串中的'％f'格式说明符与调用字符串格式函数的相应参数之间不应存在不匹配" id="c" impl="PB-47" originalId="PB-47" quickfix="false" scope="line" severity="2">
               <file path="PB\PB-47.rule"/>
            </rule>
            <rule header="在调用字符串格式化函数时，格式字符串中的'%u'格式说明符及其对应的参数之间不应存在不匹配" id="d" impl="PB-48" originalId="PB-48" quickfix="false" scope="line" severity="2">
               <file path="PB\PB-48.rule"/>
            </rule>
            <rule header="在调用字符串格式化函数时，格式字符串中的'%p'格式说明符及其对应的参数之间不应存在不匹配" id="e" impl="PB-49" originalId="PB-49" quickfix="false" scope="line" severity="2">
               <file path="PB\PB-49.rule"/>
            </rule>
            <rule header="格式字符串中的格式说明符的数量和调用字符串格式化函数时相应的参数的数量应该相等" id="f" impl="PB-50" originalId="PB-50" quickfix="false" scope="line" severity="2">
               <file path="PB\PB-50.rule"/>
            </rule>
         </category>
         <category description="CERT-FLP06_C (REC) 为浮点操作将整数转换为浮点数" name="FLP06">
            <rule header="不应使用可能导致信息丢失的从整型到浮点型的隐式转换" id="a" impl="MISRA-043_c" originalId="MISRA-043_c" quickfix="false" scope="line" severity="2">
               <file path="MISRA\MISRA-043_c.rule"/>
            </rule>
            <rule header="不应使用可能会导致信息丢失的从整数常量到浮点类型的隐式转换" id="b" impl="MISRA-043_d" originalId="MISRA-043_d" quickfix="false" scope="line" severity="2">
               <file path="MISRA\MISRA-043_d.rule"/>
            </rule>
         </category>
         <category description="CERT-FLP30_C (RULE) 不使用浮点变量作为循环计数器" name="FLP30">
            <rule header="不得使用浮点变量作为循环计数器" id="a" impl="MISRA-065" originalId="MISRA-065" quickfix="false" scope="line" severity="2">
               <file path="MISRA\MISRA-065.rule"/>
            </rule>
         </category>
         <category description="CERT-INT02_C (REC) 了解整数转换规则" name="INT02">
            <rule header="不应使用可能导致信息丢失的从较宽到较窄的整数类型的隐式转换" id="a" impl="MISRA-043" originalId="MISRA-043" quickfix="false" scope="line" severity="2">
               <file path="MISRA\MISRA-043.rule"/>
            </rule>
            <rule header="避免在同一个表达式中混合使用不同精度的算术运算" id="b" impl="MISRA-043_b" originalId="MISRA-043_b" quickfix="false" scope="line" severity="2">
               <file path="MISRA\MISRA-043_b.rule"/>
            </rule>
         </category>
         <category description="CERT-INT07_C (REC) 对数值使用显式符号或无符号字符类型" name="INT07">
            <rule header="普通字符(plain char)类型只能用于存储和使用字符值" id="a" impl="MISRA2004-6_1" originalId="MISRA2004-6_1" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-6_1.rule"/>
            </rule>
            <rule header="带符号的 char 和 不带符号的 char 类型只能用于存储和数值类型" id="b" impl="MISRA2004-6_2" originalId="MISRA2004-6_2" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-6_2.rule"/>
            </rule>
         </category>
         <category description="CERT-INT13_C (REC) 只在无符号操作数上使用位操作符" name="INT13">
            <rule header="位运算符应只适用于无符号的基本类型操作数" id="a" impl="CODSTA-63" originalId="CODSTA-63" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-63.rule"/>
            </rule>
         </category>
         <category description="CERT-INT15_C (REC) 对程序员定义的整数类型使用 intmax_t 或 uintmax_t 进行格式化的 IO" name="INT15">
            <rule header="在程序员定义的整数类型上使用 intmax_t 或 uintmax_t 进行格式化 IO" id="a" impl="PB-78" originalId="PB-78" quickfix="false" scope="line" severity="2">
               <file path="PB\PB-78.rule"/>
            </rule>
         </category>
         <category description="CERT-INT30_C (RULE) 确保无符号整数操作不隐藏" name="INT30">
            <rule header="'+'， '-'， '*' 运算符常量表达式中的整数溢出或下溢" id="b" impl="PB-66_a" originalId="PB-66_a" quickfix="false" scope="line" severity="2">
               <file path="PB\PB-66_a.rule"/>
            </rule>
            <rule header="'&lt;&lt;' 运算符常量表达式中的整数溢出或下溢" id="c" impl="PB-66_b" originalId="PB-66_b" quickfix="false" scope="line" severity="2">
               <file path="PB\PB-66_b.rule"/>
            </rule>
         </category>
         <category description="CERT-INT31_C (RULE) 确保整数转换不会导致数据丢失或错误解释" name="INT31">
            <rule header="当操作数被解释为布尔值时，应使用基本布尔类型的表达式" id="a" impl="CODSTA-161_a" originalId="CODSTA-161_a" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-161_a.rule"/>
            </rule>
            <rule header="当操作数被解释为数值时，不应使用本质上为布尔类型的操作数当操作数被解释为数值时，不应使用本质上为布尔类型的操作数" id="b" impl="CODSTA-161_b" originalId="CODSTA-161_b" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-161_b.rule"/>
            </rule>
            <rule header="字符类型的操作数不应该用在需要数类型的地方" id="c" impl="CODSTA-161_c" originalId="CODSTA-161_c" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-161_c.rule"/>
            </rule>
            <rule header="在算术运算中不应该使用枚举类型" id="d" impl="CODSTA-161_d" originalId="CODSTA-161_d" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-161_d.rule"/>
            </rule>
            <rule header="不要对有符号类型和枚举类型使用移位和位运算" id="e" impl="CODSTA-161_e" originalId="CODSTA-161_e" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-161_e.rule"/>
            </rule>
            <rule header="本质上带符号或枚举类型的操作数不应用作移位操作符的右侧操作数" id="f" impl="CODSTA-161_f" originalId="CODSTA-161_f" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-161_f.rule"/>
            </rule>
            <rule header="一元减运算符的操作数不应该是无符号类型" id="g" impl="CODSTA-161_g" originalId="CODSTA-161_g" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-161_g.rule"/>
            </rule>
            <rule header="表达式的值不能赋给更小基本类型的对象" id="h" impl="CODSTA-163_a" originalId="CODSTA-163_a" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-163_a.rule"/>
            </rule>
            <rule header="表达式的值不应分配给不同基本类型类别的对象" id="i" impl="CODSTA-163_b" originalId="CODSTA-163_b" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-163_b.rule"/>
            </rule>
            <rule header="执行常规算术转换的运算符的两个操作数应具有相同的基本类型类别" id="j" impl="CODSTA-164_a" originalId="CODSTA-164_a" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-164_a.rule"/>
            </rule>
            <rule header="第二个和第三个三元操作符的操作数有相同的基本类型类别" id="k" impl="CODSTA-164_b" originalId="CODSTA-164_b" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-164_b.rule"/>
            </rule>
            <rule header="复合表达式的值不应该赋值给宽数据类型的一个对象" id="l" impl="CODSTA-157" originalId="CODSTA-157" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-157.rule"/>
            </rule>
            <rule header="如果复合表达式用作执行通常算术转换的运算符的一个操作数，则另一个操作数不应具有更广泛的基本类型" id="m" impl="CODSTA-156_a" originalId="CODSTA-156_a" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-156_a.rule"/>
            </rule>
            <rule header="如果复合表达式用作执行通常算术转换的运算符的第一个(第二个或第三个)操作数，则另一个操作数不应具有更广泛的基本类型" id="n" impl="CODSTA-156_b" originalId="CODSTA-156_b" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-156_b.rule"/>
            </rule>
         </category>
         <category description="CERT-INT32_C (RULE) 确保对有符号整数的操作不会导致溢出" name="INT32">
            <rule header="'+'， '-'， '*' 运算符常量表达式中的整数溢出或下溢" id="b" impl="PB-66_a" originalId="PB-66_a" quickfix="false" scope="line" severity="2">
               <file path="PB\PB-66_a.rule"/>
            </rule>
            <rule header="'&lt;&lt;' 运算符常量表达式中的整数溢出或下溢" id="c" impl="PB-66_b" originalId="PB-66_b" quickfix="false" scope="line" severity="2">
               <file path="PB\PB-66_b.rule"/>
            </rule>
         </category>
         <category description="CERT-MEM01_C (REC) 在 free() 之后立即在指针中存储一个新值" name="MEM01">
            <rule header="始终将一个新值赋给指向已释放内存的表达式" id="b" impl="MRM-09" originalId="MRM-09" quickfix="false" scope="line" severity="2">
               <file path="MRM\MRM-09.rule"/>
            </rule>
            <rule header="始终将一个新值赋给指向已释放内存的全局或成员变量" id="c" impl="MRM-10" originalId="MRM-10" quickfix="false" scope="line" severity="2">
               <file path="MRM\MRM-10.rule"/>
            </rule>
            <rule header="总是为指向释放内存的参数或局部变量分配新值" id="d" impl="MRM-11" originalId="MRM-11" quickfix="false" scope="line" severity="2">
               <file path="MRM\MRM-11.rule"/>
            </rule>
         </category>
         <category description="CERT-MEM04_C (REC) 注意零长度分配" name="MEM04">
            <rule header="应检查传递给库函数的值的有效性" id="a" impl="MISRA2004-20_3" originalId="MISRA2004-20_3" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-20_3.rule"/>
            </rule>
         </category>
         <category description="CERT-MEM07_C (REC) 确保对calloc()的参数在相乘时，不要重复" name="MEM07">
            <rule header="应检查传递给库函数的值的有效性" id="a" impl="MISRA2004-20_3" originalId="MISRA2004-20_3" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-20_3.rule"/>
            </rule>
         </category>
         <category description="CERT-MEM35_C (RULE) 为对象分配足够的内存" name="MEM35">
            <rule header="不要在指针类型上使用 sizeof 操作符来指定通过 'malloc'， 'calloc' 或 'realloc' 函数分配的内存大小" id="a" impl="MRM-45" originalId="MRM-45" quickfix="false" scope="line" severity="2">
               <file path="MRM\MRM-45.rule"/>
            </rule>
         </category>
         <category description="CERT-MSC01_C (REC) 争取逻辑完整性" name="MSC01">
            <rule header="所有 'if...else-if' 结构应使用一个 'else' 子句终止" id="a" impl="MISRA2004-14_10" originalId="MISRA2004-14_10" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-14_10.rule"/>
            </rule>
            <rule header="switch 语句中最后一个子句必须为 default 子句" id="b" impl="MISRA2004-15_3" originalId="MISRA2004-15_3" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-15_3.rule"/>
            </rule>
         </category>
         <category description="CERT-MSC30_C (RULE) 不使用 rand() 函数生成伪随机数" name="MSC30">
            <rule header="不要使用 rand() 函数来生成伪随机数" id="a" impl="SECURITY-02_b" originalId="SECURITY-02_b" quickfix="false" scope="line" severity="2">
               <file path="SECURITY\SECURITY-02_b.rule"/>
            </rule>
         </category>
         <category description="CERT-MSC37_C (RULE) 确保控制永远不会到达非 void 函数的末尾" name="MSC37">
            <rule header="具有非 void 返回类型的函数的所有退出路径，除 main() 外，都应具有带有表达式的显式返回语句" id="a" impl="MISRA2004-16_8_b" originalId="MISRA2004-16_8_b" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-16_8_b.rule"/>
            </rule>
         </category>
         <category description="CERT-POS33_C (RULE) 不要使用 vfork() " name="POS33">
            <rule header="避免使用 'vfork()' 函数" id="a" impl="SECURITY-10" originalId="SECURITY-10" quickfix="false" scope="line" severity="2">
               <file path="SECURITY\SECURITY-10.rule"/>
            </rule>
         </category>
         <category description="CERT-POS34_C (RULE) 不要使用指向自动变量作为参数的指针调用  putenv() " name="POS34">
            <rule header="限制使用系统属性（环境变量）" id="a" impl="SECURITY-03" originalId="SECURITY-03" quickfix="false" scope="line" severity="2">
               <file path="SECURITY\SECURITY-03.rule"/>
            </rule>
         </category>
         <category description="CERT-POS44_C (RULE) 不使用信号终止线程" name="POS44">
            <rule header="The 'pthread_kill', 'pthread_sigqueue' and 'tgkill' functions should not be used to send signals to threads" id="a" impl="SECURITY-53" originalId="SECURITY-53" quickfix="false" scope="line" severity="2">
               <file path="SECURITY\SECURITY-53.rule"/>
            </rule>
         </category>
         <category description="CERT-SIG00_C (REC) 由不可中断信号处理程序处理的掩码信号" name="SIG00">
            <rule header="不应使用 &lt;signal.h&gt; 的信号处理工具" id="a" impl="MISRA2004-20_8_b" originalId="MISRA2004-20_8_b" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-20_8_b.rule"/>
            </rule>
         </category>
         <category description="CERT-STR11_C (REC) 不指定用字符串字面量初始化的字符数组的界限" name="STR11">
            <rule header="不要指定用字符串文本初始化的字符数组的大小" id="a" impl="CODSTA-197" originalId="CODSTA-197" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-197.rule"/>
            </rule>
         </category>
         <category description="CERT-STR30_C (RULE) 不尝试修改字符串字面量" name="STR30">
            <rule header="字符串字面量不应该被修改" id="a" impl="PB-27" originalId="PB-27" quickfix="false" scope="line" severity="2">
               <file path="PB\PB-27.rule"/>
            </rule>
         </category>
         <category description="CERT-STR34_C (RULE) 在将字符转换为更大的整数大小之前，先将其转换为无符号字符" name="STR34">
            <rule header="在赋值给较大的整型之前将字符强制转换为 unsigned char 类型" id="b" impl="CODSTA-187_a" originalId="CODSTA-187_a" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-187_a.rule"/>
            </rule>
            <rule header="'signed char' 类型的表达式不应该作为数组下标使用" id="c" impl="CODSTA-187_b" originalId="CODSTA-187_b" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-187_b.rule"/>
            </rule>
            <rule header="在转换为更大的整型之前将字符转换为无符号字符类型" id="d" impl="CODSTA-187_c" originalId="CODSTA-187_c" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-187_c.rule"/>
            </rule>
         </category>
         <category description="CERT-WIN00_C (REC) 在动态加载库时要明确" name="WIN00">
            <rule header="谨慎使用以确保 LoadLibrary() 加载正确的库" id="a" impl="SECURITY-04" originalId="SECURITY-04" quickfix="false" scope="line" severity="2">
               <file path="SECURITY\SECURITY-04.rule"/>
            </rule>
         </category>
         <category description="CERT-API00_C (REC) 函数应该验证它们的参数" name="API00">
            <rule header="必须在每个函数内部检查参数的有效性" id="a" impl="CODSTA-86" originalId="CODSTA-86" quickfix="false" scope="line" severity="3">
               <file path="CODSTA\CODSTA-86.rule"/>
            </rule>
         </category>
         <category description="CERT-API01_C (REC) 避免在敏感数据之前直接在内存中放置字符串" name="API01">
            <rule header="避免使用可能导致缓冲区溢出的不安全字符串函数" id="b" impl="SECURITY-12" originalId="SECURITY-12" quickfix="false" scope="line" severity="3">
               <file path="SECURITY\SECURITY-12.rule"/>
            </rule>
         </category>
         <category description="CERT-CON33_C (RULE) 在使用库函数时消除抢占条件" name="CON33">
            <rule header="避免使用对线程不安全(thread-unsafe)的函数" id="a" impl="SECURITY-25" originalId="SECURITY-25" quickfix="false" scope="line" severity="3">
               <file path="SECURITY\SECURITY-25.rule"/>
            </rule>
         </category>
         <category description="CERT-CON36_C (RULE) 封装在循环中伪唤醒的函数" name="CON36">
            <rule header="封装可以在循环中伪唤醒的函数" id="a" impl="CODSTA-191" originalId="CODSTA-191" quickfix="false" scope="line" severity="3">
               <file path="CODSTA\CODSTA-191.rule"/>
            </rule>
         </category>
         <category description="CERT-CON38_C (RULE) 在使用条件变量时保持线程安全性和活性" name="CON38">
            <rule header="使用带有唯一条件变量的 'cnd_signal()' 函数" id="a" impl="SECURITY-49" originalId="SECURITY-49" quickfix="false" scope="line" severity="3">
               <file path="SECURITY\SECURITY-49.rule"/>
            </rule>
         </category>
         <category description="CERT-CON41_C (RULE) 封装在循环中可能出现虚假错误的函数" name="CON41">
            <rule header="循环中使用包装函数可能失败" id="a" impl="CODSTA-194" originalId="CODSTA-194" quickfix="false" scope="line" severity="3">
               <file path="CODSTA\CODSTA-194.rule"/>
            </rule>
         </category>
         <category description="CERT-DCL00_C (REC) 使用 Const限定不可变对象" name="DCL00">
            <rule header="尽可能将局部变量声明为 const" id="a" impl="CODSTA-CPP-53" originalId="CODSTA-CPP-53" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-53.rule"/>
            </rule>
            <rule header="尽可能将参数声明为 const" id="b" impl="CODSTA-CPP-53_b" originalId="CODSTA-CPP-53_b" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-53_b.rule"/>
            </rule>
         </category>
         <category description="CERT-DCL01_C (REC) 不要在子类中重用变量名" name="DCL01">
            <rule header="在局部或者函数原型体范围内声明的标识符不应该隐藏一个在全局或者命名空间范围内声明的标识符" id="a" impl="MISRA2004-5_2_a" originalId="MISRA2004-5_2_a" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-5_2_a.rule"/>
            </rule>
            <rule header="在内层的局部范围内声明的标识符不应该隐藏在外层的局部范围内声明的标识符" id="b" impl="MISRA2004-5_2_b" originalId="MISRA2004-5_2_b" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-5_2_b.rule"/>
            </rule>
         </category>
         <category description="CERT-DCL02_C (REC) 使用外表不同的标识符" name="DCL02">
            <rule header="使用视觉上不同的标识符" id="a" impl="NAMING-54" originalId="NAMING-54" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-54.rule"/>
            </rule>
         </category>
         <category description="CERT-DCL04_C (REC) 一次声明不声明多个变量" name="DCL04">
            <rule header="每个变量都要在单独的声明语句中被声明" id="a" impl="FORMAT-33" originalId="FORMAT-33" quickfix="false" scope="line" severity="3">
               <file path="FORMAT\FORMAT-33.rule"/>
            </rule>
         </category>
         <category description="CERT-DCL05_C (REC) 只使用非指针类型的typedefs " name="DCL05">
            <rule header="如果指针不用于修改指向地址的对象则声明参数的类型为 typedef 的 const 指针" id="a" impl="MISRA2004-16_7_b" originalId="MISRA2004-16_7_b" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-16_7_b.rule"/>
            </rule>
         </category>
         <category description="CERT-DCL06_C (REC) 使用有意义的符号常量来表示字面量值" name="DCL06">
            <rule header="使用有意义的符号常量来表示字面值" id="a" impl="CODSTA-29" originalId="CODSTA-29" quickfix="false" scope="line" severity="3">
               <file path="CODSTA\CODSTA-29.rule"/>
            </rule>
         </category>
         <category description="CERT-DCL12_C (REC) 使用不透明类型实现抽象数据类型" name="DCL12">
            <rule header="如果指向一个结构体或联合体的指针在一个编译单元内从未被间接引用，那么该对象的实现应该被隐藏起来" id="a" impl="CODSTA-115" originalId="CODSTA-115" quickfix="false" scope="line" severity="3">
               <file path="CODSTA\CODSTA-115.rule"/>
            </rule>
         </category>
         <category description="CERT-DCL13_C (REC) 将指向函数未更改的值的指针的函数参数声明为 const" name="DCL13">
            <rule header="如果函数参数中指针参数在函数中不用来修改地址对象，则应声明为常量类型" id="a" impl="MISRA2004-16_7" originalId="MISRA2004-16_7" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-16_7.rule"/>
            </rule>
         </category>
         <category description="CERT-DCL15_C (REC) 将不需要外部链接的文件范围对象或函数声明为静态" name="DCL15">
            <rule header="应该在头文件中声明具有外部链接的对象或函数" id="a" impl="MISRA-023" originalId="MISRA-023" quickfix="false" scope="line" severity="3">
               <file path="MISRA\MISRA-023.rule"/>
            </rule>
         </category>
         <category description="CERT-DCL16_C (REC) 使用&quot;L&quot;，而不是&quot;l&quot;表示一个长整型值" name="DCL16">
            <rule header="使用大写 'L' 而非小写 'l' 来指定长整型" id="a" impl="PORT-01" originalId="PORT-01" quickfix="false" scope="line" severity="3">
               <file path="PORT\PORT-01.rule"/>
            </rule>
         </category>
         <category description="CERT-DCL18_C (REC) 在指定十进制值时，不要以0开始的整型常量" name="DCL18">
            <rule header="八进制和十六进制转义序列将被终止" id="a" impl="CODSTA-117" originalId="CODSTA-117" quickfix="false" scope="line" severity="3">
               <file path="CODSTA\CODSTA-117.rule"/>
            </rule>
            <rule header="不应该使用八进制常数（除零外）" id="b" impl="MISRA2004-7_1_a" originalId="MISRA2004-7_1_a" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-7_1_a.rule"/>
            </rule>
         </category>
         <category description="CERT-DCL19_C (REC) 最小化变量和函数的范围" name="DCL19">
            <rule header="尽可能地声明局部变量" id="a" impl="OPT-01" originalId="OPT-01" quickfix="false" scope="line" severity="3">
               <file path="OPT\OPT-01.rule"/>
            </rule>
         </category>
         <category description="CERT-DCL31_C (RULE) 在使用标识符之前声明它们" name="DCL31">
            <rule header="所有对象和函数必须先声明再使用" id="a" impl="MISRA-020" originalId="MISRA-020" quickfix="false" scope="line" severity="3">
               <file path="MISRA\MISRA-020.rule"/>
            </rule>
         </category>
         <category description="CERT-DCL37_C (RULE) 不要声明或定义保留标识符" name="DCL37">
            <rule header="不要使用以下划线开头的带有#define 或 #undef 名称的标识符" id="a" impl="MISRA2004-20_1_a" originalId="MISRA2004-20_1_a" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-20_1_a.rule"/>
            </rule>
         </category>
         <category description="CERT-DCL38_C (RULE) 在声明灵活数组成员（flexible array member）时使用正确的语法" name="DCL38">
            <rule header="结构体的最终成员不应该是“0”或“1”的数组" id="a" impl="CODSTA-192" originalId="CODSTA-192" quickfix="false" scope="line" severity="3">
               <file path="CODSTA\CODSTA-192.rule"/>
            </rule>
         </category>
         <category description="CERT-DCL39_C (RULE) 通过信任边界（trust boundary）传递结构体时避免信息泄漏" name="DCL39">
            <rule header="不应将指向结构体的指针传递给可将数据复制到用户空间的函数" id="a" impl="SECURITY-46" originalId="SECURITY-46" quickfix="false" scope="line" severity="3">
               <file path="SECURITY\SECURITY-46.rule"/>
            </rule>
         </category>
         <category description="CERT-DCL40_C (RULE) 不创建相同函数或对象的不兼容声明" name="DCL40">
            <rule header="如果对象或者函数被声明了一次以上，那么他们的类型应该是兼容的" id="b" impl="MISRA2004-8_4" originalId="MISRA2004-8_4" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-8_4.rule"/>
            </rule>
         </category>
         <category description="CERT-DCL41_C (RULE) 在第一个case标签之前不要在switch语句中声明变量" name="DCL41">
            <rule header="switch 语句应该只包含 switch 标签和 switch 子句，不能包含其他代码" id="a" impl="MISRA2004-15_0_b" originalId="MISRA2004-15_0_b" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-15_0_b.rule"/>
            </rule>
         </category>
         <category description="CERT-ENV02_C (REC) 注意多个具有相同有效名称的环境变量" name="ENV02">
            <rule header="限制使用系统属性（环境变量）" id="a" impl="SECURITY-03" originalId="SECURITY-03" quickfix="false" scope="line" severity="3">
               <file path="SECURITY\SECURITY-03.rule"/>
            </rule>
         </category>
         <category description="CERT-ENV30_C (RULE) 不要通过函数的返回值来修改对象引用" name="ENV30">
            <rule header="标准库函数 'localeconv', 'getenv', 'setlocale' 或 'strerror' 返回的指针仅当它们具有指向 const 限定类型的指针时使用" id="a" impl="CODSTA-185_a" originalId="CODSTA-185_a" quickfix="false" scope="line" severity="3">
               <file path="CODSTA\CODSTA-185_a.rule"/>
            </rule>
         </category>
         <category description="CERT-ERR02_C (REC) 避免某些错误指示器" name="ERR02">
            <rule header="不得使用标准的库的 input/output 函数" id="a" impl="CODSTA-110" originalId="CODSTA-110" quickfix="false" scope="line" severity="3">
               <file path="CODSTA\CODSTA-110.rule"/>
            </rule>
         </category>
         <category description="CERT-ERR04_C (REC) 选择一个合适的终止策略" name="ERR04">
            <rule header="不得使用  'stdlib.h' 或者 'cstdlib' 库中的 'abort()' 函数" id="a" impl="PB-75" originalId="PB-75" quickfix="false" scope="line" severity="3">
               <file path="PB\PB-75.rule"/>
            </rule>
            <rule header="'stdlib.h' 或者 'cstdlib' 库中的 'exit()' 函数不应该被使用" id="b" impl="PB-75_b" originalId="PB-75_b" quickfix="false" scope="line" severity="3">
               <file path="PB\PB-75_b.rule"/>
            </rule>
            <rule header="不得使用 'stdlib.h' 或 'cstdlib' 库中的 'quick_exit()' 和 '_Exit()' 函数" id="c" impl="PB-75_c" originalId="PB-75_c" quickfix="false" scope="line" severity="3">
               <file path="PB\PB-75_c.rule"/>
            </rule>
         </category>
         <category description="CERT-ERR05_C (REC) 不依赖于应用程序的代码应该提供错误检测，而不需要指定错误处理" name="ERR05">
            <rule header="不得使用  'stdlib.h' 或者 'cstdlib' 库中的 'abort()' 函数" id="a" impl="PB-75" originalId="PB-75" quickfix="false" scope="line" severity="3">
               <file path="PB\PB-75.rule"/>
            </rule>
            <rule header="'stdlib.h' 或者 'cstdlib' 库中的 'exit()' 函数不应该被使用" id="b" impl="PB-75_b" originalId="PB-75_b" quickfix="false" scope="line" severity="3">
               <file path="PB\PB-75_b.rule"/>
            </rule>
            <rule header="不得使用 'stdlib.h' 或 'cstdlib' 库中的 'quick_exit()' 和 '_Exit()' 函数" id="c" impl="PB-75_c" originalId="PB-75_c" quickfix="false" scope="line" severity="3">
               <file path="PB\PB-75_c.rule"/>
            </rule>
         </category>
         <category description="CERT-ERR06_C (REC) 理解 assert() 和 abort() 的终止行为" name="ERR06">
            <rule header="不要使用断言" id="a" impl="CODSTA-199" originalId="CODSTA-199" quickfix="false" scope="line" severity="3">
               <file path="CODSTA\CODSTA-199.rule"/>
            </rule>
         </category>
         <category description="CERT-ERR34_C (RULE) 在将字符串转换为数字时检测错误" name="ERR34">
            <rule header="不得使用库stdlib.h中的库函数atof，atoi和atol" id="a" impl="MISRA2004-20_10" originalId="MISRA2004-20_10" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-20_10.rule"/>
            </rule>
         </category>
         <category description="CERT-EXP00_C (REC) 使用括号作为操作的优先级" name="EXP00">
            <rule header="如果操作符的优先级低于算术运算符，应该使用圆括号明确表达式的操作顺序" id="a" impl="CODSTA-97" originalId="CODSTA-97" quickfix="false" scope="line" severity="3">
               <file path="CODSTA\CODSTA-97.rule"/>
            </rule>
         </category>
         <category description="CERT-EXP02_C (REC) 注意逻辑 AND 和 OR 运算符的短路行为" name="EXP02">
            <rule header="逻辑&amp;&amp;或||运算符的右操作数不得含有副作用" id="a" impl="MISRA2004-12_4_a" originalId="MISRA2004-12_4_a" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-12_4_a.rule"/>
            </rule>
         </category>
         <category description="CERT-EXP12_C (REC) 不要忽略函数返回的值" name="EXP12">
            <rule header="应该使用具有非 void 返回类型的函数返回值" id="a" impl="CODSTA-122_a" originalId="CODSTA-122_a" quickfix="false" scope="line" severity="3">
               <file path="CODSTA\CODSTA-122_a.rule"/>
            </rule>
            <rule header="应使用一个非 void 返回类型函数返回的值" id="b" impl="CODSTA-122_b" originalId="CODSTA-122_b" quickfix="false" scope="line" severity="3">
               <file path="CODSTA\CODSTA-122_b.rule"/>
            </rule>
         </category>
         <category description="CERT-EXP14_C (REC) 在对小于int的整数类型执行按位操作时，要注意整数提升" name="EXP14">
            <rule header="避免在同一个表达式中混合使用不同精度的算术运算" id="a" impl="MISRA-043_b" originalId="MISRA-043_b" quickfix="false" scope="line" severity="3">
               <file path="MISRA\MISRA-043_b.rule"/>
            </rule>
         </category>
         <category description="CERT-EXP15_C (REC) 不要将分号放在 if， for， 或者 while 语句的同一行上" name="EXP15">
            <rule header="分号的可疑使用" id="a" impl="CODSTA-57" originalId="CODSTA-57" quickfix="false" scope="line" severity="3">
               <file path="CODSTA\CODSTA-57.rule"/>
            </rule>
         </category>
         <category description="CERT-EXP35_C (RULE) 不要修改具有临时生存期的对象" name="EXP35">
            <rule header="不要修改具有临时生命周期的对象" id="a" impl="CODSTA-196" originalId="CODSTA-196" quickfix="false" scope="line" severity="3">
               <file path="CODSTA\CODSTA-196.rule"/>
            </rule>
         </category>
         <category description="CERT-EXP36_C (RULE) 不将指针转换为更严格对齐的指针类型" name="EXP36">
            <rule header="不要将指针转换为更严格对齐的指针类型" id="a" impl="CODSTA-230" originalId="CODSTA-230" quickfix="false" scope="line" severity="3">
               <file path="CODSTA\CODSTA-230.rule"/>
            </rule>
         </category>
         <category description="CERT-EXP37_C (RULE) 用正确的参数和类型调用函数" name="EXP37">
            <rule header="函数类型的不兼容指针之间不能进行转换" id="a" impl="CODSTA-124_b" originalId="CODSTA-124_b" quickfix="false" scope="line" severity="3">
               <file path="CODSTA\CODSTA-124_b.rule"/>
            </rule>
            <rule header="如果文件是使用 'open' 或 'openat' 系统调用创建的，则指定访问权限位" id="b" impl="SECURITY-42" originalId="SECURITY-42" quickfix="false" scope="line" severity="3">
               <file path="SECURITY\SECURITY-42.rule"/>
            </rule>
            <rule header="在函数调用时，函数总是有可见的原型" id="d" impl="MISRA-071_b" originalId="MISRA-071_b" quickfix="false" scope="line" severity="3">
               <file path="MISRA\MISRA-071_b.rule"/>
            </rule>
         </category>
         <category description="CERT-EXP39_C (RULE) 不能通过不兼容类型的指针来访问变量" name="EXP39">
            <rule header="不存在从整型到浮点型的隐式转换" id="a" impl="MISRA2004-10_1_b" originalId="MISRA2004-10_1_b" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-10_1_b.rule"/>
            </rule>
            <rule header="不应在指向对象类型的指针和指向对象类型的其他指针之间执行强制转换" id="b" impl="MISRA2004-11_4" originalId="MISRA2004-11_4" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-11_4.rule"/>
            </rule>
         </category>
         <category description="CERT-EXP40_C (RULE) 不要修改常量对象" name="EXP40">
            <rule header="强制转换不得从指针或引用类型中删除任何“const”或“volatile”限定条件" id="a" impl="MISRA2004-11_5" originalId="MISRA2004-11_5" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-11_5.rule"/>
            </rule>
         </category>
         <category description="CERT-EXP43_C (RULE) 在使用限制条件指针时避免未定义的行为" name="EXP43">
            <rule header="不得使用严格的类型限定符" id="a" impl="CODSTA-121" originalId="CODSTA-121" quickfix="false" scope="line" severity="3">
               <file path="CODSTA\CODSTA-121.rule"/>
            </rule>
         </category>
         <category description="CERT-EXP44_C (RULE) 不要依赖于 sizeof、_Alignof 或 _Generic 的操作数的副作用" name="EXP44">
            <rule header="不应在sizeof运算符的操作数中访问由volatile左值指定的对象" id="a" impl="MISRA2004-12_3_b" originalId="MISRA2004-12_3_b" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-12_3_b.rule"/>
            </rule>
            <rule header="会导致副作用的函数调用不应该用作 sizeof 运算符的操作数" id="b" impl="MISRA2004-12_3_c" originalId="MISRA2004-12_3_c" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-12_3_c.rule"/>
            </rule>
         </category>
         <category description="CERT-FIO38_C (RULE) 不复制文件（FILE）对象" name="FIO38">
            <rule header="指向 FILE 对象的指针不应被解引用" id="a" impl="CODSTA-166_a" originalId="CODSTA-166_a" quickfix="false" scope="line" severity="3">
               <file path="CODSTA\CODSTA-166_a.rule"/>
            </rule>
         </category>
         <category description="CERT-FIO41_C (RULE) 不要使用带有副作用的流参数调用 getc()、putc()、getwc() 或 putwc()" name="FIO41">
            <rule header="不要用含有赋值、增量或减量运算符的流参数调用 'getc()', 'putc()', 'getwc()', 或 'putwc()'" id="a" impl="CODSTA-228_a" originalId="CODSTA-228_a" quickfix="false" scope="line" severity="3">
               <file path="CODSTA\CODSTA-228_a.rule"/>
            </rule>
            <rule header="不要使用包含函数调用或类似函数的宏调用的流参数调用 'getc()'、 'putc()'、 'getwc()' 或 'putwc()'" id="b" impl="CODSTA-228_b" originalId="CODSTA-228_b" quickfix="false" scope="line" severity="3">
               <file path="CODSTA\CODSTA-228_b.rule"/>
            </rule>
         </category>
         <category description="CERT-FLP00_C (REC) 了解浮点数的局限性" name="FLP00">
            <rule header="禁止对浮点数类型的表达式做相等或不相等的比较" id="a" impl="MISRA2004-13_3" originalId="MISRA2004-13_3" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-13_3.rule"/>
            </rule>
         </category>
         <category description="CERT-FLP02_C (REC) 当需要精确计算时，避免使用浮点数" name="FLP02">
            <rule header="禁止对浮点数类型的表达式做相等或不相等的比较" id="a" impl="MISRA2004-13_3" originalId="MISRA2004-13_3" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-13_3.rule"/>
            </rule>
         </category>
         <category description="CERT-FLP03_C (REC) 检测和处理浮点错误" name="FLP03">
            <rule header="避免宽字段到窄字段浮点型数据的隐式转换" id="b" impl="MISRA2004-10_2_b" originalId="MISRA2004-10_2_b" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-10_2_b.rule"/>
            </rule>
            <rule header="避免隐式的窄字段到宽字段浮点型数据转换" id="c" impl="MISRA2004-10_2_c" originalId="MISRA2004-10_2_c" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-10_2_c.rule"/>
            </rule>
            <rule header="避免将浮点数从较宽的浮点类型隐式转换为较窄的浮点类型" id="d" impl="MISRA2004-10_2_d" originalId="MISRA2004-10_2_d" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-10_2_d.rule"/>
            </rule>
         </category>
         <category description="CERT-FLP34_C (RULE) 确保浮点转换在新类型的范围内" name="FLP34">
            <rule header="避免宽字段到窄字段浮点型数据的隐式转换" id="a" impl="MISRA2004-10_2_b" originalId="MISRA2004-10_2_b" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-10_2_b.rule"/>
            </rule>
            <rule header="避免将浮点数从较宽的浮点类型隐式转换为较窄的浮点类型" id="b" impl="MISRA2004-10_2_d" originalId="MISRA2004-10_2_d" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-10_2_d.rule"/>
            </rule>
         </category>
         <category description="CERT-FLP36_C (RULE) 将整数值转换为浮点类型时保持精度" name="FLP36">
            <rule header="不应使用可能导致信息丢失的从整型到浮点型的隐式转换" id="a" impl="MISRA-043_c" originalId="MISRA-043_c" quickfix="false" scope="line" severity="3">
               <file path="MISRA\MISRA-043_c.rule"/>
            </rule>
            <rule header="不应使用可能会导致信息丢失的从整数常量到浮点类型的隐式转换" id="b" impl="MISRA-043_d" originalId="MISRA-043_d" quickfix="false" scope="line" severity="3">
               <file path="MISRA\MISRA-043_d.rule"/>
            </rule>
         </category>
         <category description="CERT-FLP37_C (RULE) 不要使用对象来比较浮点值" name="FLP37">
            <rule header="不要使用对象表示形式来比较浮点值" id="c" impl="CODSTA-190" originalId="CODSTA-190" quickfix="false" scope="line" severity="3">
               <file path="CODSTA\CODSTA-190.rule"/>
            </rule>
         </category>
         <category description="CERT-INT05_C (REC) 如果不能处理所有可能的输入，不要使用输入函数转换字符数据" name="INT05">
            <rule header="避免使用不安全的不检查界限的字符串函数" id="a" impl="SECURITY-13" originalId="SECURITY-13" quickfix="false" scope="line" severity="3">
               <file path="SECURITY\SECURITY-13.rule"/>
            </rule>
         </category>
         <category description="CERT-INT09_C (REC) 确保枚举常量映射到唯一值" name="INT09">
            <rule header="在枚举类型中，要么仅对第一个元素进行显式地初始化，要么所有元素都进行显式的初始化" id="a" impl="MISRA2004-9_3" originalId="MISRA2004-9_3" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-9_3.rule"/>
            </rule>
         </category>
         <category description="CERT-INT10_C (REC) 使用 % 运算符时不要假设余数为正" name="INT10">
            <rule header="余数运算符 '%' 的操作数应为无符号的整数类型" id="a" impl="CODSTA-229" originalId="CODSTA-229" quickfix="false" scope="line" severity="3">
               <file path="CODSTA\CODSTA-229.rule"/>
            </rule>
         </category>
         <category description="CERT-INT12_C (REC) 在表达式中使用普通 int 位域（plain int bit-field）时，不要对其类型进行假设" name="INT12">
            <rule header="只能将位域定义为有符号的整型或无符号的整型" id="a" impl="MISRA2004-6_4" originalId="MISRA2004-6_4" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-6_4.rule"/>
            </rule>
         </category>
         <category description="CERT-INT16_C (REC) 不要假设有符号整数的表示" name="INT16">
            <rule header="位运算符应只适用于无符号的基本类型操作数" id="a" impl="CODSTA-63" originalId="CODSTA-63" quickfix="false" scope="line" severity="3">
               <file path="CODSTA\CODSTA-63.rule"/>
            </rule>
         </category>
         <category description="CERT-INT35_C (RULE) 使用正确的整数精度" name="INT35">
            <rule header="检查 shift 操作符的右指针操作数时，请使用正确的整数精度" id="a" impl="SECURITY-47" originalId="SECURITY-47" quickfix="false" scope="line" severity="3">
               <file path="SECURITY\SECURITY-47.rule"/>
            </rule>
         </category>
         <category description="CERT-INT36_C (RULE) 将指针转换为整数或将整数转换为指针" name="INT36">
            <rule header="不应在指向对象类型的指针与除 'uintptr_t' 或 'intptr_t' 以外的整数类型之间执行转换" id="b" impl="CODSTA-127_b" originalId="CODSTA-127_b" quickfix="false" scope="line" severity="3">
               <file path="CODSTA\CODSTA-127_b.rule"/>
            </rule>
         </category>
         <category description="CERT-MEM02_C (REC) 将内存分配函数调用的结果立即强制类型转换为分配类型的指针" name="MEM02">
            <rule header="内存分配函数的结果应被立即转换" id="a" impl="MRM-58_a" originalId="MRM-58_a" quickfix="false" scope="line" severity="3">
               <file path="MRM\MRM-58_a.rule"/>
            </rule>
            <rule header="内存分配函数的结果应该立即被转换为指向被分配类型的指针" id="b" impl="MRM-58_b" originalId="MRM-58_b" quickfix="false" scope="line" severity="3">
               <file path="MRM\MRM-58_b.rule"/>
            </rule>
         </category>
         <category description="CERT-MEM33_C (RULE) 动态分配和复制包含灵活数组成员的结构体" name="MEM33">
            <rule header="动态分配包含灵活数组成员的结构体" id="a" impl="CODSTA-193" originalId="CODSTA-193" quickfix="false" scope="line" severity="3">
               <file path="CODSTA\CODSTA-193.rule"/>
            </rule>
            <rule header="不要复制包含柔性数组成员的结构体的实例" id="b" impl="PB-71" originalId="PB-71" quickfix="false" scope="line" severity="3">
               <file path="PB\PB-71.rule"/>
            </rule>
         </category>
         <category description="CERT-MSC04_C (REC) 一致地以可读的方式使用注释" name="MSC04">
            <rule header="禁止在 C 语言风格的注释中使用 /* 字符序列" id="a" impl="MISRA2004-2_3" originalId="MISRA2004-2_3" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-2_3.rule"/>
            </rule>
            <rule header="字符序列 // 不得被用于 C 语言风格的注释中" id="b" impl="COMMENT-11" originalId="COMMENT-11" quickfix="false" scope="line" severity="3">
               <file path="COMMENT\COMMENT-11.rule"/>
            </rule>
            <rule header="字符序列 /* 不得被用于 C++ 语言风格的注释中" id="c" impl="COMMENT-12" originalId="COMMENT-12" quickfix="false" scope="line" severity="3">
               <file path="COMMENT\COMMENT-12.rule"/>
            </rule>
            <rule header="不得在 // 注释中使用行合并" id="d" impl="COMMENT-13" originalId="COMMENT-13" quickfix="false" scope="line" severity="3">
               <file path="COMMENT\COMMENT-13.rule"/>
            </rule>
         </category>
         <category description="CERT-MSC07_C (REC) 检测和删除死代码" name="MSC07">
            <rule header="在 &quot;else&quot; 语句块中不应存在执行不到的代码" id="a" impl="MISRA2004-14_1_a" originalId="MISRA2004-14_1_a" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-14_1_a.rule"/>
            </rule>
            <rule header="在 'return', 'break', 'continue', 和 'goto' 语句之后不应存在执行不到的代码" id="b" impl="MISRA2004-14_1_b" originalId="MISRA2004-14_1_b" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-14_1_b.rule"/>
            </rule>
            <rule header="在 &quot;if/else/while/for&quot; 语句块中不应存在执行不到的代码" id="c" impl="MISRA2004-14_1_c" originalId="MISRA2004-14_1_c" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-14_1_c.rule"/>
            </rule>
            <rule header="在 switch 语句中不应存在执行不到的代码" id="d" impl="MISRA2004-14_1_d" originalId="MISRA2004-14_1_d" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-14_1_d.rule"/>
            </rule>
            <rule header="在 'for' 循环中不应存在执行不到的代码" id="e" impl="MISRA2004-14_1_e" originalId="MISRA2004-14_1_e" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-14_1_e.rule"/>
            </rule>
            <rule header="在 'if' 或 'switch' 语句后不应存在不可访问的代码" id="f" impl="MISRA2004-14_1_f" originalId="MISRA2004-14_1_f" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-14_1_f.rule"/>
            </rule>
            <rule header="在 while/for/do...while 循环内的 &quot;if&quot; 或 &quot;switch&quot; 语句后不应存在执行不到的代码" id="g" impl="MISRA2004-14_1_g" originalId="MISRA2004-14_1_g" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-14_1_g.rule"/>
            </rule>
         </category>
         <category description="CERT-MSC09_C (REC) 字符编码:为安全起见，使用 ASCII 子集" name="MSC09">
            <rule header="只使用 ISO C 标准中定义的字符" id="a" impl="MISRA-005" originalId="MISRA-005" quickfix="false" scope="line" severity="3">
               <file path="MISRA\MISRA-005.rule"/>
            </rule>
         </category>
         <category description="CERT-MSC11_C (REC) 使用断言合并诊断测试" name="MSC11">
            <rule header="广泛地使用断言证明内部假设和不变式" id="a" impl="CODSTA-11" originalId="CODSTA-11" quickfix="false" scope="line" severity="3">
               <file path="CODSTA\CODSTA-11.rule"/>
            </rule>
         </category>
         <category description="CERT-MSC12_C (REC) 检测和删除无效或从未执行的代码" name="MSC12">
            <rule header="在 &quot;else&quot; 语句块中不应存在执行不到的代码" id="a" impl="MISRA2004-14_1_a" originalId="MISRA2004-14_1_a" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-14_1_a.rule"/>
            </rule>
            <rule header="在 'return', 'break', 'continue', 和 'goto' 语句之后不应存在执行不到的代码" id="b" impl="MISRA2004-14_1_b" originalId="MISRA2004-14_1_b" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-14_1_b.rule"/>
            </rule>
            <rule header="在 &quot;if/else/while/for&quot; 语句块中不应存在执行不到的代码" id="c" impl="MISRA2004-14_1_c" originalId="MISRA2004-14_1_c" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-14_1_c.rule"/>
            </rule>
            <rule header="在 switch 语句中不应存在执行不到的代码" id="d" impl="MISRA2004-14_1_d" originalId="MISRA2004-14_1_d" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-14_1_d.rule"/>
            </rule>
            <rule header="在 'for' 循环中不应存在执行不到的代码" id="e" impl="MISRA2004-14_1_e" originalId="MISRA2004-14_1_e" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-14_1_e.rule"/>
            </rule>
            <rule header="在 'if' 或 'switch' 语句后不应存在不可访问的代码" id="f" impl="MISRA2004-14_1_f" originalId="MISRA2004-14_1_f" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-14_1_f.rule"/>
            </rule>
            <rule header="在 while/for/do...while 循环内的 &quot;if&quot; 或 &quot;switch&quot; 语句后不应存在执行不到的代码" id="g" impl="MISRA2004-14_1_g" originalId="MISRA2004-14_1_g" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-14_1_g.rule"/>
            </rule>
            <rule header="所有非 null 语句无论如何执行都至少有一个副作用，或者导致控制流发生变化" id="k" impl="MISRA2004-14_2" originalId="MISRA2004-14_2" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-14_2.rule"/>
            </rule>
         </category>
         <category description="CERT-MSC13_C (REC) 检测和删除未使用的值" name="MSC13">
            <rule header="避免使用不必要的局部变量" id="a" impl="OPT-06" originalId="OPT-06" quickfix="false" scope="line" severity="3">
               <file path="OPT\OPT-06.rule"/>
            </rule>
         </category>
         <category description="CERT-MSC14_C (REC) 不引入不必要的平台依赖" name="MSC14">
            <rule header="对常量无符号整数表达式的求值不应该导致循环" id="a" impl="PB-73" originalId="PB-73" quickfix="false" scope="line" severity="3">
               <file path="PB\PB-73.rule"/>
            </rule>
         </category>
         <category description="CERT-MSC22_C (REC) 安全地使用 setjmp()、longjmp() 工具" name="MSC22">
            <rule header="不应使用 &lt;setjmp.h&gt; 提供的工具" id="a" impl="MISRA2004-20_7" originalId="MISRA2004-20_7" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-20_7.rule"/>
            </rule>
         </category>
         <category description="CERT-MSC24_C (REC) 不要使用已弃用或过时的函数" name="MSC24">
            <rule header="不得使用库stdlib.h中的库函数atof，atoi和atol" id="a" impl="MISRA2004-20_10" originalId="MISRA2004-20_10" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-20_10.rule"/>
            </rule>
            <rule header="不得使用 'stdlib.h' 或 'cstdlib' 库中的 'getenv()' 函数" id="b" impl="SECURITY-52" originalId="SECURITY-52" quickfix="false" scope="line" severity="3">
               <file path="SECURITY\SECURITY-52.rule"/>
            </rule>
            <rule header="避免使用可能导致缓冲区溢出的不安全字符串函数" id="c" impl="SECURITY-12" originalId="SECURITY-12" quickfix="false" scope="line" severity="3">
               <file path="SECURITY\SECURITY-12.rule"/>
            </rule>
            <rule header="不要使用不安全的 C 函数来写入未检查范围的缓冲区" id="d" impl="SECURITY-07" originalId="SECURITY-07" quickfix="false" scope="line" severity="3">
               <file path="SECURITY\SECURITY-07.rule"/>
            </rule>
         </category>
         <category description="CERT-MSC38_C (RULE) 如果预定义的标识符可能只实现为宏(macro)，那么不要将其视为对象" name="MSC38">
            <rule header="类似函数的宏在调用时参数个数必须一致" id="a" impl="MISRA2004-19_8" originalId="MISRA2004-19_8" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-19_8.rule"/>
            </rule>
         </category>
         <category description="CERT-MSC40_C (RULE) 不要违反约束" name="MSC40">
            <rule header="带有外部链接的函数的内联定义不应包含静态对象的定义和使用" id="a" impl="CODSTA-202" originalId="CODSTA-202" quickfix="false" scope="line" severity="3">
               <file path="CODSTA\CODSTA-202.rule"/>
            </rule>
         </category>
         <category description="CERT-PRE00_C (REC) 选择内联或静态函数，而不是类似函数的宏" name="PRE00">
            <rule header="函数应该优先于宏函数的使用" id="a" impl="MISRA2004-19_7" originalId="MISRA2004-19_7" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-19_7.rule"/>
            </rule>
         </category>
         <category description="CERT-PRE06_C (REC) 使用 include保护机制来包含头文件" name="PRE06">
            <rule header="使用多个包含保护" id="a" impl="PFO-02" originalId="PFO-02" quickfix="false" scope="line" severity="3">
               <file path="PFO\PFO-02.rule"/>
            </rule>
         </category>
         <category description="CERT-PRE07_C (REC) 避免使用重复的问号" name="PRE07">
            <rule header="禁止使用三联符" id="a" impl="MISRA2004-4_2" originalId="MISRA2004-4_2" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-4_2.rule"/>
            </rule>
         </category>
         <category description="CERT-PRE30_C (RULE) 不创建一个通用字符名称贯穿连接（concatenation）" name="PRE30">
            <rule header="避免产生通用字符名称的占位符串联" id="a" impl="PREPROC-21" originalId="PREPROC-21" quickfix="false" scope="line" severity="3">
               <file path="PREPROC\PREPROC-21.rule"/>
            </rule>
         </category>
         <category description="CERT-PRE31_C (RULE) 避免不安全宏参数的副作用" name="PRE31">
            <rule header="断言不应该包含赋值，自增或自减运算符" id="b" impl="CODSTA-150" originalId="CODSTA-150" quickfix="false" scope="line" severity="3">
               <file path="CODSTA\CODSTA-150.rule"/>
            </rule>
            <rule header="断言不应该包含函数调用或者类似于函数的宏调用" id="c" impl="CODSTA-150_b" originalId="CODSTA-150_b" quickfix="false" scope="line" severity="3">
               <file path="CODSTA\CODSTA-150_b.rule"/>
            </rule>
            <rule header="避免不安全宏参数造成的不良影响" id="d" impl="CODSTA-150_c" originalId="CODSTA-150_c" quickfix="false" scope="line" severity="3">
               <file path="CODSTA\CODSTA-150_c.rule"/>
            </rule>
         </category>
         <category description="CERT-PRE32_C (RULE) 不要在调用函数类宏时使用预处理器指令" name="PRE32">
            <rule header="类似函数的宏的参数不应该包含类似预处理命令的标识" id="a" impl="MISRA2004-19_9" originalId="MISRA2004-19_9" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-19_9.rule"/>
            </rule>
         </category>
         <category description="CERT-SIG01_C (REC) 了解关于信号处理程序持久性的具体实现细节" name="SIG01">
            <rule header="不应使用 &lt;signal.h&gt; 的信号处理工具" id="a" impl="MISRA2004-20_8_b" originalId="MISRA2004-20_8_b" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-20_8_b.rule"/>
            </rule>
         </category>
         <category description="CERT-STR04_C (REC) 对于基本字符集中的字符使用普通字符" name="STR04">
            <rule header="普通字符(plain char)类型只能用于存储和使用字符值" id="a" impl="MISRA2004-6_1" originalId="MISRA2004-6_1" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-6_1.rule"/>
            </rule>
         </category>
         <category description="CERT-STR05_C (REC) 当引用字符串字面量时使用指向const的指针" name="STR05">
            <rule header="字符串字面量不应该被修改" id="a" impl="PB-27" originalId="PB-27" quickfix="false" scope="line" severity="3">
               <file path="PB\PB-27.rule"/>
            </rule>
         </category>
         <category description="CERT-STR09_C (REC) 不要为带有普通字符类型的表达式假定数字值" name="STR09">
            <rule header="带有类型(普通) char 和 wchar_t 的表达式不能作为内建运算符的操作数，除了 =, ==, != 和一元 &amp; 运算符" id="a" impl="CODSTA-69" originalId="CODSTA-69" quickfix="false" scope="line" severity="3">
               <file path="CODSTA\CODSTA-69.rule"/>
            </rule>
         </category>
         <category description="CERT-STR10_C (REC) 不连接不同类型的字符串字面量" name="STR10">
            <rule header="窄字符串和宽字符串不应该串联在一起" id="a" impl="PB-38" originalId="PB-38" quickfix="false" scope="line" severity="3">
               <file path="PB\PB-38.rule"/>
            </rule>
         </category>
      </category>
      <category description="SEI CERT C++" name="CERT_CPP">
         <category description="CERT-CTR55_CPP (RULE) 如果结果会溢出，请不要在迭代器上使用加法操作符" name="CTR55">
            <rule header="不要从迭代器中添加或减去一个值大于1的常量" id="a" impl="PB-74" originalId="PB-74" quickfix="false" scope="line" severity="1">
               <file path="PB\PB-74.rule"/>
            </rule>
         </category>
         <category description="CERT-DCL50_CPP (RULE) 不要定义 C 语言风格的可变函数" name="DCL50">
            <rule header="函数不应使用可变数量的参数定义" id="a" impl="MISRA2004-16_1" originalId="MISRA2004-16_1" quickfix="false" scope="line" severity="1">
               <file path="MISRA2004\MISRA2004-16_1.rule"/>
            </rule>
         </category>
         <category description="CERT-ERR54_CPP (RULE) 捕获处理程序应该将其参数类型从大多数派生到最小派生排序" name="ERR54">
            <rule header="如果在一个 try-catch 语句或函数 try-block 中为派生类及其部分或全部基类提供多个处理程序，则应将派生程度最高的处理程序排序为派生程度最高的基类" id="a" impl="EXCEPT-17" originalId="EXCEPT-17" quickfix="false" scope="line" severity="1">
               <file path="EXCEPT\EXCEPT-17.rule"/>
            </rule>
         </category>
         <category description="CERT-ERR59_CPP (RULE) 不要在跨执行边界抛出异常" name="ERR59">
            <rule header="不要越过执行边界抛出异常" id="a" impl="PORT-30" originalId="PORT-30" quickfix="false" scope="line" severity="1">
               <file path="PORT\PORT-30.rule"/>
            </rule>
         </category>
         <category description="CERT-EXP60_CPP (RULE) 不要跨执行边界传递非标准布局类型的对象" name="EXP60">
            <rule header="不要跨越执行边界传递非标准布局类型的对象" id="a" impl="PORT-31" originalId="PORT-31" quickfix="false" scope="line" severity="1">
               <file path="PORT\PORT-31.rule"/>
            </rule>
         </category>
         <category description="CERT-MEM51_CPP (RULE) 正确地释放动态分配的资源" name="MEM51">
            <rule header="在对相应的 new/malloc 以及 delete/free 的调用中应使用相同的形式" id="a" impl="MRM-06" originalId="MRM-06" quickfix="false" scope="line" severity="1">
               <file path="MRM\MRM-06.rule"/>
            </rule>
            <rule header="释放数组内存时 delete 必须使用空括号([])" id="b" impl="MRM-36" originalId="MRM-36" quickfix="false" scope="line" severity="1">
               <file path="MRM\MRM-36.rule"/>
            </rule>
            <rule header="复制构造函数和复制赋值运算符都应该为具有非平凡析构函数的类声明" id="c" impl="MRM-40_d" originalId="MRM-40_d" quickfix="false" scope="line" severity="1">
               <file path="MRM\MRM-40_d.rule"/>
            </rule>
         </category>
         <category description="CERT-MEM52_CPP (RULE) 检测和处理内存分配错误" name="MEM52">
            <rule header="检查 new 的返回值" id="a" impl="MRM-34" originalId="MRM-34" quickfix="false" scope="line" severity="1">
               <file path="MRM\MRM-34.rule"/>
            </rule>
            <rule header="由于函数参数的评估顺序尚未定义，禁止在函数参数列表中进行资源分配" id="b" impl="MRM-01" originalId="MRM-01" quickfix="false" scope="line" severity="1">
               <file path="MRM\MRM-01.rule"/>
            </rule>
         </category>
         <category description="CERT-MEM53_CPP (RULE) 在手动管理对象生命周期时显式构造和析构对象" name="MEM53">
            <rule header="禁止对含有构造函数的对象调用 malloc/realloc" id="a" impl="MRM-08" originalId="MRM-08" quickfix="false" scope="line" severity="1">
               <file path="MRM\MRM-08.rule"/>
            </rule>
         </category>
         <category description="CERT-MEM54_CPP (RULE) 适当提供指向足够存储容量的对齐指针， 以快速布局" name="MEM54">
            <rule header="不要传递存储容量不足或者没有对正在构造的对象进行适当的对齐以配置 'new' 的指针" id="a" impl="MRM-55" originalId="MRM-55" quickfix="false" scope="line" severity="1">
               <file path="MRM\MRM-55.rule"/>
            </rule>
            <rule header="当一个对象数组传递给配置 'new' 的分配作用时会存在开销" id="b" impl="MRM-55_b" originalId="MRM-55_b" quickfix="false" scope="line" severity="1">
               <file path="MRM\MRM-55_b.rule"/>
            </rule>
         </category>
         <category description="CERT-MEM55_CPP (RULE) 尊重替换动态存储管理要求" name="MEM55">
            <rule header="当分配失败时，用户定义的'new'操作符应该抛出'std::bad_alloc'异常" id="a" impl="MRM-53" originalId="MRM-53" quickfix="false" scope="line" severity="1">
               <file path="MRM\MRM-53.rule"/>
            </rule>
         </category>
         <category description="CERT-STR50_CPP (RULE) 保证字符串存储有足够容纳字符数据和空终止符的空间" name="STR50">
            <rule header="不要使用 'char' 缓冲区来存储来自 'std::cin' 的输入" id="g" impl="SECURITY-51" originalId="SECURITY-51" quickfix="false" scope="line" severity="1">
               <file path="SECURITY\SECURITY-51.rule"/>
            </rule>
         </category>
         <category description="CERT-CON51_CPP (RULE) 确保在特殊条件下积极持有的锁被释放" name="CON51">
            <rule header="不要直接在互斥锁上调用lock()" id="a" impl="CODSTA-MCPP-21" originalId="CODSTA-MCPP-21" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-21.rule"/>
            </rule>
         </category>
         <category description="CERT-CTR53_CPP (RULE) 使用有效的迭代器范围" name="CTR53">
            <rule header="不要使用一个不是真实范围的迭代器范围" id="a" impl="STL-36" originalId="STL-36" quickfix="false" scope="line" severity="2">
               <file path="STL\STL-36.rule"/>
            </rule>
         </category>
         <category description="CERT-CTR56_CPP (RULE) 不要在多态对象上使用指针算法" name="CTR56">
            <rule header="不要以多态方式处理数组" id="a" impl="PB-10" originalId="PB-10" quickfix="false" scope="line" severity="2">
               <file path="PB\PB-10.rule"/>
            </rule>
            <rule header="指向派生类对象数组的指针不应转换为基类指针" id="b" impl="PB-57" originalId="PB-57" quickfix="false" scope="line" severity="2">
               <file path="PB\PB-57.rule"/>
            </rule>
         </category>
         <category description="CERT-DCL54_CPP (RULE) 在相同范围内以成对的形式重载 allocation 和 deallocation 函数" name="DCL54">
            <rule header="始终同时提供 new 和 delete 操作符" id="a" impl="MRM-28" originalId="MRM-28" quickfix="false" scope="line" severity="2">
               <file path="MRM\MRM-28.rule"/>
            </rule>
         </category>
         <category description="CERT-DCL57_CPP (RULE) 不要让异常从析构函数或deallocation函数中逃脱" name="DCL57">
            <rule header="不允许从析构、释放和交换中抛出异常" id="a" impl="EXCEPT-01" originalId="EXCEPT-01" quickfix="false" scope="line" severity="2">
               <file path="EXCEPT\EXCEPT-01.rule"/>
            </rule>
         </category>
         <category description="CERT-DCL58_CPP (RULE) 不要修改标准命名空间" name="DCL58">
            <rule header="不要修改标准命名空间 'std' 和 'posix'" id="a" impl="CODSTA-CPP-95" originalId="CODSTA-CPP-95" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-95.rule"/>
            </rule>
         </category>
         <category description="CERT-ERR55_CPP (RULE) 尊重异常规范" name="ERR55">
            <rule header="如果函数的声明包含异常规范，则该函数只能抛出指定类型的异常" id="a" impl="EXCEPT-14" originalId="EXCEPT-14" quickfix="false" scope="line" severity="2">
               <file path="EXCEPT\EXCEPT-14.rule"/>
            </rule>
         </category>
         <category description="CERT-ERR56_CPP (RULE) 保证异常安全" name="ERR56">
            <rule header="不要让 'catch' 块为空" id="b" impl="EXCEPT-25" originalId="EXCEPT-25" quickfix="false" scope="line" severity="2">
               <file path="EXCEPT\EXCEPT-25.rule"/>
            </rule>
         </category>
         <category description="CERT-ERR58_CPP (RULE) 处理所有在 main() 函数开始执行之前抛出的异常" name="ERR58">
            <rule header="只有在程序启动后和终止前才会出现异常情况" id="a" impl="EXCEPT-08" originalId="EXCEPT-08" quickfix="false" scope="line" severity="2">
               <file path="EXCEPT\EXCEPT-08.rule"/>
            </rule>
         </category>
         <category description="CERT-EXP50_CPP (RULE) 不依赖于副作用的评估顺序" name="EXP50">
            <rule header="表达式的值应该在任何标准允许的赋值顺序下是一样的" id="a" impl="MISRA2004-12_2_a" originalId="MISRA2004-12_2_a" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-12_2_a.rule"/>
            </rule>
            <rule header="不要编写依赖于函数参数求值顺序的代码" id="b" impl="MISRA2004-12_2_b" originalId="MISRA2004-12_2_b" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-12_2_b.rule"/>
            </rule>
            <rule header="不要编写依赖于函数标志符和函数参数的求值顺序的代码" id="c" impl="MISRA2004-12_2_c" originalId="MISRA2004-12_2_c" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-12_2_c.rule"/>
            </rule>
            <rule header="涉及一个函数调用时，不要编写依赖表达式求值顺序的代码" id="d" impl="MISRA2004-12_2_d" originalId="MISRA2004-12_2_d" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-12_2_d.rule"/>
            </rule>
            <rule header="在序列点之间，对象的存储值最多只能通过表达式的评估来修改一次" id="e" impl="MISRA2004-12_2_e" originalId="MISRA2004-12_2_e" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-12_2_e.rule"/>
            </rule>
            <rule header="不要编写依赖于函数调用求值顺序的代码" id="f" impl="MISRA2004-12_2_g" originalId="MISRA2004-12_2_g" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-12_2_g.rule"/>
            </rule>
         </category>
         <category description="CERT-EXP54_CPP (RULE) 不要在超出其生命周期访问对象" name="EXP54">
            <rule header="不得从函数中返回具有自动存储的对象的地址" id="b" impl="MISRA2004-17_6_a" originalId="MISRA2004-17_6_a" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-17_6_a.rule"/>
            </rule>
            <rule header="自动存储对象的地址不应分配给在第一个对象不再存在后可能持久存在的另一个对象" id="c" impl="MISRA2004-17_6_b" originalId="MISRA2004-17_6_b" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-17_6_b.rule"/>
            </rule>
         </category>
         <category description="CERT-EXP55_CPP (RULE) 不要通过 cv 非限定类型访问 cv 限定对象" name="EXP55">
            <rule header="强制转换不得从指针或引用类型中删除任何“const”或“volatile”限定条件" id="a" impl="MISRA2004-11_5" originalId="MISRA2004-11_5" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-11_5.rule"/>
            </rule>
         </category>
         <category description="CERT-EXP61_CPP (RULE) lambda 对象的生命周期不能超过其任何引用捕获对象" name="EXP61">
            <rule header="永远不要返回通过引用捕获本地对象的lambda" id="a" impl="CODSTA-MCPP-17" originalId="CODSTA-MCPP-17" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-17.rule"/>
            </rule>
            <rule header="永远不要通过引用从外部lambda捕获本地对象" id="b" impl="CODSTA-MCPP-17_b" originalId="CODSTA-MCPP-17_b" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-17_b.rule"/>
            </rule>
            <rule header="通过引用捕获本地对象的lambda不应被赋值给有更长生命周期的变量" id="c" impl="CODSTA-MCPP-17_c" originalId="CODSTA-MCPP-17_c" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-17_c.rule"/>
            </rule>
         </category>
         <category description="CERT-EXP62_CPP (RULE) 不访问不属于对象值表示形式的对象表示的位" name="EXP62">
            <rule header="不要将可能包含填充位的类的对象与 C 标准库函数进行比较" id="a" impl="CODSTA-CPP-100" originalId="CODSTA-CPP-100" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-100.rule"/>
            </rule>
         </category>
         <category description="CERT-MEM57_CPP (RULE) 避免对过度对齐的类型使用默认的 new 操作符" name="MEM57">
            <rule header="避免对过度对齐类型使用默认运算符 'new'" id="a" impl="MRM-54" originalId="MRM-54" quickfix="false" scope="line" severity="2">
               <file path="MRM\MRM-54.rule"/>
            </rule>
         </category>
         <category description="CERT-MSC50_CPP (RULE) 不使用 std::rand() 函数生成伪随机数" name="MSC50">
            <rule header="不要使用 rand() 函数来生成伪随机数" id="a" impl="SECURITY-02_b" originalId="SECURITY-02_b" quickfix="false" scope="line" severity="2">
               <file path="SECURITY\SECURITY-02_b.rule"/>
            </rule>
         </category>
         <category description="CERT-MSC52_CPP (RULE) 值返回函数必须从所有出口路径返回一个值" name="MSC52">
            <rule header="具有非 void 返回类型的函数的所有退出路径，除 main() 外，都应具有带有表达式的显式返回语句" id="a" impl="MISRA2004-16_8_b" originalId="MISRA2004-16_8_b" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-16_8_b.rule"/>
            </rule>
         </category>
         <category description="CERT-OOP52_CPP (RULE) 不要删除没有虚拟析构函数的多态对象" name="OOP52">
            <rule header="在具有虚函数的基类中定义虚拟析构函数" id="a" impl="OOP-22" originalId="OOP-22" quickfix="false" scope="line" severity="2">
               <file path="OOP\OOP-22.rule"/>
            </rule>
         </category>
         <category description="CERT-OOP55_CPP (RULE) 不要使用指向成员指针的操作符来访问不存在的成员" name="OOP55">
            <rule header="强制类型转换不应将指向函数的指针转换为任何其他指针类型，包括指向函数类型的指针" id="a" impl="CODSTA-62" originalId="CODSTA-62" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-62.rule"/>
            </rule>
         </category>
         <category description="CERT-OOP57_CPP (RULE) 相比 C 语言标准的库函数优先选择特殊的成员函数和重载的操作符" name="OOP57">
            <rule header="不要使用C标准库函数初始化具有非普通类类型的对象" id="a" impl="CODSTA-CPP-93" originalId="CODSTA-CPP-93" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-93.rule"/>
            </rule>
            <rule header="不要将非标准布局类类型的对象与C标准库函数进行比较" id="b" impl="CODSTA-CPP-94" originalId="CODSTA-CPP-94" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-94.rule"/>
            </rule>
         </category>
         <category description="CERT-OOP58_CPP (RULE) 拷贝操作不能改变源对象" name="OOP58">
            <rule header="拷贝操作不能改变源对象" id="a" impl="CODSTA-CPP-98" originalId="CODSTA-CPP-98" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-98.rule"/>
            </rule>
         </category>
         <category description="CERT-CON54_CPP (RULE) 封装在循环中伪唤醒的函数" name="CON54">
            <rule header="封装可以在循环中伪唤醒的函数" id="a" impl="CODSTA-191" originalId="CODSTA-191" quickfix="false" scope="line" severity="3">
               <file path="CODSTA\CODSTA-191.rule"/>
            </rule>
         </category>
         <category description="CERT-CON55_CPP (RULE) 在使用条件变量时保持线程安全性和活性" name="CON55">
            <rule header="当多个线程在等待同一个条件变量时，不要使用 'notify_one()' 函数" id="a" impl="SECURITY-50" originalId="SECURITY-50" quickfix="false" scope="line" severity="3">
               <file path="SECURITY\SECURITY-50.rule"/>
            </rule>
         </category>
         <category description="CERT-CTR57_CPP (RULE) 提供有效的排序谓词" name="CTR57">
            <rule header="禁止对关联容器使用判定相等数值为 true 的比较函数" id="a" impl="STL-16" originalId="STL-16" quickfix="false" scope="line" severity="3">
               <file path="STL\STL-16.rule"/>
            </rule>
         </category>
         <category description="CERT-CTR58_CPP (RULE) 谓词函数对象不应该可变" name="CTR58">
            <rule header="使谓词常量成为纯函数" id="a" impl="STL-29" originalId="STL-29" quickfix="false" scope="line" severity="3">
               <file path="STL\STL-29.rule"/>
            </rule>
         </category>
         <category description="CERT-DCL51_CPP (RULE) 不要声明或定义保留标识符" name="DCL51">
            <rule header="不要使用以下划线开头的带有#define 或 #undef 名称的标识符" id="a" impl="MISRA2004-20_1_a" originalId="MISRA2004-20_1_a" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-20_1_a.rule"/>
            </rule>
            <rule header="不要重新定义保留字" id="b" impl="MISRA2004-20_1_b" originalId="MISRA2004-20_1_b" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-20_1_b.rule"/>
            </rule>
            <rule header="不使用 #define 或 #undef 标识符 'defined'" id="c" impl="MISRA2004-20_1_e" originalId="MISRA2004-20_1_e" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-20_1_e.rule"/>
            </rule>
            <rule header="标准库宏、对象和函数的名称不应该被重用" id="d" impl="MISRA2004-20_2" originalId="MISRA2004-20_2" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-20_2.rule"/>
            </rule>
            <rule header="不应该重复使用标准库中的宏，对象和函数(C90)" id="e" impl="MISRA2004-20_2_a" originalId="MISRA2004-20_2_a" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-20_2_a.rule"/>
            </rule>
            <rule header="标准库宏，对象和函数的名称不得重复使用（C99）" id="f" impl="MISRA2004-20_2_b" originalId="MISRA2004-20_2_b" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-20_2_b.rule"/>
            </rule>
         </category>
         <category description="CERT-DCL52_CPP (RULE) 绝不限定一个引用类型为 const 或  volatile" name="DCL52">
            <rule header="永远不要使用'const'或'volatile'来限定引用类型" id="a" impl="CODSTA-CPP-97" originalId="CODSTA-CPP-97" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-97.rule"/>
            </rule>
         </category>
         <category description="CERT-DCL53_CPP (RULE) 不要写语法含糊的声明" name="DCL53">
            <rule header="函数声明中的参数名不应该括在括号中" id="a" impl="FORMAT-48" originalId="FORMAT-48" quickfix="false" scope="line" severity="3">
               <file path="FORMAT\FORMAT-48.rule"/>
            </rule>
            <rule header="变量声明中的局部变量名不应该用括号括起来" id="b" impl="FORMAT-49" originalId="FORMAT-49" quickfix="false" scope="line" severity="3">
               <file path="FORMAT\FORMAT-49.rule"/>
            </rule>
            <rule header="避免语法上有歧义的函数声明" id="c" impl="PB-79" originalId="PB-79" quickfix="false" scope="line" severity="3">
               <file path="PB\PB-79.rule"/>
            </rule>
         </category>
         <category description="CERT-DCL55_CPP (RULE) 在跨越信任边界传递类对象时避免信息泄漏" name="DCL55">
            <rule header="不应将指向结构体的指针传递给可将数据复制到用户空间的函数" id="a" impl="SECURITY-46" originalId="SECURITY-46" quickfix="false" scope="line" severity="3">
               <file path="SECURITY\SECURITY-46.rule"/>
            </rule>
         </category>
         <category description="CERT-DCL56_CPP (RULE) 在静态对象的初始化过程中避免循环" name="DCL56">
            <rule header="通过用局部静态对象替换非局部静态对象来避免跨越编译单元的初始化顺序问题" id="a" impl="INIT-12" originalId="INIT-12" quickfix="false" scope="line" severity="3">
               <file path="INIT\INIT-12.rule"/>
            </rule>
         </category>
         <category description="CERT-DCL59_CPP (RULE) 不要在头文件中定义不具名的命名空间" name="DCL59">
            <rule header="头文件中不应有未命名的命名空间" id="a" impl="CODSTA-CPP-74" originalId="CODSTA-CPP-74" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-74.rule"/>
            </rule>
         </category>
         <category description="CERT-ERR50_CPP (RULE) 不要突然终止程序" name="ERR50">
            <rule header="使用 'std::atexit()' 或 'std::at_quick_exit()' 注册函数的执行不应异常退出" id="a" impl="PB-44" originalId="PB-44" quickfix="false" scope="line" severity="3">
               <file path="PB\PB-44.rule"/>
            </rule>
            <rule header="不允许从析构、释放和交换中抛出异常" id="b" impl="EXCEPT-01" originalId="EXCEPT-01" quickfix="false" scope="line" severity="3">
               <file path="EXCEPT\EXCEPT-01.rule"/>
            </rule>
            <rule header="不要从析构函数内抛出" id="c" impl="EXCEPT-03" originalId="EXCEPT-03" quickfix="false" scope="line" severity="3">
               <file path="EXCEPT\EXCEPT-03.rule"/>
            </rule>
            <rule header="至少应该有一个异常处理程序来捕获所有其他未处理的异常" id="d" impl="EXCEPT-06" originalId="EXCEPT-06" quickfix="false" scope="line" severity="3">
               <file path="EXCEPT\EXCEPT-06.rule"/>
            </rule>
            <rule header="空抛出(throw;)只能用于catch处理程序的复合语句中" id="e" impl="EXCEPT-07" originalId="EXCEPT-07" quickfix="false" scope="line" severity="3">
               <file path="EXCEPT\EXCEPT-07.rule"/>
            </rule>
            <rule header="只有在程序启动后和终止前才会出现异常情况" id="f" impl="EXCEPT-08" originalId="EXCEPT-08" quickfix="false" scope="line" severity="3">
               <file path="EXCEPT\EXCEPT-08.rule"/>
            </rule>
            <rule header="代码中显式抛出的每个异常都应在可能导致该点的所有调用路径中具有兼容类型的处理程序" id="g" impl="EXCEPT-13" originalId="EXCEPT-13" quickfix="false" scope="line" severity="3">
               <file path="EXCEPT\EXCEPT-13.rule"/>
            </rule>
            <rule header="如果函数的声明包含异常规范，则该函数只能抛出指定类型的异常" id="h" impl="EXCEPT-14" originalId="EXCEPT-14" quickfix="false" scope="line" severity="3">
               <file path="EXCEPT\EXCEPT-14.rule"/>
            </rule>
            <rule header="在全局或命名空间作用域中调用的函数不能抛出未处理的异常" id="i" impl="EXCEPT-18" originalId="EXCEPT-18" quickfix="false" scope="line" severity="3">
               <file path="EXCEPT\EXCEPT-18.rule"/>
            </rule>
            <rule header="不得使用  'stdlib.h' 或者 'cstdlib' 库中的 'abort()' 函数" id="l" impl="PB-75" originalId="PB-75" quickfix="false" scope="line" severity="3">
               <file path="PB\PB-75.rule"/>
            </rule>
            <rule header="不得使用 'stdlib.h' 或 'cstdlib' 库中的 'quick_exit()' 和 '_Exit()' 函数" id="n" impl="PB-75_c" originalId="PB-75_c" quickfix="false" scope="line" severity="3">
               <file path="PB\PB-75_c.rule"/>
            </rule>
         </category>
         <category description="CERT-ERR51_CPP (RULE) 处理所有异常" name="ERR51">
            <rule header="代码中显式抛出的每个异常都应在可能导致该点的所有调用路径中具有兼容类型的处理程序" id="b" impl="EXCEPT-13" originalId="EXCEPT-13" quickfix="false" scope="line" severity="3">
               <file path="EXCEPT\EXCEPT-13.rule"/>
            </rule>
         </category>
         <category description="CERT-ERR52_CPP (RULE) 不要使用 setjmp() 或 longjmp()" name="ERR52">
            <rule header="不应使用 &lt;setjmp.h&gt; 提供的工具" id="a" impl="MISRA2004-20_7" originalId="MISRA2004-20_7" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-20_7.rule"/>
            </rule>
            <rule header="不应使用标准头文件 &lt;setjmp.h&gt; 或 &lt;csetjmp&gt;" id="b" impl="MISRA2004-20_7_b" originalId="MISRA2004-20_7_b" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-20_7_b.rule"/>
            </rule>
         </category>
         <category description="CERT-ERR53_CPP (RULE) 不要在构造函数或析构函数的 try-block 处理程序中引用基类或类数据成员" name="ERR53">
            <rule header="以 function-try-block 实现的类构造函数或析构函数的处理程序不应引用该类或其基类的非静态成员" id="a" impl="EXCEPT-16" originalId="EXCEPT-16" quickfix="false" scope="line" severity="3">
               <file path="EXCEPT\EXCEPT-16.rule"/>
            </rule>
         </category>
         <category description="CERT-ERR60_CPP (RULE) 异常对象不抛出 (nothrow)拷贝可构造的" name="ERR60">
            <rule header="异常对象必须是不可抛出复制构造函数" id="a" impl="EXCEPT-19" originalId="EXCEPT-19" quickfix="false" scope="line" severity="3">
               <file path="EXCEPT\EXCEPT-19.rule"/>
            </rule>
            <rule header="继承自'std::exception'的类的显式声明复制构造函数应该具有非抛出异常规范" id="b" impl="EXCEPT-20" originalId="EXCEPT-20" quickfix="false" scope="line" severity="3">
               <file path="EXCEPT\EXCEPT-20.rule"/>
            </rule>
         </category>
         <category description="CERT-ERR61_CPP (RULE) 通过 lvalue 引用捕获异常" name="ERR61">
            <rule header="一个类的类型异常应始终通过引用捕获" id="a" impl="EXCEPT-15" originalId="EXCEPT-15" quickfix="false" scope="line" severity="3">
               <file path="EXCEPT\EXCEPT-15.rule"/>
            </rule>
            <rule header="按值抛出，按参考捕获" id="b" impl="EXCEPT-02" originalId="EXCEPT-02" quickfix="false" scope="line" severity="3">
               <file path="EXCEPT\EXCEPT-02.rule"/>
            </rule>
         </category>
         <category description="CERT-ERR62_CPP (RULE) 在将字符串转换为数字时检测错误" name="ERR62">
            <rule header="不得使用库stdlib.h中的库函数atof，atoi和atol" id="a" impl="MISRA2004-20_10" originalId="MISRA2004-20_10" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-20_10.rule"/>
            </rule>
         </category>
         <category description="CERT-EXP52_CPP (RULE) 不要依赖于未评估操作数的副作用" name="EXP52">
            <rule header="sizeof 运算符的操作数不应包含任何有副作用的表达式" id="a" impl="MISRA2004-12_3" originalId="MISRA2004-12_3" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-12_3.rule"/>
            </rule>
            <rule header="不应在sizeof运算符的操作数中访问由volatile左值指定的对象" id="b" impl="MISRA2004-12_3_b" originalId="MISRA2004-12_3_b" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-12_3_b.rule"/>
            </rule>
            <rule header="会导致副作用的函数调用不应该用作 sizeof 运算符的操作数" id="c" impl="MISRA2004-12_3_c" originalId="MISRA2004-12_3_c" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-12_3_c.rule"/>
            </rule>
            <rule header="typeid 操作符的操作数不能包含任何有副作用的表达式" id="d" impl="CODSTA-CPP-104" originalId="CODSTA-CPP-104" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-104.rule"/>
            </rule>
            <rule header="'typeid' 操作符的操作数不应包含导致副作用的函数调用" id="e" impl="CODSTA-CPP-104_b" originalId="CODSTA-CPP-104_b" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-104_b.rule"/>
            </rule>
         </category>
         <category description="CERT-EXP56_CPP (RULE) 不要调用包含不匹配语言链接的函数" name="EXP56">
            <rule header="不要使用不匹配的语言链接调用函数" id="a" impl="CODSTA-CPP-96" originalId="CODSTA-CPP-96" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-96.rule"/>
            </rule>
         </category>
         <category description="CERT-EXP57_CPP (RULE) 不要强制类型转换或删除不完整类的指针" name="EXP57">
            <rule header="不要在删除点上时删除类不完整的对象" id="a" impl="PB-55" originalId="PB-55" quickfix="false" scope="line" severity="3">
               <file path="PB\PB-55.rule"/>
            </rule>
            <rule header="不能在指向不完整类型的指针和任何其他类型的指针之间进行转换" id="b" impl="CODSTA-125" originalId="CODSTA-125" quickfix="false" scope="line" severity="3">
               <file path="CODSTA\CODSTA-125.rule"/>
            </rule>
         </category>
         <category description="CERT-EXP59_CPP (RULE) 在有效类型和成员上使用 offsetof()" name="EXP59">
            <rule header="在有效的类型以及成员上使用 offsetof()" id="a" impl="CODSTA-CPP-99" originalId="CODSTA-CPP-99" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-99.rule"/>
            </rule>
         </category>
         <category description="CERT-INT50_CPP (RULE) 不要强制类型转换到一个超出范围的枚举值" name="INT50">
            <rule header="带有枚举底层类型的表达式只能具有与枚举的枚举数相对应的值" id="a" impl="PB-70" originalId="PB-70" quickfix="false" scope="line" severity="3">
               <file path="PB\PB-70.rule"/>
            </rule>
         </category>
         <category description="CERT-OOP50_CPP (RULE) 不要从构造函数或析构函数中调用虚拟函数" name="OOP50">
            <rule header="避免从构造函数调用虚函数" id="a" impl="OOP-16" originalId="OOP-16" quickfix="false" scope="line" severity="3">
               <file path="OOP\OOP-16.rule"/>
            </rule>
            <rule header="避免从析构函数调用虚函数" id="b" impl="OOP-16_b" originalId="OOP-16_b" quickfix="false" scope="line" severity="3">
               <file path="OOP\OOP-16_b.rule"/>
            </rule>
         </category>
         <category description="CERT-OOP51_CPP (RULE) 不要分割派生对象" name="OOP51">
            <rule header="避免切片函数参数/返回值" id="a" impl="PB-20" originalId="PB-20" quickfix="false" scope="line" severity="3">
               <file path="PB\PB-20.rule"/>
            </rule>
         </category>
         <category description="CERT-OOP53_CPP (RULE) 按规范顺序来编写构造函数成员初始化器" name="OOP53">
            <rule header="在初始化列表中按声明成员的顺序列出成员" id="a" impl="INIT-10" originalId="INIT-10" quickfix="false" scope="line" severity="3">
               <file path="INIT\INIT-10.rule"/>
            </rule>
         </category>
         <category description="CERT-OOP54_CPP (RULE) 正确地处理自拷贝赋值" name="OOP54">
            <rule header="检查 operator= 中的自我赋值" id="a" impl="OOP-34" originalId="OOP-34" quickfix="false" scope="line" severity="3">
               <file path="OOP\OOP-34.rule"/>
            </rule>
         </category>
      </category>
      <category description="编码规范" name="CODSTA">
         <rule header="局部变量或参数名称跟类成员变量或父类/结构体成员变量的名称至少应该2个或以上字符不同" id="22" impl="CODSTA-22" quickfix="false" scope="line" severity="1">
            <file path="CODSTA\CODSTA-22.rule"/>
         </rule>
         <rule header="避免内部或外部变量名称与 C++ 保留字冲突" id="39" impl="CODSTA-39" quickfix="false" scope="line" severity="1">
            <file path="CODSTA\CODSTA-39.rule"/>
         </rule>
         <rule header="局部变量不应使用与成员变量相同的名称" id="44" impl="CODSTA-44" quickfix="false" scope="line" severity="1">
            <file path="CODSTA\CODSTA-44.rule"/>
         </rule>
         <rule header="参数不应使用与成员变量相同的名称" id="45" impl="CODSTA-45" quickfix="false" scope="line" severity="1">
            <file path="CODSTA\CODSTA-45.rule"/>
         </rule>
         <category description="C++ 编码规范" name="CPP">
            <rule header="允许转换的构造函数应该是使用 explicit 修饰" id="04" impl="CODSTA-CPP-04" quickfix="false" scope="line" severity="1">
               <file path="CODSTA-CPP\CODSTA-CPP-04.rule"/>
            </rule>
            <rule header="不要使用用户自定义的转换函数" id="05" impl="CODSTA-CPP-05" quickfix="false" scope="line" severity="1">
               <file path="CODSTA-CPP\CODSTA-CPP-05.rule"/>
            </rule>
            <rule header="条件运算符的第一个操作数应该具有布尔类型" id="65" impl="CODSTA-CPP-65" quickfix="false" scope="line" severity="1">
               <file path="CODSTA-CPP\CODSTA-CPP-65.rule"/>
            </rule>
            <rule header="至少声明一个构造函数以防止编译器提供一个公共的构造函数" id="19" impl="CODSTA-CPP-19" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-19.rule"/>
            </rule>
            <rule header="在接口中不应该使用数组类型参数" id="55" impl="CODSTA-CPP-55" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-55.rule"/>
            </rule>
            <rule header="私有方法和被保护的方法不应该用数组类型声明参数" id="55_b" impl="CODSTA-CPP-55_b" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-55_b.rule"/>
            </rule>
            <rule header="拷贝操作不能改变源对象" id="98" impl="CODSTA-CPP-98" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-98.rule"/>
            </rule>
            <rule header="赋值操作符返回一个 *this 指向的引用；使赋值操作符的返回类型是指向自身 类类型的非常量引用" id="02" impl="CODSTA-CPP-02" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-02.rule"/>
            </rule>
            <rule header="位操作符，比较操作符，逻辑操作符，逗号操作符应该为 const" id="03" impl="CODSTA-CPP-03" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-03.rule"/>
            </rule>
            <rule header="避免从成员函数返回指向类数据的非 const 句柄(指针或引用)" id="06" impl="CODSTA-CPP-06" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-06.rule"/>
            </rule>
            <rule header="后缀增量和减量应该依据其前缀的实际情况实现" id="07" impl="CODSTA-CPP-07" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-07.rule"/>
            </rule>
            <rule header="避免重载逻辑操作符AND, OR (&amp;&amp;, ||)" id="08" impl="CODSTA-CPP-08" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-08.rule"/>
            </rule>
            <rule header="避免使用强制类型转换符 reinterpret_cast" id="09" impl="CODSTA-CPP-09" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-09.rule"/>
            </rule>
            <rule header="不要定义包含成员函数的结构体" id="10" impl="CODSTA-CPP-10" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-10.rule"/>
            </rule>
            <rule header="不要将可能包含填充位的类的对象与 C 标准库函数进行比较" id="100" impl="CODSTA-CPP-100" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-100.rule"/>
            </rule>
            <rule header="关系运算符应返回布尔值" id="101" impl="CODSTA-CPP-101" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-101.rule"/>
            </rule>
            <rule header="二进制算术运算符和位运算符应返回一个 'prvalue'" id="102" impl="CODSTA-CPP-102" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-102.rule"/>
            </rule>
            <rule header="不得使用输出参数" id="103" impl="CODSTA-CPP-103" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-103.rule"/>
            </rule>
            <rule header="typeid 操作符的操作数不能包含任何有副作用的表达式" id="104" impl="CODSTA-CPP-104" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-104.rule"/>
            </rule>
            <rule header="'typeid' 操作符的操作数不应包含导致副作用的函数调用" id="104_b" impl="CODSTA-CPP-104_b" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-104_b.rule"/>
            </rule>
            <rule header="当操作等同于编译器操作时，将特殊变量定义为 default" id="105" impl="CODSTA-CPP-105" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-105.rule"/>
            </rule>
            <rule header="使用委托构造函数来减少代码重复" id="106" impl="CODSTA-CPP-106" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-106.rule"/>
            </rule>
            <rule header="比较运算符应为非成员函数" id="107" impl="CODSTA-CPP-107" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-107.rule"/>
            </rule>
            <rule header="比较运算符应为具有相同参数类型和 noexcept 的非成员函数" id="107_b" impl="CODSTA-CPP-107_b" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-107_b.rule"/>
            </rule>
            <rule header="使用 const 引用 'cheap to copy' 类型的参数应按值传递" id="108" impl="CODSTA-CPP-108" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-108.rule"/>
            </rule>
            <rule header="通过值传递具有平凡复制构造函数的小对象" id="108_b" impl="CODSTA-CPP-108_b" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-108_b.rule"/>
            </rule>
            <rule header="非 'cheap to copy' 类型的参数应该通过引用来传递" id="109" impl="CODSTA-CPP-109" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-109.rule"/>
            </rule>
            <rule header="不应使用 C 风格强制转换" id="11" impl="CODSTA-CPP-11" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-11.rule"/>
            </rule>
            <rule header="基类和成员变量的类应放在不同的头文件当中" id="12" impl="CODSTA-CPP-12" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-12.rule"/>
            </rule>
            <rule header="作为函数返回类型的类应该放在单独的头文件中" id="13" impl="CODSTA-CPP-13" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-13.rule"/>
            </rule>
            <rule header="在函数原形中作为入口参数类型的类应该放在单独的头文件中" id="14" impl="CODSTA-CPP-14" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-14.rule"/>
            </rule>
            <rule header="使用在内联成员函数内部的函数应该放在单独的头文件中" id="15" impl="CODSTA-CPP-15" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-15.rule"/>
            </rule>
            <rule header="当两个操作符是对立的(例如==和!=)时，可以同时定义它们" id="16" impl="CODSTA-CPP-16" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-16.rule"/>
            </rule>
            <rule header="不要使用 'struct' 关键字来声明 C++ 的变量" id="17" impl="CODSTA-CPP-17" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-17.rule"/>
            </rule>
            <rule header="如果想支持混合模式的操作, 操作符应该是非成员函数" id="20" impl="CODSTA-CPP-20" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-20.rule"/>
            </rule>
            <rule header="避免使用任何虚的赋值操作符。赋值操作符不能返回常量 T&amp;" id="24" impl="CODSTA-CPP-24" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-24.rule"/>
            </rule>
            <rule header="非公共成员应为虚函数，公共函数应为非虚函数" id="25" impl="CODSTA-CPP-25" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-25.rule"/>
            </rule>
            <rule header="保持类型和函数在单独的命名空间中，除非它们确实需要一起运行" id="26" impl="CODSTA-CPP-26" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-26.rule"/>
            </rule>
            <rule header="保持一个类型和它的非成员函数接口在同一个命名空间" id="27" impl="CODSTA-CPP-27" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-27.rule"/>
            </rule>
            <rule header="如果定义了二进制运算操作符 ( + , - , * , / , ^ , % , | , &amp; )，应同时定义其对应的赋值操作符" id="28" impl="CODSTA-CPP-28" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-28.rule"/>
            </rule>
            <rule header="算术和赋值操作符应该有规范的形式" id="29" impl="CODSTA-CPP-29" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-29.rule"/>
            </rule>
            <rule header="非成员操作符比成员操作符更支持混合形式的算术运算" id="30" impl="CODSTA-CPP-30" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-30.rule"/>
            </rule>
            <rule header="除非打算内联函数，否则函数定义不应放在类规范中" id="32" impl="CODSTA-CPP-32" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-32.rule"/>
            </rule>
            <rule header="不应在模板类定义中定义成员函数" id="33" impl="CODSTA-CPP-33" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-33.rule"/>
            </rule>
            <rule header="避免在指针上使用 static_cast" id="34" impl="CODSTA-CPP-34" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-34.rule"/>
            </rule>
            <rule header="避免使用dynamic_casts" id="35" impl="CODSTA-CPP-35" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-35.rule"/>
            </rule>
            <rule header="全局命名空间应该只包含 main() 和命名空间声明" id="36" impl="CODSTA-CPP-36" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-36.rule"/>
            </rule>
            <rule header="在函数的执行体中不应定义类，结构体，联合体(class/struct/union)" id="37" impl="CODSTA-CPP-37" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-37.rule"/>
            </rule>
            <rule header="转换操作符, operator-&gt;, operator(), operator[] 应该为常量类型" id="38" impl="CODSTA-CPP-38" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-38.rule"/>
            </rule>
            <rule header="不要在头文件中或 #include 之前写 namespace usings" id="39" impl="CODSTA-CPP-39" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-39.rule"/>
            </rule>
            <rule header="不要使用 'enum' 关键字在 C++ 中声明变量" id="41" impl="CODSTA-CPP-41" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-41.rule"/>
            </rule>
            <rule header="不使用 'mutable' 关键字声明成员变量" id="42" impl="CODSTA-CPP-42" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-42.rule"/>
            </rule>
            <rule header="尽可能将引用参数声明为 const 引用" id="43" impl="CODSTA-CPP-43" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-43.rule"/>
            </rule>
            <rule header="应使非 const 成员函数调用 const 成员函数，而非复制 const 的定义" id="44" impl="CODSTA-CPP-44" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-44.rule"/>
            </rule>
            <rule header="一个类的私有成员部分应该声明成以下顺序:构造函数、析构函数、成员函数、成员操作符函数、枚举以及其他" id="45" impl="CODSTA-CPP-45" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-45.rule"/>
            </rule>
            <rule header="在一个类中作用范围的顺序为: public 位置应在最前面" id="46" impl="CODSTA-CPP-46" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-46.rule"/>
            </rule>
            <rule header="在一个类中作用范围的顺序: protected 位于 private 之前" id="47" impl="CODSTA-CPP-47" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-47.rule"/>
            </rule>
            <rule header="在类的protected域中，各项应该以如下顺序声明: 构造函数, 析构函数, 成员函数, 成员操作符函数, 枚举类型和其他" id="48" impl="CODSTA-CPP-48" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-48.rule"/>
            </rule>
            <rule header="在类的 public 域中，各项应该以如下顺序声明: 构造函数, 析构函数, 成员函数, 成员操作符函数, 枚举类型和其他" id="49" impl="CODSTA-CPP-49" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-49.rule"/>
            </rule>
            <rule header="不要使用 static 关键字，除非在函数或者类中" id="50" impl="CODSTA-CPP-50" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-50.rule"/>
            </rule>
            <rule header="在源文件中不要定义内联函数" id="51" impl="CODSTA-CPP-51" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-51.rule"/>
            </rule>
            <rule header="构造函数使用赋值型的操作符和独立型的操作符的自然的关系" id="52" impl="CODSTA-CPP-52" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-52.rule"/>
            </rule>
            <rule header="尽可能将局部变量声明为 const" id="53" impl="CODSTA-CPP-53" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-53.rule"/>
            </rule>
            <rule header="尽可能将参数声明为 const" id="53_b" impl="CODSTA-CPP-53_b" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-53_b.rule"/>
            </rule>
            <rule header="成员函数应尽可能声明为常量" id="54" impl="CODSTA-CPP-54" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-54.rule"/>
            </rule>
            <rule header="类，结构体或枚举不应该在其类型定义中被声明" id="56" impl="CODSTA-CPP-56" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-56.rule"/>
            </rule>
            <rule header="命名空间的嵌套不能超过两层" id="57" impl="CODSTA-CPP-57" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-57.rule"/>
            </rule>
            <rule header="从不是重载运算符函数得到的非 void 类型的返回值应该始终被使用" id="58" impl="CODSTA-CPP-58" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-58.rule"/>
            </rule>
            <rule header="不能使用C语言库" id="59" impl="CODSTA-CPP-59" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-59.rule"/>
            </rule>
            <rule header="仅应使用 ISO/IEC 14882:2003 中定义的转义序列" id="60" impl="CODSTA-CPP-60" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-60.rule"/>
            </rule>
            <rule header="仅应使用 ISO/IEC 14882:2014 中定义的转义序列" id="60_b" impl="CODSTA-CPP-60_b" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-60_b.rule"/>
            </rule>
            <rule header="NULL 不得用作一个整数值" id="62" impl="CODSTA-CPP-62" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-62.rule"/>
            </rule>
            <rule header="字面量 （0） 不应用作空指针常数" id="63" impl="CODSTA-CPP-63" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-63.rule"/>
            </rule>
            <rule header="if 语句的条件和循环语句的条件应该是布尔类型" id="64" impl="CODSTA-CPP-64" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-64.rule"/>
            </rule>
            <rule header="不得使用 C 语言风格的强制类型转换(除 void 强制类型转换外)和函数符号式强制类型转换(除了显式的构造函数调用外)" id="66" impl="CODSTA-CPP-66" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-66.rule"/>
            </rule>
            <rule header="! 运算符，逻辑 &amp;&amp; 或逻辑 || 运算符的每个操作数应该都是布尔类型" id="67" impl="CODSTA-CPP-67" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-67.rule"/>
            </rule>
            <rule header="一元 &amp; 运算符不得被重载" id="68" impl="CODSTA-CPP-68" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-68.rule"/>
            </rule>
            <rule header="for 循环应该包含一个没有浮动类型的单一的循环计数器" id="69" impl="CODSTA-CPP-69" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-69.rule"/>
            </rule>
            <rule header="如果循环计数器不是被 -- 或 ++ 修改，那么在条件中此循环计数器应该只能被用作 &lt;=, &lt;, &gt; 或 &gt;= 的操作数" id="70" impl="CODSTA-CPP-70" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-70.rule"/>
            </rule>
            <rule header="循环计数器应该被 --, ++, -=n, 或 +=n 之一修改；这里的 n 在整个循环期间保持不变" id="71" impl="CODSTA-CPP-71" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-71.rule"/>
            </rule>
            <rule header="循环计数器以外的循环控制变量不得在判定条件或运算表达式中被修改" id="72" impl="CODSTA-CPP-72" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-72.rule"/>
            </rule>
            <rule header="在循环体语句中被修改的循环计数器以外的循环控制变量应该是布尔类型的" id="73" impl="CODSTA-CPP-73" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-73.rule"/>
            </rule>
            <rule header="头文件中不应有未命名的命名空间" id="74" impl="CODSTA-CPP-74" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-74.rule"/>
            </rule>
            <rule header="不得使用 using 指示符" id="75" impl="CODSTA-CPP-75" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-75.rule"/>
            </rule>
            <rule header="在同一个命名空间中标识符的多重声明不得跨越该标识符的 using 声明" id="76" impl="CODSTA-CPP-76" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-76.rule"/>
            </rule>
            <rule header="Const 成员函数不得返回指向类数据的非 const 指针或引用" id="77" impl="CODSTA-CPP-77" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-77.rule"/>
            </rule>
            <rule header="如果一个成员函数可以是 static，那么就应该定义为 static，否则，如果它可以是 const，那么它就应该被定义为 const" id="78" impl="CODSTA-CPP-78" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-78.rule"/>
            </rule>
            <rule header="判等运算符 (== 或 !=)的任何一个操作数都不应该是一个指向虚成员函数的指针" id="79" impl="CODSTA-CPP-79" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-79.rule"/>
            </rule>
            <rule header="避免重载逗号运算符 &quot;,&quot;" id="80" impl="CODSTA-CPP-80" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-80.rule"/>
            </rule>
            <rule header="避免未封装的全局变量 (包括在命名空间中声明的变量和公共静态成员)" id="82" impl="CODSTA-CPP-82" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-82.rule"/>
            </rule>
            <rule header="在一个局部范围内声明的标识符不应该隐藏在一个类作用域中声明的标识符" id="83" impl="CODSTA-CPP-83" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-83.rule"/>
            </rule>
            <rule header="在类的作用域中声明的标识符不应该隐藏在全局或命名空间范围内声明的标识符" id="84" impl="CODSTA-CPP-84" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-84.rule"/>
            </rule>
            <rule header="在一个内部类作用域中声明的标识符不应该隐藏在外部类作用域中声明的标识符" id="85" impl="CODSTA-CPP-85" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-85.rule"/>
            </rule>
            <rule header="如果在一个类中定义了两个相反的相等运算符（'=='、'!='），则其中一个运算符应以另一个运算符的形式定义" id="86" impl="CODSTA-CPP-86" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-86.rule"/>
            </rule>
            <rule header="如果标识符指的是一个类型，它不应也指向同一范围内的对象或函数" id="87_a" impl="CODSTA-CPP-87_a" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-87_a.rule"/>
            </rule>
            <rule header="如果标识符指的是一个类型，它不应也指向同一范围内的对象或函数" id="87_b" impl="CODSTA-CPP-87_b" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-87_b.rule"/>
            </rule>
            <rule header="如果标识符指的是一个类型，它不应也指向同一范围内的对象或函数" id="87_c" impl="CODSTA-CPP-87_c" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-87_c.rule"/>
            </rule>
            <rule header="typedef 的名称不应该与其基本类型的名称相同" id="88" impl="CODSTA-CPP-88" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-88.rule"/>
            </rule>
            <rule header="不应该在头文件中使用 'using' 指令和 'using' 声明(除了类和函数范围内的 using 声明)" id="90" impl="CODSTA-CPP-90" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-90.rule"/>
            </rule>
            <rule header="二进制过载操作符应该用其对应的复合赋值运算符实现" id="91" impl="CODSTA-CPP-91" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-91.rule"/>
            </rule>
            <rule header="多重继承层次中可访问的实例名必须独一无二" id="92" impl="CODSTA-CPP-92" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-92.rule"/>
            </rule>
            <rule header="不要使用C标准库函数初始化具有非普通类类型的对象" id="93" impl="CODSTA-CPP-93" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-93.rule"/>
            </rule>
            <rule header="不要将非标准布局类类型的对象与C标准库函数进行比较" id="94" impl="CODSTA-CPP-94" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-94.rule"/>
            </rule>
            <rule header="不要修改标准命名空间 'std' 和 'posix'" id="95" impl="CODSTA-CPP-95" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-95.rule"/>
            </rule>
            <rule header="不要使用不匹配的语言链接调用函数" id="96" impl="CODSTA-CPP-96" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-96.rule"/>
            </rule>
            <rule header="永远不要使用'const'或'volatile'来限定引用类型" id="97" impl="CODSTA-CPP-97" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-97.rule"/>
            </rule>
            <rule header="在有效的类型以及成员上使用 offsetof()" id="99" impl="CODSTA-CPP-99" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-99.rule"/>
            </rule>
            <rule header="最好使用非成员非友元函数(non-member non-friend)替代成员函数" id="22" impl="CODSTA-CPP-22" quickfix="false" scope="line" severity="4">
               <file path="CODSTA-CPP\CODSTA-CPP-22.rule"/>
            </rule>
            <rule header="不允许仅存在 getters/setters(accessors/mutators) 的类" id="81" impl="CODSTA-CPP-81" quickfix="false" scope="line" severity="4">
               <file path="CODSTA-CPP\CODSTA-CPP-81.rule"/>
            </rule>
            <rule header="不要分配枚举到bool" id="89" impl="CODSTA-CPP-89" quickfix="false" scope="line" severity="4">
               <file path="CODSTA-CPP\CODSTA-CPP-89.rule"/>
            </rule>
            <rule header="最好使用头文件 iostream.h 而非 stdio.h" id="01" impl="CODSTA-CPP-01" quickfix="false" scope="line" severity="5">
               <file path="CODSTA-CPP\CODSTA-CPP-01.rule"/>
            </rule>
            <rule header="将全局变量，常量，枚举类型和自定义类型变量(typedefs)封装在一个类中" id="18" impl="CODSTA-CPP-18" quickfix="false" scope="line" severity="5">
               <file path="CODSTA-CPP\CODSTA-CPP-18.rule"/>
            </rule>
            <rule header="赋值操作符必须返回常引用" id="21" impl="CODSTA-CPP-21" quickfix="false" scope="line" severity="5">
               <file path="CODSTA-CPP\CODSTA-CPP-21.rule"/>
            </rule>
            <rule header="每当一个全局函数被引用时，使用::作用域运算符" id="23" impl="CODSTA-CPP-23" quickfix="false" scope="line" severity="5">
               <file path="CODSTA-CPP\CODSTA-CPP-23.rule"/>
            </rule>
            <rule header="不要在构造函数上使用关键字 'explicit'" id="31" impl="CODSTA-CPP-31" quickfix="false" scope="line" severity="5">
               <file path="CODSTA-CPP\CODSTA-CPP-31.rule"/>
            </rule>
            <rule header="限制一个类的对象个数" id="40" impl="CODSTA-CPP-40" quickfix="false" scope="line" severity="5">
               <file path="CODSTA-CPP\CODSTA-CPP-40.rule"/>
            </rule>
         </category>
         <rule header="在 for 循环中不要使用 break" id="08" impl="CODSTA-08" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-08.rule"/>
         </rule>
         <rule header="在&lt;tgmath.h&gt;中声明的任何通用类型宏的所有参数都应具有适当的基本类型" id="108_c" impl="CODSTA-108_c" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-108_c.rule"/>
         </rule>
         <rule header="在 &lt;tgmath.h&gt; 中声明的任何多参数通用类型宏的所有参数应具有相同的标准类型" id="108_d" impl="CODSTA-108_d" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-108_d.rule"/>
         </rule>
         <rule header="不应使用指向可变修改数组类型的指针" id="112_b" impl="CODSTA-112_b" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-112_b.rule"/>
         </rule>
         <rule header="全局函数不能声明数组类型的参数" id="142" impl="CODSTA-142" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-142.rule"/>
         </rule>
         <rule header="当数组作为参数传入一个函数时不要声明数组的大小" id="15" impl="CODSTA-15" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-15.rule"/>
         </rule>
         <rule header="当数组被初始化的时不要声明数组的大小" id="16" impl="CODSTA-16" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-16.rule"/>
         </rule>
         <rule header="数组参数的声明不得在 [ ] 之间包含 'static' 关键字" id="160" impl="CODSTA-160" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-160.rule"/>
         </rule>
         <rule header="指向 FILE 对象的指针不应被解引用" id="166_a" impl="CODSTA-166_a" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-166_a.rule"/>
         </rule>
         <rule header="指向 FILE 对象的指针不应由库函数解引用" id="166_b" impl="CODSTA-166_b" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-166_b.rule"/>
         </rule>
         <rule header="运算符'sizeof'的操作数不能是声明为&quot;array of type&quot;的函数参数" id="182" impl="CODSTA-182" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-182.rule"/>
         </rule>
         <rule header="标准库函数 'localeconv', 'getenv', 'setlocale' 或 'strerror' 返回的指针仅当它们具有指向 const 限定类型的指针时使用" id="185_a" impl="CODSTA-185_a" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-185_a.rule"/>
         </rule>
         <rule header="不要指定用字符串文本初始化的字符数组的大小" id="197" impl="CODSTA-197" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-197.rule"/>
         </rule>
         <rule header="应该使用 EOS 作为字符串的结尾而不是使用 NULL" id="20" impl="CODSTA-20" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-20.rule"/>
         </rule>
         <rule header="带有外部链接的函数的内联定义不应包含静态对象的定义和使用" id="202" impl="CODSTA-202" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-202.rule"/>
         </rule>
         <rule header="字母后缀应使用大写字母而不是小写字母" id="51" impl="CODSTA-51" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-51.rule"/>
         </rule>
         <rule header="Case 语句的标签应该使用枚举(enum)类型而不是使用整数类型(和常量)" id="55" impl="CODSTA-55" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-55.rule"/>
         </rule>
         <category description="Modern C++ 编码规范" name="MCPP">
            <rule header="优于 std::bind、std::bind1st 和 std::bind2nd 的 lambda" id="07" impl="CODSTA-MCPP-07" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-07.rule"/>
            </rule>
            <rule header="使用 auto 类型来声明变量" id="08_a" impl="CODSTA-MCPP-08_a" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-08_a.rule"/>
            </rule>
            <rule header="请使用 auto 类型作为函数返回值" id="08_b" impl="CODSTA-MCPP-08_b" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-08_b.rule"/>
            </rule>
            <rule header="用户定义类型的所有std::hash专门化都应具有noexcept函数调用运算符" id="27" impl="CODSTA-MCPP-27" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-27.rule"/>
            </rule>
            <rule header="如果一个类通过 '=default'、'=delete' 或用户提供的声明声明了一个复制或移动操作或析构函数，那么这五个特殊成员函数中的所有其他函数也都应被声明" id="56" impl="CODSTA-MCPP-56" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-56.rule"/>
            </rule>
            <rule header="自定义类型转换函数需要使用标识符标识" id="01" impl="CODSTA-MCPP-01" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-01.rule"/>
            </rule>
            <rule header="不能使用typedef定义类型" id="02" impl="CODSTA-MCPP-02" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-02.rule"/>
            </rule>
            <rule header="使用作用域枚举类型" id="03" impl="CODSTA-MCPP-03" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-03.rule"/>
            </rule>
            <rule header="每个重载的虚函数都应使用 override 或 final 声明符声明。" id="05" impl="CODSTA-MCPP-05" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-05.rule"/>
            </rule>
            <rule header="使用 delete 关键避免声明拷贝构造函数以及拷贝赋值运算符" id="06_a" impl="CODSTA-MCPP-06_a" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-06_a.rule"/>
            </rule>
            <rule header="通过使用 delete 关键字来声明拷贝构造以及拷贝赋值运算符，而不是使用私有方法的基类来避免拷贝类" id="06_b" impl="CODSTA-MCPP-06_b" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-06_b.rule"/>
            </rule>
            <rule header="不应该使用 'binder1st' 和 'binder2nd' 标识符" id="07_b" impl="CODSTA-MCPP-07_b" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-07_b.rule"/>
            </rule>
            <rule header="如果函数不抛出异常，则请使用关键字 'noexcept' 声明" id="09" impl="CODSTA-MCPP-09" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-09.rule"/>
            </rule>
            <rule header="比起迭代器，更倾向于常量迭代器" id="10_a" impl="CODSTA-MCPP-10_a" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-10_a.rule"/>
            </rule>
            <rule header="应该使用 cbegin(), crbegin, cend(), crend() 函数" id="10_b" impl="CODSTA-MCPP-10_b" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-10_b.rule"/>
            </rule>
            <rule header="在右值(rvalue)引用上使用 std::move() 和在转发引用(forwarding references)上使用 std::forward()" id="13" impl="CODSTA-MCPP-13" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-13.rule"/>
            </rule>
            <rule header="'std::forward' 函数应用来转发通用引用" id="13_b" impl="CODSTA-MCPP-13_b" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-13_b.rule"/>
            </rule>
            <rule header="避免在转发引用上使用重载" id="14" impl="CODSTA-MCPP-14" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-14.rule"/>
            </rule>
            <rule header="避免默认捕获模式" id="15_a" impl="CODSTA-MCPP-15_a" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-15_a.rule"/>
            </rule>
            <rule header="在 lambda 中显式地使用 'this' 指针具有捕获副作用" id="15_b" impl="CODSTA-MCPP-15_b" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-15_b.rule"/>
            </rule>
            <rule header="建议使用 'std::make_shared' 而不是直接使用 new" id="16_c" impl="CODSTA-MCPP-16_c" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-16_c.rule"/>
            </rule>
            <rule header="优先使用 std::unique_ptr 而不是 std::auto_ptr" id="16_d" impl="CODSTA-MCPP-16_d" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-16_d.rule"/>
            </rule>
            <rule header="'std::make_unique'应该用来构造属于'std::unique_ptr'的对象" id="16_e" impl="CODSTA-MCPP-16_e" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-16_e.rule"/>
            </rule>
            <rule header="永远不要返回通过引用捕获本地对象的lambda" id="17" impl="CODSTA-MCPP-17" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-17.rule"/>
            </rule>
            <rule header="永远不要通过引用从外部lambda捕获本地对象" id="17_b" impl="CODSTA-MCPP-17_b" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-17_b.rule"/>
            </rule>
            <rule header="通过引用捕获本地对象的lambda不应被赋值给有更长生命周期的变量" id="17_c" impl="CODSTA-MCPP-17_c" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-17_c.rule"/>
            </rule>
            <rule header="在lambda表达式中避免不必要的默认捕获模式" id="18_a" impl="CODSTA-MCPP-18_a" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-18_a.rule"/>
            </rule>
            <rule header="避免不必要的lambda 捕获" id="18_b" impl="CODSTA-MCPP-18_b" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-18_b.rule"/>
            </rule>
            <rule header="使用引用修饰符&amp;(ref-qualifier)来声明赋值运算符" id="19" impl="CODSTA-MCPP-19" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-19.rule"/>
            </rule>
            <rule header="在基于范围的'for'循环中对自动声明使用显式引用限定符" id="22" impl="CODSTA-MCPP-22" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-22.rule"/>
            </rule>
            <rule header="如果类的 public 析构函数是非虚拟的，则该类应该声明为 final" id="23" impl="CODSTA-MCPP-23" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-23.rule"/>
            </rule>
            <rule header="在成员函数声明中,只应该指定 virtual,override 或 final 中的一个" id="24" impl="CODSTA-MCPP-24" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-24.rule"/>
            </rule>
            <rule header="数字序列分隔符 ' 只能与相应的数值类型匹配使用" id="25" impl="CODSTA-MCPP-25" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-25.rule"/>
            </rule>
            <rule header="指向成员虚拟函数的指针只应该被测试是否与空指针常量相等" id="26" impl="CODSTA-MCPP-26" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-26.rule"/>
            </rule>
            <rule header="lambda 不应是 typeid 的操作数" id="28" impl="CODSTA-MCPP-28" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-28.rule"/>
            </rule>
            <rule header="当将指针传递给线程中的对象时，使用智能指针" id="29" impl="CODSTA-MCPP-29" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-29.rule"/>
            </rule>
            <rule header="考虑将本地对象的 'std::shared_ptr' 类型替换为 'std::unique_ptr' 类型" id="30" impl="CODSTA-MCPP-30" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-30.rule"/>
            </rule>
            <rule header="定义操作符 delete 的分级版本和未分级版本" id="31" impl="CODSTA-MCPP-31" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-31.rule"/>
            </rule>
            <rule header="静态对象和线程本地对象应不断初始化" id="32" impl="CODSTA-MCPP-32" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-32.rule"/>
            </rule>
            <rule header="用户定义的文字运算符只能执行传递参数的转换" id="33" impl="CODSTA-MCPP-33" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-33.rule"/>
            </rule>
            <rule header="智能指针只有在表示生存期语义时才可以用作参数类型" id="34" impl="CODSTA-MCPP-34" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-34.rule"/>
            </rule>
            <rule header="如果函数代替被管理的对象，参数应该只声明为对 'std::shared_ptr' 或 'std::unique_ptr' 的非常量左值(const Ivalue)引用" id="35" impl="CODSTA-MCPP-35" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-35.rule"/>
            </rule>
            <rule header="不要将参数类型声明为 'std::shared_ptr' 或 'std::unique_ptr' 的 rvalue 引用" id="36" impl="CODSTA-MCPP-36" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-36.rule"/>
            </rule>
            <rule header="析构类不需要进一步明确初始化，以及要求基类中的所有构造函数都应使用继承构造函数" id="37" impl="CODSTA-MCPP-37" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-37.rule"/>
            </rule>
            <rule header="带括号但不带等号的初始化{}，应用于变量的初始化" id="38" impl="CODSTA-MCPP-38" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-38.rule"/>
            </rule>
            <rule header="不应使用 '{}' 或 '= {}' 括号初始化来初始化 auto 类型的变量" id="39" impl="CODSTA-MCPP-39" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-39.rule"/>
            </rule>
            <rule header="不要过度使用 'auto' 说明符" id="40" impl="CODSTA-MCPP-40" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-40.rule"/>
            </rule>
            <rule header="不应该使用 'random_shuffle' 标识符" id="41" impl="CODSTA-MCPP-41" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-41.rule"/>
            </rule>
            <rule header="不要在 'bool' 类型的操作数上使用递增操作符（++）" id="42" impl="CODSTA-MCPP-42" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-42.rule"/>
            </rule>
            <rule header="不应该使用 'set_unexpected' 标识符" id="43" impl="CODSTA-MCPP-43" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-43.rule"/>
            </rule>
            <rule header="lambda 表达式不应该在另一个 lambda 表达式中定义" id="44" impl="CODSTA-MCPP-44" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-44.rule"/>
            </rule>
            <rule header="应该显式指定非 void 返回类型 lambda 表达式的返回类型" id="45" impl="CODSTA-MCPP-45" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-45.rule"/>
            </rule>
            <rule header="在每个 lambda 表达式中包含一个参数列表" id="46" impl="CODSTA-MCPP-46" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-46.rule"/>
            </rule>
            <rule header="避免使用std::initializer_list重载构造函数" id="47" impl="CODSTA-MCPP-47" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-47.rule"/>
            </rule>
            <rule header="一个函数的多个输出值应该以结构体或元组的形式返回" id="48" impl="CODSTA-MCPP-48" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-48.rule"/>
            </rule>
            <rule header="用户定义的复制和移动赋值运算符应使用用户定义的无抛出交换函数" id="49" impl="CODSTA-MCPP-49" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-49.rule"/>
            </rule>
            <rule header="不应使用循环遍历容器中的所有元素而不使用循环计数器的 for 循环" id="50" impl="CODSTA-MCPP-50" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-50.rule"/>
            </rule>
            <rule header="将结果立即转换为常量迭代器时，请使用常量容器调用" id="51" impl="CODSTA-MCPP-51" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-51.rule"/>
            </rule>
            <rule header="不要在 final 类中引入 virtual 函数" id="52" impl="CODSTA-MCPP-52" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-52.rule"/>
            </rule>
            <rule header="不要在以 const 或 const＆type 声明的对象上使用 std :: move" id="53" impl="CODSTA-MCPP-53" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-53.rule"/>
            </rule>
            <rule header="不要创建 std::array 的右值引用" id="54" impl="CODSTA-MCPP-54" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-54.rule"/>
            </rule>
            <rule header="使用 std::call_once 而不是双重检查锁定模式" id="55" impl="CODSTA-MCPP-55" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-55.rule"/>
            </rule>
            <rule header="使用 nullptr 代替 null 和 0" id="04" impl="CODSTA-MCPP-04" quickfix="false" scope="line" severity="4">
               <file path="CODSTA-MCPP\CODSTA-MCPP-04.rule"/>
            </rule>
            <rule header="尽量使用 constexpr 声明常量类型变量" id="11_a_cpp11" impl="CODSTA-MCPP-11_a_cpp11" quickfix="false" scope="line" severity="4">
               <file path="CODSTA-MCPP\CODSTA-MCPP-11_a_cpp11.rule"/>
            </rule>
            <rule header="尽量使用 constexpr 来声明函数" id="11_b_cpp11" impl="CODSTA-MCPP-11_b_cpp11" quickfix="false" scope="line" severity="4">
               <file path="CODSTA-MCPP\CODSTA-MCPP-11_b_cpp11.rule"/>
            </rule>
            <rule header="建议使用智能指针成员而不是原始指针成员" id="16_a" impl="CODSTA-MCPP-16_a" quickfix="false" scope="line" severity="4">
               <file path="CODSTA-MCPP\CODSTA-MCPP-16_a.rule"/>
            </rule>
            <rule header="对于数组或 STL 容器建议使用智能指针而不是原始指针" id="16_b" impl="CODSTA-MCPP-16_b" quickfix="false" scope="line" severity="4">
               <file path="CODSTA-MCPP\CODSTA-MCPP-16_b.rule"/>
            </rule>
            <rule header="选择使用智能指针而不是原始局部指针" id="20" impl="CODSTA-MCPP-20" quickfix="false" scope="line" severity="4">
               <file path="CODSTA-MCPP\CODSTA-MCPP-20.rule"/>
            </rule>
            <rule header="不要直接在互斥锁上调用lock()" id="21" impl="CODSTA-MCPP-21" quickfix="false" scope="line" severity="4">
               <file path="CODSTA-MCPP\CODSTA-MCPP-21.rule"/>
            </rule>
         </category>
         <rule header="数组元素必须由数组操作符[ ]访问" id="01" impl="CODSTA-01" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-01.rule"/>
         </rule>
         <rule header="union 成员不应被声明为位域" id="02_b" impl="CODSTA-02_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-02_b.rule"/>
         </rule>
         <rule header="不要通过 #define 定义常量" id="03" impl="CODSTA-03" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-03.rule"/>
         </rule>
         <rule header="应该尽可能避免使用指向指针的指针" id="05" impl="CODSTA-05" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-05.rule"/>
         </rule>
         <rule header="避免使用 '?:' 三元运算符" id="06" impl="CODSTA-06" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-06.rule"/>
         </rule>
         <rule header="如果函数没有参数，使用 ( ) 而不是 ( void )" id="07" impl="CODSTA-07" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-07.rule"/>
         </rule>
         <rule header="不能将函数指针强制转换为原始类型指针" id="09" impl="CODSTA-09" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-09.rule"/>
         </rule>
         <rule header="存储类型修饰符应该关联类型，而不是变量或函数" id="10" impl="CODSTA-10" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-10.rule"/>
         </rule>
         <rule header="在算术运算中不允许混合使用有符号值和无符号值" id="100" impl="CODSTA-100" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-100.rule"/>
         </rule>
         <rule header="在条件运算符的第二个和第三个操作数中不允许混合使用有符号和无符号值" id="101" impl="CODSTA-101" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-101.rule"/>
         </rule>
         <rule header="可能会导致错误的单个运算符只能在适当的上下文中使用" id="102" impl="CODSTA-102" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-102.rule"/>
         </rule>
         <rule header="具有副作用的函数调用只能在适当的上下文中使用" id="103" impl="CODSTA-103" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-103.rule"/>
         </rule>
         <rule header="如果逻辑 &amp;&amp; 或 || 的操作数包含二元运算符则操作数应该被括起来" id="104" impl="CODSTA-104" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-104.rule"/>
         </rule>
         <rule header="不得使用在&lt;stdlib.h&gt;中的 bsearch 和 qsort 库函数" id="107" impl="CODSTA-107" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-107.rule"/>
         </rule>
         <rule header="不得使用标准头文件 &lt;tgmath.h&gt;" id="108" impl="CODSTA-108" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-108.rule"/>
         </rule>
         <rule header="不应使用指定为由 &lt;tgmath.h&gt; 提供的设施" id="108_b" impl="CODSTA-108_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-108_b.rule"/>
         </rule>
         <rule header="&lt;fenv.h&gt; 提供的功能不应被使用" id="109" impl="CODSTA-109" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-109.rule"/>
         </rule>
         <rule header="标准头文件 &lt;fenv.h&gt; 不应被使用" id="109_b" impl="CODSTA-109_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-109_b.rule"/>
         </rule>
         <rule header="不得使用标准的库的 input/output 函数" id="110" impl="CODSTA-110" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-110.rule"/>
         </rule>
         <rule header="不得使用联合体关键字" id="111" impl="CODSTA-111" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-111.rule"/>
         </rule>
         <rule header="不应使用变长数组" id="112" impl="CODSTA-112" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-112.rule"/>
         </rule>
         <rule header="不得声明灵活的数组成员" id="113" impl="CODSTA-113" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-113.rule"/>
         </rule>
         <rule header="汇编语言应该封装在 C/C++ 函数中并被隔离" id="114" impl="CODSTA-114" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-114.rule"/>
         </rule>
         <rule header="'default' 标签（如果存在）应显示为 switch 语句的第一个或最后一个 switch 标签" id="116" impl="CODSTA-116" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-116.rule"/>
         </rule>
         <rule header="八进制和十六进制转义序列将被终止" id="117" impl="CODSTA-117" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-117.rule"/>
         </rule>
         <rule header="当一个有外部链接的对象或函数被定义时，则声明应该为可见的" id="118" impl="CODSTA-118" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-118.rule"/>
         </rule>
         <rule header="'default' 标签在终止 'break' 之前应有声明或注释" id="119" impl="CODSTA-119" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-119.rule"/>
         </rule>
         <rule header="避免使用移位操作，尽量使用算术运算" id="12" impl="CODSTA-12" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-12.rule"/>
         </rule>
         <rule header="内联函数应该声明为静态存储类" id="120" impl="CODSTA-120" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-120.rule"/>
         </rule>
         <rule header="不得使用严格的类型限定符" id="121" impl="CODSTA-121" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-121.rule"/>
         </rule>
         <rule header="应该使用具有非 void 返回类型的函数返回值" id="122_a" impl="CODSTA-122_a" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-122_a.rule"/>
         </rule>
         <rule header="应使用一个非 void 返回类型函数返回的值" id="122_b" impl="CODSTA-122_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-122_b.rule"/>
         </rule>
         <rule header="不得在指向函数的指针与指向函数的指针以外的任何类型之间执行转换" id="124_a" impl="CODSTA-124_a" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-124_a.rule"/>
         </rule>
         <rule header="函数类型的不兼容指针之间不能进行转换" id="124_b" impl="CODSTA-124_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-124_b.rule"/>
         </rule>
         <rule header="不能在指向不完整类型的指针和任何其他类型的指针之间进行转换" id="125" impl="CODSTA-125" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-125.rule"/>
         </rule>
         <rule header="不得在指向对象类型的指针和指向不同对象类型的指针之间执行强制转换" id="126" impl="CODSTA-126" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-126.rule"/>
         </rule>
         <rule header="不能在指向 void 的指针和算术类型之间执行强制类型转换" id="129_a" impl="CODSTA-129_a" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-129_a.rule"/>
         </rule>
         <rule header="不应在指向 void 的指针和算术类型之间执行隐式转换" id="129_b" impl="CODSTA-129_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-129_b.rule"/>
         </rule>
         <rule header="&gt;, &gt;=, &lt;, &lt;= 不应用于指针类型，除非它们指向相同的数组" id="13" impl="CODSTA-13" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-13.rule"/>
         </rule>
         <rule header="不应在指向对象的指针和非整数算术类型之间执行强制转换" id="130" impl="CODSTA-130" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-130.rule"/>
         </rule>
         <rule header="使用 NULL 而不是文本零 （0） 作为空指针常量" id="131" impl="CODSTA-131" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-131.rule"/>
         </rule>
         <rule header="C90中规定宏不应该与关键字定义为相同名称" id="133_a" impl="CODSTA-133_a" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-133_a.rule"/>
         </rule>
         <rule header="C99中规定宏不应该与关键字定义为相同名称" id="133_b" impl="CODSTA-133_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-133_b.rule"/>
         </rule>
         <rule header="不得使用从任何类型到指针或者指针到任何类型的类型转换" id="135" impl="CODSTA-135" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-135.rule"/>
         </rule>
         <rule header="不应使用标识符 va_list, va_arg, va_start, va_end, va_copy" id="136_a" impl="CODSTA-136_a" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-136_a.rule"/>
         </rule>
         <rule header="不应使用标识符 va_list, va_arg, va_start, va_end" id="136_b" impl="CODSTA-136_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-136_b.rule"/>
         </rule>
         <rule header="不应使用标准头文件 &lt;stdarg.h&gt; 或 &lt;cstdarg&gt;" id="136_c" impl="CODSTA-136_c" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-136_c.rule"/>
         </rule>
         <rule header="函数调用不得是 sizeof 运算符的操作数" id="137" impl="CODSTA-137" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-137.rule"/>
         </rule>
         <rule header="不得使用一个内置赋值运算符的结果" id="138" impl="CODSTA-138" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-138.rule"/>
         </rule>
         <rule header="指针减法仅适用于同一数组元素的地址指针" id="13_b" impl="CODSTA-13_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-13_b.rule"/>
         </rule>
         <rule header="禁止将 const 转换成非 const" id="14" impl="CODSTA-14" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-14.rule"/>
         </rule>
         <rule header="初始化器列表不应该包含持久的副作用" id="141_a" impl="CODSTA-141_a" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-141_a.rule"/>
         </rule>
         <rule header="使用数组参数调用的函数不应该声明具有指针参数" id="142_b" impl="CODSTA-142_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-142_b.rule"/>
         </rule>
         <rule header="未检查源缓冲区大小而使用 'strcpy' 是可疑的" id="143" impl="CODSTA-143" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-143.rule"/>
         </rule>
         <rule header="应当使用函数 'read' 和 'readlink' 返回的值" id="144" impl="CODSTA-144" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-144.rule"/>
         </rule>
         <rule header="在期望有空终止的字符串的函数中使用可能没有空终止的字符串" id="145" impl="CODSTA-145" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-145.rule"/>
         </rule>
         <rule header="从一个面向字符的标准输入输出 I/O 函数返回的一个值不应该隐式转换为一个小于的 'int' 类型" id="146" impl="CODSTA-146" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-146.rule"/>
         </rule>
         <rule header="不应该使用相关的操作符 &lt;, &gt;, &gt;=, &lt;= 比较指针和 NULL" id="147" impl="CODSTA-147" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-147.rule"/>
         </rule>
         <rule header="不要使用字符串字面量作为等号或关系运算符的操作数" id="148" impl="CODSTA-148" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-148.rule"/>
         </rule>
         <rule header="switch 语句中各 case 之间缺失 break 语句" id="149" impl="CODSTA-149" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-149.rule"/>
         </rule>
         <rule header="断言不应该包含赋值，自增或自减运算符" id="150" impl="CODSTA-150" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-150.rule"/>
         </rule>
         <rule header="避免不安全宏参数造成的不良影响" id="150_c" impl="CODSTA-150_c" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-150_c.rule"/>
         </rule>
         <rule header="复合表达式的值不得传递给一个不同的基本类型类别或更广泛的基本类型" id="152" impl="CODSTA-152" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-152.rule"/>
         </rule>
         <rule header="在转换单元中外部对象或函数不得有多个non-defining声明" id="154" impl="CODSTA-154" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-154.rule"/>
         </rule>
         <rule header="应该使用C99中stdint.h的typedefs而不是个人自己的声明" id="155" impl="CODSTA-155" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-155.rule"/>
         </rule>
         <rule header="如果复合表达式用作执行通常算术转换的运算符的一个操作数，则另一个操作数不应具有更广泛的基本类型" id="156_a" impl="CODSTA-156_a" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-156_a.rule"/>
         </rule>
         <rule header="如果复合表达式用作执行通常算术转换的运算符的第一个(第二个或第三个)操作数，则另一个操作数不应具有更广泛的基本类型" id="156_b" impl="CODSTA-156_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-156_b.rule"/>
         </rule>
         <rule header="复合表达式的值不应该赋值给宽数据类型的一个对象" id="157" impl="CODSTA-157" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-157.rule"/>
         </rule>
         <rule header="函数类型应该包含具体名称的参数" id="158" impl="CODSTA-158" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-158.rule"/>
         </rule>
         <rule header="函数类型应当为原型形式" id="159" impl="CODSTA-159" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-159.rule"/>
         </rule>
         <rule header="当操作数被解释为布尔值时，应使用基本布尔类型的表达式" id="161_a" impl="CODSTA-161_a" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-161_a.rule"/>
         </rule>
         <rule header="当操作数被解释为数值时，不应使用本质上为布尔类型的操作数当操作数被解释为数值时，不应使用本质上为布尔类型的操作数" id="161_b" impl="CODSTA-161_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-161_b.rule"/>
         </rule>
         <rule header="字符类型的操作数不应该用在需要数类型的地方" id="161_c" impl="CODSTA-161_c" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-161_c.rule"/>
         </rule>
         <rule header="在算术运算中不应该使用枚举类型" id="161_d" impl="CODSTA-161_d" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-161_d.rule"/>
         </rule>
         <rule header="不要对有符号类型和枚举类型使用移位和位运算" id="161_e" impl="CODSTA-161_e" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-161_e.rule"/>
         </rule>
         <rule header="本质上带符号或枚举类型的操作数不应用作移位操作符的右侧操作数" id="161_f" impl="CODSTA-161_f" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-161_f.rule"/>
         </rule>
         <rule header="一元减运算符的操作数不应该是无符号类型" id="161_g" impl="CODSTA-161_g" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-161_g.rule"/>
         </rule>
         <rule header="基本字符类型表达式不能用于加减运算符" id="162" impl="CODSTA-162" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-162.rule"/>
         </rule>
         <rule header="表达式的值不能赋给更小基本类型的对象" id="163_a" impl="CODSTA-163_a" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-163_a.rule"/>
         </rule>
         <rule header="表达式的值不应分配给不同基本类型类别的对象" id="163_b" impl="CODSTA-163_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-163_b.rule"/>
         </rule>
         <rule header="执行常规算术转换的运算符的两个操作数应具有相同的基本类型类别" id="164_a" impl="CODSTA-164_a" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-164_a.rule"/>
         </rule>
         <rule header="第二个和第三个三元操作符的操作数有相同的基本类型类别" id="164_b" impl="CODSTA-164_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-164_b.rule"/>
         </rule>
         <rule header="不要从基本布尔类型转换或转换为基本布尔类型" id="165_b" impl="CODSTA-165_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-165_b.rule"/>
         </rule>
         <rule header="for循环的循环计数器不能是浮点类型" id="167_a" impl="CODSTA-167_a" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-167_a.rule"/>
         </rule>
         <rule header="在'while' 和 'do-while' 中的循环计数器不要使用浮点类型" id="167_b" impl="CODSTA-167_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-167_b.rule"/>
         </rule>
         <rule header="'for' 循环中只能有一个循环计数器，而不能在 'for' 循环体中进行修改" id="168" impl="CODSTA-168" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-168.rule"/>
         </rule>
         <rule header="for循环的第一个判断条件应该是格式良好的" id="169_a" impl="CODSTA-169_a" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-169_a.rule"/>
         </rule>
         <rule header="'for' 循环的第二个子句应格式正确" id="169_b" impl="CODSTA-169_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-169_b.rule"/>
         </rule>
         <rule header="for 循环的第三部分应该是格式良好的" id="169_c" impl="CODSTA-169_c" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-169_c.rule"/>
         </rule>
         <rule header="不要使用 NULL 标识符; 而是使用 0 替代" id="17" impl="CODSTA-17" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-17.rule"/>
         </rule>
         <rule header="在预处理之前的宏命名应该与预处理之后的标识符区分开来" id="170_c90" impl="CODSTA-170_c90" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-170_c90.rule"/>
         </rule>
         <rule header="在预处理之前的宏命名应该与预处理之后的标识符区分开来" id="170_c99" impl="CODSTA-170_c99" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-170_c99.rule"/>
         </rule>
         <rule header="宏命名应该与参数区分开来（c90)" id="171_c90" impl="CODSTA-171_c90" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-171_c90.rule"/>
         </rule>
         <rule header="宏命名需要与它的参数名区分开来（c99)" id="171_c99" impl="CODSTA-171_c99" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-171_c99.rule"/>
         </rule>
         <rule header="宏的命名需要与当前定义的其他宏的命名区分开来（c90）" id="172_c90" impl="CODSTA-172_c90" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-172_c90.rule"/>
         </rule>
         <rule header="宏的名称应该有别于其他当前定义的宏的名称(c99)" id="172_c99" impl="CODSTA-172_c99" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-172_c99.rule"/>
         </rule>
         <rule header="程序不应超过标准 (c90) 强加的转换限制" id="174_a_c90" impl="CODSTA-174_a_c90" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-174_a_c90.rule"/>
         </rule>
         <rule header="程序不应超过施加的标准编译限制 (c99)" id="174_a_c99" impl="CODSTA-174_a_c99" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-174_a_c99.rule"/>
         </rule>
         <rule header="程序不应超过(c90)标准规定的编译限制" id="174_b_c90" impl="CODSTA-174_b_c90" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-174_b_c90.rule"/>
         </rule>
         <rule header="程序不应超过施加的标准编译限制 (c99)" id="174_b_c99" impl="CODSTA-174_b_c99" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-174_b_c99.rule"/>
         </rule>
         <rule header="外部标识符应不同" id="178" impl="CODSTA-178" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-178.rule"/>
         </rule>
         <rule header="在文件范围和命名空间中声明的不同标识符应该区分开来 (c90)" id="179_a_c90" impl="CODSTA-179_a_c90" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-179_a_c90.rule"/>
         </rule>
         <rule header="在文件范围和命名空间中声明的不同标识符应该区分开来 (c99)" id="179_a_c99" impl="CODSTA-179_a_c99" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-179_a_c99.rule"/>
         </rule>
         <rule header="在同样的块范围和命名空间中的标识符必须不相同 (c90)" id="179_b_c90" impl="CODSTA-179_b_c90" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-179_b_c90.rule"/>
         </rule>
         <rule header="在同样的块范围和命名空间中的标识符必须不相同 (c99)" id="179_b_c99" impl="CODSTA-179_b_c99" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-179_b_c99.rule"/>
         </rule>
         <rule header="标准库函数 'memcmp', 'memmove' and 'memcmp' 的指针参数应该指向兼容的类型" id="183" impl="CODSTA-183" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-183.rule"/>
         </rule>
         <rule header="传入标准库函数 'memcmp' 的指针参数不能指向指针类型、无符号类型、有符号类型、布尔类型或枚举类型" id="184" impl="CODSTA-184" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-184.rule"/>
         </rule>
         <rule header="由结构体 'lconv' 的成员指向的字符串不应该被修改" id="185_b" impl="CODSTA-185_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-185_b.rule"/>
         </rule>
         <rule header="指定的用来初始化数组对象的初始化器应明确指定数组对象的大小" id="186" impl="CODSTA-186" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-186.rule"/>
         </rule>
         <rule header="在赋值给较大的整型之前将字符强制转换为 unsigned char 类型" id="187_a" impl="CODSTA-187_a" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-187_a.rule"/>
         </rule>
         <rule header="'signed char' 类型的表达式不应该作为数组下标使用" id="187_b" impl="CODSTA-187_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-187_b.rule"/>
         </rule>
         <rule header="在转换为更大的整型之前将字符转换为无符号字符类型" id="187_c" impl="CODSTA-187_c" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-187_c.rule"/>
         </rule>
         <rule header="不要混淆窄字符串、宽字符串和函数" id="188" impl="CODSTA-188" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-188.rule"/>
         </rule>
         <rule header="不要拿整型和指针做加减运算" id="189" impl="CODSTA-189" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-189.rule"/>
         </rule>
         <rule header="使用 ctype.h 的函数对字符测试" id="19" impl="CODSTA-19" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-19.rule"/>
         </rule>
         <rule header="不要使用对象表示形式来比较浮点值" id="190" impl="CODSTA-190" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-190.rule"/>
         </rule>
         <rule header="封装可以在循环中伪唤醒的函数" id="191" impl="CODSTA-191" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-191.rule"/>
         </rule>
         <rule header="结构体的最终成员不应该是“0”或“1”的数组" id="192" impl="CODSTA-192" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-192.rule"/>
         </rule>
         <rule header="动态分配包含灵活数组成员的结构体" id="193" impl="CODSTA-193" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-193.rule"/>
         </rule>
         <rule header="循环中使用包装函数可能失败" id="194" impl="CODSTA-194" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-194.rule"/>
         </rule>
         <rule header="不要在表达式中两次引用原子变量" id="195" impl="CODSTA-195" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-195.rule"/>
         </rule>
         <rule header="不要修改具有临时生命周期的对象" id="196" impl="CODSTA-196" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-196.rule"/>
         </rule>
         <rule header="浮点型复杂表达式的值不应转换为更广泛的浮点型" id="198" impl="CODSTA-198" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-198.rule"/>
         </rule>
         <rule header="浮点型复杂表达式的值不应转换为整数类型" id="198_b" impl="CODSTA-198_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-198_b.rule"/>
         </rule>
         <rule header="不要使用断言" id="199" impl="CODSTA-199" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-199.rule"/>
         </rule>
         <rule header="使用初始化器显式指定数组声明中的数组大小" id="200" impl="CODSTA-200" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-200.rule"/>
         </rule>
         <rule header="不以本机方式处理结构化文本数据" id="201" impl="CODSTA-201" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-201.rule"/>
         </rule>
         <rule header="声明为 'noreturn' 的函数应该具有 'void' 返回类型" id="204" impl="CODSTA-204" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-204.rule"/>
         </rule>
         <rule header="不要将数组转换为指向比数组大的结构的指针" id="205" impl="CODSTA-205" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-205.rule"/>
         </rule>
         <rule header="不应使用 '_Noreturn' 函数说明符" id="206" impl="CODSTA-206" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-206.rule"/>
         </rule>
         <rule header="不应该使用 &lt;stdnoreturn.h&gt; 头文件" id="207" impl="CODSTA-207" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-207.rule"/>
         </rule>
         <rule header="不应使用 &lt;stdalign.h&gt; 头文件" id="208" impl="CODSTA-208" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-208.rule"/>
         </rule>
         <rule header="不应使用指定为由 &lt;stdatomic.h&gt; 提供的功能" id="209" impl="CODSTA-209" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-209.rule"/>
         </rule>
         <rule header="不要使用宏 ATOMIC_VAR_INIT" id="209_b" impl="CODSTA-209_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-209_b.rule"/>
         </rule>
         <rule header="不应使用 '_Thread_local' 存储类说明符" id="210" impl="CODSTA-210" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-210.rule"/>
         </rule>
         <rule header="不应该使用被指定为由 &lt;threads.h&gt; 头文件提供的功能" id="211" impl="CODSTA-211" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-211.rule"/>
         </rule>
         <rule header="不应使用 “rsize_t” 类型" id="212" impl="CODSTA-212" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-212.rule"/>
         </rule>
         <rule header="不应使用 '_Alignas' 对齐说明符和 '_Alignof' 运算符" id="213" impl="CODSTA-213" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-213.rule"/>
         </rule>
         <rule header="不应该使用 '_Atomic' 类型说明符和 '_Atomic' 类型限定符" id="214" impl="CODSTA-214" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-214.rule"/>
         </rule>
         <rule header="宏 '__STDC_WANT_LIB_EXT1__' 不应定义为 '0' 以外的值" id="215" impl="CODSTA-215" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-215.rule"/>
         </rule>
         <rule header="不应使用 '_Generic' 运算符" id="216" impl="CODSTA-216" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-216.rule"/>
         </rule>
         <rule header="不应该使用 'errno_t' 类型" id="217" impl="CODSTA-217" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-217.rule"/>
         </rule>
         <rule header="不要使用以下宏：RSIZE_MAX，L_tmpnam_s，TMP_MAX_S" id="218" impl="CODSTA-218" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-218.rule"/>
         </rule>
         <rule header="不使用 ISO/IEC 9899:2011 标准的附件 K 中定义的函数" id="219" impl="CODSTA-219" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-219.rule"/>
         </rule>
         <rule header="整数常量宏的参数应为具有适当值的十进制，八进制或十六进制常量" id="220" impl="CODSTA-220" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-220.rule"/>
         </rule>
         <rule header="不应使用最小宽度的整数常数宏的小整数变体" id="220_b" impl="CODSTA-220_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-220_b.rule"/>
         </rule>
         <rule header="函数类型的规范中不要包含任何类型限定符" id="221" impl="CODSTA-221" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-221.rule"/>
         </rule>
         <rule header="避免隐式整体从大范围的类型转换到小范围的类型转换" id="222" impl="CODSTA-222" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-222.rule"/>
         </rule>
         <rule header="&lt;cstdint&gt; 中的固定宽度整数类型，指示大小和符号，应用于代替基本数字类型" id="223" impl="CODSTA-223" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-223.rule"/>
         </rule>
         <rule header="应使用 typedef 替代普通 char 类型" id="223_b" impl="CODSTA-223_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-223_b.rule"/>
         </rule>
         <rule header="条件运算符不应用作子表达式" id="224" impl="CODSTA-224" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-224.rule"/>
         </rule>
         <rule header="不得显示（语法上）测试浮点表达式的等号（==）或不等号（！=）" id="225" impl="CODSTA-225" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-225.rule"/>
         </rule>
         <rule header="应使用可能返回错误的标准库函数所返回的值" id="226_a" impl="CODSTA-226_a" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-226_a.rule"/>
         </rule>
         <rule header="应该使用可能返回错误的POSIX库函数所返回的值" id="227" impl="CODSTA-227" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-227.rule"/>
         </rule>
         <rule header="不要用含有赋值、增量或减量运算符的流参数调用 'getc()', 'putc()', 'getwc()', 或 'putwc()'" id="228_a" impl="CODSTA-228_a" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-228_a.rule"/>
         </rule>
         <rule header="所有的 'if' 语句必须有对应的 'else' 分支语句" id="23" impl="CODSTA-23" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-23.rule"/>
         </rule>
         <rule header="不要将指针转换为更严格对齐的指针类型" id="230" impl="CODSTA-230" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-230.rule"/>
         </rule>
         <rule header="不要将具有线程存储期的对象的地址分配给具有静态存储期的对象" id="231" impl="CODSTA-231" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-231.rule"/>
         </rule>
         <rule header="在表达式中，增量（++）和减量（--）运算符不应该与算术运算符混合使用" id="232" impl="CODSTA-232" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-232.rule"/>
         </rule>
         <rule header="避免使用魔数" id="26" impl="CODSTA-26" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-26.rule"/>
         </rule>
         <rule header="避免在函数内修改全局变量" id="27" impl="CODSTA-27" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-27.rule"/>
         </rule>
         <rule header="使用有意义的符号常量来表示字面值" id="29" impl="CODSTA-29" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-29.rule"/>
         </rule>
         <rule header="避免返回句柄给函数的参数" id="30" impl="CODSTA-30" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-30.rule"/>
         </rule>
         <rule header="避免使用显式类型转换(强制类型转换)" id="31" impl="CODSTA-31" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-31.rule"/>
         </rule>
         <rule header="如果 test 是指针时，则不能使用类似于 if(test) 或 if(!test) 的逻辑表达式" id="32" impl="CODSTA-32" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-32.rule"/>
         </rule>
         <rule header="在 if, while 或 switch 语句的条件表达式中不要使用 ++ 或 -- 操作符" id="33" impl="CODSTA-33" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-33.rule"/>
         </rule>
         <rule header="当声明函数指针时使用 typedef 来简化程序语法" id="34" impl="CODSTA-34" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-34.rule"/>
         </rule>
         <rule header="始终为 switch 语句提供一个 default 分支" id="35" impl="CODSTA-35" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-35.rule"/>
         </rule>
         <rule header="通过值传递内置类型，除非你想要修改这些参数" id="36" impl="CODSTA-36" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-36.rule"/>
         </rule>
         <rule header="选择 const 对象或枚举类型来 #defines 定义简单常量" id="37" impl="CODSTA-37" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-37.rule"/>
         </rule>
         <rule header="不要使用防止编译器检查类型的 #define 指令" id="38" impl="CODSTA-38" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-38.rule"/>
         </rule>
         <rule header="当一个函数没有传递参数值或者没有返回值时应使用 'void'" id="40" impl="CODSTA-40" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-40.rule"/>
         </rule>
         <rule header="所有的结构体都应该有 typedefs 类型定义" id="47" impl="CODSTA-47" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-47.rule"/>
         </rule>
         <rule header="请勿使用以下双字符组：&lt;%, %&gt;, &lt;:, :&gt;, %:, %:%:" id="48" impl="CODSTA-48" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-48.rule"/>
         </rule>
         <rule header="如果 'for' 语句中无初始化或者无增量表达式; 应该使用 while 循环替代" id="49" impl="CODSTA-49" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-49.rule"/>
         </rule>
         <rule header="十六进制常量应该全部使用大写字母表示" id="50" impl="CODSTA-50" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-50.rule"/>
         </rule>
         <rule header="除了初始化单个for循环参数的值外，for循环中的初始化表达式将不执行任何操作" id="52" impl="CODSTA-52" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-52.rule"/>
         </rule>
         <rule header="在 for 循环中的增量表达式除了改变单个循环参数到下一个值外，不应该执行其他任何操作" id="53" impl="CODSTA-53" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-53.rule"/>
         </rule>
         <rule header="每个 switch 语句至少有两个 case 分支和一个潜在的 default 分支" id="54" impl="CODSTA-54" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-54.rule"/>
         </rule>
         <rule header="'switch' 语句的所有 'case' 和 'default' 标签应该有一个显式的 'break' 或 'return' 语句， 或者 'fall through' 注释" id="56" impl="CODSTA-56" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-56.rule"/>
         </rule>
         <rule header="避免使用相等运算符 (&quot;==&quot;, &quot;!=&quot;) 来对 TRUE 宏/枚举(enum)常量进行值比较" id="60" impl="CODSTA-60" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-60.rule"/>
         </rule>
         <rule header="除非所有枚举值都经过测试，否则 switch 语句的最后一个子句应为 default-clause" id="61" impl="CODSTA-61" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-61.rule"/>
         </rule>
         <rule header="强制类型转换不应将指向函数的指针转换为任何其他指针类型，包括指向函数类型的指针" id="62" impl="CODSTA-62" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-62.rule"/>
         </rule>
         <rule header="位运算符应只适用于无符号的基本类型操作数" id="63" impl="CODSTA-63" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-63.rule"/>
         </rule>
         <rule header="非条件 throw 或 break 语句应终止每个非空的 switch 语句" id="64" impl="CODSTA-64" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-64.rule"/>
         </rule>
         <rule header="具有整数类型的对象或指向 void 类型的指针不应转换为具有指针类型的对象" id="65" impl="CODSTA-65" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-65.rule"/>
         </rule>
         <rule header="二进制位运算符的非常量的操作数应该具有相同的基本类型" id="66" impl="CODSTA-66" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-66.rule"/>
         </rule>
         <rule header="用于对象，函数返回类型，或函数参数的类型在所有声明和重新声明中应该对应完全相同" id="67" impl="CODSTA-67" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-67.rule"/>
         </rule>
         <rule header="后缀 &quot;U&quot; 应该适用于所有无符号类型的八进制或十六进制整型字面量" id="68" impl="CODSTA-68" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-68.rule"/>
         </rule>
         <rule header="带有类型(普通) char 和 wchar_t 的表达式不能作为内建运算符的操作数，除了 =, ==, != 和一元 &amp; 运算符" id="69" impl="CODSTA-69" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-69.rule"/>
         </rule>
         <rule header="具有枚举类型的表达式不得用作除了 [ ],  =, ==, !=, &lt;, &lt;=, &gt;, &gt;=, 和一元 &amp; 运算符以外的内建运算符的操作数" id="70" impl="CODSTA-70" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-70.rule"/>
         </rule>
         <rule header="具有带符号的整数类型且已命名的位域应该有超过一位的长度" id="71" impl="CODSTA-71" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-71.rule"/>
         </rule>
         <rule header="汇编指令应该只能使用 asm 声明来引入" id="73" impl="CODSTA-73" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-73.rule"/>
         </rule>
         <rule header="位域不得有枚举(enum)类型" id="74" impl="CODSTA-74" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-74.rule"/>
         </rule>
         <rule header="位域应该要么是 bool 类型要么是显式无符号(unsigned)或有符号(signed)的整数类型" id="75" impl="CODSTA-75" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-75.rule"/>
         </rule>
         <rule header="标识符 main 不得用于除了全局的 main 函数以外的其它函数" id="76" impl="CODSTA-76" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-76.rule"/>
         </rule>
         <rule header="goto 语句应该跳转到同一个函数体中位于 goto 语句后面声明的标签" id="77" impl="CODSTA-77" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-77.rule"/>
         </rule>
         <rule header="任何由 goto 语句引用的标签应该声明在同一个模块中，或者在一个包含 goto 语句的模块中" id="78" impl="CODSTA-78" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-78.rule"/>
         </rule>
         <rule header="对任何循环语句，都应存在不止一个用于循环终止的 break 或 goto 语句" id="79" impl="CODSTA-79" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-79.rule"/>
         </rule>
         <rule header="continue 语句只应该被用于具有良好格式的 for 循环中" id="80" impl="CODSTA-80" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-80.rule"/>
         </rule>
         <rule header="如果一个函数有内部链接，那么所有的重新声明都应该包括'static'存储类说明符" id="81" impl="CODSTA-81" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-81.rule"/>
         </rule>
         <rule header="避免无限循环" id="82" impl="CODSTA-82" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-82.rule"/>
         </rule>
         <rule header="不要使用空的无限循环" id="82_b" impl="CODSTA-82_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-82_b.rule"/>
         </rule>
         <rule header="所有的循环必须有一个固定的上限或下限" id="83" impl="CODSTA-83" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-83.rule"/>
         </rule>
         <rule header="避免在无限循环中有退出点" id="85" impl="CODSTA-85" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-85.rule"/>
         </rule>
         <rule header="必须在每个函数内部检查参数的有效性" id="86" impl="CODSTA-86" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-86.rule"/>
         </rule>
         <rule header="使用不超过一级的指针引用" id="87" impl="CODSTA-87" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-87.rule"/>
         </rule>
         <rule header="函数指针是不允许的" id="88" impl="CODSTA-88" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-88.rule"/>
         </rule>
         <rule header="声明不得包含超过一级的间接指针" id="89" impl="CODSTA-89" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-89.rule"/>
         </rule>
         <rule header="逻辑 '&amp;&amp;' 或 '||' 的每个操作数应该为后缀表达式" id="90" impl="CODSTA-90" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-90.rule"/>
         </rule>
         <rule header="函数应该最多只有一个退出(exit)点" id="91" impl="CODSTA-91" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-91.rule"/>
         </rule>
         <rule header="不得重复使用标准库宏和对象的名称" id="92" impl="CODSTA-92" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-92.rule"/>
         </rule>
         <rule header="不应定义、重新定义、未定义标准程序库中的保留标识符、宏以及函数（C90代码）" id="92_a" impl="CODSTA-92_a" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-92_a.rule"/>
         </rule>
         <rule header="不应定义、重新定义、未定义标准库中的保留标识符、宏和函数(C99 code)" id="92_b" impl="CODSTA-92_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-92_b.rule"/>
         </rule>
         <rule header="不应该声明指针或数组类型" id="94" impl="CODSTA-94" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-94.rule"/>
         </rule>
         <rule header="不应该声明指针类型" id="95" impl="CODSTA-95" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-95.rule"/>
         </rule>
         <rule header="位域只应该有显式的无符号整数或者枚举类型" id="96" impl="CODSTA-96" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-96.rule"/>
         </rule>
         <rule header="如果操作符的优先级低于算术运算符，应该使用圆括号明确表达式的操作顺序" id="97" impl="CODSTA-97" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-97.rule"/>
         </rule>
         <rule header="所有的 'if...else if' 结构应该包含一个最后的 'else' 分支或明确的注释表示为什么不需要最后的 'else' 分支。" id="98" impl="CODSTA-98" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-98.rule"/>
         </rule>
         <rule header="在比较运算中不允许混合使用有符号值和无符号值" id="99" impl="CODSTA-99" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-99.rule"/>
         </rule>
         <category description="Modern C 编码规范" name="MC">
            <rule header="'alignof' 运算符不应与数组类型一起使用作为其操作数" id="01" impl="CODSTA-MC-01" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MC\CODSTA-MC-01.rule"/>
            </rule>
            <rule header="对象的声明最多应包含一个显式对齐说明符" id="02" impl="CODSTA-MC-02" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MC\CODSTA-MC-02.rule"/>
            </rule>
            <rule header="不应在对象声明中使用零对齐说明符" id="03" impl="CODSTA-MC-03" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MC\CODSTA-MC-03.rule"/>
            </rule>
            <rule header="具有内部链接的对象的所有声明中的显示对齐说明符应相同" id="04" impl="CODSTA-MC-04" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MC\CODSTA-MC-04.rule"/>
            </rule>
            <rule header="每个泛型选择都应该包含一个默认关联" id="05" impl="CODSTA-MC-05" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MC\CODSTA-MC-05.rule"/>
            </rule>
            <rule header="默认关联应放在关联列表中的第一个或最后一个" id="06" impl="CODSTA-MC-06" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MC\CODSTA-MC-06.rule"/>
            </rule>
            <rule header="泛型选择应指示至少一个非默认关联" id="07" impl="CODSTA-MC-07" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MC\CODSTA-MC-07.rule"/>
            </rule>
            <rule header="泛型选择只能从宏展开" id="08" impl="CODSTA-MC-08" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MC\CODSTA-MC-08.rule"/>
            </rule>
            <rule header="泛型关联应列出适当的类型" id="09" impl="CODSTA-MC-09" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MC\CODSTA-MC-09.rule"/>
            </rule>
            <rule header="宏定义中使用的泛型选择应在控制表达式中具有宏参数" id="10" impl="CODSTA-MC-10" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MC\CODSTA-MC-10.rule"/>
            </rule>
            <rule header="泛型选择的控制表达式应具有与其标准类型匹配的基本类型" id="12" impl="CODSTA-MC-12" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MC\CODSTA-MC-12.rule"/>
            </rule>
            <rule header="非从宏展开的泛型选择不应在控制表达式中包含潜在的副作用" id="13" impl="CODSTA-MC-13" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MC\CODSTA-MC-13.rule"/>
            </rule>
            <rule header="枚举类型不应与泛型选择中的整数类型混合" id="14" impl="CODSTA-MC-14" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MC\CODSTA-MC-14.rule"/>
            </rule>
            <rule header="由宏展开的泛型选择只能计算一次其参数" id="15" impl="CODSTA-MC-15" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MC\CODSTA-MC-15.rule"/>
            </rule>
            <rule header="'_Atomic' 限定符不应与 'void' 一起使用" id="16" impl="CODSTA-MC-16" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MC\CODSTA-MC-16.rule"/>
            </rule>
            <rule header="结构和联合类型原子对象的成员不应直接访问" id="17" impl="CODSTA-MC-17" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MC\CODSTA-MC-17.rule"/>
            </rule>
            <rule header="转换时不得从指针类型中删除任何 '_Atomic' 限定" id="18" impl="CODSTA-MC-18" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MC\CODSTA-MC-18.rule"/>
            </rule>
            <rule header="原子类型的表达式的值应独立于线程交错" id="19" impl="CODSTA-MC-19" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MC\CODSTA-MC-19.rule"/>
            </rule>
            <rule header="仅使用 'memory_order_seq_cst' 作为显式内存顺序参数" id="20" impl="CODSTA-MC-20" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MC\CODSTA-MC-20.rule"/>
            </rule>
            <rule header="传递给 'mtx_init()' 函数的第二参数应为 'mtx_plain', 'mtx_timed', 'mtx_plain | mtx_recursive', 或 'mtx_timed | mtx_recursive'" id="21" impl="CODSTA-MC-21" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MC\CODSTA-MC-21.rule"/>
            </rule>
            <rule header="线程对象、线程同步对象和线程特有存储指针只能由相应的标准库函数访问" id="22" impl="CODSTA-MC-22" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MC\CODSTA-MC-22.rule"/>
            </rule>
            <rule header="泛型选择不应依赖于隐式指针类型转换" id="11" impl="CODSTA-MC-11" quickfix="false" scope="line" severity="4">
               <file path="CODSTA-MC\CODSTA-MC-11.rule"/>
            </rule>
         </category>
         <rule header="三元运算符 '?:' 的第二个或第三个操作数不得含有副作用" id="105" impl="CODSTA-105" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-105.rule"/>
         </rule>
         <rule header="如果指向一个结构体或联合体的指针在一个编译单元内从未被间接引用，那么该对象的实现应该被隐藏起来" id="115" impl="CODSTA-115" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-115.rule"/>
         </rule>
         <rule header="包含递增(++)或递减(--)运算符的完整表达式应该没有其他潜在的附带后果" id="123" impl="CODSTA-123" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-123.rule"/>
         </rule>
         <rule header="不应在指向对象的指针和指向整数类型的指针之间转换" id="127" impl="CODSTA-127" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-127.rule"/>
         </rule>
         <rule header="不应在指向对象类型的指针与除 'uintptr_t' 或 'intptr_t' 以外的整数类型之间执行转换" id="127_b" impl="CODSTA-127_b" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-127_b.rule"/>
         </rule>
         <rule header="不应该执行从指向 void 的指针到指向对象的指针的转换" id="128" impl="CODSTA-128" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-128.rule"/>
         </rule>
         <rule header="不应该修改函数参数" id="132" impl="CODSTA-132" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-132.rule"/>
         </rule>
         <rule header="函数参数对应的数组类型参数应该包含合适数量的元素" id="134" impl="CODSTA-134" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-134.rule"/>
         </rule>
         <rule header="不要在布尔条件中使用枚举" id="151" impl="CODSTA-151" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-151.rule"/>
         </rule>
         <rule header="不允许对枚举类型进行转换操作" id="165_a" impl="CODSTA-165_a" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-165_a.rule"/>
         </rule>
         <rule header="不要在基本字符类型和基本浮点类型之间使用强制类型转换" id="165_c" impl="CODSTA-165_c" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-165_c.rule"/>
         </rule>
         <rule header="函数中不应该包含无用的类型声明" id="175_a" impl="CODSTA-175_a" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-175_a.rule"/>
         </rule>
         <rule header="源文件中不能包含未使用的类型声明" id="175_b" impl="CODSTA-175_b" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-175_b.rule"/>
         </rule>
         <rule header="函数不应该包含无用的局部标签声明" id="176_a" impl="CODSTA-176_a" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-176_a.rule"/>
         </rule>
         <rule header="源文件中不应该包含未使用的标签声明" id="176_b" impl="CODSTA-176_b" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-176_b.rule"/>
         </rule>
         <rule header="源文件不应包含未使用的宏定义" id="177" impl="CODSTA-177" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-177.rule"/>
         </rule>
         <rule header="不要将+, -, += 和 -= 类型操作符应用于指针类型表达式" id="181" impl="CODSTA-181" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-181.rule"/>
         </rule>
         <rule header="除了在类似函数的宏中，不应使用'Do'语句" id="18_b" impl="CODSTA-18_b" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-18_b.rule"/>
         </rule>
         <rule header="余数运算符 '%' 的操作数应为无符号的整数类型" id="229" impl="CODSTA-229" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-229.rule"/>
         </rule>
         <rule header="避免只有一个 case 分支的 swtich 语句" id="41" impl="CODSTA-41" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-41.rule"/>
         </rule>
         <rule header="分号的可疑使用" id="57" impl="CODSTA-57" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-57.rule"/>
         </rule>
         <rule header="不允许类型强制转换为 void" id="58" impl="CODSTA-58" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-58.rule"/>
         </rule>
         <rule header="在声明数组大小和 'malloc' 的内存大小时不应该使用硬编码" id="59" impl="CODSTA-59" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-59.rule"/>
         </rule>
         <rule header="不要将成员变量声明为位域" id="02" impl="CODSTA-02" quickfix="false" scope="line" severity="5">
            <file path="CODSTA\CODSTA-02.rule"/>
         </rule>
         <rule header="不要使用 'static' 关键字声明局部变量" id="04" impl="CODSTA-04" quickfix="false" scope="line" severity="5">
            <file path="CODSTA\CODSTA-04.rule"/>
         </rule>
         <rule header="广泛地使用断言证明内部假设和不变式" id="11" impl="CODSTA-11" quickfix="false" scope="line" severity="5">
            <file path="CODSTA\CODSTA-11.rule"/>
         </rule>
         <rule header="断言不应该包含函数调用或者类似于函数的宏调用" id="150_b" impl="CODSTA-150_b" quickfix="false" scope="line" severity="5">
            <file path="CODSTA\CODSTA-150_b.rule"/>
         </rule>
         <rule header="选择使用 while 而非 do 语句" id="18" impl="CODSTA-18" quickfix="false" scope="line" severity="5">
            <file path="CODSTA\CODSTA-18.rule"/>
         </rule>
         <rule header="不要硬编码字符串字面量" id="203" impl="CODSTA-203" quickfix="false" scope="line" severity="5">
            <file path="CODSTA\CODSTA-203.rule"/>
         </rule>
         <rule header="当使用枚举类型 enum 时，必须显式声明每个成员的值" id="21" impl="CODSTA-21" quickfix="false" scope="line" severity="5">
            <file path="CODSTA\CODSTA-21.rule"/>
         </rule>
         <rule header="不需要检查返回值的标准库函数应该被转换为 'void'" id="226_b" impl="CODSTA-226_b" quickfix="false" scope="line" severity="5">
            <file path="CODSTA\CODSTA-226_b.rule"/>
         </rule>
         <rule header="不要使用包含函数调用或类似函数的宏调用的流参数调用 'getc()'、 'putc()'、 'getwc()' 或 'putwc()'" id="228_b" impl="CODSTA-228_b" quickfix="false" scope="line" severity="5">
            <file path="CODSTA\CODSTA-228_b.rule"/>
         </rule>
         <rule header="宏 FALSE 应该被定义为 0(零)" id="24" impl="CODSTA-24" quickfix="false" scope="line" severity="5">
            <file path="CODSTA\CODSTA-24.rule"/>
         </rule>
         <rule header="命名为 'FALSE' 的枚举常量应该显式地被初始化为 0 值" id="25" impl="CODSTA-25" quickfix="false" scope="line" severity="5">
            <file path="CODSTA\CODSTA-25.rule"/>
         </rule>
         <rule header="必须为联合体的声明定义字段" id="28" impl="CODSTA-28" quickfix="false" scope="line" severity="5">
            <file path="CODSTA\CODSTA-28.rule"/>
         </rule>
         <rule header="宏 TRUE 应该被定义为 1" id="42" impl="CODSTA-42" quickfix="false" scope="line" severity="5">
            <file path="CODSTA\CODSTA-42.rule"/>
         </rule>
         <rule header="命名为 'TRUE' 的枚举常量应该显式地被初始化为 1" id="43" impl="CODSTA-43" quickfix="false" scope="line" severity="5">
            <file path="CODSTA\CODSTA-43.rule"/>
         </rule>
         <rule header="实际中尽量使用正逻辑而不是负逻辑" id="46" impl="CODSTA-46" quickfix="false" scope="line" severity="5">
            <file path="CODSTA\CODSTA-46.rule"/>
         </rule>
         <rule header="标准库函数的名称不应被重写" id="93" impl="CODSTA-93" quickfix="false" scope="line" severity="5">
            <file path="CODSTA\CODSTA-93.rule"/>
         </rule>
      </category>
      <category description="常见缺陷列表" name="CWE">
         <category description="CWE-772 遗漏超过有效期之后对资源的释放" name="772">
            <rule header="在具有虚函数的基类中定义虚拟析构函数" id="b" impl="OOP-22" originalId="OOP-22" quickfix="false" scope="line" severity="1">
               <file path="OOP\OOP-22.rule"/>
            </rule>
         </category>
         <category description="CWE-20 不正确的输入验证" name="20">
            <rule header="不可信任数据用作循环边界" id="j" impl="SECURITY-38" originalId="SECURITY-38" quickfix="false" scope="line" severity="2">
               <file path="SECURITY\SECURITY-38.rule"/>
            </rule>
         </category>
         <category description="CWE-200 信息泄露" name="200">
            <rule header="不要将应用程序错误导致的潜在敏感信息打印到异常消息中" id="a" impl="SECURITY-15" originalId="SECURITY-15" quickfix="false" scope="line" severity="2">
               <file path="SECURITY\SECURITY-15.rule"/>
            </rule>
         </category>
         <category description="CWE-287 错误的身份验证" name="287">
            <rule header="请勿使用弱加密功能" id="a" impl="SECURITY-37" originalId="SECURITY-37" quickfix="false" scope="line" severity="2">
               <file path="SECURITY\SECURITY-37.rule"/>
            </rule>
         </category>
         <category description="CWE-326 加密强度不够" name="326">
            <rule header="请勿使用弱加密功能" id="a" impl="SECURITY-37" originalId="SECURITY-37" quickfix="false" scope="line" severity="2">
               <file path="SECURITY\SECURITY-37.rule"/>
            </rule>
         </category>
         <category description="CWE-362 使用不适合同步的共享资源并发执行 （“竞争条件”）" name="362">
            <rule header="不允许使用容易发生竞争的功能" id="a" impl="SECURITY-19" originalId="SECURITY-19" quickfix="false" scope="line" severity="2">
               <file path="SECURITY\SECURITY-19.rule"/>
            </rule>
         </category>
         <category description="CWE-426 不可信的搜索路径" name="426">
            <rule header="谨慎使用以确保 LoadLibrary() 加载正确的库" id="a" impl="SECURITY-04" originalId="SECURITY-04" quickfix="false" scope="line" severity="2">
               <file path="SECURITY\SECURITY-04.rule"/>
            </rule>
         </category>
         <category description="CWE-427: 对搜索路径元素未加控制" name="427">
            <rule header="谨慎使用以确保 LoadLibrary() 加载正确的库" id="a" impl="SECURITY-04" originalId="SECURITY-04" quickfix="false" scope="line" severity="2">
               <file path="SECURITY\SECURITY-04.rule"/>
            </rule>
         </category>
         <category description="CWE-863 错误的授权" name="863">
            <rule header="不要使用 'cuserid' 函数" id="a" impl="SECURITY-31" originalId="SECURITY-31" quickfix="false" scope="line" severity="2">
               <file path="SECURITY\SECURITY-31.rule"/>
            </rule>
         </category>
         <category description="CWE-119 在内存缓冲区范围内对操作的不正确限制" name="119">
            <rule header="未检查源缓冲区大小而使用 'strcpy' 是可疑的" id="j" impl="CODSTA-143" originalId="CODSTA-143" quickfix="false" scope="line" severity="3">
               <file path="CODSTA\CODSTA-143.rule"/>
            </rule>
         </category>
         <category description="CWE-190 整数溢出或环绕" name="190">
            <rule header="避免在将结果转换为更广泛的整数类型的表达式中可能出现的整数溢出" id="b" impl="MISRA-048_a" originalId="MISRA-048_a" quickfix="false" scope="line" severity="3">
               <file path="MISRA\MISRA-048_a.rule"/>
            </rule>
            <rule header="避免将表达式的结果赋给更大整数类型的变量，这可能出现整数溢出" id="c" impl="PB-65" originalId="PB-65" quickfix="false" scope="line" severity="3">
               <file path="PB\PB-65.rule"/>
            </rule>
            <rule header="避免将表达式的结果与更广泛的整数类型的表达式进行比较，可能会整数溢出" id="d" impl="PB-65_b" originalId="PB-65_b" quickfix="false" scope="line" severity="3">
               <file path="PB\PB-65_b.rule"/>
            </rule>
            <rule header="'+'， '-'， '*' 运算符常量表达式中的整数溢出或下溢" id="e" impl="PB-66_a" originalId="PB-66_a" quickfix="false" scope="line" severity="3">
               <file path="PB\PB-66_a.rule"/>
            </rule>
            <rule header="'&lt;&lt;' 运算符常量表达式中的整数溢出或下溢" id="f" impl="PB-66_b" originalId="PB-66_b" quickfix="false" scope="line" severity="4">
               <file path="PB\PB-66_b.rule"/>
            </rule>
            <rule header="对常量无符号整数表达式的求值不应该导致循环" id="g" impl="PB-73" originalId="PB-73" quickfix="false" scope="line" severity="5">
               <file path="PB\PB-73.rule"/>
            </rule>
         </category>
         <category description="CWE-269 权限管理不当" name="269">
            <rule header="在放弃特权时遵守正确的撤销命令" id="a" impl="SECURITY-44" originalId="SECURITY-44" quickfix="false" scope="line" severity="3">
               <file path="SECURITY\SECURITY-44.rule"/>
            </rule>
            <rule header="确保成功地放弃特权" id="b" impl="SECURITY-45" originalId="SECURITY-45" quickfix="false" scope="line" severity="3">
               <file path="SECURITY\SECURITY-45.rule"/>
            </rule>
         </category>
         <category description="CWE-416 释放内存后再使用" name="416">
            <rule header="被释放的内存在任何情况下都不应该被访问" id="c" impl="MRM-31" originalId="MRM-31" quickfix="false" scope="line" severity="3">
               <file path="MRM\MRM-31.rule"/>
            </rule>
         </category>
         <category description="CWE-617 可达的断言" name="617">
            <rule header="不要使用断言" id="a" impl="CODSTA-199" originalId="CODSTA-199" quickfix="false" scope="line" severity="3">
               <file path="CODSTA\CODSTA-199.rule"/>
            </rule>
         </category>
         <category description="CWE-704 类型转换错误或强制转换错误" name="704">
            <rule header="不得在指向函数的指针与指向函数的指针以外的任何类型之间执行转换" id="a" impl="CODSTA-124_a" originalId="CODSTA-124_a" quickfix="false" scope="line" severity="3">
               <file path="CODSTA\CODSTA-124_a.rule"/>
            </rule>
            <rule header="函数类型的不兼容指针之间不能进行转换" id="b" impl="CODSTA-124_b" originalId="CODSTA-124_b" quickfix="false" scope="line" severity="3">
               <file path="CODSTA\CODSTA-124_b.rule"/>
            </rule>
            <rule header="不能在指向不完整类型的指针和任何其他类型的指针之间进行转换" id="c" impl="CODSTA-125" originalId="CODSTA-125" quickfix="false" scope="line" severity="3">
               <file path="CODSTA\CODSTA-125.rule"/>
            </rule>
            <rule header="不得在指向对象类型的指针和指向不同对象类型的指针之间执行强制转换" id="d" impl="CODSTA-126" originalId="CODSTA-126" quickfix="false" scope="line" severity="3">
               <file path="CODSTA\CODSTA-126.rule"/>
            </rule>
            <rule header="不能在指向 void 的指针和算术类型之间执行强制类型转换" id="g" impl="CODSTA-129_a" originalId="CODSTA-129_a" quickfix="false" scope="line" severity="3">
               <file path="CODSTA\CODSTA-129_a.rule"/>
            </rule>
            <rule header="不应在指向 void 的指针和算术类型之间执行隐式转换" id="h" impl="CODSTA-129_b" originalId="CODSTA-129_b" quickfix="false" scope="line" severity="3">
               <file path="CODSTA\CODSTA-129_b.rule"/>
            </rule>
            <rule header="不应在指向对象的指针和非整数算术类型之间执行强制转换" id="i" impl="CODSTA-130" originalId="CODSTA-130" quickfix="false" scope="line" severity="3">
               <file path="CODSTA\CODSTA-130.rule"/>
            </rule>
            <rule header="不应使用可能导致信息丢失的从较宽到较窄的整数类型的隐式转换" id="j" impl="MISRA-043" originalId="MISRA-043" quickfix="false" scope="line" severity="3">
               <file path="MISRA\MISRA-043.rule"/>
            </rule>
            <rule header="不应使用可能导致信息丢失的从整型到浮点型的隐式转换" id="k" impl="MISRA-043_c" originalId="MISRA-043_c" quickfix="false" scope="line" severity="3">
               <file path="MISRA\MISRA-043_c.rule"/>
            </rule>
            <rule header="不应使用可能会导致信息丢失的从整数常量到浮点类型的隐式转换" id="l" impl="MISRA-043_d" originalId="MISRA-043_d" quickfix="false" scope="line" severity="3">
               <file path="MISRA\MISRA-043_d.rule"/>
            </rule>
            <rule header="不应在指向对象类型的指针与除 'uintptr_t' 或 'intptr_t' 以外的整数类型之间执行转换" id="e" impl="CODSTA-127_b" originalId="CODSTA-127_b" quickfix="false" scope="line" severity="4">
               <file path="CODSTA\CODSTA-127_b.rule"/>
            </rule>
            <rule header="不应该执行从指向 void 的指针到指向对象的指针的转换" id="f" impl="CODSTA-128" originalId="CODSTA-128" quickfix="false" scope="line" severity="4">
               <file path="CODSTA\CODSTA-128.rule"/>
            </rule>
         </category>
         <category description="CWE-732 关键资源不正确的权限分配" name="732">
            <rule header="如果文件是使用 'open' 或 'openat' 系统调用创建的，则指定访问权限位" id="b" impl="SECURITY-42" originalId="SECURITY-42" quickfix="false" scope="line" severity="3">
               <file path="SECURITY\SECURITY-42.rule"/>
            </rule>
            <rule header="在调用 'mkstemp' 之前调用 'umask'" id="a" impl="SECURITY-40" originalId="SECURITY-40" quickfix="false" scope="line" severity="4">
               <file path="SECURITY\SECURITY-40.rule"/>
            </rule>
         </category>
         <category description="CWE-835 具有不可到达退出条件的循环 （“无限循环”）" name="835">
            <rule header="避免无限循环" id="a" impl="CODSTA-82" originalId="CODSTA-82" quickfix="false" scope="line" severity="3">
               <file path="CODSTA\CODSTA-82.rule"/>
            </rule>
         </category>
         <category description="CWE-843: 使用不兼容类型访问资源 ('类型混淆')" name="843">
            <rule header="不应在指向对象类型的指针和指向对象类型的其他指针之间执行强制转换" id="a" impl="MISRA2004-11_4" originalId="MISRA2004-11_4" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-11_4.rule"/>
            </rule>
         </category>
         <category description="CWE-798 使用硬编码凭证" name="798">
            <rule header="不要硬编码字符串字面量" id="a" impl="CODSTA-203" originalId="CODSTA-203" quickfix="false" scope="line" severity="5">
               <file path="CODSTA\CODSTA-203.rule"/>
            </rule>
         </category>
      </category>
      <category description="异常" name="EXCEPT">
         <rule header="不允许从析构、释放和交换中抛出异常" id="01" impl="EXCEPT-01" quickfix="false" scope="line" severity="1">
            <file path="EXCEPT\EXCEPT-01.rule"/>
         </rule>
         <rule header="按值抛出，按参考捕获" id="02" impl="EXCEPT-02" quickfix="false" scope="line" severity="1">
            <file path="EXCEPT\EXCEPT-02.rule"/>
         </rule>
         <rule header="不要从析构函数内抛出" id="03" impl="EXCEPT-03" quickfix="false" scope="line" severity="1">
            <file path="EXCEPT\EXCEPT-03.rule"/>
         </rule>
         <rule header="throw 语句的赋值表达式不得自身引起一个异常抛出" id="11" impl="EXCEPT-11" quickfix="false" scope="line" severity="1">
            <file path="EXCEPT\EXCEPT-11.rule"/>
         </rule>
         <rule header="所有的异常应该重新抛出，或者用标准的日志记录器进行记录" id="04" impl="EXCEPT-04" quickfix="false" scope="line" severity="2">
            <file path="EXCEPT\EXCEPT-04.rule"/>
         </rule>
         <rule header="在程序中不要运用 C++ 异常处理函数(例如,不得使用 throw, catch 和 try 等)" id="05" impl="EXCEPT-05" quickfix="false" scope="line" severity="2">
            <file path="EXCEPT\EXCEPT-05.rule"/>
         </rule>
         <rule header="至少应该有一个异常处理程序来捕获所有其他未处理的异常" id="06" impl="EXCEPT-06" quickfix="false" scope="line" severity="3">
            <file path="EXCEPT\EXCEPT-06.rule"/>
         </rule>
         <rule header="空抛出(throw;)只能用于catch处理程序的复合语句中" id="07" impl="EXCEPT-07" quickfix="false" scope="line" severity="3">
            <file path="EXCEPT\EXCEPT-07.rule"/>
         </rule>
         <rule header="只有在程序启动后和终止前才会出现异常情况" id="08" impl="EXCEPT-08" quickfix="false" scope="line" severity="3">
            <file path="EXCEPT\EXCEPT-08.rule"/>
         </rule>
         <rule header="异常对象不应该有指针类型" id="09" impl="EXCEPT-09" quickfix="false" scope="line" severity="3">
            <file path="EXCEPT\EXCEPT-09.rule"/>
         </rule>
         <rule header="不得使用 goto 或 switch 开关语句将控制传递到 try 或 catch 模块中" id="10" impl="EXCEPT-10" quickfix="false" scope="line" severity="3">
            <file path="EXCEPT\EXCEPT-10.rule"/>
         </rule>
         <rule header="NULL 不得被显式地抛出" id="12" impl="EXCEPT-12" quickfix="false" scope="line" severity="3">
            <file path="EXCEPT\EXCEPT-12.rule"/>
         </rule>
         <rule header="代码中显式抛出的每个异常都应在可能导致该点的所有调用路径中具有兼容类型的处理程序" id="13" impl="EXCEPT-13" quickfix="false" scope="line" severity="3">
            <file path="EXCEPT\EXCEPT-13.rule"/>
         </rule>
         <rule header="如果函数的声明包含异常规范，则该函数只能抛出指定类型的异常" id="14" impl="EXCEPT-14" quickfix="false" scope="line" severity="3">
            <file path="EXCEPT\EXCEPT-14.rule"/>
         </rule>
         <rule header="一个类的类型异常应始终通过引用捕获" id="15" impl="EXCEPT-15" quickfix="false" scope="line" severity="3">
            <file path="EXCEPT\EXCEPT-15.rule"/>
         </rule>
         <rule header="以 function-try-block 实现的类构造函数或析构函数的处理程序不应引用该类或其基类的非静态成员" id="16" impl="EXCEPT-16" quickfix="false" scope="line" severity="3">
            <file path="EXCEPT\EXCEPT-16.rule"/>
         </rule>
         <rule header="如果在一个 try-catch 语句或函数 try-block 中为派生类及其部分或全部基类提供多个处理程序，则应将派生程度最高的处理程序排序为派生程度最高的基类" id="17" impl="EXCEPT-17" quickfix="false" scope="line" severity="3">
            <file path="EXCEPT\EXCEPT-17.rule"/>
         </rule>
         <rule header="在全局或命名空间作用域中调用的函数不能抛出未处理的异常" id="18" impl="EXCEPT-18" quickfix="false" scope="line" severity="3">
            <file path="EXCEPT\EXCEPT-18.rule"/>
         </rule>
         <rule header="异常对象必须是不可抛出复制构造函数" id="19" impl="EXCEPT-19" quickfix="false" scope="line" severity="3">
            <file path="EXCEPT\EXCEPT-19.rule"/>
         </rule>
         <rule header="继承自'std::exception'的类的显式声明复制构造函数应该具有非抛出异常规范" id="20" impl="EXCEPT-20" quickfix="false" scope="line" severity="3">
            <file path="EXCEPT\EXCEPT-20.rule"/>
         </rule>
         <rule header="所有用户提供的移动构造函数和移动分配操作符都不应异常退出" id="21" impl="EXCEPT-21" quickfix="false" scope="line" severity="3">
            <file path="EXCEPT\EXCEPT-21.rule"/>
         </rule>
         <rule header="可以从函数中抛出的检测异常应在函数声明之前的注释中指定" id="22" impl="EXCEPT-22" quickfix="false" scope="line" severity="3">
            <file path="EXCEPT\EXCEPT-22.rule"/>
         </rule>
         <rule header="不使用throw异常规范" id="23" impl="EXCEPT-23" quickfix="false" scope="line" severity="3">
            <file path="EXCEPT\EXCEPT-23.rule"/>
         </rule>
         <rule header="如果在 'try-catch' 语句或 'function-try-block' 中提供了多个处理程序，那么任何省略(catch-all)处理程序都应该是最后一个" id="24" impl="EXCEPT-24" quickfix="false" scope="line" severity="3">
            <file path="EXCEPT\EXCEPT-24.rule"/>
         </rule>
         <rule header="不要让 'catch' 块为空" id="25" impl="EXCEPT-25" quickfix="false" scope="line" severity="3">
            <file path="EXCEPT\EXCEPT-25.rule"/>
         </rule>
         <rule header="避免使用 catch-all 异常处理程序" id="26" impl="EXCEPT-26" quickfix="false" scope="line" severity="3">
            <file path="EXCEPT\EXCEPT-26.rule"/>
         </rule>
      </category>
      <category description="GJB5369-2005 航天型号 C 语言安全子集" name="GJB5369">
         <rule header="禁止重新定义使用 C 或 C++ 的关键字" id="4_1_1_9" impl="GJB5369-4_1_1_9" quickfix="false" scope="line" severity="1">
            <file path="GJB5369\GJB5369-4_1_1_9.rule"/>
         </rule>
         <rule header="禁止字符串中单独使用“\”，字符串的终止必须使用“\0”" id="4_2_1_9" impl="GJB5369-4_2_1_9" quickfix="false" scope="line" severity="1">
            <file path="GJB5369\GJB5369-4_2_1_9.rule"/>
         </rule>
         <rule header="禁止使用不合适的循环变量类型" id="4_11_1_1" impl="MISRA2004-13_4" originalId="MISRA2004-13_4" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-13_4.rule"/>
         </rule>
         <rule header="禁止对指针变量使用强制类型转换赋值" id="4_12_1_1" impl="MISRA2004-11_3_b" originalId="MISRA2004-11_3_b" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-11_3_b.rule"/>
         </rule>
         <rule header="结构体变量初始化的类型必须一致" id="4_13_1_2" impl="GJB5369-4_13_1_2" quickfix="false" scope="line" severity="2">
            <file path="GJB5369\GJB5369-4_13_1_2.rule"/>
         </rule>
         <rule header="禁止对实数类型的量做是否相等的比较" id="4_14_1_1" impl="MISRA2004-13_3" originalId="MISRA2004-13_3" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-13_3.rule"/>
         </rule>
         <rule header="禁止逻辑判别的表达式不是逻辑表达式" id="4_14_1_2" impl="MISRA2004-13_2" originalId="MISRA2004-13_2" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-13_2.rule"/>
         </rule>
         <rule header="switch 语句中的表达式禁止是逻辑表达式" id="4_14_1_3" impl="MISRA2004-15_4" originalId="MISRA2004-15_4" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-15_4.rule"/>
         </rule>
         <rule header="禁止枚举类型中的元素名与已有的变量名同名" id="4_15_1_1" impl="GJB5369-4_15_1_1" quickfix="false" scope="line" severity="2">
            <file path="GJB5369\GJB5369-4_15_1_1.rule"/>
         </rule>
         <rule header="过程名禁止被重用" id="4_1_1_1" impl="GJB5369-4_1_1_1" quickfix="false" scope="line" severity="2">
            <file path="GJB5369\GJB5369-4_1_1_1.rule"/>
         </rule>
         <rule header="禁止在宏中包含不允许的项" id="4_1_1_13" impl="MISRA2004-19_4" originalId="MISRA2004-19_4" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-19_4.rule"/>
         </rule>
         <rule header="禁止重新定义保留字" id="4_1_1_14_a" impl="MISRA2004-20_1_a" originalId="MISRA2004-20_1_a" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-20_1_a.rule"/>
         </rule>
         <rule header="禁止重新定义保留字" id="4_1_1_14_b" impl="MISRA2004-20_1_b" originalId="MISRA2004-20_1_b" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-20_1_b.rule"/>
         </rule>
         <rule header="禁止对一个名字重新定义" id="4_1_1_16" impl="MISRA2004-5_4_a" originalId="MISRA2004-5_4_a" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-5_4_a.rule"/>
         </rule>
         <rule header="禁止在同一个文件中有 #if 而没有 #endif" id="4_1_1_18" impl="MISRA2004-19_17" originalId="MISRA2004-19_17" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-19_17.rule"/>
         </rule>
         <rule header="禁止数组没有边界限定" id="4_1_1_19" impl="GJB5369-4_1_1_19" quickfix="false" scope="line" severity="2">
            <file path="GJB5369\GJB5369-4_1_1_19.rule"/>
         </rule>
         <rule header="禁止在#include&lt;......&gt;中使用绝对路径名" id="4_1_1_20" impl="GJB5369-4_1_1_20" quickfix="false" scope="line" severity="2">
            <file path="GJB5369\GJB5369-4_1_1_20.rule"/>
         </rule>
         <rule header="禁止结构体声明不完整" id="4_1_1_21" impl="GJB5369-4_1_1_21" quickfix="false" scope="line" severity="2">
            <file path="GJB5369\GJB5369-4_1_1_21.rule"/>
         </rule>
         <rule header="禁止在结构体定义中含有空域" id="4_1_1_3" impl="GJB5369-4_1_1_3" quickfix="false" scope="line" severity="2">
            <file path="GJB5369\GJB5369-4_1_1_3.rule"/>
         </rule>
         <rule header="禁止过程参数只有类型没有标识符" id="4_1_1_7" impl="GJB5369-4_1_1_7" quickfix="false" scope="line" severity="2">
            <file path="GJB5369\GJB5369-4_1_1_7.rule"/>
         </rule>
         <rule header="main 必须定义为 int main(void) 或 int main(int,char*[]) 的形式" id="4_2_1_10" impl="GJB5369-4_2_1_10" quickfix="false" scope="line" severity="2">
            <file path="GJB5369\GJB5369-4_2_1_10.rule"/>
         </rule>
         <rule header="循环体必须用大括号括起来" id="4_2_1_2" impl="GJB5369-4_2_1_2" quickfix="false" scope="line" severity="2">
            <file path="GJB5369\GJB5369-4_2_1_2.rule"/>
         </rule>
         <rule header="禁止在头文件前有可执行代码" id="4_2_1_5" impl="GJB5369-4_2_1_5" quickfix="false" scope="line" severity="2">
            <file path="GJB5369\GJB5369-4_2_1_5.rule"/>
         </rule>
         <rule header="嵌入汇编程序的过程必须是纯汇编程序" id="4_2_1_7" impl="MISRA2004-2_1" originalId="MISRA2004-2_1" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-2_1.rule"/>
         </rule>
         <rule header="头文件名禁止使用 &quot;‘&quot;、&quot;\&quot;和&quot;/#&quot; 等字符" id="4_2_1_8" impl="NAMING-46" originalId="NAMING-46" quickfix="false" scope="line" severity="2">
            <file path="NAMING\NAMING-46.rule"/>
         </rule>
         <rule header="在 switch 语句中必须有 default 语句" id="4_3_1_4" impl="CODSTA-35" originalId="CODSTA-35" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-35.rule"/>
         </rule>
         <rule header="禁止 switch 语句中只包含 default 语句" id="4_3_1_6" impl="MISRA2004-15_5" originalId="MISRA2004-15_5" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-15_5.rule"/>
         </rule>
         <rule header="禁止 switch 的 case 语句不是由 break 终止" id="4_3_1_7" impl="MISRA2004-15_2" originalId="MISRA2004-15_2" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-15_2.rule"/>
         </rule>
         <rule header="禁止将参数指针赋值给过程指针" id="4_4_1_1" impl="GJB5369-4_4_1_1" quickfix="false" scope="line" severity="2">
            <file path="GJB5369\GJB5369-4_4_1_1.rule"/>
         </rule>
         <rule header="禁止指针的指针超过两级" id="4_4_1_2" impl="MISRA2004-17_5" originalId="MISRA2004-17_5" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-17_5.rule"/>
         </rule>
         <rule header="禁止将过程声明为指针类型" id="4_4_1_3" impl="MISRA-104" originalId="MISRA-104" quickfix="false" scope="line" severity="2">
            <file path="MISRA\MISRA-104.rule"/>
         </rule>
         <rule header="禁止在非赋值表达式中出现赋值操作符" id="4_6_1_1" impl="MISRA2004-13_1" originalId="MISRA2004-13_1" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-13_1.rule"/>
         </rule>
         <rule header="禁止位操作符带有布尔型的操作数" id="4_6_1_17" impl="GJB5369-4_6_1_17" quickfix="false" scope="line" severity="2">
            <file path="GJB5369\GJB5369-4_6_1_17.rule"/>
         </rule>
         <rule header="禁止位操作符作用于布尔值" id="4_6_1_18" impl="GJB5369-4_6_1_18" quickfix="false" scope="line" severity="2">
            <file path="GJB5369\GJB5369-4_6_1_18.rule"/>
         </rule>
         <rule header="禁止对有符号类型进行移位运算" id="4_6_1_3" impl="GJB5369-4_6_1_3" quickfix="false" scope="line" severity="2">
            <file path="GJB5369\GJB5369-4_6_1_3.rule"/>
         </rule>
         <rule header="对变量进行移位运算必须保证不会产生溢出" id="4_6_1_4" impl="MISRA2004-12_8" originalId="MISRA2004-12_8" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-12_8.rule"/>
         </rule>
         <rule header="禁止给无符号变量赋负值" id="4_6_1_5" impl="MISRA2004-12_9" originalId="MISRA2004-12_9" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-12_9.rule"/>
         </rule>
         <rule header="有符号类型的位长度必须大于等于两位" id="4_6_1_6" impl="GJB5369-4_6_1_6" quickfix="false" scope="line" severity="2">
            <file path="GJB5369\GJB5369-4_6_1_6.rule"/>
         </rule>
         <rule header="禁止 void 类型的变量作为参数进行传递" id="4_7_1_8" impl="GJB5369-4_7_1_8" quickfix="false" scope="line" severity="2">
            <file path="GJB5369\GJB5369-4_7_1_8.rule"/>
         </rule>
         <rule header="避免以非调用方式使用函数" id="4_7_2_2" impl="GJB5369-4_7_2_2" quickfix="false" scope="line" severity="2">
            <file path="GJB5369\GJB5369-4_7_2_2.rule"/>
         </rule>
         <rule header="禁止 Void 类型的过程中的 return 语句带有返回值" id="4_9_1_2" impl="MISRA-084" originalId="MISRA-084" quickfix="false" scope="line" severity="2">
            <file path="MISRA\MISRA-084.rule"/>
         </rule>
         <rule header="有返回值的函数中 return 必须带有返回值" id="4_9_1_3" impl="MISRA2004-16_8" originalId="MISRA2004-16_8" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-16_8.rule"/>
         </rule>
         <rule header="函数返回类型必须一致" id="4_9_1_4" impl="PB-05" originalId="PB-05" quickfix="false" scope="line" severity="2">
            <file path="PB\PB-05.rule"/>
         </rule>
         <rule header="禁止使用嵌套的注释" id="4_10_1_1" impl="MISRA2004-2_3" originalId="MISRA2004-2_3" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-2_3.rule"/>
         </rule>
         <rule header="循环变量必须是局部声明的" id="4_11_1_2" impl="GJB5369-4_11_1_2" quickfix="false" scope="line" severity="3">
            <file path="GJB5369\GJB5369-4_11_1_2.rule"/>
         </rule>
         <rule header="枚举元素的初始化必须完整" id="4_13_1_1" impl="MISRA2004-9_3" originalId="MISRA2004-9_3" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-9_3.rule"/>
         </rule>
         <rule header="结构体变量初始化的嵌套结构必须与定义的相一致" id="4_13_1_3" impl="INIT-16" originalId="INIT-16" quickfix="false" scope="line" severity="3">
            <file path="INIT\INIT-16.rule"/>
         </rule>
         <rule header="禁止局部变量与全局变量同名" id="4_15_1_2" impl="MISRA2004-5_2_a" originalId="MISRA2004-5_2_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-5_2_a.rule"/>
         </rule>
         <rule header="禁止形参名与全局变量名同名" id="4_15_1_3" impl="MISRA2004-5_2_a" originalId="MISRA2004-5_2_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-5_2_a.rule"/>
         </rule>
         <rule header="禁止形参名与类型或标识符同名" id="4_15_1_4" impl="MISRA2004-5_3_a" originalId="MISRA2004-5_3_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-5_3_a.rule"/>
         </rule>
         <rule header="禁止在内部块中重定义已有的变量名" id="4_15_1_5" impl="MISRA2004-5_2_b" originalId="MISRA2004-5_2_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-5_2_b.rule"/>
         </rule>
         <rule header="禁止复杂表达式中使用 volatile 类型的变量" id="4_15_1_6" impl="MISRA-046_a" originalId="MISRA-046_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-046_a.rule"/>
         </rule>
         <rule header="在源程序中谨慎使用非标准字符" id="4_15_2_1" impl="MISRA-005" originalId="MISRA-005" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-005.rule"/>
         </rule>
         <rule header="禁止使用预处理操作符 # 和 ##" id="4_15_2_2" impl="GJB5369-4_15_2_2" quickfix="false" scope="line" severity="3">
            <file path="GJB5369\GJB5369-4_15_2_2.rule"/>
         </rule>
         <rule header="禁止过程或函数中的参数表为空" id="4_1_1_10" impl="MISRA2004-16_5" originalId="MISRA2004-16_5" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-16_5.rule"/>
         </rule>
         <rule header="禁止在同一个宏中使用多个 # 或 ##" id="4_1_1_11" impl="MISRA2004-19_12" originalId="MISRA2004-19_12" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-19_12.rule"/>
         </rule>
         <rule header="禁止定义不象函数的宏" id="4_1_1_12" impl="MISRA-096" originalId="MISRA-096" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-096.rule"/>
         </rule>
         <rule header="字符型变量必须明确定义是有符号还是无符号" id="4_1_1_15" impl="MISRA-014" originalId="MISRA-014" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-014.rule"/>
         </rule>
         <rule header="用 typedef 自定义的类型禁止被重新定义" id="4_1_1_17" impl="MISRA2004-5_3_b" originalId="MISRA2004-5_3_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-5_3_b.rule"/>
         </rule>
         <rule header="标号名禁止被重用" id="4_1_1_2" impl="MISRA2004-5_6" originalId="MISRA2004-5_6" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-5_6.rule"/>
         </rule>
         <rule header="禁止声明多重标号" id="4_1_1_4" impl="GJB5369-4_1_1_4" quickfix="false" scope="line" severity="3">
            <file path="GJB5369\GJB5369-4_1_1_4.rule"/>
         </rule>
         <rule header="在过程声明中必须对参数说明" id="4_1_1_6" impl="GJB5369-4_1_1_6" quickfix="false" scope="line" severity="3">
            <file path="GJB5369\GJB5369-4_1_1_6.rule"/>
         </rule>
         <rule header="禁止在过程参数表中使用省略号" id="4_1_1_8" impl="MISRA2004-16_1" originalId="MISRA2004-16_1" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-16_1.rule"/>
         </rule>
         <rule header="then/else 中的语句必须用大括号括起来" id="4_2_1_3" impl="MISRA2004-14_9" originalId="MISRA2004-14_9" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-14_9.rule"/>
         </rule>
         <rule header="逻辑表达式的连接必须使用括号" id="4_2_1_4" impl="MISRA2004-12_5" originalId="MISRA2004-12_5" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_5.rule"/>
         </rule>
         <rule header="宏参数必须用括号括起来" id="4_2_1_6" impl="MISRA-096" originalId="MISRA-096" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-096.rule"/>
         </rule>
         <rule header="禁止条件判别成立时相应分支无可执行语句" id="4_3_1_1" impl="GJB5369-4_3_1_1" quickfix="false" scope="line" severity="3">
            <file path="GJB5369\GJB5369-4_3_1_1.rule"/>
         </rule>
         <rule header="在 if … else if 语句中必须使用 else 分支" id="4_3_1_2" impl="MISRA2004-14_10" originalId="MISRA2004-14_10" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-14_10.rule"/>
         </rule>
         <rule header="禁止条件判别的 else 分支无可执行语句" id="4_3_1_3" impl="GJB5369-4_3_1_3" quickfix="false" scope="line" severity="3">
            <file path="GJB5369\GJB5369-4_3_1_3.rule"/>
         </rule>
         <rule header="禁止使用空 switch 语句" id="4_3_1_5" impl="MISRA2004-15_5" originalId="MISRA2004-15_5" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-15_5.rule"/>
         </rule>
         <rule header="禁止switch的case语句中无任何可执行语句" id="4_3_1_8" impl="GJB5369-4_3_1_8" quickfix="false" scope="line" severity="3">
            <file path="GJB5369\GJB5369-4_3_1_8.rule"/>
         </rule>
         <rule header="禁止直接从过程中跳出" id="4_5_1_1" impl="MISRA2004-20_7" originalId="MISRA2004-20_7" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-20_7.rule"/>
         </rule>
         <rule header="禁止使用 goto 语句" id="4_5_1_2" impl="MISRA2004-14_4" originalId="MISRA2004-14_4" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-14_4.rule"/>
         </rule>
         <rule header="避免使用 setjmp/longjmp" id="4_5_2_1" impl="MISRA2004-20_7" originalId="MISRA2004-20_7" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-20_7.rule"/>
         </rule>
         <rule header="禁止对常数值做逻辑非的运算" id="4_6_1_11" impl="CODSTA-CPP-67" originalId="CODSTA-CPP-67" quickfix="false" scope="line" severity="3">
            <file path="CODSTA-CPP\CODSTA-CPP-67.rule"/>
         </rule>
         <rule header="禁止对有符号类型使用位运算" id="4_6_1_12" impl="MISRA2004-12_7" originalId="MISRA2004-12_7" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_7.rule"/>
         </rule>
         <rule header="禁止对枚举类型的越限使用" id="4_6_1_13" impl="PB-33" originalId="PB-33" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-33.rule"/>
         </rule>
         <rule header="禁止在逻辑表达式中使用赋值操作符" id="4_6_1_15" impl="MISRA2004-13_1" originalId="MISRA2004-13_1" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_1.rule"/>
         </rule>
         <rule header="禁止赋值操作符与“&amp;&amp;”或“||”连用" id="4_6_1_16" impl="GJB5369-4_6_1_16" quickfix="false" scope="line" severity="3">
            <file path="GJB5369\GJB5369-4_6_1_16.rule"/>
         </rule>
         <rule header="位的定义必须是有符号整数或无符号整数" id="4_6_1_7" impl="MISRA2004-6_4" originalId="MISRA2004-6_4" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-6_4.rule"/>
         </rule>
         <rule header="禁止给变量赋的值与变量的类型不一致" id="4_6_1_8" impl="GJB5369-4_6_1_8" quickfix="false" scope="line" severity="3">
            <file path="GJB5369\GJB5369-4_6_1_8.rule"/>
         </rule>
         <rule header="赋值类型必须匹配" id="4_6_1_9" impl="MISRA-043" originalId="MISRA-043" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-043.rule"/>
         </rule>
         <rule header="主过程所在文件中禁止有未被该文件中任何过程调用的子过程" id="4_7_1_2" impl="GJB5369-4_7_1_2" quickfix="false" scope="line" severity="3">
            <file path="GJB5369\GJB5369-4_7_1_2.rule"/>
         </rule>
         <rule header="static类型的过程在所在文件中必须被调用" id="4_7_1_3" impl="OPT-30" originalId="OPT-30" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-30.rule"/>
         </rule>
         <rule header="禁止使用被禁用的过程、函数、文件或名称" id="4_7_1_4" impl="MISRA2004-20_2" originalId="MISRA2004-20_2" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-20_2.rule"/>
         </rule>
         <rule header="禁止同一个表达式中调用多个相关函数" id="4_7_1_6" impl="MISRA2004-12_2_d" originalId="MISRA2004-12_2_d" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_2_d.rule"/>
         </rule>
         <rule header="禁止实参和形参类型不一致" id="4_7_1_9" impl="PB-11" originalId="PB-11" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-11.rule"/>
         </rule>
         <rule header="避免过程参数在过程调用中未被使用" id="4_7_2_1" impl="OPT-31" originalId="OPT-31" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-31.rule"/>
         </rule>
         <rule header="禁止单独使用小写字母“l”或大写字母“O”作为变量名" id="4_8_1_1" impl="GJB5369-4_8_1_1" quickfix="false" scope="line" severity="3">
            <file path="GJB5369\GJB5369-4_8_1_1.rule"/>
         </rule>
         <rule header="禁止三字母词的使用" id="4_8_1_2" impl="GJB5369-4_8_1_2" quickfix="false" scope="line" severity="3">
            <file path="GJB5369\GJB5369-4_8_1_2.rule"/>
         </rule>
         <rule header="使用的八进制数必须加以注释" id="4_8_1_3" impl="GJB5369-4_8_1_3" quickfix="false" scope="line" severity="3">
            <file path="GJB5369\GJB5369-4_8_1_3.rule"/>
         </rule>
         <rule header="避免使用老的参数表的定义形式" id="4_8_2_8" impl="GJB5369-4_8_2_8" quickfix="false" scope="line" severity="3">
            <file path="GJB5369\GJB5369-4_8_2_8.rule"/>
         </rule>
         <rule header="函数必须有返回语句" id="4_9_1_1" impl="MISRA2004-16_8" originalId="MISRA2004-16_8" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-16_8.rule"/>
         </rule>
         <rule header="谨慎使用无限循环语句" id="4_11_2_1" impl="GJB5369-4_11_2_1" quickfix="false" scope="line" severity="4">
            <file path="GJB5369\GJB5369-4_11_2_1.rule"/>
         </rule>
         <rule header="避免在循环中使用 break 语句" id="4_11_2_2" impl="MISRA-058" originalId="MISRA-058" quickfix="false" scope="line" severity="4">
            <file path="MISRA\MISRA-058.rule"/>
         </rule>
         <rule header="谨慎使用无法控制的循环条件" id="4_11_2_3" impl="GJB5369-4_11_2_3" quickfix="false" scope="line" severity="4">
            <file path="GJB5369\GJB5369-4_11_2_3.rule"/>
         </rule>
         <rule header="谨慎使用其它类型变量给指针赋值" id="4_12_2_1" impl="GJB5369-4_12_2_1" quickfix="false" scope="line" severity="4">
            <file path="GJB5369\GJB5369-4_12_2_1.rule"/>
         </rule>
         <rule header="避免使用不必要的类型转换" id="4_12_2_2" impl="OPT-29" originalId="OPT-29" quickfix="false" scope="line" severity="4">
            <file path="OPT\OPT-29.rule"/>
         </rule>
         <rule header="建议逻辑表达式采用显式的表达" id="4_14_2_1" impl="GJB5369-4_14_2_1" quickfix="false" scope="line" severity="4">
            <file path="GJB5369\GJB5369-4_14_2_1.rule"/>
         </rule>
         <rule header="避免将过程定义为参数" id="4_1_2_2" impl="GJB5369-4_1_2_2" quickfix="false" scope="line" severity="4">
            <file path="GJB5369\GJB5369-4_1_2_2.rule"/>
         </rule>
         <rule header="过程中避免使用过多的参数，建议不要超过20 个" id="4_1_2_3" impl="GJB5369-4_1_2_3" quickfix="false" scope="line" severity="4">
            <file path="GJB5369\GJB5369-4_1_2_3.rule"/>
         </rule>
         <rule header="在结构体定义中谨慎使用位域" id="4_1_2_4" impl="GJB5369-4_1_2_4" quickfix="false" scope="line" severity="4">
            <file path="GJB5369\GJB5369-4_1_2_4.rule"/>
         </rule>
         <rule header="禁止在块中使用 #define 或 #undef" id="4_1_2_6" impl="GJB5369-4_1_2_6" quickfix="false" scope="line" severity="4">
            <file path="GJB5369\GJB5369-4_1_2_6.rule"/>
         </rule>
         <rule header="谨慎使用 #pragma" id="4_1_2_7" impl="GJB5369-4_1_2_7" quickfix="false" scope="line" severity="4">
            <file path="GJB5369\GJB5369-4_1_2_7.rule"/>
         </rule>
         <rule header="谨慎使用联合(union)的声明" id="4_1_2_8" impl="MISRA2004-18_4" originalId="MISRA2004-18_4" quickfix="false" scope="line" severity="4">
            <file path="MISRA2004\MISRA2004-18_4.rule"/>
         </rule>
         <rule header="在结构体中谨慎使用无名位域" id="4_1_2_9" impl="GJB5369-4_1_2_9" quickfix="false" scope="line" severity="4">
            <file path="GJB5369\GJB5369-4_1_2_9.rule"/>
         </rule>
         <rule header="谨慎使用指针的逻辑比较" id="4_4_2_1" impl="GJB5369-4_4_2_1" quickfix="false" scope="line" severity="4">
            <file path="GJB5369\GJB5369-4_4_2_1.rule"/>
         </rule>
         <rule header="谨慎对指针进行代数运算" id="4_4_2_2" impl="GJB5369-4_4_2_2" quickfix="false" scope="line" severity="4">
            <file path="GJB5369\GJB5369-4_4_2_2.rule"/>
         </rule>
         <rule header="避免使用逗号操作符" id="4_6_2_1" impl="MISRA-042" originalId="MISRA-042" quickfix="false" scope="line" severity="4">
            <file path="MISRA\MISRA-042.rule"/>
         </rule>
         <rule header="谨防长度操作符 sizeof 的副作用" id="4_6_2_2" impl="MISRA2004-12_3" originalId="MISRA2004-12_3" quickfix="false" scope="line" severity="4">
            <file path="MISRA2004\MISRA2004-12_3.rule"/>
         </rule>
         <rule header="谨慎使用不同类型变量的混合运算" id="4_6_2_3" impl="MISRA-043" originalId="MISRA-043" quickfix="false" scope="line" severity="4">
            <file path="MISRA\MISRA-043.rule"/>
         </rule>
         <rule header="避免由于设计的原因导致某些代码不能执行" id="4_6_2_4" impl="MISRA2004-14_1_c" originalId="MISRA2004-14_1_c" quickfix="false" scope="line" severity="4">
            <file path="MISRA2004\MISRA2004-14_1_c.rule"/>
         </rule>
         <rule header="谨慎使用 abort， exit 等函数" id="4_7_2_3" impl="PB-75" originalId="PB-75" quickfix="false" scope="line" severity="4">
            <file path="PB\PB-75.rule"/>
         </rule>
         <rule header="避免使用&quot;+=&quot;或&quot;-=&quot;操作符" id="4_8_2_1" impl="GJB5369-4_8_2_1" quickfix="false" scope="line" severity="4">
            <file path="GJB5369\GJB5369-4_8_2_1.rule"/>
         </rule>
         <rule header="谨慎使用 &quot;++&quot; 或 &quot;--&quot; 操作符" id="4_8_2_2" impl="MISRA2004-12_13" originalId="MISRA2004-12_13" quickfix="false" scope="line" severity="4">
            <file path="MISRA2004\MISRA2004-12_13.rule"/>
         </rule>
         <rule header="避免使用 continue 语句" id="4_8_2_3" impl="MISRA2004-14_5" originalId="MISRA2004-14_5" quickfix="false" scope="line" severity="4">
            <file path="MISRA2004\MISRA2004-14_5.rule"/>
         </rule>
         <rule header="谨慎使用三重表达式" id="4_8_2_4" impl="CODSTA-06" originalId="CODSTA-06" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-06.rule"/>
         </rule>
         <rule header="避免使用不起作用的语句" id="4_8_2_5" impl="MISRA2004-14_2" originalId="MISRA2004-14_2" quickfix="false" scope="line" severity="4">
            <file path="MISRA2004\MISRA2004-14_2.rule"/>
         </rule>
         <rule header="避免使用空语句" id="4_8_2_6" impl="GJB5369-4_8_2_6" quickfix="false" scope="line" severity="4">
            <file path="GJB5369\GJB5369-4_8_2_6.rule"/>
         </rule>
         <rule header="谨慎使用寄存器变量" id="4_8_2_7" impl="MISRA-028" originalId="MISRA-028" quickfix="false" scope="line" severity="4">
            <file path="MISRA\MISRA-028.rule"/>
         </rule>
         <rule header="建议不使用单行注释“∥”" id="4_10_2_2" impl="GJB5369-4_10_2_2" quickfix="false" scope="line" severity="5">
            <file path="GJB5369\GJB5369-4_10_2_2.rule"/>
         </rule>
         <rule header="建议使用typedef在统一的变量声明头文件中对基本变量类型重新定义" id="4_1_2_1" impl="GJB5369-4_1_2_1" quickfix="false" scope="line" severity="5">
            <file path="GJB5369\GJB5369-4_1_2_1.rule"/>
         </rule>
         <rule header="建议一个文件中的程序总行不超过2000 行" id="4_2_2_1" impl="GJB5369-4_2_2_1" quickfix="false" scope="line" severity="5">
            <file path="GJB5369\GJB5369-4_2_2_1.rule"/>
         </rule>
         <rule header="建议一个过程或函数中的程序总行不超过 200 行" id="4_2_2_2" impl="METRICS-25" originalId="METRICS-25" quickfix="false" scope="line" severity="5">
            <file path="METRICS\METRICS-25.rule"/>
         </rule>
      </category>
      <category description="GJB8114-2013 C/C++ 语言编程安全子集" name="GJB8114">
         <category description="GJB8114-CPP 类别" name="CPP">
            <rule header="含有动态分配成员的类，必须编写拷贝构造函数，并重载赋值操作符" id="R_2_1_1" impl="GJB8114-CPP-R_2_1_1" quickfix="false" scope="line" severity="1">
               <file path="GJB8114\GJB8114-CPP-R_2_1_1.rule"/>
            </rule>
            <rule header="虚拟基类指针转换为派生类指针必须使用dynamic_cast转换" id="R_2_1_2" impl="GJB8114-CPP-R_2_1_2" quickfix="false" scope="line" severity="1">
               <file path="GJB8114\GJB8114-CPP-R_2_1_2.rule"/>
            </rule>
            <rule header="菱形层次结构的派生设计，对基类派生必须使用virtual说明" id="R_2_1_3" impl="GJB8114-CPP-R_2_1_3" quickfix="false" scope="line" severity="1">
               <file path="GJB8114\GJB8114-CPP-R_2_1_3.rule"/>
            </rule>
            <rule header="抽象类中的复制操作符重载必须是保护的或私有的" id="R_2_1_4" impl="GJB8114-CPP-R_2_1_4" quickfix="false" scope="line" severity="1">
               <file path="GJB8114\GJB8114-CPP-R_2_1_4.rule"/>
            </rule>
            <rule header="构造函数中禁止使用全局变量" id="R_2_2_1" impl="GJB8114-CPP-R_2_2_1" quickfix="false" scope="line" severity="1">
               <file path="GJB8114\GJB8114-CPP-R_2_2_1.rule"/>
            </rule>
            <rule header="类中必须明确定义缺省构造函数" id="R_2_2_2" impl="GJB8114-CPP-R_2_2_2" quickfix="false" scope="line" severity="1">
               <file path="GJB8114\GJB8114-CPP-R_2_2_2.rule"/>
            </rule>
            <rule header="单参数构造函数必须使用explicit声明" id="R_2_2_3" impl="GJB8114-CPP-R_2_2_3" quickfix="false" scope="line" severity="1">
               <file path="GJB8114\GJB8114-CPP-R_2_2_3.rule"/>
            </rule>
            <rule header="类中所有成员变量必须在构造函数中初始化" id="R_2_2_4" impl="GJB8114-CPP-R_2_2_4" quickfix="false" scope="line" severity="1">
               <file path="GJB8114\GJB8114-CPP-R_2_2_4.rule"/>
            </rule>
            <rule header="派生类构造函数必须在初始化列表中说明直接基类构造函数" id="R_2_2_5" impl="GJB8114-CPP-R_2_2_5" quickfix="false" scope="line" severity="1">
               <file path="GJB8114\GJB8114-CPP-R_2_2_5.rule"/>
            </rule>
            <rule header="具有虚拟成员函数的类，析构函数必须是虚拟的" id="R_2_3_1" impl="GJB8114-CPP-R_2_3_1" quickfix="false" scope="line" severity="1">
               <file path="GJB8114\GJB8114-CPP-R_2_3_1.rule"/>
            </rule>
            <rule header="析构函数中禁止存在不是由自身捕获处理的异常" id="R_2_3_2" impl="GJB8114-CPP-R_2_3_2" quickfix="false" scope="line" severity="1">
               <file path="GJB8114\GJB8114-CPP-R_2_3_2.rule"/>
            </rule>
            <rule header="基类虚拟函数的参数缺省值在派生类重写函数中禁止被改变" id="R_2_4_1" impl="GJB8114-CPP-R_2_4_1" quickfix="false" scope="line" severity="1">
               <file path="GJB8114\GJB8114-CPP-R_2_4_1.rule"/>
            </rule>
            <rule header="派生类对基类虚拟函数重写的声明必须使用virtual显示说明" id="R_2_4_2" impl="GJB8114-CPP-R_2_4_2" quickfix="false" scope="line" severity="1">
               <file path="GJB8114\GJB8114-CPP-R_2_4_2.rule"/>
            </rule>
            <rule header="禁止非纯虚函数被纯虚拟函数重写" id="R_2_4_3" impl="GJB8114-CPP-R_2_4_3" quickfix="false" scope="line" severity="1">
               <file path="GJB8114\GJB8114-CPP-R_2_4_3.rule"/>
            </rule>
            <rule header="禁止将不相关的指针类型强制转换为对象指针类型" id="R_2_5_1" impl="GJB8114-CPP-R_2_5_1" quickfix="false" scope="line" severity="1">
               <file path="GJB8114\GJB8114-CPP-R_2_5_1.rule"/>
            </rule>
            <rule header="指针或引用的类型转换中禁止移除const或volatile属性" id="R_2_5_2" impl="GJB8114-CPP-R_2_5_2" quickfix="false" scope="line" severity="1">
               <file path="GJB8114\GJB8114-CPP-R_2_5_2.rule"/>
            </rule>
            <rule header="函数中固定长度数组变量的传递必须使用引用方式" id="R_2_7_1" impl="GJB8114-CPP-R_2_7_1" quickfix="false" scope="line" severity="1">
               <file path="GJB8114\GJB8114-CPP-R_2_7_1.rule"/>
            </rule>
            <rule header="定义为const的成员函数禁止返回非const的指针或引用" id="R_2_7_2" impl="GJB8114-CPP-R_2_7_2" quickfix="false" scope="line" severity="1">
               <file path="GJB8114\GJB8114-CPP-R_2_7_2.rule"/>
            </rule>
            <rule header="禁止可导致非资源性对象数据被外部修改的成员函数返回" id="R_2_7_3" impl="GJB8114-CPP-R_2_7_3" quickfix="false" scope="line" severity="1">
               <file path="GJB8114\GJB8114-CPP-R_2_7_3.rule"/>
            </rule>
            <rule header="捕获的顺序必须按由派生类到基类的次序排序" id="R_2_8_1" impl="GJB8114-CPP-R_2_8_1" quickfix="false" scope="line" severity="1">
               <file path="GJB8114\GJB8114-CPP-R_2_8_1.rule"/>
            </rule>
            <rule header="每个指定的抛出必须有与之匹配的捕获" id="R_2_8_2" impl="GJB8114-CPP-R_2_8_2" quickfix="false" scope="line" severity="1">
               <file path="GJB8114\GJB8114-CPP-R_2_8_2.rule"/>
            </rule>
            <rule header="异常抛出的对象必须使用引用方式捕获" id="R_2_8_3" impl="GJB8114-CPP-R_2_8_3" quickfix="false" scope="line" severity="1">
               <file path="GJB8114\GJB8114-CPP-R_2_8_3.rule"/>
            </rule>
            <rule header="模板的声明、定义与实现必须在同一个文件之中" id="R_2_9_1" impl="GJB8114-CPP-R_2_9_1" quickfix="false" scope="line" severity="1">
               <file path="GJB8114\GJB8114-CPP-R_2_9_1.rule"/>
            </rule>
            <rule header="谨慎使用派生类由虚拟基类派生" id="A_2_1_1" impl="GJB8114-CPP-A_2_1_1" quickfix="false" scope="line" severity="3">
               <file path="GJB8114\GJB8114-CPP-A_2_1_1.rule"/>
            </rule>
            <rule header="谨慎使用内联函数" id="A_2_1_2" impl="GJB8114-CPP-A_2_1_2" quickfix="false" scope="line" severity="3">
               <file path="GJB8114\GJB8114-CPP-A_2_1_2.rule"/>
            </rule>
            <rule header="建议使用C++的类型转换操作符，避免使用C的类型转换形式" id="A_2_5_1" impl="GJB8114-CPP-A_2_5_1" quickfix="false" scope="line" severity="3">
               <file path="GJB8114\GJB8114-CPP-A_2_5_1.rule"/>
            </rule>
            <rule header="类中函数的实现代码避免在类定义的内部定义" id="A_2_7_1" impl="GJB8114-CPP-A_2_7_1" quickfix="false" scope="line" severity="3">
               <file path="GJB8114\GJB8114-CPP-A_2_7_1.rule"/>
            </rule>
            <rule header="建议在所有指定捕获之后使用缺省捕获防范遗漏的异常" id="A_2_8_1" impl="GJB8114-CPP-A_2_8_1" quickfix="false" scope="line" severity="3">
               <file path="GJB8114\GJB8114-CPP-A_2_8_1.rule"/>
            </rule>
            <rule header="谨慎对指针类型进行抛出捕获" id="A_2_8_2" impl="GJB8114-CPP-A_2_8_2" quickfix="false" scope="line" severity="3">
               <file path="GJB8114\GJB8114-CPP-A_2_8_2.rule"/>
            </rule>
            <rule header="建议模板参数列表中的类型参数使用typename关键字说明" id="A_2_9_1" impl="GJB8114-CPP-A_2_9_1" quickfix="false" scope="line" severity="3">
               <file path="GJB8114\GJB8114-CPP-A_2_9_1.rule"/>
            </rule>
            <rule header="建议除常数指针外，const说明均在类型说明的最外层" id="A_2_9_2" impl="GJB8114-CPP-A_2_9_2" quickfix="false" scope="line" severity="3">
               <file path="GJB8114\GJB8114-CPP-A_2_9_2.rule"/>
            </rule>
            <rule header="建议不要对“&amp;&amp;”、“||”、“,”进行操作符重载" id="A_2_9_3" impl="GJB8114-CPP-A_2_9_3" quickfix="false" scope="line" severity="3">
               <file path="GJB8114\GJB8114-CPP-A_2_9_3.rule"/>
            </rule>
            <rule header="禁止显式直接抛出NULL" id="R_2_8_5" impl="GJB8114-CPP-R_2_8_5" quickfix="false" scope="line" severity="3">
               <file path="GJB8114\GJB8114-CPP-R_2_8_5.rule"/>
            </rule>
         </category>
         <rule header="浮点数变量赋给整型变量必须强制转换" id="R_1_10_1" impl="GJB8114-R_1_10_1" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_10_1.rule"/>
         </rule>
         <rule header="长整数变量赋给短整数变量必须强制转换" id="R_1_10_2" impl="GJB8114-R_1_10_2" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_10_2.rule"/>
         </rule>
         <rule header="double型变量赋给float型变量必须强制转换" id="R_1_10_3" impl="GJB8114-R_1_10_3" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_10_3.rule"/>
         </rule>
         <rule header="将指针量赋予非指针变量或非指针量赋予指针变量，必须使用强制转换" id="R_1_10_5" impl="GJB8114-R_1_10_5" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_10_5.rule"/>
         </rule>
         <rule header="禁止使用无实质作用的类型转换" id="R_1_10_6" impl="GJB8114-R_1_10_6" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_10_6.rule"/>
         </rule>
         <rule header="变量初始化禁止隐含依赖于系统的缺省值" id="R_1_11_2" impl="GJB8114-R_1_11_2" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_11_2.rule"/>
         </rule>
         <rule header="结构体初始化的嵌套结构必须与定义一致" id="R_1_11_3" impl="GJB8114-R_1_11_3" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_11_3.rule"/>
         </rule>
         <rule header="枚举元素定义中的初始化必须完整" id="R_1_11_4" impl="GJB8114-R_1_11_4" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_11_4.rule"/>
         </rule>
         <rule header="禁止对逻辑量进行大于或小于的逻辑比较" id="R_1_12_1" impl="GJB8114-R_1_12_1" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_12_1.rule"/>
         </rule>
         <rule header="禁止对指针进行大于或小于的逻辑比较" id="R_1_12_2" impl="GJB8114-R_1_12_2" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_12_2.rule"/>
         </rule>
         <rule header="禁止对浮点数进行是否相等的比较" id="R_1_12_3" impl="GJB8114-R_1_12_3" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_12_3.rule"/>
         </rule>
         <rule header="禁止对无符号数进行大于等于零或小于零的比较" id="R_1_12_4" impl="GJB8114-R_1_12_4" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_12_4.rule"/>
         </rule>
         <rule header="禁止无符号数与有符号数之间的直接比较" id="R_1_12_5" impl="GJB8114-R_1_12_5" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_12_5.rule"/>
         </rule>
         <rule header="禁止局部变量与全局变量同名" id="R_1_13_1" impl="GJB8114-R_1_13_1" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_13_1.rule"/>
         </rule>
         <rule header="禁止仅依赖大写字母 'O' 与数字 '0' 区分的变量" id="R_1_13_10" impl="GJB8114-R_1_13_10" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_13_10.rule"/>
         </rule>
         <rule header="禁止单独使用小写字母“l”或大写字母“O”作为变量名" id="R_1_13_11" impl="GJB8114-R_1_13_11" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_13_11.rule"/>
         </rule>
         <rule header="禁止在表达式中出现多个同一volatile类型变量的运算" id="R_1_13_13" impl="GJB8114-R_1_13_13" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_13_13.rule"/>
         </rule>
         <rule header="禁止将NULL做为整型数0使用" id="R_1_13_14" impl="GJB8114-R_1_13_14" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_13_14.rule"/>
         </rule>
         <rule header="禁止给无符号类型变量赋负值" id="R_1_13_15" impl="GJB8114-R_1_13_15" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_13_15.rule"/>
         </rule>
         <rule header="禁止函数形参与全局变量同名" id="R_1_13_2" impl="GJB8114-R_1_13_2" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_13_2.rule"/>
         </rule>
         <rule header="禁止变量名与标识名同名。" id="R_1_13_4" impl="GJB8114-R_1_13_4" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_13_4.rule"/>
         </rule>
         <rule header="禁止变量名与typedef自定义的类型名同名" id="R_1_13_6" impl="GJB8114-R_1_13_6" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_13_6.rule"/>
         </rule>
         <rule header="禁止在内部块中重定义已有的变量名" id="R_1_13_7" impl="GJB8114-R_1_13_7" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_13_7.rule"/>
         </rule>
         <rule header="禁止仅依赖大小写区分的变量" id="R_1_13_8" impl="GJB8114-R_1_13_8" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_13_8.rule"/>
         </rule>
         <rule header="禁止仅依赖小写字母 'l' 与数字 '1' 区分的变量" id="R_1_13_9" impl="GJB8114-R_1_13_9" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_13_9.rule"/>
         </rule>
         <rule header="禁止通过宏定义改变关键字和基本类型含义" id="R_1_1_1" impl="GJB8114-R_1_1_1" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_1_1.rule"/>
         </rule>
         <rule header="位定义的有符号整型变量位长必须大于1" id="R_1_1_10" impl="GJB8114-R_1_1_10" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_1_10.rule"/>
         </rule>
         <rule header="位定义的整数型变量必须明确定义是有符号还是无符号的" id="R_1_1_11" impl="GJB8114-R_1_1_11" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_1_11.rule"/>
         </rule>
         <rule header="函数声明中必须对参数类型进行声明，并带有变量名" id="R_1_1_13" impl="GJB8114-R_1_1_13" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_1_13.rule"/>
         </rule>
         <rule header="函数中的参数必须使用类型声明" id="R_1_1_15" impl="GJB8114-R_1_1_15" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_1_15.rule"/>
         </rule>
         <rule header="禁止在函数体内使用外部声明。" id="R_1_1_17" impl="GJB8114-R_1_1_17" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_1_17.rule"/>
         </rule>
         <rule header="数组定义禁止没有显式的边界限定。" id="R_1_1_18" impl="GJB8114-R_1_1_18" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_1_18.rule"/>
         </rule>
         <rule header="禁止使用 extern 声明对变量初始化" id="R_1_1_19" impl="GJB8114-R_1_1_19" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_1_19.rule"/>
         </rule>
         <rule header="禁止将其它标识宏定义为关键字和基本类型" id="R_1_1_2" impl="GJB8114-R_1_1_2" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_1_2.rule"/>
         </rule>
         <rule header="用于数值计算的字符型变量必须明确定义是有符号还是无符号。" id="R_1_1_20" impl="GJB8114-R_1_1_20" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_1_20.rule"/>
         </rule>
         <rule header="禁止在#include语句中使用绝对路径。" id="R_1_1_21" impl="GJB8114-R_1_1_21" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_1_21.rule"/>
         </rule>
         <rule header="函数参数表为空时，必须使用void明确说明。" id="R_1_1_23" impl="GJB8114-R_1_1_23" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_1_23.rule"/>
         </rule>
         <rule header="用 typedef 自定义的类型禁止被重新定义。" id="R_1_1_3" impl="GJB8114-R_1_1_3" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_1_3.rule"/>
         </rule>
         <rule header="禁止重新定义C或C++的关键字" id="R_1_1_4" impl="GJB8114-R_1_1_4" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_1_4.rule"/>
         </rule>
         <rule header="函数中的#define和#undef必须配对使用。" id="R_1_1_6" impl="GJB8114-R_1_1_6" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_1_6.rule"/>
         </rule>
         <rule header="以函数形式定义的宏，参数和结果必须用括号括起来" id="R_1_1_7" impl="GJB8114-R_1_1_7" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_1_7.rule"/>
         </rule>
         <rule header="结构、联合、枚举的定义中必须定义标识名。" id="R_1_1_8" impl="GJB8114-R_1_1_8" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_1_8.rule"/>
         </rule>
         <rule header="结构体定义中禁止含有无名结构体" id="R_1_1_9" impl="GJB8114-R_1_1_9" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_1_9.rule"/>
         </rule>
         <rule header="循环体必须用大括号括起来。" id="R_1_2_1" impl="GJB8114-R_1_2_1" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_2_1.rule"/>
         </rule>
         <rule header="if、else if、else必须用大括号括起来。" id="R_1_2_2" impl="GJB8114-R_1_2_2" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_2_2.rule"/>
         </rule>
         <rule header="禁止在头文件前有可执行代码。" id="R_1_2_3" impl="GJB8114-R_1_2_3" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_2_3.rule"/>
         </rule>
         <rule header="引起二义性理解的逻辑表达式，必须使用括号显式说明优先级顺序。" id="R_1_2_4" impl="GJB8114-R_1_2_4" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_2_4.rule"/>
         </rule>
         <rule header="逻辑判别表达式中的运算项必须要使用括号" id="R_1_2_5" impl="GJB8114-R_1_2_5" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_2_5.rule"/>
         </rule>
         <rule header="禁止嵌套注释" id="R_1_2_6" impl="GJB8114-R_1_2_6" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_2_6.rule"/>
         </rule>
         <rule header="禁止指针的指针超过两级。" id="R_1_3_1" impl="GJB8114-R_1_3_1" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_3_1.rule"/>
         </rule>
         <rule header="函数指针的使用必须加以&amp;明确说明" id="R_1_3_2" impl="GJB8114-R_1_3_2" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_3_2.rule"/>
         </rule>
         <rule header="禁止对参数指针进行赋值。" id="R_1_3_3" impl="GJB8114-R_1_3_3" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_3_3.rule"/>
         </rule>
         <rule header="禁止将局部变量地址做为函数返回值返回。" id="R_1_3_4" impl="GJB8114-R_1_3_4" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_3_4.rule"/>
         </rule>
         <rule header="指针变量被释放后必须置为NULL" id="R_1_3_6" impl="GJB8114-R_1_3_6" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_3_6.rule"/>
         </rule>
         <rule header="动态分配的指针变量定义时如未被分配空间必须初始化为NULL" id="R_1_3_7" impl="GJB8114-R_1_3_7" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_3_7.rule"/>
         </rule>
         <rule header="空指针必须使用NULL，禁止使用整型数0" id="R_1_3_9" impl="GJB8114-R_1_3_9" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_3_9.rule"/>
         </rule>
         <rule header="在if-else if语句中必须使用else分支。" id="R_1_4_1" impl="GJB8114-R_1_4_1" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_4_1.rule"/>
         </rule>
         <rule header="条件判定分支如果为空，必须以单独一行的分号加注释进行明确说明" id="R_1_4_2" impl="GJB8114-R_1_4_2" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_4_2.rule"/>
         </rule>
         <rule header="禁止使用空switch语句" id="R_1_4_3" impl="GJB8114-R_1_4_3" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_4_3.rule"/>
         </rule>
         <rule header="禁止对bool量使用switch语句。" id="R_1_4_4" impl="GJB8114-R_1_4_4" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_4_4.rule"/>
         </rule>
         <rule header="禁止switch语句中只包含default语句" id="R_1_4_5" impl="GJB8114-R_1_4_5" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_4_5.rule"/>
         </rule>
         <rule header="除枚举类型列举完全外，switch必须要有default。" id="R_1_4_6" impl="GJB8114-R_1_4_6" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_4_6.rule"/>
         </rule>
         <rule header="switch 中的 case 和 default 必须以 break 或 return 终止，共用 case 必须加以明确注释" id="R_1_4_7" impl="GJB8114-R_1_4_7" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_4_7.rule"/>
         </rule>
         <rule header="禁止从复合语句外goto到复合语句内，或由下向上goto。" id="R_1_5_1_a" impl="GJB8114-R_1_5_1_a" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_5_1_a.rule"/>
         </rule>
         <rule header="禁止从复合语句外goto到复合语句内，或由下向上goto。" id="R_1_5_1_b" impl="GJB8114-R_1_5_1_b" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_5_1_b.rule"/>
         </rule>
         <rule header="禁止使用 setjmp/longjmp。" id="R_1_5_2" impl="GJB8114-R_1_5_2" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_5_2.rule"/>
         </rule>
         <rule header="禁止将浮点常数赋给整型变量" id="R_1_6_1" impl="GJB8114-R_1_6_1" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_6_1.rule"/>
         </rule>
         <rule header="禁止对常数值做逻辑非的运算" id="R_1_6_10" impl="GJB8114-R_1_6_10" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_6_10.rule"/>
         </rule>
         <rule header="禁止非枚举类型变量使用枚举类型的值" id="R_1_6_11" impl="GJB8114-R_1_6_11" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_6_11.rule"/>
         </rule>
         <rule header="禁止在sizeof中使用赋值" id="R_1_6_13" impl="GJB8114-R_1_6_13" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_6_13.rule"/>
         </rule>
         <rule header="禁止使用gets函数，应使用fgets函数替代" id="R_1_6_18" impl="GJB8114-R_1_6_18" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_6_18.rule"/>
         </rule>
         <rule header="禁止将越界整数赋给整型变量" id="R_1_6_2_a" impl="GJB8114-R_1_6_2_a" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_6_2_a.rule"/>
         </rule>
         <rule header="禁止将越界整数赋给整型变量" id="R_1_6_2_b" impl="GJB8114-R_1_6_2_b" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_6_2_b.rule"/>
         </rule>
         <rule header="禁止在逻辑表达式中使用赋值语句" id="R_1_6_3" impl="GJB8114-R_1_6_3" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_6_3.rule"/>
         </rule>
         <rule header="禁止对逻辑表达式进行位运算" id="R_1_6_4" impl="GJB8114-R_1_6_4" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_6_4.rule"/>
         </rule>
         <rule header="禁止在运算表达式中或函数调用参数中使用++或--操作符" id="R_1_6_5" impl="GJB8114-R_1_6_5" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_6_5.rule"/>
         </rule>
         <rule header="对变量进行移位运算禁止超出变量长度" id="R_1_6_6" impl="GJB8114-R_1_6_6" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_6_6.rule"/>
         </rule>
         <rule header="禁止移位操作中的移位数为负数" id="R_1_6_7" impl="GJB8114-R_1_6_7" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_6_7.rule"/>
         </rule>
         <rule header="禁止覆盖标准函数库的函数" id="R_1_7_1" impl="GJB8114-R_1_7_1" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_7_1.rule"/>
         </rule>
         <rule header="函数返回值的类型必须与定义一致" id="R_1_7_10" impl="GJB8114-R_1_7_10" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_7_10.rule"/>
         </rule>
         <rule header="具有返回值的函数，其返回值如果不被使用，调用时应有(void)说明" id="R_1_7_11" impl="GJB8114-R_1_7_11" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_7_11.rule"/>
         </rule>
         <rule header="无返回值的函数，调用时禁止再用(void)重复说明" id="R_1_7_12" impl="GJB8114-R_1_7_12" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_7_12.rule"/>
         </rule>
         <rule header="禁止同一个表达式中调用多个顺序相关函数" id="R_1_7_14" impl="GJB8114-R_1_7_14" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_7_14.rule"/>
         </rule>
         <rule header="禁止使用直接或间接自调用函数" id="R_1_7_16" impl="GJB8114-R_1_7_16" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_7_16.rule"/>
         </rule>
         <rule header="禁止函数的实参和形参类型不一致" id="R_1_7_2" impl="GJB8114-R_1_7_2" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_7_2.rule"/>
         </rule>
         <rule header="禁止使用旧形式的函数参数表定义形式" id="R_1_7_4" impl="GJB8114-R_1_7_4" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_7_4.rule"/>
         </rule>
         <rule header="函数声明和函数定义中的参数类型必须一致" id="R_1_7_5" impl="GJB8114-R_1_7_5" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_7_5.rule"/>
         </rule>
         <rule header="有返回值的函数必须通过返回语句返回" id="R_1_7_7" impl="GJB8114-R_1_7_7" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_7_7.rule"/>
         </rule>
         <rule header="禁止无返回值函数的返回语句带有返回值" id="R_1_7_8" impl="GJB8114-R_1_7_8" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_7_8.rule"/>
         </rule>
         <rule header="有返回值函数的返回语句必须带有返回值" id="R_1_7_9" impl="GJB8114-R_1_7_9" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_7_9.rule"/>
         </rule>
         <rule header="在 &quot;else&quot; 语句块中不应存在不可达代码" id="R_1_8_1_a" impl="GJB8114-R_1_8_1_a" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_8_1_a.rule"/>
         </rule>
         <rule header="在 'return', 'break', 'continue', 和 'goto' 语句之后不应存在不可达代码" id="R_1_8_1_b" impl="GJB8114-R_1_8_1_b" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_8_1_b.rule"/>
         </rule>
         <rule header="在 &quot;if/else/while/for&quot; 语句块中不应存在不可达代码" id="R_1_8_1_c" impl="GJB8114-R_1_8_1_c" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_8_1_c.rule"/>
         </rule>
         <rule header="在 Switch 语句中不应存在不可达代码" id="R_1_8_1_d" impl="GJB8114-R_1_8_1_d" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_8_1_d.rule"/>
         </rule>
         <rule header="在 'for' 循环中不应存在不可达代码" id="R_1_8_1_e" impl="GJB8114-R_1_8_1_e" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_8_1_e.rule"/>
         </rule>
         <rule header="在 'if' 或 'switch' 语句之后不应存在不可达代码" id="R_1_8_1_f" impl="GJB8114-R_1_8_1_f" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_8_1_f.rule"/>
         </rule>
         <rule header="在 while/for/do...while 循环内的 &quot;if&quot; 或 &quot;switch&quot; 语句后不应存在不可达代码" id="R_1_8_1_g" impl="GJB8114-R_1_8_1_g" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_8_1_g.rule"/>
         </rule>
         <rule header="禁止使用无效语句" id="R_1_8_3" impl="GJB8114-R_1_8_3" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_8_3.rule"/>
         </rule>
         <rule header="使用八进制数必须明确注释" id="R_1_8_4" impl="GJB8114-R_1_8_4" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_8_4.rule"/>
         </rule>
         <rule header="数字类型后缀必须使用大写字母" id="R_1_8_5" impl="GJB8114-R_1_8_5" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_8_5.rule"/>
         </rule>
         <rule header="for循环控制变量必须使用局部变量" id="R_1_9_1" impl="GJB8114-R_1_9_1" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_9_1.rule"/>
         </rule>
         <rule header="for循环控制变量必须使用整数型变量" id="R_1_9_2" impl="GJB8114-R_1_9_2" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_9_2.rule"/>
         </rule>
         <rule header="禁止在for循环体内部修改循环控制变量" id="R_1_9_3" impl="GJB8114-R_1_9_3" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_9_3.rule"/>
         </rule>
         <rule header="无限循环必须使用while(1)语句，禁止使用for(;;)等其它形式的语句" id="R_1_9_4" impl="GJB8114-R_1_9_4" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_9_4.rule"/>
         </rule>
         <rule header="缺省捕获必须放在所有指定捕获之后" id="R_2_8_4" impl="GJB8114-R_2_8_4" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_2_8_4.rule"/>
         </rule>
         <rule header="禁止变量名与函数名同名" id="R_1_13_3" impl="GJB8114-R_1_13_3" quickfix="false" scope="line" severity="2">
            <file path="GJB8114\GJB8114-R_1_13_3.rule"/>
         </rule>
         <rule header="禁止变量名与枚举元素同名" id="R_1_13_5" impl="GJB8114-R_1_13_5" quickfix="false" scope="line" severity="2">
            <file path="GJB8114\GJB8114-R_1_13_5.rule"/>
         </rule>
         <rule header="浮点型数转换成整型数应考虑是否需要四舍五入" id="A_1_10_1" impl="GJB8114-A_1_10_1" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_10_1.rule"/>
         </rule>
         <rule header="谨慎将double型数转换成float型数" id="A_1_10_2" impl="GJB8114-A_1_10_2" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_10_2.rule"/>
         </rule>
         <rule header="谨慎将长整型数转换成短整型数" id="A_1_10_3" impl="GJB8114-A_1_10_3" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_10_3.rule"/>
         </rule>
         <rule header="谨慎将指针量赋予非指针变量或非指针量赋予指针变量" id="A_1_10_4" impl="GJB8114-A_1_10_4" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_10_4.rule"/>
         </rule>
         <rule header="建议变量在声明的同时进行初始化" id="A_1_11_1" impl="GJB8114-A_1_11_1" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_11_1.rule"/>
         </rule>
         <rule header="建议所有全局变量在统一设计的初始化模块中进行初始化" id="A_1_11_2" impl="GJB8114-A_1_11_2" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_11_2.rule"/>
         </rule>
         <rule header="与常数进行是否相等的判别，建议常数在左，变量在右" id="A_1_12_1" impl="GJB8114-A_1_12_1" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_12_1.rule"/>
         </rule>
         <rule header="推荐使用带类型前缀的变量命名" id="A_1_13_1" impl="GJB8114-A_1_13_1" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_13_1.rule"/>
         </rule>
         <rule header="字符型变量命名应以c为前缀" id="A_1_13_1_a" impl="GJB8114-A_1_13_1_a" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_13_1_a.rule"/>
         </rule>
         <rule header="有符号字符型变量应以uc为前缀" id="A_1_13_1_b" impl="GJB8114-A_1_13_1_b" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_13_1_b.rule"/>
         </rule>
         <rule header="无符号字符型变量应以uc为前缀" id="A_1_13_1_c" impl="GJB8114-A_1_13_1_c" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_13_1_c.rule"/>
         </rule>
         <rule header="所有整型变量以小写字母 'i' 开头" id="A_1_13_1_d" impl="GJB8114-A_1_13_1_d" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_13_1_d.rule"/>
         </rule>
         <rule header="所有无符号整型变量以 'ui' 开头" id="A_1_13_1_f" impl="GJB8114-A_1_13_1_f" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_13_1_f.rule"/>
         </rule>
         <rule header="所有短整型变量以字母 's' 开头" id="A_1_13_1_g" impl="GJB8114-A_1_13_1_g" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_13_1_g.rule"/>
         </rule>
         <rule header="无符号短整型变量应以us为前缀" id="A_1_13_1_i" impl="GJB8114-A_1_13_1_i" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_13_1_i.rule"/>
         </rule>
         <rule header="所有长整型变量名以 'l' 开头" id="A_1_13_1_j" impl="GJB8114-A_1_13_1_j" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_13_1_j.rule"/>
         </rule>
         <rule header="无符号长整型变量应以'ul'为前缀" id="A_1_13_1_m" impl="GJB8114-A_1_13_1_m" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_13_1_m.rule"/>
         </rule>
         <rule header="浮点类型变量名以小写字母 'f' 开头" id="A_1_13_1_n" impl="GJB8114-A_1_13_1_n" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_13_1_n.rule"/>
         </rule>
         <rule header="双精类型变量名以小写字母 'd' 开头" id="A_1_13_1_p" impl="GJB8114-A_1_13_1_p" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_13_1_p.rule"/>
         </rule>
         <rule header="长双精度型变量应以ld为前缀" id="A_1_13_1_q" impl="GJB8114-A_1_13_1_q" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_13_1_q.rule"/>
         </rule>
         <rule header="谨慎使用寄存器变量" id="A_1_13_2" impl="GJB8114-A_1_13_2" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_13_2.rule"/>
         </rule>
         <rule header="建议使用typedef对基本变量类型重新定义。" id="A_1_1_1" impl="GJB8114-A_1_1_1" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_1_1.rule"/>
         </rule>
         <rule header="谨慎由于宏中括号不匹配造成使用上的误解" id="A_1_1_2" impl="GJB8114-A_1_1_2" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_1_2.rule"/>
         </rule>
         <rule header="宏定义中谨慎使用##或#。" id="A_1_1_3" impl="GJB8114-A_1_1_3" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_1_3.rule"/>
         </rule>
         <rule header="建议函数内部变量在函数体开始处统一定义" id="A_1_1_4" impl="GJB8114-A_1_1_4" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_1_4.rule"/>
         </rule>
         <rule header="建议结构体嵌套定义不超过3层" id="A_1_1_5" impl="GJB8114-A_1_1_5" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_1_5.rule"/>
         </rule>
         <rule header="建议用宏或const定义常数。" id="A_1_1_6_a" impl="GJB8114-A_1_1_6_a" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_1_6_a.rule"/>
         </rule>
         <rule header="建议用宏或const定义常数。" id="A_1_1_6_b" impl="GJB8114-A_1_1_6_b" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_1_6_b.rule"/>
         </rule>
         <rule header="一个文件中的语句总行不超过2000行。" id="A_1_2_1" impl="GJB8114-A_1_2_1" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_2_1.rule"/>
         </rule>
         <rule header="一个函数中的语句总行不超过200行。" id="A_1_2_2" impl="GJB8114-A_1_2_2" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_2_2.rule"/>
         </rule>
         <rule header="C语言程序建议使用标准C的注释符，谨慎使用 //注释。" id="A_1_2_3" impl="GJB8114-A_1_2_3" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_2_3.rule"/>
         </rule>
         <rule header="谨慎使用函数指针。" id="A_1_3_1" impl="GJB8114-A_1_3_1" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_3_1.rule"/>
         </rule>
         <rule header="谨慎使用无类型指针" id="A_1_3_2" impl="GJB8114-A_1_3_2" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_3_2.rule"/>
         </rule>
         <rule header="谨慎对指针进行算术运算。" id="A_1_3_3" impl="GJB8114-A_1_3_3" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_3_3.rule"/>
         </rule>
         <rule header="避免层数过多的分支嵌套，建议最多不超过7层。" id="A_1_4_1" impl="GJB8114-A_1_4_1" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_4_1.rule"/>
         </rule>
         <rule header="谨慎使用goto语句" id="A_1_5_1" impl="GJB8114-A_1_5_1" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_5_1.rule"/>
         </rule>
         <rule header="禁止对有符号整形量进行位运算" id="A_1_6_1" impl="GJB8114-A_1_6_1" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_6_1.rule"/>
         </rule>
         <rule header="谨慎做整型量除以整型变量的除法" id="A_1_6_2" impl="GJB8114-A_1_6_2" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_6_2.rule"/>
         </rule>
         <rule header="避免使用strcpy函数，应使用strncpy函数替代" id="A_1_6_4" impl="GJB8114-A_1_6_4" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_6_4.rule"/>
         </rule>
         <rule header="避免使用strcat函数，应使用strncat函数替代" id="A_1_6_5" impl="GJB8114-A_1_6_5" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_6_5.rule"/>
         </rule>
         <rule header="谨慎使用逗号操作符" id="A_1_6_6" impl="GJB8114-A_1_6_6" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_6_6.rule"/>
         </rule>
         <rule header="函数中避免使用过多的参数，建议不要超过10个" id="A_1_7_1" impl="GJB8114-A_1_7_1" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_7_1.rule"/>
         </rule>
         <rule header="函数中避免存在未被使用的调用参数" id="A_1_7_2" impl="GJB8114-A_1_7_2" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_7_2.rule"/>
         </rule>
         <rule header="谨慎使用abort、exit函数" id="A_1_7_3" impl="GJB8114-A_1_7_3" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_7_3.rule"/>
         </rule>
         <rule header="函数中数组变量作为参数指针传递时，建议同时传递数组长度" id="A_1_7_5" impl="GJB8114-A_1_7_5" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_7_5.rule"/>
         </rule>
         <rule header="避免使用空语句" id="A_1_8_1" impl="GJB8114-A_1_8_1" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_8_1.rule"/>
         </rule>
         <rule header="避免无用的多余变量" id="A_1_8_2_a" impl="GJB8114-A_1_8_2_a" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_8_2_a.rule"/>
         </rule>
         <rule header="避免无用的多余变量" id="A_1_8_2_b" impl="GJB8114-A_1_8_2_b" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_8_2_b.rule"/>
         </rule>
         <rule header="避免无用的多余函数" id="A_1_8_3" impl="GJB8114-A_1_8_3" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_8_3.rule"/>
         </rule>
         <rule header="推荐使用数字类型后缀" id="A_1_8_4_a" impl="GJB8114-A_1_8_4_a" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_8_4_a.rule"/>
         </rule>
         <rule header="推荐使用数字类型后缀" id="A_1_8_4_b" impl="GJB8114-A_1_8_4_b" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_8_4_b.rule"/>
         </rule>
         <rule header="推荐使用数字类型后缀" id="A_1_8_4_c" impl="GJB8114-A_1_8_4_c" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_8_4_c.rule"/>
         </rule>
         <rule header="推荐使用数字类型后缀" id="A_1_8_4_d" impl="GJB8114-A_1_8_4_d" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_8_4_d.rule"/>
         </rule>
         <rule header="谨慎使用无限循环语句" id="A_1_9_1" impl="GJB8114-A_1_9_1" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_9_1.rule"/>
         </rule>
         <rule header="谨慎在循环中使用多个break语句" id="A_1_9_2" impl="GJB8114-A_1_9_2" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_9_2.rule"/>
         </rule>
         <rule header="谨慎在循环中使用多个continue语句" id="A_1_9_3" impl="GJB8114-A_1_9_3" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_9_3.rule"/>
         </rule>
         <rule header="禁止函数原形中的参数与实际定义中的形参不一致" id="R_1_1_14_a" impl="GJB8114-R_1_1_14_a" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-R_1_1_14_a.rule"/>
         </rule>
         <rule header="函数声明必须与函数原型一致(形参类型和实参必须匹配)" id="R_1_1_14_b" impl="GJB8114-R_1_1_14_b" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-R_1_1_14_b.rule"/>
         </rule>
         <rule header="禁止在函数参数表中使用省略号" id="R_1_7_15" impl="GJB8114-R_1_7_15" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-R_1_7_15.rule"/>
         </rule>
      </category>
      <category description="高完整性 C++" name="HICPP">
         <category description="HIC++ 10.3.1 确保派生类最多只有一个基类，而基类不是接口类" name="10_3_1">
            <rule header="确保派生类最多具有一个不是接口类的基类" id="a" impl="OOP-07_c" originalId="OOP-07_c" quickfix="false" scope="line" severity="1">
               <file path="OOP\OOP-07_c.rule"/>
            </rule>
         </category>
         <category description="HIC++ 12.1.1 不声明隐式用户定义的转换" name="12_1_1">
            <rule header="允许转换的构造函数应该是使用 explicit 修饰" id="a" impl="CODSTA-CPP-04" originalId="CODSTA-CPP-04" quickfix="false" scope="line" severity="1">
               <file path="CODSTA-CPP\CODSTA-CPP-04.rule"/>
            </rule>
            <rule header="自定义类型转换函数需要使用标识符标识" id="b" impl="CODSTA-MCPP-01" originalId="CODSTA-MCPP-01" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-01.rule"/>
            </rule>
         </category>
         <category description="HIC++ 12.2.1 声明虚拟、私有或受保护的类型的析构函数作为基类" name="12_2_1">
            <rule header="在基类中将析构函数设置为虚拟的" id="a" impl="OOP-24" originalId="OOP-24" quickfix="false" scope="line" severity="1">
               <file path="OOP\OOP-24.rule"/>
            </rule>
         </category>
         <category description="HIC++ 12.4.2 确保构造函数显式初始化所有基类和非静态数据成员" name="12_4_2">
            <rule header="所有成员变量都应该在构造函数中初始化" id="a" impl="INIT-06" originalId="INIT-06" quickfix="false" scope="line" severity="1">
               <file path="INIT\INIT-06.rule"/>
            </rule>
         </category>
         <category description="HIC++ 15.2.1 不要从析构函数中抛出异常" name="15_2_1">
            <rule header="不要从析构函数内抛出" id="a" impl="EXCEPT-03" originalId="EXCEPT-03" quickfix="false" scope="line" severity="1">
               <file path="EXCEPT\EXCEPT-03.rule"/>
            </rule>
         </category>
         <category description="HIC++ 5.1.2 不依赖于表达式中的求值序列" name="5_1_2">
            <rule header="不要编写依赖于函数参数求值顺序的代码" id="b" impl="MISRA2004-12_2_b" originalId="MISRA2004-12_2_b" quickfix="false" scope="line" severity="1">
               <file path="MISRA2004\MISRA2004-12_2_b.rule"/>
            </rule>
            <rule header="表达式的值应该在任何标准允许的赋值顺序下是一样的" id="a" impl="MISRA2004-12_2_a" originalId="MISRA2004-12_2_a" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-12_2_a.rule"/>
            </rule>
            <rule header="不要编写依赖于函数标志符和函数参数的求值顺序的代码" id="c" impl="MISRA2004-12_2_c" originalId="MISRA2004-12_2_c" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-12_2_c.rule"/>
            </rule>
            <rule header="涉及一个函数调用时，不要编写依赖表达式求值顺序的代码" id="d" impl="MISRA2004-12_2_d" originalId="MISRA2004-12_2_d" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-12_2_d.rule"/>
            </rule>
            <rule header="在序列点之间，对象的存储值最多只能通过表达式的评估来修改一次" id="e" impl="MISRA2004-12_2_e" originalId="MISRA2004-12_2_e" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-12_2_e.rule"/>
            </rule>
            <rule header="不要在两个相邻的序列点之间使用多个 volatile" id="f" impl="MISRA2004-12_2_f" originalId="MISRA2004-12_2_f" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-12_2_f.rule"/>
            </rule>
            <rule header="不要编写依赖于函数调用求值顺序的代码" id="g" impl="MISRA2004-12_2_g" originalId="MISRA2004-12_2_g" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-12_2_g.rule"/>
            </rule>
            <rule header="禁止在同一个表达式中混合使用递加符 (++) 和递减符 (--) 与其他运算符" id="h" impl="MISRA2004-12_13" originalId="MISRA2004-12_13" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-12_13.rule"/>
            </rule>
            <rule header="不应该使用逗号运算符" id="i" impl="MISRA2004-12_10" originalId="MISRA2004-12_10" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-12_10.rule"/>
            </rule>
            <rule header="不得使用一个内置赋值运算符的结果" id="j" impl="CODSTA-138" originalId="CODSTA-138" quickfix="false" scope="line" severity="3">
               <file path="CODSTA\CODSTA-138.rule"/>
            </rule>
         </category>
         <category description="HIC++ 11.1.1 声明所有数据成员为私有状态" name="11_1_1">
            <rule header="避免 &quot;public&quot; 数据成员" id="a" impl="OOP-18" originalId="OOP-18" quickfix="false" scope="line" severity="2">
               <file path="OOP\OOP-18.rule"/>
            </rule>
            <rule header="避免 'protected' 数据成员" id="b" impl="OOP-19" originalId="OOP-19" quickfix="false" scope="line" severity="2">
               <file path="OOP\OOP-19.rule"/>
            </rule>
         </category>
         <category description="HIC++ 16.1.2 在 #include 命令中提供的文件名中不包含路径说明符" name="16_1_2">
            <rule header="在 #include 语句中不允许绝对或相对路径名" id="a" impl="PREPROC-06" originalId="PREPROC-06" quickfix="false" scope="line" severity="2">
               <file path="PREPROC\PREPROC-06.rule"/>
            </rule>
            <rule header="字符 \ 不得出现在头文件的名称中" id="b" impl="NAMING-48" originalId="NAMING-48" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-48.rule"/>
            </rule>
         </category>
         <category description="HIC++ 5.4.3 不要将基类转换为派生类" name="5_4_3">
            <rule header="向下的强制转换(基类到衍生类的转换)是不允许的" id="a" impl="OOP-35" originalId="OOP-35" quickfix="false" scope="line" severity="2">
               <file path="OOP\OOP-35.rule"/>
            </rule>
         </category>
         <category description="HIC++ 10.1.1 确保访问基类子对象不需要显式消除歧义" name="10_1_1">
            <rule header="对于多重继承使用虚公共基类" id="a" impl="OOP-06" originalId="OOP-06" quickfix="false" scope="line" severity="3">
               <file path="OOP\OOP-06.rule"/>
            </rule>
         </category>
         <category description="HIC++ 10.2.1 当重写虚拟函数时，使用覆盖特殊标识符" name="10_2_1">
            <rule header="每个重载的虚函数都应使用 override 或 final 声明符声明。" id="a" impl="CODSTA-MCPP-05" originalId="CODSTA-MCPP-05" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-05.rule"/>
            </rule>
         </category>
         <category description="HIC++ 11.2.1 不要使用朋友声明" name="11_2_1">
            <rule header="避免使用友元(friend)机制" id="a" impl="OOP-11" originalId="OOP-11" quickfix="false" scope="line" severity="3">
               <file path="OOP\OOP-11.rule"/>
            </rule>
         </category>
         <category description="HIC++ 12.3.1 正确地为操作符 new 和 delete 声明重载" name="12_3_1">
            <rule header="如果写了 new 操作符应该对应写 delete 操作符" id="a" impl="MRM-26" originalId="MRM-26" quickfix="false" scope="line" severity="3">
               <file path="MRM\MRM-26.rule"/>
            </rule>
            <rule header="如果写了 new[] 操作符应该对应写 delete[] 操作符" id="b" impl="MRM-27" originalId="MRM-27" quickfix="false" scope="line" severity="3">
               <file path="MRM\MRM-27.rule"/>
            </rule>
         </category>
         <category description="HIC++ 12.4.3 在同一个非静态成员的构造函数中，不要同时指定 NSDMI 和成员初始化器" name="12_4_3">
            <rule header="有默认值的非静态成员不能在构造函数初始化列表中使用" id="a" impl="HICPP-12_4_3-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-12_4_3-a.rule"/>
            </rule>
         </category>
         <category description="HIC++ 12.4.4 在初始化列表中按照的顺序写入成员" name="12_4_4">
            <rule header="在初始化列表中按声明成员的顺序列出成员" id="a" impl="INIT-10" originalId="INIT-10" quickfix="false" scope="line" severity="3">
               <file path="INIT\INIT-10.rule"/>
            </rule>
         </category>
         <category description="HIC++ 12.4.5 使用委托构造函数来减少代码重复" name="12_4_5">
            <rule header="使用委托构造函数来减少代码重复" id="a" impl="CODSTA-CPP-106" originalId="CODSTA-CPP-106" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-106.rule"/>
            </rule>
         </category>
         <category description="HIC++ 12.5.1 明确定义 =default 或  =delete具体类的隐式特殊成员函数" name="12_5_1">
            <rule header="显式定义 =default or =delete 由编译器隐式提供的具体类的特殊成员函数" id="a" impl="HICPP-12_5_1-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-12_5_1-a.rule"/>
            </rule>
         </category>
         <category description="HIC++ 12.5.2 如果行为是等效的，定义特殊成员 =default" name="12_5_2">
            <rule header="当操作等同于编译器操作时，将特殊变量定义为 default" id="a" impl="CODSTA-CPP-105" originalId="CODSTA-CPP-105" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-105.rule"/>
            </rule>
         </category>
         <category description="HIC++ 12.5.3 确保用户定义的 move/copy 构造函数仅移动 /copie 基对象和成员对象" name="12_5_3">
            <rule header="拷贝构造函数应仅对其基类型及该类型的非静态成员进行初始化" id="a" impl="OOP-46" originalId="OOP-46" quickfix="false" scope="line" severity="3">
               <file path="OOP\OOP-46.rule"/>
            </rule>
         </category>
         <category description="HIC++ 12.5.4 除 move 构造函数和 move 赋值运算符外，声明不存在" name="12_5_4">
            <rule header="所有用户提供的移动构造函数和移动分配操作符都不应异常退出" id="a" impl="EXCEPT-21" originalId="EXCEPT-21" quickfix="false" scope="line" severity="3">
               <file path="EXCEPT\EXCEPT-21.rule"/>
            </rule>
         </category>
         <category description="HIC++ 12.5.6 使用原子的、非抛出的交换操作来实现复制和移动赋值操作符" name="12_5_6">
            <rule header="用户定义的复制和移动赋值运算符应使用用户定义的无抛出交换函数" id="a" impl="CODSTA-MCPP-49" originalId="CODSTA-MCPP-49" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-49.rule"/>
            </rule>
         </category>
         <category description="HIC++ 12.5.7 使用 ref 限定符 &amp;声明赋值运算符" name="12_5_7">
            <rule header="使用引用修饰符&amp;(ref-qualifier)来声明赋值运算符" id="a" impl="CODSTA-MCPP-19" originalId="CODSTA-MCPP-19" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-19.rule"/>
            </rule>
         </category>
         <category description="HIC++ 12.5.8 对受保护的抽象类进行复制赋值操作，或定义其 =delete" name="12_5_8">
            <rule header="在抽象类中拷贝赋值运算符应该被声明为 protected 或 private" id="a" impl="OOP-42" originalId="OOP-42" quickfix="false" scope="line" severity="3">
               <file path="OOP\OOP-42.rule"/>
            </rule>
         </category>
         <category description="HIC++ 13.1.1 确保从调用函数的地方可以看到函数的所有重载" name="13_1_1">
            <rule header="派生类里声明的成员函数不应该隐藏基类中声明的函数" id="a" impl="OOP-53" originalId="OOP-53" quickfix="false" scope="line" severity="3">
               <file path="OOP\OOP-53.rule"/>
            </rule>
         </category>
         <category description="HIC++ 13.1.2 如果一组可调用函数的成员包含一个通用引用参数，请确保其中一个出现在所有其他成员的相同位置" name="13_1_2">
            <rule header="避免在转发引用上使用重载" id="a" impl="CODSTA-MCPP-14" originalId="CODSTA-MCPP-14" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-14.rule"/>
            </rule>
         </category>
         <category description="HIC++ 13.2.1 不要重载具有特殊语义的运算符" name="13_2_1">
            <rule header="避免重载逻辑操作符AND, OR (&amp;&amp;, ||)" id="a" impl="CODSTA-CPP-08" originalId="CODSTA-CPP-08" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-08.rule"/>
            </rule>
            <rule header="避免重载逗号运算符 &quot;,&quot;" id="b" impl="CODSTA-CPP-80" originalId="CODSTA-CPP-80" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-80.rule"/>
            </rule>
         </category>
         <category description="HIC++ 13.2.2 确保重载二进制操作符的返回类型与内置对应的匹配" name="13_2_2">
            <rule header="关系运算符应返回布尔值" id="a" impl="CODSTA-CPP-101" originalId="CODSTA-CPP-101" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-101.rule"/>
            </rule>
            <rule header="二进制算术运算符和位运算符应返回一个 'prvalue'" id="b" impl="CODSTA-CPP-102" originalId="CODSTA-CPP-102" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-102.rule"/>
            </rule>
         </category>
         <category description="HIC++ 13.2.3 将二进制算术和位运算符声明为非成员" name="13_2_3">
            <rule header="将二进制算术和位运算符声明为非成员" id="a" impl="HICPP-13_2_3-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-13_2_3-a.rule"/>
            </rule>
         </category>
         <category description="HIC++ 13.2.4 当重载下标运算符( operator[] )时，实现 const 和非 const 版本" name="13_2_4">
            <rule header="重载 [] 运算符函数时，必须同时实现const和非const版本" id="a" impl="HICPP-13_2_4-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-13_2_4-a.rule"/>
            </rule>
         </category>
         <category description="HIC++ 13.2.5 实现最小操作符集，并使用它们实现所有其他相关操作符" name="13_2_5">
            <rule header="二进制过载操作符应该用其对应的复合赋值运算符实现" id="a" impl="CODSTA-CPP-91" originalId="CODSTA-CPP-91" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-91.rule"/>
            </rule>
         </category>
         <category description="HIC++ 14.1.1 使用可变参数模板，而不是省略号" name="14_1_1">
            <rule header="避免使用有可变数量参数的函数" id="a" impl="MISRA-069" originalId="MISRA-069" quickfix="false" scope="line" severity="3">
               <file path="MISRA\MISRA-069.rule"/>
            </rule>
         </category>
         <category description="HIC++ 14.2.1 将模板专门化声明在与其专门化的主模板相同的文件中。" name="14_2_1">
            <rule header="模板所有的部分和显式专门化都应在与其主模板声明相同的文件中声明" id="a" impl="TEMPL-10" originalId="TEMPL-10" quickfix="false" scope="line" severity="3">
               <file path="TEMPL\TEMPL-10.rule"/>
            </rule>
         </category>
         <category description="HIC++ 14.2.2 不要显式地专门化用其他模板重载的函数模板" name="14_2_2">
            <rule header="重载函数模板不应显式特化" id="a" impl="TEMPL-09" originalId="TEMPL-09" quickfix="false" scope="line" severity="3">
               <file path="TEMPL\TEMPL-09.rule"/>
            </rule>
         </category>
         <category description="HIC++ 14.2.3 声明外部显式实例化模板" name="14_2_3">
            <rule header="声明 'extern' 一个显式实例化的模板" id="a" impl="TEMPL-15" originalId="TEMPL-15" quickfix="false" scope="line" severity="3">
               <file path="TEMPL\TEMPL-15.rule"/>
            </rule>
         </category>
         <category description="HIC++ 15.1.1 仅对异常使用 std::exception 的实例" name="15_1_1">
            <rule header="只能使用 std::exception 异常" id="a" impl="HICPP-15_1_1-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-15_1_1-a.rule"/>
            </rule>
         </category>
         <category description="HIC++ 15.3.1 不要从构造函数/析构函数 try 块的 catch 处理程序访问非静态成员" name="15_3_1">
            <rule header="以 function-try-block 实现的类构造函数或析构函数的处理程序不应引用该类或其基类的非静态成员" id="a" impl="EXCEPT-16" originalId="EXCEPT-16" quickfix="false" scope="line" severity="3">
               <file path="EXCEPT\EXCEPT-16.rule"/>
            </rule>
         </category>
         <category description="HIC++ 15.3.2 确保程序不会导致调用 std::terminate" name="15_3_2">
            <rule header="至少应该有一个异常处理程序来捕获所有其他未处理的异常" id="b" impl="EXCEPT-06" originalId="EXCEPT-06" quickfix="false" scope="line" severity="3">
               <file path="EXCEPT\EXCEPT-06.rule"/>
            </rule>
         </category>
         <category description="HIC++ 16.1.1 只使用预处理器来实现包含保护，包括包含保护的头文件" name="16_1_1">
            <rule header="避免使用宏定义" id="a" impl="PREPROC-01" originalId="PREPROC-01" quickfix="false" scope="line" severity="3">
               <file path="PREPROC\PREPROC-01.rule"/>
            </rule>
            <rule header="#ifndef 程序预处理指示字仅用于防止相同头文件的多个 inclusion" id="b" impl="PREPROC-10" originalId="PREPROC-10" quickfix="false" scope="line" severity="3">
               <file path="PREPROC\PREPROC-10.rule"/>
            </rule>
            <rule header="不应使用 #ifdef, #else, #elif 程序预处理指示字" id="c" impl="PREPROC-11" originalId="PREPROC-11" quickfix="false" scope="line" severity="3">
               <file path="PREPROC\PREPROC-11.rule"/>
            </rule>
            <rule header="使用多个包含保护" id="d" impl="PFO-02" originalId="PFO-02" quickfix="false" scope="line" severity="3">
               <file path="PFO\PFO-02.rule"/>
            </rule>
            <rule header="#endif 程序预处理指示字将仅用于防止同一头文件多个包含" id="e" impl="PREPROC-10_b" originalId="PREPROC-10_b" quickfix="false" scope="line" severity="3">
               <file path="PREPROC\PREPROC-10_b.rule"/>
            </rule>
            <rule header="#if 程序预处理指示字仅用于防止相同头文件的多个 inclusion" id="f" impl="PREPROC-10_c" originalId="PREPROC-10_c" quickfix="false" scope="line" severity="3">
               <file path="PREPROC\PREPROC-10_c.rule"/>
            </rule>
            <rule header="不应使用 #error 指令" id="g" impl="PREPROC-22" originalId="PREPROC-22" quickfix="false" scope="line" severity="3">
               <file path="PREPROC\PREPROC-22.rule"/>
            </rule>
            <rule header="不应使用 #pragma 指令" id="h" impl="PREPROC-23" originalId="PREPROC-23" quickfix="false" scope="line" severity="3">
               <file path="PREPROC\PREPROC-23.rule"/>
            </rule>
            <rule header="不应使用 #undef" id="i" impl="PREPROC-25" originalId="PREPROC-25" quickfix="false" scope="line" severity="3">
               <file path="PREPROC\PREPROC-25.rule"/>
            </rule>
         </category>
         <category description="HIC++ 16.1.3 将 #include 指令中的文件名与文件系统上的匹配" name="16_1_3">
            <rule header="将 #include 指令中的文件名匹配到文件系统上的文件名" id="a" impl="PREPROC-20" originalId="PREPROC-20" quickfix="false" scope="line" severity="3">
               <file path="PREPROC\PREPROC-20.rule"/>
            </rule>
         </category>
         <category description="HIC++ 16.1.4 对系统和标准库头文件使用 &lt;&gt; 的方括号。对所有其他头文件使用引号" name="16_1_4">
            <rule header="对于系统和标准库头文件，使用&lt;&gt;方括号。对所有其他头文件使用引号" id="a" impl="HICPP-16_1_4-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-16_1_4-a.rule"/>
            </rule>
         </category>
         <category description="HIC++ 17.1.1 不要使用 std::vector&lt; bool&gt;" name="17_1_1">
            <rule header="避免使用 vector&lt;bool&gt;" id="a" impl="STL-14" originalId="STL-14" quickfix="false" scope="line" severity="3">
               <file path="STL\STL-14.rule"/>
            </rule>
         </category>
         <category description="HIC++ 17.2.1 包装使用 C 标准库" name="17_2_1">
            <rule header="不得使用错误指示符 'errno'" id="b" impl="MISRA2004-20_5" originalId="MISRA2004-20_5" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-20_5.rule"/>
            </rule>
            <rule header="包装使用的 C 标准库" id="a" impl="HICPP-17_2_1-a" quickfix="false" scope="line" severity="4">
               <file path="HICPP\HICPP-17_2_1-a.rule"/>
            </rule>
         </category>
         <category description="HIC++ 17.3.1 不要在 const 或 const &amp; 声明的对象上使用 std::move 移动" name="17_3_1">
            <rule header="不要在以 const 或 const＆type 声明的对象上使用 std :: move" id="a" impl="CODSTA-MCPP-53" originalId="CODSTA-MCPP-53" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-53.rule"/>
            </rule>
         </category>
         <category description="HIC++ 17.3.2 使用 std::forward 到  forward 的通用引用" name="17_3_2">
            <rule header="'std::forward' 函数应用来转发通用引用" id="a" impl="CODSTA-MCPP-13_b" originalId="CODSTA-MCPP-13_b" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-13_b.rule"/>
            </rule>
         </category>
         <category description="HIC++ 17.3.4 不要创建数组类型的智能指针" name="17_3_4">
            <rule header="不要创建数组类型的智能指针" id="a" impl="HICPP-17_3_4-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-17_3_4-a.rule"/>
            </rule>
         </category>
         <category description="HIC++ 17.3.5 不要创建 std::array 的 rvalue 引用" name="17_3_5">
            <rule header="不要创建 std::array 的右值引用" id="a" impl="CODSTA-MCPP-54" originalId="CODSTA-MCPP-54" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-54.rule"/>
            </rule>
         </category>
         <category description="HIC++ 17.4.1 当结果立即转换为 const 迭代器时，使用 const 容器调用" name="17_4_1">
            <rule header="将结果立即转换为常量迭代器时，请使用常量容器调用" id="a" impl="CODSTA-MCPP-51" originalId="CODSTA-MCPP-51" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-51.rule"/>
            </rule>
         </category>
         <category description="HIC++ 17.4.2 使用 API 在适当的位置调用构造对象" name="17_4_2">
            <rule header="建议使用 'std::make_shared' 而不是直接使用 new" id="a" impl="CODSTA-MCPP-16_c" originalId="CODSTA-MCPP-16_c" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-16_c.rule"/>
            </rule>
         </category>
         <category description="HIC++ 17.5.1 不要忽略 std::remove， std::remove if 或 std::unique 的结果" name="17_5_1">
            <rule header="通过擦除遵循类似删除的算法从容器中删除元素" id="a" impl="STL-23" originalId="STL-23" quickfix="false" scope="line" severity="3">
               <file path="STL\STL-23.rule"/>
            </rule>
         </category>
         <category description="HIC++ 18.1.1 不要使用特定平台的多线程工具" name="18_1_1">
            <rule header="不使用特定平台的多线程工具" id="a" impl="HICPP-18_1_1-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-18_1_1-a.rule"/>
            </rule>
         </category>
         <category description="HIC++ 18.2.1 使用高完整性 ::thread 替代 std::thread" name="18_2_1">
            <rule header="使用 high_integrity::thread 而不是 std::thread" id="a" impl="HICPP-18_2_1-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-18_2_1-a.rule"/>
            </rule>
         </category>
         <category description="HIC++ 18.2.3 不要在线程间共享易变数据" name="18_2_3">
            <rule header="不要在线程间共享不稳定的数据" id="a" impl="HICPP-18_2_3-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-18_2_3-a.rule"/>
            </rule>
         </category>
         <category description="HIC++ 18.2.4 使用 std::call_once 而不是双重检查锁定模式" name="18_2_4">
            <rule header="使用 std::call_once 而不是双重检查锁定模式" id="a" impl="CODSTA-MCPP-55" originalId="CODSTA-MCPP-55" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-55.rule"/>
            </rule>
         </category>
         <category description="HIC++ 18.3.3 不要使用 std::recursive 互斥锁" name="18_3_3">
            <rule header="不要使用std::recursive_mutex" id="a" impl="HICPP-18_3_3-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-18_3_3-a.rule"/>
            </rule>
         </category>
         <category description="HIC++ 18.3.4 当 std::lock 防卫无法使用时，只能使用 std::unique 的锁" name="18_3_4">
            <rule header="当 std::lock 守护不能使用时，只使用std::unique lock" id="a" impl="HICPP-18_3_4-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-18_3_4-a.rule"/>
            </rule>
         </category>
         <category description="HIC++ 18.3.5 不要直接访问 std::mutex 对象的成员" name="18_3_5">
            <rule header="不要直接访问std::mutex" id="a" impl="HICPP-18_3_5-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-18_3_5-a.rule"/>
            </rule>
         </category>
         <category description="HIC++ 18.3.6 不要使用轻松原子" name="18_3_6">
            <rule header="不要使用松弛原子" id="a" impl="HICPP-18_3_6-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-18_3_6-a.rule"/>
            </rule>
         </category>
         <category description="HIC++ 18.4.1 不要在 std::mutex 上使用 std::condition 变量" name="18_4_1">
            <rule header="不要对std::mutex使用 std::condition_variable_any" id="a" impl="HICPP-18_4_1-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-18_4_1-a.rule"/>
            </rule>
         </category>
         <category description="HIC++ 1.2.1 确保所有语句都是可访问的" name="1_2_1">
            <rule header="在 &quot;else&quot; 语句块中不应存在执行不到的代码" id="a" impl="MISRA2004-14_1_a" originalId="MISRA2004-14_1_a" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-14_1_a.rule"/>
            </rule>
            <rule header="在 'return', 'break', 'continue', 和 'goto' 语句之后不应存在执行不到的代码" id="b" impl="MISRA2004-14_1_b" originalId="MISRA2004-14_1_b" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-14_1_b.rule"/>
            </rule>
            <rule header="在 &quot;if/else/while/for&quot; 语句块中不应存在执行不到的代码" id="c" impl="MISRA2004-14_1_c" originalId="MISRA2004-14_1_c" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-14_1_c.rule"/>
            </rule>
            <rule header="在 switch 语句中不应存在执行不到的代码" id="d" impl="MISRA2004-14_1_d" originalId="MISRA2004-14_1_d" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-14_1_d.rule"/>
            </rule>
            <rule header="在 'for' 循环中不应存在执行不到的代码" id="e" impl="MISRA2004-14_1_e" originalId="MISRA2004-14_1_e" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-14_1_e.rule"/>
            </rule>
            <rule header="在 'if' 或 'switch' 语句后不应存在不可访问的代码" id="f" impl="MISRA2004-14_1_f" originalId="MISRA2004-14_1_f" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-14_1_f.rule"/>
            </rule>
            <rule header="在 while/for/do...while 循环内的 &quot;if&quot; 或 &quot;switch&quot; 语句后不应存在执行不到的代码" id="g" impl="MISRA2004-14_1_g" originalId="MISRA2004-14_1_g" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-14_1_g.rule"/>
            </rule>
         </category>
         <category description="HIC++ 1.2.2 确保没有表达式或子表达式是冗余的" name="1_2_2">
            <rule header="所有非 null 语句无论如何执行都至少有一个副作用，或者导致控制流发生变化" id="a" impl="MISRA2004-14_2" originalId="MISRA2004-14_2" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-14_2.rule"/>
            </rule>
         </category>
         <category description="HIC++ 1.3.1  对于布尔类型的变量，不要使用递增操作符(++)" name="1_3_1">
            <rule header="不要在 'bool' 类型的操作数上使用递增操作符（++）" id="a" impl="CODSTA-MCPP-42" originalId="CODSTA-MCPP-42" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-42.rule"/>
            </rule>
         </category>
         <category description="HIC++ 1.3.3 不要使用 C 标准库 .h 标题" name="1_3_3">
            <rule header="不能使用C语言库" id="a" impl="CODSTA-CPP-59" originalId="CODSTA-CPP-59" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-59.rule"/>
            </rule>
         </category>
         <category description="HIC++ 1.3.4 不使用已弃用的 STL 库特性" name="1_3_4">
            <rule header="不要使用已弃用的STL库功能" id="a" impl="HICPP-1_3_4-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-1_3_4-a.rule"/>
            </rule>
         </category>
         <category description="HIC++ 1.3.5 不使用抛出异常规范" name="1_3_5">
            <rule header="不使用throw异常规范" id="a" impl="EXCEPT-23" originalId="EXCEPT-23" quickfix="false" scope="line" severity="3">
               <file path="EXCEPT\EXCEPT-23.rule"/>
            </rule>
         </category>
         <category description="HIC++ 2.2.1 不要使用有向图或三向图" name="2_2_1">
            <rule header="请勿使用以下双字符组：&lt;%, %&gt;, &lt;:, :&gt;, %:, %:%:" id="a" impl="CODSTA-48" originalId="CODSTA-48" quickfix="false" scope="line" severity="3">
               <file path="CODSTA\CODSTA-48.rule"/>
            </rule>
            <rule header="禁止使用三联符" id="b" impl="MISRA2004-4_2" originalId="MISRA2004-4_2" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-4_2.rule"/>
            </rule>
         </category>
         <category description="HIC++ 2.3.1 不要使用C注释分隔符 /* ... */" name="2_3_1">
            <rule header="推荐使用 C++ 风格的注释" id="a" impl="COMMENT-01" originalId="COMMENT-01" quickfix="false" scope="line" severity="3">
               <file path="COMMENT\COMMENT-01.rule"/>
            </rule>
         </category>
         <category description="HIC++ 2.4.1 确保每个标识符不同于任何其他可见标识符" name="2_4_1">
            <rule header="不同的标识符应该是书写明确的" id="a" impl="NAMING-47" originalId="NAMING-47" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-47.rule"/>
            </rule>
         </category>
         <category description="HIC++ 2.5.1 不连接具有不同编码前缀的字符串" name="2_5_1">
            <rule header="不应连接具有不同编码前缀的字符串文字" id="a" impl="PB-38_b" originalId="PB-38_b" quickfix="false" scope="line" severity="3">
               <file path="PB\PB-38_b.rule"/>
            </rule>
         </category>
         <category description="HIC++ 2.5.2 不要使用八进制常量 （除了 0）" name="2_5_2">
            <rule header="不应该使用八进制常数（除零外）" id="a" impl="MISRA2004-7_1_a" originalId="MISRA2004-7_1_a" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-7_1_a.rule"/>
            </rule>
         </category>
         <category description="HIC++ 3.1.1 不要隐藏声明" name="3_1_1">
            <rule header="在局部或者函数原型体范围内声明的标识符不应该隐藏一个在全局或者命名空间范围内声明的标识符" id="a" impl="MISRA2004-5_2_a" originalId="MISRA2004-5_2_a" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-5_2_a.rule"/>
            </rule>
            <rule header="在内层的局部范围内声明的标识符不应该隐藏在外层的局部范围内声明的标识符" id="b" impl="MISRA2004-5_2_b" originalId="MISRA2004-5_2_b" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-5_2_b.rule"/>
            </rule>
            <rule header="在一个局部范围内声明的标识符不应该隐藏在一个类作用域中声明的标识符" id="c" impl="CODSTA-CPP-83" originalId="CODSTA-CPP-83" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-83.rule"/>
            </rule>
            <rule header="在类的作用域中声明的标识符不应该隐藏在全局或命名空间范围内声明的标识符" id="d" impl="CODSTA-CPP-84" originalId="CODSTA-CPP-84" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-84.rule"/>
            </rule>
            <rule header="在一个内部类作用域中声明的标识符不应该隐藏在外部类作用域中声明的标识符" id="e" impl="CODSTA-CPP-85" originalId="CODSTA-CPP-85" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-85.rule"/>
            </rule>
         </category>
         <category description="HIC++ 3.2.1 不要在块范围内声明函数" name="3_2_1">
            <rule header="始终在文件的范围内声明函数" id="a" impl="MISRA2004-8_6" originalId="MISRA2004-8_6" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-8_6.rule"/>
            </rule>
         </category>
         <category description="HIC++ 3.3.1 不要使用静态存储时间的变量" name="3_3_1">
            <rule header="不要使用具有静态存储期的函数" id="a" impl="HICPP-3_3_1-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-3_3_1-a.rule"/>
            </rule>
         </category>
         <category description="HIC++ 3.4.1 不得将引用或指针返回到函数中定义的自动变量" name="3_4_1">
            <rule header="不得从函数中返回具有自动存储的对象的地址" id="a" impl="MISRA2004-17_6_a" originalId="MISRA2004-17_6_a" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-17_6_a.rule"/>
            </rule>
         </category>
         <category description="HIC++ 3.4.2 不要将变量的地址分配给寿命更长的指针" name="3_4_2">
            <rule header="自动存储对象的地址不应分配给在第一个对象不再存在后可能持久存在的另一个对象" id="a" impl="MISRA2004-17_6_b" originalId="MISRA2004-17_6_b" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-17_6_b.rule"/>
            </rule>
         </category>
         <category description="HIC++ 3.5.1 不得对值或对象的内部做任何假设" name="3_5_1">
            <rule header="禁止使用联合体" id="a" impl="MISRA2004-18_4" originalId="MISRA2004-18_4" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-18_4.rule"/>
            </rule>
            <rule header="typedef 应该用于替代基本类型" id="b" impl="MISRA2004-6_3_b" originalId="MISRA2004-6_3_b" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-6_3_b.rule"/>
            </rule>
         </category>
         <category description="HIC++ 4.1.1 确保函数参数不进行 array-to-pointer 转换" name="4_1_1">
            <rule header="作为函数实参传递的数组类型标识符不得退化为一个指针" id="a" impl="PB-41" originalId="PB-41" quickfix="false" scope="line" severity="3">
               <file path="PB\PB-41.rule"/>
            </rule>
            <rule header="不要将具有数组类型的表达式传递给一个具有指针或者数组类型参数的函数" id="b" impl="PB-41_b" originalId="PB-41_b" quickfix="false" scope="line" severity="3">
               <file path="PB\PB-41_b.rule"/>
            </rule>
         </category>
         <category description="HIC++ 4.2.1 确保将 U 后缀应用于需要无符号整型表达式的上下文中使用的文字" name="4_2_1">
            <rule header="将U后缀应用到需要无符号整型表达式的上下文中" id="a" impl="HICPP-4_2_1-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-4_2_1-a.rule"/>
            </rule>
         </category>
         <category description="HIC++ 4.2.2 确保在整数表达式中不会出现数据丢失" name="4_2_2">
            <rule header="一个移位操作符的右操作数应该位于 0 与左操作数底层类型的位宽减 1之间" id="a" impl="MISRA2004-12_8" originalId="MISRA2004-12_8" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-12_8.rule"/>
            </rule>
            <rule header="避免使用显式类型转换(强制类型转换)" id="b" impl="CODSTA-31" originalId="CODSTA-31" quickfix="false" scope="line" severity="3">
               <file path="CODSTA\CODSTA-31.rule"/>
            </rule>
            <rule header="'+'， '-'， '*' 运算符常量表达式中的整数溢出或下溢" id="c" impl="PB-66_a" originalId="PB-66_a" quickfix="false" scope="line" severity="3">
               <file path="PB\PB-66_a.rule"/>
            </rule>
            <rule header="'&lt;&lt;' 运算符常量表达式中的整数溢出或下溢" id="d" impl="PB-66_b" originalId="PB-66_b" quickfix="false" scope="line" severity="4">
               <file path="PB\PB-66_b.rule"/>
            </rule>
         </category>
         <category description="HIC++ 4.3.1 不要将更宽的浮点类型的表达式转换为更窄的浮点类型" name="4_3_1">
            <rule header="避免宽字段到窄字段浮点型数据的隐式转换" id="a" impl="MISRA2004-10_2_b" originalId="MISRA2004-10_2_b" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-10_2_b.rule"/>
            </rule>
            <rule header="避免将浮点数从较宽的浮点类型隐式转换为较窄的浮点类型" id="b" impl="MISRA2004-10_2_d" originalId="MISRA2004-10_2_d" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-10_2_d.rule"/>
            </rule>
         </category>
         <category description="HIC++ 4.4.1 除非使用标准库函数，否则不要将浮动值转换为整数类型" name="4_4_1">
            <rule header="避免从浮点类型到整型的隐式转换" id="a" impl="MISRA2004-10_2_a" originalId="MISRA2004-10_2_a" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-10_2_a.rule"/>
            </rule>
         </category>
         <category description="HIC++ 5.1.1 在代码中使用符号名而不是文字值" name="5_1_1">
            <rule header="避免使用魔数" id="a" impl="CODSTA-26" originalId="CODSTA-26" quickfix="false" scope="line" severity="3">
               <file path="CODSTA\CODSTA-26.rule"/>
            </rule>
         </category>
         <category description="HIC++ 5.1.3 在表达式中使用括号来指定表达式的意图" name="5_1_3">
            <rule header="除非表达式中的所有运算符都相同，否则使用圆括号" id="a" impl="MISRA2004-12_1_e" originalId="MISRA2004-12_1_e" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-12_1_e.rule"/>
            </rule>
            <rule header="逻辑运算符 &amp;&amp; 或者 || 的操作数应该是基本表达式" id="b" impl="MISRA2004-12_5" originalId="MISRA2004-12_5" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-12_5.rule"/>
            </rule>
         </category>
         <category description="HIC++ 5.1.4 不要在 lambda 中隐式捕获变量" name="5_1_4">
            <rule header="不要在lambda中隐式地捕获变量" id="a" impl="HICPP-5_1_4-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-5_1_4-a.rule"/>
            </rule>
         </category>
         <category description="HIC++ 5.1.5 在每个 lambda 表达式中包含（可能为空）参数列表" name="5_1_5">
            <rule header="在每个 lambda 表达式中包含一个参数列表" id="a" impl="CODSTA-MCPP-46" originalId="CODSTA-MCPP-46" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-46.rule"/>
            </rule>
         </category>
         <category description="HIC++ 5.1.6 不要将副作用编码到右边的操作数中： &amp;&amp;， ||， sizeof， typeid， 或传递给条件变量的函数 ::wait" name="5_1_6">
            <rule header="sizeof 运算符的操作数不应包含任何有副作用的表达式" id="a" impl="MISRA2004-12_3" originalId="MISRA2004-12_3" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-12_3.rule"/>
            </rule>
            <rule header="不应在sizeof运算符的操作数中访问由volatile左值指定的对象" id="b" impl="MISRA2004-12_3_b" originalId="MISRA2004-12_3_b" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-12_3_b.rule"/>
            </rule>
            <rule header="会导致副作用的函数调用不应该用作 sizeof 运算符的操作数" id="c" impl="MISRA2004-12_3_c" originalId="MISRA2004-12_3_c" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-12_3_c.rule"/>
            </rule>
            <rule header="逻辑&amp;&amp;或||运算符的右操作数不得含有副作用" id="d" impl="MISRA2004-12_4_a" originalId="MISRA2004-12_4_a" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-12_4_a.rule"/>
            </rule>
            <rule header="typeid 操作符的操作数不能包含任何有副作用的表达式" id="e" impl="CODSTA-CPP-104" originalId="CODSTA-CPP-104" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-104.rule"/>
            </rule>
            <rule header="'typeid' 操作符的操作数不应包含导致副作用的函数调用" id="f" impl="CODSTA-CPP-104_b" originalId="CODSTA-CPP-104_b" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-104_b.rule"/>
            </rule>
         </category>
         <category description="HIC++ 5.2.2 确保函数本身不直接或间接调用" name="5_2_2">
            <rule header="函数不应该直接或者间接地调用自己" id="a" impl="MISRA2004-16_2" originalId="MISRA2004-16_2" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-16_2.rule"/>
            </rule>
         </category>
         <category description="HIC++ 5.3.1 不对无符号类型的操作数应用一元减号" name="5_3_1">
            <rule header="一元减法运算符不得适用于其原始类型是无符号型的表达式" id="a" impl="MISRA2004-12_9" originalId="MISRA2004-12_9" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-12_9.rule"/>
            </rule>
         </category>
         <category description="HIC++ 5.3.2 使用 new 分配内存，使用 delete 释放内存" name="5_3_2">
            <rule header="不要使用 calloc, malloc, realloc 和 free 函数" id="a" impl="MRM-46" originalId="MRM-46" quickfix="false" scope="line" severity="3">
               <file path="MRM\MRM-46.rule"/>
            </rule>
         </category>
         <category description="HIC++ 5.3.3 确保 delete 格式与 new 格式匹配，new 用于分配内存" name="5_3_3">
            <rule header="释放非数组内存时 delete 不能使用括号([])" id="a" impl="MRM-35" originalId="MRM-35" quickfix="false" scope="line" severity="3">
               <file path="MRM\MRM-35.rule"/>
            </rule>
            <rule header="释放数组内存时 delete 必须使用空括号([])" id="b" impl="MRM-36" originalId="MRM-36" quickfix="false" scope="line" severity="3">
               <file path="MRM\MRM-36.rule"/>
            </rule>
         </category>
         <category description="HIC++ 5.4.1 仅使用转换表单: static cast (excl. void*)， dynamic cast 或explicit constructor call" name="5_4_1">
            <rule header="不应使用 C 风格强制转换" id="a" impl="CODSTA-CPP-11" originalId="CODSTA-CPP-11" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-11.rule"/>
            </rule>
            <rule header="避免使用强制类型转换符 reinterpret_cast" id="b" impl="CODSTA-CPP-09" originalId="CODSTA-CPP-09" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-09.rule"/>
            </rule>
            <rule header="强制转换不得从指针或引用类型中删除任何“const”或“volatile”限定条件" id="c" impl="MISRA2004-11_5" originalId="MISRA2004-11_5" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-11_5.rule"/>
            </rule>
         </category>
         <category description="HIC++ 5.4.2 不要将表达式转换为枚举类型" name="5_4_2">
            <rule header="不要将表达式转换为枚举类型" id="a" impl="HICPP-5_4_2-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-5_4_2-a.rule"/>
            </rule>
         </category>
         <category description="HIC++ 5.6.1 不要使用带符号操作数的位操作符" name="5_6_1">
            <rule header="位运算符应只适用于无符号的基本类型操作数" id="a" impl="CODSTA-63" originalId="CODSTA-63" quickfix="false" scope="line" severity="3">
               <file path="CODSTA\CODSTA-63.rule"/>
            </rule>
         </category>
         <category description="HIC++ 5.7.1 不要期望编写浮点运算产生精确结果的代码" name="5_7_1">
            <rule header="禁止对浮点数类型的表达式做相等或不相等的比较" id="a" impl="MISRA2004-13_3" originalId="MISRA2004-13_3" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-13_3.rule"/>
            </rule>
         </category>
         <category description="HIC++ 5.7.2 确保指向虚拟函数成员的指针仅与 nullptr 进行比较(==)" name="5_7_2">
            <rule header="指向成员虚拟函数的指针只应该被测试是否与空指针常量相等" id="a" impl="CODSTA-MCPP-26" originalId="CODSTA-MCPP-26" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-26.rule"/>
            </rule>
         </category>
         <category description="HIC++ 5.8.1 不使用条件运算符 (?:)作为子表达式" name="5_8_1">
            <rule header="条件运算符不应用作子表达式" id="a" impl="CODSTA-224" originalId="CODSTA-224" quickfix="false" scope="line" severity="3">
               <file path="CODSTA\CODSTA-224.rule"/>
            </rule>
         </category>
         <category description="HIC++ 6.1.1 在复合语句中包含选择语句或迭代语句的主体" name="6_1_1">
            <rule header="'switch', 'while', 'do...while' 或 'for' 语句的主体应该是复合语句" id="a" impl="MISRA2004-14_8" originalId="MISRA2004-14_8" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-14_8.rule"/>
            </rule>
            <rule header="'if' 和 'else' 语句后应跟一个复合句" id="b" impl="MISRA2004-14_9" originalId="MISRA2004-14_9" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-14_9.rule"/>
            </rule>
         </category>
         <category description="HIC++ 6.1.2 通过多路选择语句明确覆盖所有路径" name="6_1_2">
            <rule header="所有 'if...else-if' 结构应使用一个 'else' 子句终止" id="a" impl="MISRA2004-14_10" originalId="MISRA2004-14_10" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-14_10.rule"/>
            </rule>
            <rule header="switch 语句中最后一个子句必须为 default 子句" id="b" impl="MISRA2004-15_3" originalId="MISRA2004-15_3" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-15_3.rule"/>
            </rule>
         </category>
         <category description="HIC++ 6.1.3 确保非 null 的 case 语句块不会进入下一个标签" name="6_1_3">
            <rule header="非条件 throw 或 break 语句应终止每个非空的 switch 语句" id="a" impl="CODSTA-64" originalId="CODSTA-64" quickfix="false" scope="line" severity="3">
               <file path="CODSTA\CODSTA-64.rule"/>
            </rule>
         </category>
         <category description="HIC++ 6.1.4 确保 switch 语句至少有两个 case 标签，区别于默认标签" name="6_1_4">
            <rule header="每个 switch 语句至少有两个 case 分支和一个潜在的 default 分支" id="a" impl="CODSTA-54" originalId="CODSTA-54" quickfix="false" scope="line" severity="3">
               <file path="CODSTA\CODSTA-54.rule"/>
            </rule>
            <rule header="switch 表达式不应该出现一个实际为布尔的值" id="b" impl="MISRA2004-15_4" originalId="MISRA2004-15_4" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-15_4.rule"/>
            </rule>
         </category>
         <category description="HIC++ 6.2.1 实现一个循环，该循环只使用元素值作为基于范围的循环" name="6_2_1">
            <rule header="不应使用循环遍历容器中的所有元素而不使用循环计数器的 for 循环" id="a" impl="CODSTA-MCPP-50" originalId="CODSTA-MCPP-50" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-50.rule"/>
            </rule>
         </category>
         <category description="HIC++ 6.2.2 确保一个循环有一个循环计数器，一个可选的控制变量，并且不简并" name="6_2_2">
            <rule header="'for' 循环中只能有一个循环计数器，而不能在 'for' 循环体中进行修改" id="a" impl="CODSTA-168" originalId="CODSTA-168" quickfix="false" scope="line" severity="3">
               <file path="CODSTA\CODSTA-168.rule"/>
            </rule>
         </category>
         <category description="HIC++ 6.2.3 循环中不超过一次的修改控制或计数器变量" name="6_2_3">
            <rule header="禁止在循环体中修改循环计数器" id="a" impl="MISRA2004-13_6" originalId="MISRA2004-13_6" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-13_6.rule"/>
            </rule>
         </category>
         <category description="HIC++ 6.2.4 仅在 for 表达式中修改 for 循环计数器" name="6_2_4">
            <rule header="for 循环的第三部分应该是格式良好的" id="a" impl="CODSTA-169_c" originalId="CODSTA-169_c" quickfix="false" scope="line" severity="3">
               <file path="CODSTA\CODSTA-169_c.rule"/>
            </rule>
         </category>
         <category description="HIC++ 6.3.1 确保跳转语句或切换条件的标签稍后出现在相同或封闭的块中" name="6_3_1">
            <rule header="只有当最紧密包围的复合语句是 switch 语句的主体时才能使用 switch 标签" id="a" impl="MISRA2004-15_1" originalId="MISRA2004-15_1" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-15_1.rule"/>
            </rule>
            <rule header="goto 语句应该跳转到同一个函数体中位于 goto 语句后面声明的标签" id="b" impl="CODSTA-77" originalId="CODSTA-77" quickfix="false" scope="line" severity="3">
               <file path="CODSTA\CODSTA-77.rule"/>
            </rule>
            <rule header="任何由 goto 语句引用的标签应该声明在同一个模块中，或者在一个包含 goto 语句的模块中" id="c" impl="CODSTA-78" originalId="CODSTA-78" quickfix="false" scope="line" severity="3">
               <file path="CODSTA\CODSTA-78.rule"/>
            </rule>
         </category>
         <category description="HIC++ 6.3.2 确保非空返回类型函数的执行以带有返回值的返回语句结束" name="6_3_2">
            <rule header="具有非 void 返回类型的函数的所有退出路径，除 main() 外，都应具有带有表达式的显式返回语句" id="a" impl="MISRA2004-16_8_b" originalId="MISRA2004-16_8_b" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-16_8_b.rule"/>
            </rule>
         </category>
         <category description="HIC++ 6.4.1 尽可能推迟变量定义" name="6_4_1">
            <rule header="尽可能地声明局部变量" id="a" impl="OPT-01" originalId="OPT-01" quickfix="false" scope="line" severity="3">
               <file path="OPT\OPT-01.rule"/>
            </rule>
            <rule header="尽可能推迟变量定义" id="b" impl="OPT-20" originalId="OPT-20" quickfix="false" scope="line" severity="3">
               <file path="OPT\OPT-20.rule"/>
            </rule>
         </category>
         <category description="HIC++ 7.1.1 在单独的声明中在单独一行上声明每个标识符" name="7_1_1">
            <rule header="不允许在同一行声明多个变量" id="a" impl="FORMAT-29" originalId="FORMAT-29" quickfix="false" scope="line" severity="3">
               <file path="FORMAT\FORMAT-29.rule"/>
            </rule>
            <rule header="每个变量都要在单独的声明语句中被声明" id="b" impl="FORMAT-33" originalId="FORMAT-33" quickfix="false" scope="line" severity="3">
               <file path="FORMAT\FORMAT-33.rule"/>
            </rule>
         </category>
         <category description="HIC++ 7.1.10 对包含编译时常量的断言使用静态断言" name="7_1_10">
            <rule header="对于涉及编译时常量的断言使用static_assert" id="a" impl="HICPP-7_1_10-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-7_1_10-a.rule"/>
            </rule>
         </category>
         <category description="HIC++ 7.1.2 尽可能使用const" name="7_1_2">
            <rule header="尽可能将局部变量声明为 const" id="a" impl="CODSTA-CPP-53" originalId="CODSTA-CPP-53" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-53.rule"/>
            </rule>
            <rule header="尽可能将参数声明为 const" id="b" impl="CODSTA-CPP-53_b" originalId="CODSTA-CPP-53_b" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-53_b.rule"/>
            </rule>
         </category>
         <category description="HIC++ 7.1.3 在声明中，不要在非类型说明符前放置类型说明符" name="7_1_3">
            <rule header="在声明中不要将类型说明符放在非类型说明符之前" id="a" impl="HICPP-7_1_3-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-7_1_3-a.rule"/>
            </rule>
         </category>
         <category description="HIC++ 7.1.4 将 CV-qualifiers 放置在类型的右侧" name="7_1_4">
            <rule header="将CV限定词放在其适用类型的右侧" id="a" impl="FORMAT-47_a" originalId="FORMAT-47_a" quickfix="false" scope="line" severity="3">
               <file path="FORMAT\FORMAT-47_a.rule"/>
            </rule>
         </category>
         <category description="HIC++ 7.1.5 不要内联大型函数" name="7_1_5">
            <rule header="不要内联大型函数" id="a" impl="HICPP-7_1_5-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-7_1_5-a.rule"/>
            </rule>
         </category>
         <category description="HIC++ 7.1.6 使用 class 类型或 typedef 来抽象标量和标准整数类型" name="7_1_6">
            <rule header="普通字符(plain char)类型只能用于存储和使用字符值" id="a" impl="MISRA2004-6_1" originalId="MISRA2004-6_1" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-6_1.rule"/>
            </rule>
            <rule header="使用类类型或typedef来定义标量或标准整数类型" id="b" impl="HICPP-7_1_6-b" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-7_1_6-b.rule"/>
            </rule>
            <rule header="使用class类型或typedef来抽象基础类型" id="c" impl="HICPP-7_1_6-c" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-7_1_6-c.rule"/>
            </rule>
         </category>
         <category description="HIC++ 7.1.7 优先使用尾部返回类型来使用 typename 类型消除歧义" name="7_1_7">
            <rule header="如果返回类型前面带有 'typename' 关键字，使用尾随返回类型语法" id="a" impl="TEMPL-17" originalId="TEMPL-17" quickfix="false" scope="line" severity="3">
               <file path="TEMPL\TEMPL-17.rule"/>
            </rule>
         </category>
         <category description="HIC++ 7.1.8 在声明变量时使用 auto id = expr，使其具有与初始化器函数调用相同的类型" name="7_1_8">
            <rule header="使用 auto 关键字声明通过函数调用初始化的变量" id="a" impl="HICPP-7_1_8-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-7_1_8-a.rule"/>
            </rule>
         </category>
         <category description="HIC++ 7.1.9 不明确指定 lambda 的返回类型" name="7_1_9">
            <rule header="没有显式地指定lambda的返回类型" id="a" impl="HICPP-7_1_9-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-7_1_9-a.rule"/>
            </rule>
         </category>
         <category description="HIC++ 7.2.1 使用显式枚举库并确保它足够大，可以存储所有枚举器" name="7_2_1">
            <rule header="使用明确的枚举基础并确保它足够大以存储所有枚举器" id="a" impl="HICPP-7_2_1-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-7_2_1-a.rule"/>
            </rule>
         </category>
         <category description="HIC++ 7.2.2在枚举中初始化 none、第一个或所有的计数器" name="7_2_2">
            <rule header="初始化枚举中的所有枚举数时，只初始化第一个枚举数，或不初始化枚举数" id="a" impl="HICPP-7_2_2-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-7_2_2-a.rule"/>
            </rule>
         </category>
         <category description="HIC++ 7.3.1 不要使用指令" name="7_3_1">
            <rule header="不得使用 using 指示符" id="a" impl="CODSTA-CPP-75" originalId="CODSTA-CPP-75" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-75.rule"/>
            </rule>
         </category>
         <category description="HIC++ 7.4.1 确保在主源文件中未命名的命名空间中定义来自单个转换单元的任何对象、函数或类型" name="7_4_1">
            <rule header="不要使用 static 关键字，除非在函数或者类中" id="a" impl="CODSTA-CPP-50" originalId="CODSTA-CPP-50" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-50.rule"/>
            </rule>
         </category>
         <category description="HIC++ 7.5.1 不要使用 asm 进行声明" name="7_5_1">
            <rule header="不要使用asm声明" id="a" impl="HICPP-7_5_1-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-7_5_1-a.rule"/>
            </rule>
         </category>
         <category description="HIC++ 8.1.1 不要使用多层次的指针指向" name="8_1_1">
            <rule header="声明不得包含超过一级的间接指针" id="a" impl="CODSTA-89" originalId="CODSTA-89" quickfix="false" scope="line" severity="3">
               <file path="CODSTA\CODSTA-89.rule"/>
            </rule>
         </category>
         <category description="HIC++ 8.2.1 在所有声明中使参数名不存在或完全相同" name="8_2_1">
            <rule header="禁止函数声明中使用的标识符与实际定义中的标识符不一致" id="a" impl="MISRA2004-16_4" originalId="MISRA2004-16_4" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-16_4.rule"/>
            </rule>
         </category>
         <category description="HIC++ 8.2.2 不要声明参数过多的函数" name="8_2_2">
            <rule header="避免函数的参数数目超过5个" id="a" impl="METRICS-15" originalId="METRICS-15" quickfix="false" scope="line" severity="3">
               <file path="METRICS\METRICS-15.rule"/>
            </rule>
         </category>
         <category description="HIC++ 8.2.3 通过值传递带有简单复制构造函数的小对象" name="8_2_3">
            <rule header="通过值传递具有平凡复制构造函数的小对象" id="a" impl="CODSTA-CPP-108_b" originalId="CODSTA-CPP-108_b" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-108_b.rule"/>
            </rule>
         </category>
         <category description="HIC++ 8.2.4 通过对 const 的引用，进而不通过 std::unique ptr " name="8_2_4">
            <rule header="不要传递 const 引用类型的 std::unique_ptr 对象" id="a" impl="HICPP-8_2_4-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-8_2_4-a.rule"/>
            </rule>
         </category>
         <category description="HIC++ 8.3.1 不要编写复杂程度过高的 McCabe 圈复杂度的函数" name="8_3_1">
            <rule header="将圈复杂度限制在 10 之内" id="a" impl="METRICS-18" originalId="METRICS-18" quickfix="false" scope="line" severity="3">
               <file path="METRICS\METRICS-18.rule"/>
            </rule>
         </category>
         <category description="HIC++ 8.3.3 不要使用默认参数" name="8_3_3">
            <rule header="不要使用缺省参数" id="a" impl="HICPP-8_3_3-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-8_3_3-a.rule"/>
            </rule>
         </category>
         <category description="HIC++ 8.3.4 引用 const 定义参数类型为 rvalu e的 =delete 函数" name="8_3_4">
            <rule header="将有 const 参数的 rvalue 引用函数定义为 =delete" id="a" impl="HICPP-8_3_4-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-8_3_4-a.rule"/>
            </rule>
         </category>
         <category description="HIC++ 8.4.1 不要访问无效对象或不确定值的对象" name="8_4_1">
            <rule header="所有自动变量在使用之前都必须被赋值" id="c" impl="MISRA-030" originalId="MISRA-030" quickfix="false" scope="line" severity="3">
               <file path="MISRA\MISRA-030.rule"/>
            </rule>
         </category>
         <category description="HIC++ 8.4.2 确保已加固的聚合初始化程序与聚合对象的布局匹配" name="8_4_2">
            <rule header="集合或联合的初始化程序应放在大括号中" id="a" impl="INIT-16" originalId="INIT-16" quickfix="false" scope="line" severity="3">
               <file path="INIT\INIT-16.rule"/>
            </rule>
         </category>
         <category description="HIC++ 9.1.1 声明任何不需要此功能的静态成员函数。或者，声明不修改对象的外部可见状态的任何 const 成员函数" name="9_1_1">
            <rule header="如果一个成员函数可以是 static，那么就应该定义为 static，否则，如果它可以是 const，那么它就应该被定义为 const" id="a" impl="CODSTA-CPP-78" originalId="CODSTA-CPP-78" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-78.rule"/>
            </rule>
         </category>
         <category description="HIC++ 9.1.2 在覆盖虚拟函数时，使默认参数保持相同或不存在" name="9_1_2">
            <rule header="禁止使用不同的默认参数值来重定义继承的虚拟函数" id="a" impl="OOP-13" originalId="OOP-13" quickfix="false" scope="line" severity="3">
               <file path="OOP\OOP-13.rule"/>
            </rule>
         </category>
         <category description="HIC++ 9.1.3 不要从 const 成员函数返回非 const 句柄到类数据中" name="9_1_3">
            <rule header="Const 成员函数不得返回指向类数据的非 const 指针或引用" id="a" impl="CODSTA-CPP-77" originalId="CODSTA-CPP-77" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-77.rule"/>
            </rule>
         </category>
         <category description="HIC++ 9.1.4 不要编写将非 const 句柄返回到比成员函数更难访问的数据的成员函数" name="9_1_4">
            <rule header="公共成员函数不应该返回指向私有的/受保护的类数据的非常量句柄" id="a" impl="OOP-36" originalId="OOP-36" quickfix="false" scope="line" severity="3">
               <file path="OOP\OOP-36.rule"/>
            </rule>
         </category>
         <category description="HIC++ 9.1.5 在最终类中不引入虚拟函数" name="9_1_5">
            <rule header="不要在 final 类中引入 virtual 函数" id="a" impl="CODSTA-MCPP-52" originalId="CODSTA-MCPP-52" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-52.rule"/>
            </rule>
         </category>
         <category description="HIC++ 9.2.1 使用显式无符号整数或枚举类型声明位字段" name="9_2_1">
            <rule header="位域只应该有显式的无符号整数或者枚举类型" id="a" impl="CODSTA-96" originalId="CODSTA-96" quickfix="false" scope="line" severity="3">
               <file path="CODSTA\CODSTA-96.rule"/>
            </rule>
         </category>
         <category description="HIC++ 2.3.2 不要注释掉代码" name="2_3_2">
            <rule header="不要使用注释来删除部分代码" id="a" impl="HICPP-2_3_2-a" quickfix="false" scope="line" severity="4">
               <file path="HICPP\HICPP-2_3_2-a.rule"/>
            </rule>
         </category>
         <category description="HIC++ 2.5.3 对空指针常量使用 nullptr" name="2_5_3">
            <rule header="使用 nullptr 代替 null 和 0" id="a" impl="CODSTA-MCPP-04" originalId="CODSTA-MCPP-04" quickfix="false" scope="line" severity="4">
               <file path="CODSTA-MCPP\CODSTA-MCPP-04.rule"/>
            </rule>
         </category>
         <category description="HIC++ 3.4.3 资源使用 RAII" name="3_4_3">
            <rule header="选择使用智能指针而不是原始局部指针" id="a" impl="CODSTA-MCPP-20" originalId="CODSTA-MCPP-20" quickfix="false" scope="line" severity="4">
               <file path="CODSTA-MCPP\CODSTA-MCPP-20.rule"/>
            </rule>
            <rule header="不要直接在互斥锁上调用lock()" id="b" impl="CODSTA-MCPP-21" originalId="CODSTA-MCPP-21" quickfix="false" scope="line" severity="4">
               <file path="CODSTA-MCPP\CODSTA-MCPP-21.rule"/>
            </rule>
            <rule header="使用 RAII 防止资源泄漏" id="c" impl="MRM-52" originalId="MRM-52" quickfix="false" scope="line" severity="4">
               <file path="MRM\MRM-52.rule"/>
            </rule>
         </category>
         <category description="HIC++ 1.3.2 不要使用 register 关键字" name="1_3_2">
            <rule header="不应使用'register'存储类说明符" id="a" impl="MISRA-028" originalId="MISRA-028" quickfix="false" scope="line" severity="5">
               <file path="MISRA\MISRA-028.rule"/>
            </rule>
         </category>
         <category description="HIC++ 2.1.1 不要在源文件中使用标签字符" name="2_1_1">
            <rule header="禁止使用未用 ASCII 空格的制表符" id="a" impl="FORMAT-01" originalId="FORMAT-01" quickfix="false" scope="line" severity="5">
               <file path="FORMAT\FORMAT-01.rule"/>
            </rule>
         </category>
      </category>
      <category description="初始化" name="INIT">
         <rule header="不要初始化对地址可以更改的对象的引用" id="05" impl="INIT-05" quickfix="false" scope="line" severity="1">
            <file path="INIT\INIT-05.rule"/>
         </rule>
         <rule header="所有成员变量都应该在构造函数中初始化" id="06" impl="INIT-06" quickfix="false" scope="line" severity="1">
            <file path="INIT\INIT-06.rule"/>
         </rule>
         <rule header="初始化类的静态成员变量" id="09" impl="INIT-09" quickfix="false" scope="line" severity="1">
            <file path="INIT\INIT-09.rule"/>
         </rule>
         <rule header="禁止在基类构造函数中使用未初始化的非静态成员变量" id="13_a" impl="INIT-13_a" quickfix="false" scope="line" severity="1">
            <file path="INIT\INIT-13_a.rule"/>
         </rule>
         <rule header="不要在虚拟基类构造函数中使用非虚拟基类未初始化的非静态成员变量" id="13_b" impl="INIT-13_b" quickfix="false" scope="line" severity="1">
            <file path="INIT\INIT-13_b.rule"/>
         </rule>
         <rule header="初始化所有指针变量" id="04" impl="INIT-04" quickfix="false" scope="line" severity="2">
            <file path="INIT\INIT-04.rule"/>
         </rule>
         <rule header="赋值运算符应赋值所有数据成员" id="11" impl="INIT-11" quickfix="false" scope="line" severity="2">
            <file path="INIT\INIT-11.rule"/>
         </rule>
         <rule header="头文件中不应该初始化带有external链接类型的对象" id="01" impl="INIT-01" quickfix="false" scope="line" severity="3">
            <file path="INIT\INIT-01.rule"/>
         </rule>
         <rule header="不能用有符号常量初始化无符号整型变量" id="02" impl="INIT-02" quickfix="false" scope="line" severity="3">
            <file path="INIT\INIT-02.rule"/>
         </rule>
         <rule header="初始化所有变量" id="03" impl="INIT-03" quickfix="false" scope="line" severity="3">
            <file path="INIT\INIT-03.rule"/>
         </rule>
         <rule header="通过用户自定义的构造函数显式初始化类成员" id="07" impl="INIT-07" quickfix="false" scope="line" severity="3">
            <file path="INIT\INIT-07.rule"/>
         </rule>
         <rule header="用户自定义的构造函数必须初始化动态分配的类对象" id="08" impl="INIT-08" quickfix="false" scope="line" severity="3">
            <file path="INIT\INIT-08.rule"/>
         </rule>
         <rule header="在初始化列表中按声明成员的顺序列出成员" id="10" impl="INIT-10" quickfix="false" scope="line" severity="3">
            <file path="INIT\INIT-10.rule"/>
         </rule>
         <rule header="通过用局部静态对象替换非局部静态对象来避免跨越编译单元的初始化顺序问题" id="12" impl="INIT-12" quickfix="false" scope="line" severity="3">
            <file path="INIT\INIT-12.rule"/>
         </rule>
         <rule header="不能假设在构造函数中成员的初始化顺序" id="13" impl="INIT-13" quickfix="false" scope="line" severity="3">
            <file path="INIT\INIT-13.rule"/>
         </rule>
         <rule header="禁止在基类构造函数中使用基类的可能未初始化的非静态成员变量" id="13_c" impl="INIT-13_c" quickfix="false" scope="line" severity="3">
            <file path="INIT\INIT-13_c.rule"/>
         </rule>
         <rule header="集合或联合的初始化程序应放在大括号中" id="16" impl="INIT-16" quickfix="false" scope="line" severity="3">
            <file path="INIT\INIT-16.rule"/>
         </rule>
         <rule header="在所有构造函数中,使用相同常量值初始化数据成员的用户定义的构造函数应使用NSDMI进行初始化" id="17" impl="INIT-17" quickfix="false" scope="line" severity="3">
            <file path="INIT\INIT-17.rule"/>
         </rule>
         <rule header="用户定义的构造函数如果在所有构造函数中用相同的常量值初始化数据成员，应该使用NSDMI进行初始化" id="17_b" impl="INIT-17_b" quickfix="false" scope="line" severity="3">
            <file path="INIT\INIT-17_b.rule"/>
         </rule>
         <rule header="构造函数中的 NSDMI 和非静态成员的初始化不能在同一类型中使用" id="18" impl="INIT-18" quickfix="false" scope="line" severity="3">
            <file path="INIT\INIT-18.rule"/>
         </rule>
         <rule header="考虑添加构造函数来初始化 'struct' 结构体成员变量" id="15" impl="INIT-15" quickfix="false" scope="line" severity="4">
            <file path="INIT\INIT-15.rule"/>
         </rule>
         <rule header="构造函数中推荐使用初始化列表而非赋值" id="14" impl="INIT-14" quickfix="false" scope="line" severity="5">
            <file path="INIT\INIT-14.rule"/>
         </rule>
      </category>
      <category description="MISRA C 2004" name="MISRA2004">
         <rule header="不要编写依赖于函数参数求值顺序的代码" id="12_2_b" impl="MISRA2004-12_2_b" quickfix="false" scope="line" severity="1">
            <file path="MISRA2004\MISRA2004-12_2_b.rule"/>
         </rule>
         <rule header="避免在有符号和无符号整数类型之间进行隐式转换" id="10_1_a" impl="MISRA2004-10_1_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-10_1_a.rule"/>
         </rule>
         <rule header="不存在从整型到浮点型的隐式转换" id="10_1_b" impl="MISRA2004-10_1_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-10_1_b.rule"/>
         </rule>
         <rule header="避免隐式的复合表达式的数据类型转换" id="10_1_c" impl="MISRA2004-10_1_c" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-10_1_c.rule"/>
         </rule>
         <rule header="避免从更宽到更窄的类型的隐式转换" id="10_1_d" impl="MISRA2004-10_1_d" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-10_1_d.rule"/>
         </rule>
         <rule header="避免隐式的函数返回表达式类型转换" id="10_1_e" impl="MISRA2004-10_1_e" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-10_1_e.rule"/>
         </rule>
         <rule header="避免隐式的复合表达式的类型转换" id="10_1_f" impl="MISRA2004-10_1_f" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-10_1_f.rule"/>
         </rule>
         <rule header="避免函数参数进行隐式地类型转换" id="10_1_g" impl="MISRA2004-10_1_g" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-10_1_g.rule"/>
         </rule>
         <rule header="避免隐式的复合表达式的数据类型转换" id="10_1_i" impl="MISRA2004-10_1_i" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-10_1_i.rule"/>
         </rule>
         <rule header="避免从浮点类型到整型的隐式转换" id="10_2_a" impl="MISRA2004-10_2_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-10_2_a.rule"/>
         </rule>
         <rule header="避免宽字段到窄字段浮点型数据的隐式转换" id="10_2_b" impl="MISRA2004-10_2_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-10_2_b.rule"/>
         </rule>
         <rule header="避免隐式的窄字段到宽字段浮点型数据转换" id="10_2_c" impl="MISRA2004-10_2_c" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-10_2_c.rule"/>
         </rule>
         <rule header="避免将浮点数从较宽的浮点类型隐式转换为较窄的浮点类型" id="10_2_d" impl="MISRA2004-10_2_d" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-10_2_d.rule"/>
         </rule>
         <rule header="整型复合表达式的值只能被强制转换到较短的类型，或者与该表达式类型相同的有符号类型" id="10_3" impl="MISRA2004-10_3" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-10_3.rule"/>
         </rule>
         <rule header="浮点型复杂表达式的值不应转换为更广泛的浮点型" id="10_4" impl="CODSTA-198" originalId="CODSTA-198" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-198.rule"/>
         </rule>
         <rule header="浮点型复杂表达式的值不应转换为整数类型" id="10_4_b" impl="CODSTA-198_b" originalId="CODSTA-198_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-198_b.rule"/>
         </rule>
         <rule header="如果对无符号字符型或无符号短整型进行 ~  和 &lt;&lt; 位运算后，其结果应立即强制转换成操作数的基本类型" id="10_5" impl="MISRA2004-10_5" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-10_5.rule"/>
         </rule>
         <rule header="除了整数类型外不允许其他类型和函数指针进行类型转换" id="11_1" impl="MISRA2004-11_1" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-11_1.rule"/>
         </rule>
         <rule header="对象指针只能被转换成整数类型，与对象同类型的指针和 void 指针" id="11_2" impl="MISRA2004-11_2" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-11_2.rule"/>
         </rule>
         <rule header="对象指针只能被转换成整数类型，与对象同类型的指针和 void 指针" id="11_2_b" impl="MISRA2004-11_2_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-11_2_b.rule"/>
         </rule>
         <rule header="对象指针只能被转换成整数类型，与对象同类型的指针和 void 指针" id="11_2_c" impl="MISRA2004-11_2_c" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-11_2_c.rule"/>
         </rule>
         <rule header="不允许指针类型和整数类型之间进行类型转换" id="11_3_a" impl="MISRA2004-11_3_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-11_3_a.rule"/>
         </rule>
         <rule header="不应在指针类型和整数类型之间进行转换" id="11_3_b" impl="MISRA2004-11_3_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-11_3_b.rule"/>
         </rule>
         <rule header="不应在指向对象类型的指针和指向对象类型的其他指针之间执行强制转换" id="11_4" impl="MISRA2004-11_4" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-11_4.rule"/>
         </rule>
         <rule header="强制转换不得从指针或引用类型中删除任何“const”或“volatile”限定条件" id="11_5" impl="MISRA2004-11_5" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-11_5.rule"/>
         </rule>
         <rule header="不应该使用逗号运算符" id="12_10" impl="MISRA2004-12_10" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_10.rule"/>
         </rule>
         <rule header="禁止对浮点数值进行位操作" id="12_12" impl="MISRA2004-12_12" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_12.rule"/>
         </rule>
         <rule header="禁止在同一个表达式中混合使用递加符 (++) 和递减符 (--) 与其他运算符" id="12_13" impl="MISRA2004-12_13" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_13.rule"/>
         </rule>
         <rule header="当赋值运算符包含赋值表达式时，将括号用于赋值运算符的右侧操作数" id="12_1_a" impl="MISRA2004-12_1_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_1_a.rule"/>
         </rule>
         <rule header="谨慎使用 C 语言中表达式的优先运算规则" id="12_1_d" impl="MISRA2004-12_1_d" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_1_d.rule"/>
         </rule>
         <rule header="除非表达式中的所有运算符都相同，否则使用圆括号" id="12_1_e" impl="MISRA2004-12_1_e" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_1_e.rule"/>
         </rule>
         <rule header="表达式的值应该在任何标准允许的赋值顺序下是一样的" id="12_2_a" impl="MISRA2004-12_2_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_2_a.rule"/>
         </rule>
         <rule header="不要编写依赖于函数标志符和函数参数的求值顺序的代码" id="12_2_c" impl="MISRA2004-12_2_c" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_2_c.rule"/>
         </rule>
         <rule header="涉及一个函数调用时，不要编写依赖表达式求值顺序的代码" id="12_2_d" impl="MISRA2004-12_2_d" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_2_d.rule"/>
         </rule>
         <rule header="在序列点之间，对象的存储值最多只能通过表达式的评估来修改一次" id="12_2_e" impl="MISRA2004-12_2_e" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_2_e.rule"/>
         </rule>
         <rule header="不要在两个相邻的序列点之间使用多个 volatile" id="12_2_f" impl="MISRA2004-12_2_f" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_2_f.rule"/>
         </rule>
         <rule header="不要编写依赖于函数调用求值顺序的代码" id="12_2_g" impl="MISRA2004-12_2_g" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_2_g.rule"/>
         </rule>
         <rule header="sizeof 运算符的操作数不应包含任何有副作用的表达式" id="12_3" impl="MISRA2004-12_3" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_3.rule"/>
         </rule>
         <rule header="不应在sizeof运算符的操作数中访问由volatile左值指定的对象" id="12_3_b" impl="MISRA2004-12_3_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_3_b.rule"/>
         </rule>
         <rule header="会导致副作用的函数调用不应该用作 sizeof 运算符的操作数" id="12_3_c" impl="MISRA2004-12_3_c" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_3_c.rule"/>
         </rule>
         <rule header="逻辑&amp;&amp;或||运算符的右操作数不得含有副作用" id="12_4_a" impl="MISRA2004-12_4_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_4_a.rule"/>
         </rule>
         <rule header="逻辑运算符 &amp;&amp; 或者 || 的操作数应该是基本表达式" id="12_5" impl="MISRA2004-12_5" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_5.rule"/>
         </rule>
         <rule header="逻辑运算符 (&amp;&amp;, || 和 !) 的操作数应该是有效的布尔值" id="12_6_a" impl="MISRA2004-12_6_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_6_a.rule"/>
         </rule>
         <rule header="有效布尔值的表达式不应该用作除 (&amp;&amp;, ||, !, =, ==, !=, ?:) 之外的运算符的操作数。" id="12_6_b" impl="MISRA2004-12_6_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_6_b.rule"/>
         </rule>
         <rule header="禁止对有符号类型使用位操作" id="12_7" impl="MISRA2004-12_7" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_7.rule"/>
         </rule>
         <rule header="一个移位操作符的右操作数应该位于 0 与左操作数底层类型的位宽减 1之间" id="12_8" impl="MISRA2004-12_8" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_8.rule"/>
         </rule>
         <rule header="一元减法运算符不得适用于其原始类型是无符号型的表达式" id="12_9" impl="MISRA2004-12_9" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_9.rule"/>
         </rule>
         <rule header="禁止在产生布尔值的表达式中使用赋值运算符" id="13_1" impl="MISRA2004-13_1" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_1.rule"/>
         </rule>
         <rule header="测试一个值是否为零应该是显式的，除非操作数实际上是布尔值" id="13_2" impl="MISRA2004-13_2" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_2.rule"/>
         </rule>
         <rule header="禁止对浮点数类型的表达式做相等或不相等的比较" id="13_3" impl="MISRA2004-13_3" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_3.rule"/>
         </rule>
         <rule header="for 循环语句中的控制表达式不能包含浮点类型对象" id="13_4" impl="MISRA2004-13_4" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_4.rule"/>
         </rule>
         <rule header="for 循环语句的三个表达式应该仅与循环控制相关" id="13_5" impl="MISRA2004-13_5" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_5.rule"/>
         </rule>
         <rule header="禁止在循环体中修改循环计数器" id="13_6" impl="MISRA2004-13_6" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_6.rule"/>
         </rule>
         <rule header="不允许其结果是不变的布尔运算" id="13_7_a" impl="MISRA2004-13_7_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_a.rule"/>
         </rule>
         <rule header="不允许其结果是不变的布尔运算" id="13_7_aa" impl="MISRA2004-13_7_aa" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_aa.rule"/>
         </rule>
         <rule header="不允许其结果是不变的布尔运算" id="13_7_ab" impl="MISRA2004-13_7_ab" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_ab.rule"/>
         </rule>
         <rule header="不允许其结果是不变的布尔运算" id="13_7_ac" impl="MISRA2004-13_7_ac" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_ac.rule"/>
         </rule>
         <rule header="不允许其结果是不变的布尔运算" id="13_7_ad" impl="MISRA2004-13_7_ad" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_ad.rule"/>
         </rule>
         <rule header="不允许其结果是不变的布尔运算" id="13_7_ae" impl="MISRA2004-13_7_ae" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_ae.rule"/>
         </rule>
         <rule header="不允许其结果是不变的布尔运算" id="13_7_af" impl="MISRA2004-13_7_af" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_af.rule"/>
         </rule>
         <rule header="不允许其结果是不变的布尔运算" id="13_7_ag" impl="MISRA2004-13_7_ag" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_ag.rule"/>
         </rule>
         <rule header="不允许其结果是不变的布尔运算" id="13_7_ah" impl="MISRA2004-13_7_ah" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_ah.rule"/>
         </rule>
         <rule header="不允许其结果是不变的布尔运算" id="13_7_ai" impl="MISRA2004-13_7_ai" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_ai.rule"/>
         </rule>
         <rule header="不允许其结果是不变的布尔运算" id="13_7_aj" impl="MISRA2004-13_7_aj" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_aj.rule"/>
         </rule>
         <rule header="不允许其结果是不变的布尔运算" id="13_7_ak" impl="MISRA2004-13_7_ak" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_ak.rule"/>
         </rule>
         <rule header="不允许其结果是不变的布尔运算" id="13_7_b" impl="MISRA2004-13_7_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_b.rule"/>
         </rule>
         <rule header="不允许其结果是不变的布尔运算" id="13_7_c" impl="MISRA2004-13_7_c" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_c.rule"/>
         </rule>
         <rule header="不允许其结果是不变的布尔运算" id="13_7_d" impl="MISRA2004-13_7_d" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_d.rule"/>
         </rule>
         <rule header="不允许其结果是不变的布尔运算" id="13_7_j" impl="MISRA2004-13_7_j" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_j.rule"/>
         </rule>
         <rule header="不允许其结果是不变的布尔运算" id="13_7_k" impl="MISRA2004-13_7_k" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_k.rule"/>
         </rule>
         <rule header="不允许其结果是不变的布尔运算" id="13_7_l" impl="MISRA2004-13_7_l" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_l.rule"/>
         </rule>
         <rule header="不允许其结果是不变的布尔运算" id="13_7_m" impl="MISRA2004-13_7_m" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_m.rule"/>
         </rule>
         <rule header="不允许其结果是不变的布尔运算" id="13_7_n" impl="MISRA2004-13_7_n" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_n.rule"/>
         </rule>
         <rule header="不允许其结果是不变的布尔运算" id="13_7_s" impl="MISRA2004-13_7_s" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_s.rule"/>
         </rule>
         <rule header="不允许其结果是不变的布尔运算" id="13_7_t" impl="MISRA2004-13_7_t" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_t.rule"/>
         </rule>
         <rule header="不允许其结果是不变的布尔运算" id="13_7_u" impl="MISRA2004-13_7_u" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_u.rule"/>
         </rule>
         <rule header="不允许其结果是不变的布尔运算" id="13_7_v" impl="MISRA2004-13_7_v" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_v.rule"/>
         </rule>
         <rule header="不允许结果不变的布尔运算" id="13_7_w" impl="MISRA2004-13_7_w" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_w.rule"/>
         </rule>
         <rule header="不允许其结果是不变的布尔运算" id="13_7_x" impl="MISRA2004-13_7_x" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_x.rule"/>
         </rule>
         <rule header="不允许其结果是不变的布尔运算" id="13_7_y" impl="MISRA2004-13_7_y" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_y.rule"/>
         </rule>
         <rule header="不允许其结果是不变的布尔运算" id="13_7_z" impl="MISRA2004-13_7_z" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_z.rule"/>
         </rule>
         <rule header="所有 'if...else-if' 结构应使用一个 'else' 子句终止" id="14_10" impl="MISRA2004-14_10" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-14_10.rule"/>
         </rule>
         <rule header="在 &quot;else&quot; 语句块中不应存在执行不到的代码" id="14_1_a" impl="MISRA2004-14_1_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-14_1_a.rule"/>
         </rule>
         <rule header="在 'return', 'break', 'continue', 和 'goto' 语句之后不应存在执行不到的代码" id="14_1_b" impl="MISRA2004-14_1_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-14_1_b.rule"/>
         </rule>
         <rule header="在 &quot;if/else/while/for&quot; 语句块中不应存在执行不到的代码" id="14_1_c" impl="MISRA2004-14_1_c" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-14_1_c.rule"/>
         </rule>
         <rule header="在 switch 语句中不应存在执行不到的代码" id="14_1_d" impl="MISRA2004-14_1_d" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-14_1_d.rule"/>
         </rule>
         <rule header="在 'for' 循环中不应存在执行不到的代码" id="14_1_e" impl="MISRA2004-14_1_e" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-14_1_e.rule"/>
         </rule>
         <rule header="在 'if' 或 'switch' 语句后不应存在不可访问的代码" id="14_1_f" impl="MISRA2004-14_1_f" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-14_1_f.rule"/>
         </rule>
         <rule header="在 while/for/do...while 循环内的 &quot;if&quot; 或 &quot;switch&quot; 语句后不应存在执行不到的代码" id="14_1_g" impl="MISRA2004-14_1_g" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-14_1_g.rule"/>
         </rule>
         <rule header="所有非 null 语句无论如何执行都至少有一个副作用，或者导致控制流发生变化" id="14_2" impl="MISRA2004-14_2" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-14_2.rule"/>
         </rule>
         <rule header="空语句应单独一行出现，或其后跟有注释" id="14_3" impl="MISRA2004-14_3" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-14_3.rule"/>
         </rule>
         <rule header="不应该使用 goto 语句" id="14_4" impl="MISRA2004-14_4" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-14_4.rule"/>
         </rule>
         <rule header="不要使用 continue 语句" id="14_5" impl="MISRA2004-14_5" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-14_5.rule"/>
         </rule>
         <rule header="对任何循环语句，最多不应超过一个 break 语句用于循环终止" id="14_6" impl="MISRA2004-14_6" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-14_6.rule"/>
         </rule>
         <rule header="函数末端应只提供一个出口点" id="14_7" impl="MISRA2004-14_7" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-14_7.rule"/>
         </rule>
         <rule header="'switch', 'while', 'do...while' 或 'for' 语句的主体应该是复合语句" id="14_8" impl="MISRA2004-14_8" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-14_8.rule"/>
         </rule>
         <rule header="'if' 和 'else' 语句后应跟一个复合句" id="14_9" impl="MISRA2004-14_9" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-14_9.rule"/>
         </rule>
         <rule header="break 语句应只出现在 switch 子句末端" id="15_0_a" impl="MISRA2004-15_0_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-15_0_a.rule"/>
         </rule>
         <rule header="switch 语句应该只包含 switch 标签和 switch 子句，不能包含其他代码" id="15_0_b" impl="MISRA2004-15_0_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-15_0_b.rule"/>
         </rule>
         <rule header="只有当最紧密包围的复合语句是 switch 语句的主体时才能使用 switch 标签" id="15_1" impl="MISRA2004-15_1" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-15_1.rule"/>
         </rule>
         <rule header="无条件的 break 语句应该作为每一个非空 case 子句的结束" id="15_2" impl="MISRA2004-15_2" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-15_2.rule"/>
         </rule>
         <rule header="无条件的 break 语句应作为所有非空 default 条件的结束" id="15_2_b" impl="MISRA2004-15_2_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-15_2_b.rule"/>
         </rule>
         <rule header="switch 语句中最后一个子句必须为 default 子句" id="15_3" impl="MISRA2004-15_3" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-15_3.rule"/>
         </rule>
         <rule header="switch 表达式不应该出现一个实际为布尔的值" id="15_4" impl="MISRA2004-15_4" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-15_4.rule"/>
         </rule>
         <rule header="switch 表达式不应该出现一个实际为布尔的值" id="15_4_b" impl="MISRA2004-15_4_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-15_4_b.rule"/>
         </rule>
         <rule header="每一个 switch 语句至少有一个 case 子句" id="15_5" impl="MISRA2004-15_5" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-15_5.rule"/>
         </rule>
         <rule header="函数不应使用可变数量的参数定义" id="16_1" impl="MISRA2004-16_1" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-16_1.rule"/>
         </rule>
         <rule header="如果函数返回了错误信息，那么错误信息应该进行测试" id="16_10" impl="MISRA2004-16_10" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-16_10.rule"/>
         </rule>
         <rule header="函数不应该直接或者间接地调用自己" id="16_2" impl="MISRA2004-16_2" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-16_2.rule"/>
         </rule>
         <rule header="在函数原型声明中应该为所有参数提供标识符" id="16_3" impl="MISRA2004-16_3" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-16_3.rule"/>
         </rule>
         <rule header="禁止函数声明中使用的标识符与实际定义中的标识符不一致" id="16_4" impl="MISRA2004-16_4" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-16_4.rule"/>
         </rule>
         <rule header="没有参数的函数必须声明参数类型为 void" id="16_5" impl="MISRA2004-16_5" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-16_5.rule"/>
         </rule>
         <rule header="传递给函数的参数个数必须与函数定义的参数一致" id="16_6" impl="MISRA2004-16_6" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-16_6.rule"/>
         </rule>
         <rule header="如果函数参数中指针参数在函数中不用来修改地址对象，则应声明为常量类型" id="16_7" impl="MISRA2004-16_7" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-16_7.rule"/>
         </rule>
         <rule header="如果指针不用于修改指向地址的对象则声明参数的类型为 typedef 的 const 指针" id="16_7_b" impl="MISRA2004-16_7_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-16_7_b.rule"/>
         </rule>
         <rule header="具有非空返回类型的函数的所有退出路径都应该有一个带有表达式的显式返回语句" id="16_8" impl="MISRA2004-16_8" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-16_8.rule"/>
         </rule>
         <rule header="具有非 void 返回类型的函数的所有退出路径，除 main() 外，都应具有带有表达式的显式返回语句" id="16_8_b" impl="MISRA2004-16_8_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-16_8_b.rule"/>
         </rule>
         <rule header="函数标识符只能与前面的  '&amp;' 一起使用，或者与括号中的参数列表一起使用，参数列表可以是空的" id="16_9" impl="MISRA2004-16_9" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-16_9.rule"/>
         </rule>
         <rule header="不要对那些没有指向数组或数组元素地址的指针进行指针运算" id="17_1" impl="MISRA2004-17_1" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-17_1.rule"/>
         </rule>
         <rule header="指针减法仅适用于同一数组元素的地址指针" id="17_2" impl="CODSTA-13_b" originalId="CODSTA-13_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-13_b.rule"/>
         </rule>
         <rule header="&gt;, &gt;=, &lt;, &lt;= 不应用于指针类型，除非它们指向相同的数组" id="17_3" impl="CODSTA-13" originalId="CODSTA-13" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-13.rule"/>
         </rule>
         <rule header="只有数组索引才能进行算术指针操作" id="17_4" impl="MISRA2004-17_4" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-17_4.rule"/>
         </rule>
         <rule header="对象的声明应该包含不超过 2 层的指针嵌套" id="17_5" impl="MISRA2004-17_5" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-17_5.rule"/>
         </rule>
         <rule header="不得从函数中返回具有自动存储的对象的地址" id="17_6_a" impl="MISRA2004-17_6_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-17_6_a.rule"/>
         </rule>
         <rule header="自动存储对象的地址不应分配给在第一个对象不再存在后可能持久存在的另一个对象" id="17_6_b" impl="MISRA2004-17_6_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-17_6_b.rule"/>
         </rule>
         <rule header="在转换单元结束之前，所有的结构体和联合体必须有完整的声明" id="18_1" impl="MISRA2004-18_1" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-18_1.rule"/>
         </rule>
         <rule header="不应该将结构体自身的一个成员变量赋给另一个成员变量" id="18_2" impl="MISRA2004-18_2" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-18_2.rule"/>
         </rule>
         <rule header="结构体的每个成员不应该赋值给自己的其他成员变量" id="18_2_b" impl="MISRA2004-18_2_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-18_2_b.rule"/>
         </rule>
         <rule header="禁止使用联合体" id="18_4" impl="MISRA2004-18_4" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-18_4.rule"/>
         </rule>
         <rule header="#include 之前只允许有预处理命令和注释" id="19_1" impl="MISRA2004-19_1" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-19_1.rule"/>
         </rule>
         <rule header="在类函数宏指令的定义中，参数的每个实例都应该用圆括号括起来，除非它用作 # 或者 ## 的运算对象" id="19_10" impl="MISRA2004-19_10" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-19_10.rule"/>
         </rule>
         <rule header="不要使用在编译单元中未定义的预编译器指令 #if 和 #elif  宏" id="19_11_b" impl="MISRA2004-19_11_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-19_11_b.rule"/>
         </rule>
         <rule header="禁止宏定义中使用多个 # 和 ##" id="19_12" impl="MISRA2004-19_12" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-19_12.rule"/>
         </rule>
         <rule header="禁止使用预处理操作符 # 和 ##" id="19_13" impl="MISRA2004-19_13" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-19_13.rule"/>
         </rule>
         <rule header="预处理操作符只能用在两种标准格式之一" id="19_14" impl="MISRA2004-19_14" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-19_14.rule"/>
         </rule>
         <rule header="必须采取预防措施以防止头文件的内容被引用两次" id="19_15" impl="MISRA2004-19_15" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-19_15.rule"/>
         </rule>
         <rule header="预处理指令即使被预处理程序排除,在语法上也是有意义的" id="19_16" impl="MISRA2004-19_16" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-19_16.rule"/>
         </rule>
         <rule header="在同一个文件中 #else, #elif 和 #endif 必须对应有 #if 或 #ifdef 预处理指令" id="19_17" impl="MISRA2004-19_17" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-19_17.rule"/>
         </rule>
         <rule header="非标准字符不应该用于 #include 指令的头文件名称中" id="19_2" impl="MISRA2004-19_2" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-19_2.rule"/>
         </rule>
         <rule header="#include 指令后面应当添加 &lt;filename&gt; 或是 &quot;filename&quot;" id="19_3" impl="MISRA-089" originalId="MISRA-089" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-089.rule"/>
         </rule>
         <rule header="避免宏定义中存在关键字和基本类型" id="19_4" impl="MISRA2004-19_4" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-19_4.rule"/>
         </rule>
         <rule header="禁止在块中使用 #define 或 #undef" id="19_5" impl="MISRA2004-19_5" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-19_5.rule"/>
         </rule>
         <rule header="不应使用 #undef" id="19_6" impl="PREPROC-25" originalId="PREPROC-25" quickfix="false" scope="line" severity="3">
            <file path="PREPROC\PREPROC-25.rule"/>
         </rule>
         <rule header="函数应该优先于宏函数的使用" id="19_7" impl="MISRA2004-19_7" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-19_7.rule"/>
         </rule>
         <rule header="类似函数的宏在调用时参数个数必须一致" id="19_8" impl="MISRA2004-19_8" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-19_8.rule"/>
         </rule>
         <rule header="类似函数的宏的参数不应该包含类似预处理命令的标识" id="19_9" impl="MISRA2004-19_9" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-19_9.rule"/>
         </rule>
         <rule header="不得使用库stdlib.h中的库函数atof，atoi和atol" id="20_10" impl="MISRA2004-20_10" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-20_10.rule"/>
         </rule>
         <rule header="不得使用  'stdlib.h' 或者 'cstdlib' 库中的 'abort()' 函数" id="20_11" impl="PB-75" originalId="PB-75" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-75.rule"/>
         </rule>
         <rule header="'stdlib.h' 或者 'cstdlib' 库中的 'exit()' 函数不应该被使用" id="20_11_b" impl="PB-75_b" originalId="PB-75_b" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-75_b.rule"/>
         </rule>
         <rule header="不得使用 'stdlib.h' 或 'cstdlib' 库中的 'getenv()' 函数" id="20_11_c" impl="SECURITY-52" originalId="SECURITY-52" quickfix="false" scope="line" severity="3">
            <file path="SECURITY\SECURITY-52.rule"/>
         </rule>
         <rule header="不得使用 'stdlib.h' 或 'cstdlib' 库中的 'system()' 函数" id="20_11_d" impl="SECURITY-48_b" originalId="SECURITY-48_b" quickfix="false" scope="line" severity="3">
            <file path="SECURITY\SECURITY-48_b.rule"/>
         </rule>
         <rule header="不应使用标准头文件 &lt;time.h&gt; 或 &lt;ctime&gt;" id="20_12" impl="MISRA2004-20_12" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-20_12.rule"/>
         </rule>
         <rule header="不应使用库 &lt;time.h&gt; 中的时间处理函数和宏" id="20_12_b" impl="MISRA2004-20_12_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-20_12_b.rule"/>
         </rule>
         <rule header="不应使用库 &lt;time.h&gt; 中定义的类型" id="20_12_c" impl="MISRA2004-20_12_c" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-20_12_c.rule"/>
         </rule>
         <rule header="不要使用以下划线开头的带有#define 或 #undef 名称的标识符" id="20_1_a" impl="MISRA2004-20_1_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-20_1_a.rule"/>
         </rule>
         <rule header="不要重新定义保留字" id="20_1_b" impl="MISRA2004-20_1_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-20_1_b.rule"/>
         </rule>
         <rule header="不应定义、重新定义、未定义标准程序库中的保留标识符、宏以及函数（C90代码）" id="20_1_c" impl="CODSTA-92_a" originalId="CODSTA-92_a" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-92_a.rule"/>
         </rule>
         <rule header="不使用 #define 或 #undef 标识符 'defined'" id="20_1_e" impl="MISRA2004-20_1_e" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-20_1_e.rule"/>
         </rule>
         <rule header="标准库宏、对象和函数的名称不应该被重用" id="20_2" impl="MISRA2004-20_2" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-20_2.rule"/>
         </rule>
         <rule header="不应该重复使用标准库中的宏，对象和函数(C90)" id="20_2_a" impl="MISRA2004-20_2_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-20_2_a.rule"/>
         </rule>
         <rule header="标准库宏，对象和函数的名称不得重复使用（C99）" id="20_2_b" impl="MISRA2004-20_2_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-20_2_b.rule"/>
         </rule>
         <rule header="应检查传递给库函数的值的有效性" id="20_3" impl="MISRA2004-20_3" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-20_3.rule"/>
         </rule>
         <rule header="不应使用动态堆内存分配" id="20_4" impl="MISRA2004-20_4" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-20_4.rule"/>
         </rule>
         <rule header="不得使用错误指示符 'errno'" id="20_5" impl="MISRA2004-20_5" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-20_5.rule"/>
         </rule>
         <rule header="不应该使用库文件 stddef.h 中的 offsetof 宏" id="20_6" impl="MISRA2004-20_6" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-20_6.rule"/>
         </rule>
         <rule header="不应使用 &lt;setjmp.h&gt; 提供的工具" id="20_7" impl="MISRA2004-20_7" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-20_7.rule"/>
         </rule>
         <rule header="不应使用标准头文件 &lt;setjmp.h&gt; 或 &lt;csetjmp&gt;" id="20_7_b" impl="MISRA2004-20_7_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-20_7_b.rule"/>
         </rule>
         <rule header="不应使用标准头文件 &lt;signal.h&gt; 或 &lt;csignal&gt;" id="20_8" impl="MISRA2004-20_8" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-20_8.rule"/>
         </rule>
         <rule header="不应使用 &lt;signal.h&gt; 的信号处理工具" id="20_8_b" impl="MISRA2004-20_8_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-20_8_b.rule"/>
         </rule>
         <rule header="禁止使用库文件 stdio.h 中的输入/输出函数" id="20_9" impl="MISRA2004-20_9" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-20_9.rule"/>
         </rule>
         <rule header="汇编代码应该是封装且独立的" id="2_1" impl="MISRA2004-2_1" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-2_1.rule"/>
         </rule>
         <rule header="源代码只能使用 /* ... */ 来注释" id="2_2" impl="MISRA2004-2_2" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-2_2.rule"/>
         </rule>
         <rule header="禁止在 C 语言风格的注释中使用 /* 字符序列" id="2_3" impl="MISRA2004-2_3" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-2_3.rule"/>
         </rule>
         <rule header="使用 #pragma 指令必须进行注释并说明" id="3_4" impl="MISRA2004-3_4" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-3_4.rule"/>
         </rule>
         <rule header="不要把位域和其他数据混合在同一个结构体里" id="3_5" impl="MISRA2004-3_5" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-3_5.rule"/>
         </rule>
         <rule header="应只使用 ISO C 标准中定义的转义字符" id="4_1" impl="MISRA2004-4_1" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-4_1.rule"/>
         </rule>
         <rule header="禁止使用三联符" id="4_2" impl="MISRA2004-4_2" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-4_2.rule"/>
         </rule>
         <rule header="用户指定的 C 外部标识符的前 31 个字符应不同" id="5_1_a" impl="PORT-35_a" originalId="PORT-35_a" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-35_a.rule"/>
         </rule>
         <rule header="用户指定的C内部标识符应与前31个字符中的外部标识符不同" id="5_1_b" impl="PORT-35_b" originalId="PORT-35_b" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-35_b.rule"/>
         </rule>
         <rule header="在相同范围内声明的用户指定的C内部标识符的前31个字符应不同" id="5_1_c" impl="PORT-35_c" originalId="PORT-35_c" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-35_c.rule"/>
         </rule>
         <rule header="在局部或者函数原型体范围内声明的标识符不应该隐藏一个在全局或者命名空间范围内声明的标识符" id="5_2_a" impl="MISRA2004-5_2_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-5_2_a.rule"/>
         </rule>
         <rule header="在内层的局部范围内声明的标识符不应该隐藏在外层的局部范围内声明的标识符" id="5_2_b" impl="MISRA2004-5_2_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-5_2_b.rule"/>
         </rule>
         <rule header="不能重用 typedef 名称" id="5_3_a" impl="MISRA2004-5_3_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-5_3_a.rule"/>
         </rule>
         <rule header="不能将 typedef 的名称重用在另一个 typedef 名称" id="5_3_b" impl="MISRA2004-5_3_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-5_3_b.rule"/>
         </rule>
         <rule header="在程序中标记(tag)的名称不得重用于其它目的" id="5_4_a" impl="MISRA2004-5_4_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-5_4_a.rule"/>
         </rule>
         <rule header="标记(tag)的名称不得被重用于定义一个不同的标号" id="5_4_b" impl="MISRA2004-5_4_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-5_4_b.rule"/>
         </rule>
         <rule header="typedef 的名称不应该与 typdef 指定的类型名称相同" id="5_4_c" impl="MISRA2004-5_4_c" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-5_4_c.rule"/>
         </rule>
         <rule header="普通字符(plain char)类型只能用于存储和使用字符值" id="6_1" impl="MISRA2004-6_1" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-6_1.rule"/>
         </rule>
         <rule header="带符号的 char 和 不带符号的 char 类型只能用于存储和数值类型" id="6_2" impl="MISRA2004-6_2" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-6_2.rule"/>
         </rule>
         <rule header="typedef 定义基本类型应该在名称中包含数字" id="6_3" impl="MISRA2004-6_3" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-6_3.rule"/>
         </rule>
         <rule header="typedef 应该用于替代基本类型" id="6_3_b" impl="MISRA2004-6_3_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-6_3_b.rule"/>
         </rule>
         <rule header="只能将位域定义为有符号的整型或无符号的整型" id="6_4" impl="MISRA2004-6_4" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-6_4.rule"/>
         </rule>
         <rule header="具有带符号的整数类型且已命名的位域应该有超过一位的长度" id="6_5" impl="CODSTA-71" originalId="CODSTA-71" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-71.rule"/>
         </rule>
         <rule header="signed整数型的未命名位域的长度应大于1bit" id="6_5_a" impl="MISRA2004-6_5_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-6_5_a.rule"/>
         </rule>
         <rule header="不应该使用八进制常数（除零外）" id="7_1_a" impl="MISRA2004-7_1_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-7_1_a.rule"/>
         </rule>
         <rule header="八进制转义序列不应该被使用" id="7_1_b" impl="MISRA2004-7_1_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-7_1_b.rule"/>
         </rule>
         <rule header="静态存储类说明符应该用于具有内部链接的对象和函数的定义和声明" id="8_11" impl="MISRA2004-8_11" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-8_11.rule"/>
         </rule>
         <rule header="当数组声明具有外部链接，其大小应该显式地说明或者在初始化时隐性地定义" id="8_12" impl="MISRA2004-8_12" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-8_12.rule"/>
         </rule>
         <rule header="函数应该有函数原型并且该原型应该对函数定义和调用可见" id="8_1_a" impl="MISRA-071_a" originalId="MISRA-071_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-071_a.rule"/>
         </rule>
         <rule header="在函数调用时，函数总是有可见的原型" id="8_1_b" impl="MISRA-071_b" originalId="MISRA-071_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-071_b.rule"/>
         </rule>
         <rule header="声明或定义某个函数时，必须显式地规定其类型" id="8_2_a" impl="MISRA2004-8_2_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-8_2_a.rule"/>
         </rule>
         <rule header="声明或定义某个对象时，必须显式地规定其类型" id="8_2_b" impl="MISRA2004-8_2_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-8_2_b.rule"/>
         </rule>
         <rule header="在声明和定义中使用相同的类型" id="8_3_a" impl="MISRA2004-8_3_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-8_3_a.rule"/>
         </rule>
         <rule header="函数的声明与原型的类型必须一致" id="8_3_b" impl="MISRA2004-8_3_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-8_3_b.rule"/>
         </rule>
         <rule header="如果对象或者函数被声明了一次以上，那么他们的类型应该是兼容的" id="8_4" impl="MISRA2004-8_4" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-8_4.rule"/>
         </rule>
         <rule header="在头文件中不应定义函数和对象" id="8_5" impl="MISRA2004-8_5" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-8_5.rule"/>
         </rule>
         <rule header="始终在文件的范围内声明函数" id="8_6" impl="MISRA2004-8_6" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-8_6.rule"/>
         </rule>
         <rule header="如果仅从单个函数中访问对象，则应在块范围内定义对象" id="8_7" impl="MISRA2004-8_7" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-8_7.rule"/>
         </rule>
         <rule header="所有自动变量在使用之前都必须被赋值" id="9_1" impl="MISRA-030" originalId="MISRA-030" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-030.rule"/>
         </rule>
         <rule header="集合或联合的初始化程序应放在大括号中" id="9_2" impl="INIT-16" originalId="INIT-16" quickfix="false" scope="line" severity="3">
            <file path="INIT\INIT-16.rule"/>
         </rule>
         <rule header="数组不应被部分初始化" id="9_2_b" impl="MISRA2004-9_2_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-9_2_b.rule"/>
         </rule>
         <rule header="结构体的非零初始化要求每个元素都有显示初始化器" id="9_2_c" impl="MISRA2004-9_2_c" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-9_2_c.rule"/>
         </rule>
         <rule header="在枚举类型中，要么仅对第一个元素进行显式地初始化，要么所有元素都进行显式的初始化" id="9_3" impl="MISRA2004-9_3" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-9_3.rule"/>
         </rule>
         <rule header="代码段不应该被&quot;注释掉&quot;" id="2_4" impl="MISRA2004-2_4" quickfix="false" scope="line" severity="4">
            <file path="MISRA2004\MISRA2004-2_4.rule"/>
         </rule>
         <rule header="禁止重用静态存储周期的对象或函数的标识符" id="5_5_a" impl="MISRA2004-5_5_a" quickfix="false" scope="line" severity="4">
            <file path="MISRA2004\MISRA2004-5_5_a.rule"/>
         </rule>
         <rule header="禁止重用静态存储周期的对象或函数的标识符" id="5_5_b" impl="MISRA2004-5_5_b" quickfix="false" scope="line" severity="4">
            <file path="MISRA2004\MISRA2004-5_5_b.rule"/>
         </rule>
         <rule header="除结构体和联合体成员名称外，一个命名空间内的标识符不能与另一个命名空间里面的标识符重名" id="5_6" impl="MISRA2004-5_6" quickfix="false" scope="line" severity="4">
            <file path="MISRA2004\MISRA2004-5_6.rule"/>
         </rule>
         <rule header="禁止重用标识符名称" id="5_7" impl="MISRA2004-5_7" quickfix="false" scope="line" severity="4">
            <file path="MISRA2004\MISRA2004-5_7.rule"/>
         </rule>
         <rule header="应该在头文件中声明具有外部链接的对象或函数" id="8_10" impl="MISRA-023" originalId="MISRA-023" quickfix="false" scope="line" severity="4">
            <file path="MISRA\MISRA-023.rule"/>
         </rule>
         <rule header="无符号类型的所有常量应该使用 'U' 后缀" id="10_6" impl="MISRA2004-10_6" quickfix="false" scope="line" severity="5">
            <file path="MISRA2004\MISRA2004-10_6.rule"/>
         </rule>
         <rule header="谨慎使用 C 语言中表达式的优先运算规则" id="12_1_b" impl="MISRA2004-12_1_b" quickfix="false" scope="line" severity="5">
            <file path="MISRA2004\MISRA2004-12_1_b.rule"/>
         </rule>
         <rule header="一元运算符的操作数不需要括号" id="12_1_c" impl="MISRA2004-12_1_c" quickfix="false" scope="line" severity="5">
            <file path="MISRA2004\MISRA2004-12_1_c.rule"/>
         </rule>
         <rule header="谨慎使用 C 语言中表达式的优先运算规则" id="12_1_f" impl="MISRA2004-12_1_f" quickfix="false" scope="line" severity="5">
            <file path="MISRA2004\MISRA2004-12_1_f.rule"/>
         </rule>
      </category>
      <category description="MISRA C 2012（遗留）" name="MISRA2012">
         <category description="MISRA C 2012 规则" name="RULE">
            <rule header="'sizeof' 运算符不应该有一个被声明为 &quot;数组类型 &quot;的函数参数的操作数" id="12_5" impl="CODSTA-182" originalId="CODSTA-182" quickfix="false" scope="line" severity="1">
               <file path="CODSTA\CODSTA-182.rule"/>
            </rule>
            <rule header="函数不能隐式声明" id="17_3" impl="MISRA-071_b" originalId="MISRA-071_b" quickfix="false" scope="line" severity="1">
               <file path="MISRA\MISRA-071_b.rule"/>
            </rule>
            <rule header="具有非 void 返回类型的函数的所有出口路径，都应该有一个带有表达式的显式返回语句" id="17_4" impl="MISRA2004-16_8" originalId="MISRA2004-16_8" quickfix="false" scope="line" severity="1">
               <file path="MISRA2004\MISRA2004-16_8.rule"/>
            </rule>
            <rule header="具有非 void 返回类型的函数的所有退出路径，除 main() 外，都应具有带有表达式的显式返回语句" id="17_4_b" impl="MISRA2004-16_8_b" originalId="MISRA2004-16_8_b" quickfix="false" scope="line" severity="1">
               <file path="MISRA2004\MISRA2004-16_8_b.rule"/>
            </rule>
            <rule header="数组参数的声明在[ ]之间不应包含 'static' 关键字" id="17_6" impl="CODSTA-160" originalId="CODSTA-160" quickfix="false" scope="line" severity="1">
               <file path="CODSTA\CODSTA-160.rule"/>
            </rule>
            <rule header="不应使用指向可变修改数组类型的指针" id="18_10" impl="CODSTA-112_b" originalId="CODSTA-112_b" quickfix="false" scope="line" severity="1">
               <file path="CODSTA\CODSTA-112_b.rule"/>
            </rule>
            <rule header="一个对象不应该被分配或复制到一个重叠的对象" id="19_1_a" impl="MISRA2004-18_2" originalId="MISRA2004-18_2" quickfix="false" scope="line" severity="1">
               <file path="MISRA2004\MISRA2004-18_2.rule"/>
            </rule>
            <rule header="一个对象不应该被分配或复制到一个重叠的对象" id="19_1_b" impl="MISRA2004-18_2_b" originalId="MISRA2004-18_2_b" quickfix="false" scope="line" severity="1">
               <file path="MISRA2004\MISRA2004-18_2_b.rule"/>
            </rule>
            <rule header="由标准库函数 'localeconv'， 'getenv'， 'setlocale' 或 'strerror' 返回的指针只能像它们具有指向 const-qualified 类型的指针一样使用" id="21_19_a" impl="CODSTA-185_a" originalId="CODSTA-185_a" quickfix="false" scope="line" severity="1">
               <file path="CODSTA\CODSTA-185_a.rule"/>
            </rule>
            <rule header="由结构体 'lconv' 成员指向的字符串不应被修改" id="21_19_b" impl="CODSTA-185_b" originalId="CODSTA-185_b" quickfix="false" scope="line" severity="1">
               <file path="CODSTA\CODSTA-185_b.rule"/>
            </rule>
            <rule header="在&lt;tgmath.h&gt;中声明的任何通用类型宏的所有参数应具有适当的基本类型" id="21_22" impl="CODSTA-108_c" originalId="CODSTA-108_c" quickfix="false" scope="line" severity="1">
               <file path="CODSTA\CODSTA-108_c.rule"/>
            </rule>
            <rule header="线程对象、线程同步对象和线程特有存储指针只能由相应的标准库函数访问" id="22_12" impl="CODSTA-MC-22" originalId="CODSTA-MC-22" quickfix="false" scope="line" severity="1">
               <file path="CODSTA-MC\CODSTA-MC-22.rule"/>
            </rule>
            <rule header="传递给 'mtx_init()' 函数的第二参数应为 'mtx_plain', 'mtx_timed', 'mtx_plain | mtx_recursive', 或 'mtx_timed | mtx_recursive'" id="22_14_b" impl="CODSTA-MC-21" originalId="CODSTA-MC-21" quickfix="false" scope="line" severity="1">
               <file path="CODSTA-MC\CODSTA-MC-21.rule"/>
            </rule>
            <rule header="指向文件对象的指针不应解除引用" id="22_5_a" impl="CODSTA-166_a" originalId="CODSTA-166_a" quickfix="false" scope="line" severity="1">
               <file path="CODSTA\CODSTA-166_a.rule"/>
            </rule>
            <rule header="指向文件对象的指针不应由库函数解除引用" id="22_5_b" impl="CODSTA-166_b" originalId="CODSTA-166_b" quickfix="false" scope="line" severity="1">
               <file path="CODSTA\CODSTA-166_b.rule"/>
            </rule>
            <rule header="整数常数宏的参数应具有适当的形式" id="7_5" impl="CODSTA-220" originalId="CODSTA-220" quickfix="false" scope="line" severity="1">
               <file path="CODSTA\CODSTA-220.rule"/>
            </rule>
            <rule header="在将操作数解释为布尔值的地方，应该始终使用基本布尔类型的表达式" id="10_1_a" impl="CODSTA-161_a" originalId="CODSTA-161_a" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-161_a.rule"/>
            </rule>
            <rule header="在将操作数解释为数值的情况下，不应该使用本质上为布尔类型的操作数" id="10_1_b" impl="CODSTA-161_b" originalId="CODSTA-161_b" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-161_b.rule"/>
            </rule>
            <rule header="在将操作数解释为数值时，不应使用本质上为字符类型的操作数" id="10_1_c" impl="CODSTA-161_c" originalId="CODSTA-161_c" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-161_c.rule"/>
            </rule>
            <rule header="算术运算不应该使用枚举类型的操作数" id="10_1_d" impl="CODSTA-161_d" originalId="CODSTA-161_d" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-161_d.rule"/>
            </rule>
            <rule header="不应该在有符号的操作数或枚举类型上执行移位和按位运算操作" id="10_1_e" impl="CODSTA-161_e" originalId="CODSTA-161_e" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-161_e.rule"/>
            </rule>
            <rule header="有符号或枚举类型的操作数不应该用作按位运算的右侧操作数" id="10_1_f" impl="CODSTA-161_f" originalId="CODSTA-161_f" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-161_f.rule"/>
            </rule>
            <rule header="本质上是无符号类型的操作数不应该用作一元减号运算符的操作数" id="10_1_g" impl="CODSTA-161_g" originalId="CODSTA-161_g" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-161_g.rule"/>
            </rule>
            <rule header="不得显示（语法上）测试浮点表达式的相等（==）或不相等（！=）" id="10_1_h" impl="CODSTA-225" originalId="CODSTA-225" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-225.rule"/>
            </rule>
            <rule header="在加法和减法运算中，基本字符类型的表达式不能使用不当" id="10_2" impl="CODSTA-162" originalId="CODSTA-162" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-162.rule"/>
            </rule>
            <rule header="表达式的值不应赋给狭义的基本类型对象" id="10_3_a" impl="CODSTA-163_a" originalId="CODSTA-163_a" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-163_a.rule"/>
            </rule>
            <rule header="表达式的值不应赋给不同基本类型类别的对象" id="10_3_b" impl="CODSTA-163_b" originalId="CODSTA-163_b" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-163_b.rule"/>
            </rule>
            <rule header="执行通常的算术转换运算的两个操作数应具有相同的基本类型类别" id="10_4_a" impl="CODSTA-164_a" originalId="CODSTA-164_a" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-164_a.rule"/>
            </rule>
            <rule header="三元运算符的第二和第三操作数应具有相同的基本类型类别" id="10_4_b" impl="CODSTA-164_b" originalId="CODSTA-164_b" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-164_b.rule"/>
            </rule>
            <rule header="复合表达式的值不应赋给广义基本类型的对象" id="10_6" impl="CODSTA-157" originalId="CODSTA-157" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-157.rule"/>
            </rule>
            <rule header="如果一个复合表达式被用作运算符的一个操作数，在该操作数中执行通常的算术转换，那么另一个操作数不应该具有更广泛的基本类型" id="10_7_a" impl="CODSTA-156_a" originalId="CODSTA-156_a" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-156_a.rule"/>
            </rule>
            <rule header="如果复合表达式被用作条件运算符的一个（第二或第三个）操作数，则另一个操作数不应具有更广泛的基本类型" id="10_7_b" impl="CODSTA-156_b" originalId="CODSTA-156_b" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-156_b.rule"/>
            </rule>
            <rule header="复合表达式的值不应转换为不同的基本类型类别或更广泛的基本类型" id="10_8" impl="CODSTA-152" originalId="CODSTA-152" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-152.rule"/>
            </rule>
            <rule header="_Atomic 限定符不应应用于不完整的类型 void" id="11_10" impl="CODSTA-MC-16" originalId="CODSTA-MC-16" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MC\CODSTA-MC-16.rule"/>
            </rule>
            <rule header="不能在指向函数的指针和任何其他类型之间执行转换" id="11_1_a" impl="CODSTA-124_a" originalId="CODSTA-124_a" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-124_a.rule"/>
            </rule>
            <rule header="不能在指向函数的指针和任何其他类型之间执行转换" id="11_1_b" impl="CODSTA-124_b" originalId="CODSTA-124_b" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-124_b.rule"/>
            </rule>
            <rule header="不能在指向不完整类型的指针和任何其他类型之间执行转换" id="11_2" impl="CODSTA-125" originalId="CODSTA-125" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-125.rule"/>
            </rule>
            <rule header="不能在指向对象类型的指针和指向不同对象类型的指针之间执行强制转换" id="11_3" impl="CODSTA-126" originalId="CODSTA-126" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-126.rule"/>
            </rule>
            <rule header="在无效指针和算术类型之间不应该执行强制转换" id="11_6" impl="CODSTA-129_a" originalId="CODSTA-129_a" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-129_a.rule"/>
            </rule>
            <rule header="不能在指向对象的指针和非整数算术类型之间执行强制转换" id="11_7" impl="CODSTA-130" originalId="CODSTA-130" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-130.rule"/>
            </rule>
            <rule header="宏 NULL 应该是整数空指针常量的唯一允许形式" id="11_9_a" impl="CODSTA-CPP-63" originalId="CODSTA-CPP-63" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-63.rule"/>
            </rule>
            <rule header="宏 NULL 应该是整数空指针常量的唯一允许形式" id="11_9_b" impl="CODSTA-131" originalId="CODSTA-131" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-131.rule"/>
            </rule>
            <rule header="原子对象的结构体和联合体成员不得直接访问" id="12_6" impl="CODSTA-MC-17" originalId="CODSTA-MC-17" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MC\CODSTA-MC-17.rule"/>
            </rule>
            <rule header="构造器列表不应包含持久的副作用" id="13_1_a" impl="CODSTA-141_a" originalId="CODSTA-141_a" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-141_a.rule"/>
            </rule>
            <rule header="在标准允许的任何评求值顺序下，表达式的值应相同" id="13_2_a" impl="MISRA2004-12_2_a" originalId="MISRA2004-12_2_a" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-12_2_a.rule"/>
            </rule>
            <rule header="不要编写依赖于函数参数求值顺序的代码" id="13_2_b" impl="MISRA2004-12_2_b" originalId="MISRA2004-12_2_b" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-12_2_b.rule"/>
            </rule>
            <rule header="不要编写依赖于函数标识符和函数参数的求值顺序的代码" id="13_2_c" impl="MISRA2004-12_2_c" originalId="MISRA2004-12_2_c" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-12_2_c.rule"/>
            </rule>
            <rule header="不要编写依赖于包含函数调用表达式的求值顺序的代码" id="13_2_d" impl="MISRA2004-12_2_d" originalId="MISRA2004-12_2_d" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-12_2_d.rule"/>
            </rule>
            <rule header="在序列点之间，对象的存储值应通过表达式的求值最多修改一次" id="13_2_e" impl="MISRA2004-12_2_e" originalId="MISRA2004-12_2_e" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-12_2_e.rule"/>
            </rule>
            <rule header="不要在一个表达式中使用多个 volatile 关键字" id="13_2_f" impl="MISRA2004-12_2_f" originalId="MISRA2004-12_2_f" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-12_2_f.rule"/>
            </rule>
            <rule header="不要编写依赖于函数调用求值顺序的代码" id="13_2_g" impl="MISRA2004-12_2_g" originalId="MISRA2004-12_2_g" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-12_2_g.rule"/>
            </rule>
            <rule header="原子类型的表达式的值应独立于线程交错" id="13_2_h" impl="CODSTA-MC-19" originalId="CODSTA-MC-19" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MC\CODSTA-MC-19.rule"/>
            </rule>
            <rule header="逻辑运算符 &amp;&amp;或||运算符的右操作数不应含有持续的副作用" id="13_5" impl="MISRA2004-12_4_a" originalId="MISRA2004-12_4_a" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-12_4_a.rule"/>
            </rule>
            <rule header="sizeof 算符的操作数不应包含任何可能产生副作用的表达式" id="13_6_a" impl="MISRA2004-12_3" originalId="MISRA2004-12_3" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-12_3.rule"/>
            </rule>
            <rule header="sizeof 运算符的操作数不应包含任何可能产生副作用的表达式" id="13_6_b" impl="MISRA2004-12_3_b" originalId="MISRA2004-12_3_b" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-12_3_b.rule"/>
            </rule>
            <rule header="sizeof 运算符的操作数不应包含任何可能产生副作用的表达式" id="13_6_c" impl="CODSTA-137" originalId="CODSTA-137" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-137.rule"/>
            </rule>
            <rule header="for 循环中的循环计数器本质上不应该具有浮点数据类型" id="14_1_a" impl="CODSTA-167_a" originalId="CODSTA-167_a" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-167_a.rule"/>
            </rule>
            <rule header="while 循环和 do-while 循环中的循环计数器本质上不应该具有浮点数据类型" id="14_1_b" impl="CODSTA-167_b" originalId="CODSTA-167_b" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-167_b.rule"/>
            </rule>
            <rule header="'for' 循环中只能有一个循环计数器，不能在 'for'循环体中进行修改" id="14_2_a" impl="CODSTA-168" originalId="CODSTA-168" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-168.rule"/>
            </rule>
            <rule header="for 循环的第一个子句应该是格式规范的" id="14_2_b" impl="CODSTA-169_a" originalId="CODSTA-169_a" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-169_a.rule"/>
            </rule>
            <rule header="for 循环的第二句应该是格式规范的" id="14_2_c" impl="CODSTA-169_b" originalId="CODSTA-169_b" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-169_b.rule"/>
            </rule>
            <rule header="for 循环的第三句应该是格式规范的" id="14_2_d" impl="CODSTA-169_c" originalId="CODSTA-169_c" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-169_c.rule"/>
            </rule>
            <rule header="if 语句的控制表达式和迭代语句的控制表达式应该具有基本的布尔类型" id="14_4" impl="MISRA2004-13_2" originalId="MISRA2004-13_2" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-13_2.rule"/>
            </rule>
            <rule header="goto 语句将跳转到后面在相同函数中声明的标签" id="15_2" impl="CODSTA-77" originalId="CODSTA-77" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-77.rule"/>
            </rule>
            <rule header="goto 语句引用的任何标签都应声明在同一个块中，或包含 goto 语句的任何块中" id="15_3" impl="CODSTA-78" originalId="CODSTA-78" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-78.rule"/>
            </rule>
            <rule header="迭代语句或选择语句的主体应该是复合语句" id="15_6_a" impl="MISRA2004-14_8" originalId="MISRA2004-14_8" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-14_8.rule"/>
            </rule>
            <rule header="迭代语句或选择语句的主体应该是复合语句" id="15_6_b" impl="MISRA2004-14_9" originalId="MISRA2004-14_9" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-14_9.rule"/>
            </rule>
            <rule header="所有 'if ...else if' 结构都应该以 else 语句结束" id="15_7" impl="MISRA2004-14_10" originalId="MISRA2004-14_10" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-14_10.rule"/>
            </rule>
            <rule header="switch 语句只包含 switch 标签和 switch 子句，不包含其他代码" id="16_1_a" impl="MISRA2004-15_0_b" originalId="MISRA2004-15_0_b" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-15_0_b.rule"/>
            </rule>
            <rule header="只有当最接近的复合语句是 switch 语句的主体时，才能使用 switch 标签" id="16_1_b" impl="MISRA2004-15_1" originalId="MISRA2004-15_1" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-15_1.rule"/>
            </rule>
            <rule header="无条件 break 语句应该终止所有非  null 的 case 子句" id="16_1_c" impl="MISRA2004-15_2" originalId="MISRA2004-15_2" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-15_2.rule"/>
            </rule>
            <rule header="无条件 break 语句应该终止所有非  null 的 default 子句" id="16_1_d" impl="MISRA2004-15_2_b" originalId="MISRA2004-15_2_b" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-15_2_b.rule"/>
            </rule>
            <rule header="始终为 switch 语句提供 default 分支" id="16_1_e" impl="CODSTA-35" originalId="CODSTA-35" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-35.rule"/>
            </rule>
            <rule header="在终止 'break' 之前， 'default' 标签应有声明或注释" id="16_1_f" impl="CODSTA-119" originalId="CODSTA-119" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-119.rule"/>
            </rule>
            <rule header="'default' 标签（如果存在的话）应该作为 switch 语句的第一个或最后一个 switch 子句出现" id="16_1_g" impl="CODSTA-116" originalId="CODSTA-116" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-116.rule"/>
            </rule>
            <rule header="每个 switch 语句至少应有两个 switch 子句" id="16_1_h" impl="OPT-39" originalId="OPT-39" quickfix="false" scope="line" severity="2">
               <file path="OPT\OPT-39.rule"/>
            </rule>
            <rule header="只有当最接近的复合语句是switch语句的主体时，才能使用 switch 标签" id="16_2" impl="MISRA2004-15_1" originalId="MISRA2004-15_1" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-15_1.rule"/>
            </rule>
            <rule header="无条件 break 语句应该终止所有 switch 子句" id="16_3_a" impl="MISRA2004-15_2" originalId="MISRA2004-15_2" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-15_2.rule"/>
            </rule>
            <rule header="无条件 break 语句应该终止所有switch子句" id="16_3_b" impl="MISRA2004-15_2_b" originalId="MISRA2004-15_2_b" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-15_2_b.rule"/>
            </rule>
            <rule header="每个 'switch' 语句都应该有一个 'default' 标签" id="16_4_a" impl="CODSTA-35" originalId="CODSTA-35" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-35.rule"/>
            </rule>
            <rule header="在终止 'break' 之前， 'default' 标签应有声明或注释" id="16_4_b" impl="CODSTA-119" originalId="CODSTA-119" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-119.rule"/>
            </rule>
            <rule header="default 标签应该作为 switch 语句的第一个或最后一个 switch 标签出现" id="16_5" impl="CODSTA-116" originalId="CODSTA-116" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-116.rule"/>
            </rule>
            <rule header="每个 switch 语句至少应有两个 switch 子句" id="16_6" impl="OPT-39" originalId="OPT-39" quickfix="false" scope="line" severity="2">
               <file path="OPT\OPT-39.rule"/>
            </rule>
            <rule header="switch 表达式不应该具有基本的布尔类型" id="16_7_a" impl="MISRA2004-15_4" originalId="MISRA2004-15_4" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-15_4.rule"/>
            </rule>
            <rule header="switch 表达式不应该具有基本的布尔类型" id="16_7_b" impl="MISRA2004-15_4_b" originalId="MISRA2004-15_4_b" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-15_4_b.rule"/>
            </rule>
            <rule header="用_Noreturn函数说明符声明的函数应具有void返回类型" id="17_10" impl="CODSTA-204" originalId="CODSTA-204" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-204.rule"/>
            </rule>
            <rule header="函数类型不应该被类型限定" id="17_13" impl="CODSTA-221" originalId="CODSTA-221" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-221.rule"/>
            </rule>
            <rule header="不应该使用 &lt;stdarg.h&gt; 的特性" id="17_1_a" impl="CODSTA-136_a" originalId="CODSTA-136_a" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-136_a.rule"/>
            </rule>
            <rule header="不应该使用 &lt;stdarg.h&gt; 的特性" id="17_1_b" impl="CODSTA-136_b" originalId="CODSTA-136_b" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-136_b.rule"/>
            </rule>
            <rule header="不应使用标准头文件 &lt;stdarg.h&gt; " id="17_1_c" impl="CODSTA-136_c" originalId="CODSTA-136_c" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-136_c.rule"/>
            </rule>
            <rule header="函数不能直接或间接的调用它本身" id="17_2" impl="MISRA2004-16_2" originalId="MISRA2004-16_2" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-16_2.rule"/>
            </rule>
            <rule header="函数中被声明为数组类型的参数中应该有一定数量的元素" id="17_5" impl="CODSTA-134" originalId="CODSTA-134" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-134.rule"/>
            </rule>
            <rule header="使用具有返回非 void 类型的函数的返回值" id="17_7_a" impl="CODSTA-122_a" originalId="CODSTA-122_a" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-122_a.rule"/>
            </rule>
            <rule header="使用具有返回非 void 类型的函数的返回值" id="17_7_b" impl="CODSTA-122_b" originalId="CODSTA-122_b" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-122_b.rule"/>
            </rule>
            <rule header="具有自动存储功能的对象的地址不能从函数返回" id="18_6_a" impl="MISRA2004-17_6_a" originalId="MISRA2004-17_6_a" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-17_6_a.rule"/>
            </rule>
            <rule header="具有自动存储功能的对象可能在第一个对象停止存在后仍然存在，它的地址不应分配给另一个对象" id="18_6_b" impl="MISRA2004-17_6_b" originalId="MISRA2004-17_6_b" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-17_6_b.rule"/>
            </rule>
            <rule header="不要将具有线程存储期的对象的地址分配给具有静态存储期的对象" id="18_6_c" impl="CODSTA-231" originalId="CODSTA-231" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-231.rule"/>
            </rule>
            <rule header="不应声明灵活的数组成员" id="18_7" impl="CODSTA-113" originalId="CODSTA-113" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-113.rule"/>
            </rule>
            <rule header="不应使用变长数组" id="18_8" impl="CODSTA-112" originalId="CODSTA-112" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-112.rule"/>
            </rule>
            <rule header="一个对象不得在其生命周期之外使用" id="18_9" impl="CODSTA-196" originalId="CODSTA-196" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-196.rule"/>
            </rule>
            <rule header="程序不应超过（c90）标准规定的编译限制" id="1_1_a_c90" impl="CODSTA-174_a_c90" originalId="CODSTA-174_a_c90" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-174_a_c90.rule"/>
            </rule>
            <rule header="程序不应超过 （c99）标准规定的编译限制" id="1_1_a_c99" impl="CODSTA-174_a_c99" originalId="CODSTA-174_a_c99" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-174_a_c99.rule"/>
            </rule>
            <rule header="程序不应超过（c90）标准规定的编译限制" id="1_1_b_c90" impl="CODSTA-174_b_c90" originalId="CODSTA-174_b_c90" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-174_b_c90.rule"/>
            </rule>
            <rule header="程序不应超过（c99）标准规定的编译限制" id="1_1_b_c99" impl="CODSTA-174_b_c99" originalId="CODSTA-174_b_c99" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-174_b_c99.rule"/>
            </rule>
            <rule header="在规范标准允许的任何求值顺序下，表达式的值应相同" id="1_3_f" impl="MISRA2004-12_2_a" originalId="MISRA2004-12_2_a" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-12_2_a.rule"/>
            </rule>
            <rule header="不要编写依赖于函数参数求值顺序的代码" id="1_3_g" impl="MISRA2004-12_2_b" originalId="MISRA2004-12_2_b" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-12_2_b.rule"/>
            </rule>
            <rule header="不要编写依赖于函数 designator 和函数参数的求值顺序的代码" id="1_3_h" impl="MISRA2004-12_2_c" originalId="MISRA2004-12_2_c" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-12_2_c.rule"/>
            </rule>
            <rule header="不要编写依赖于含有函数调用的表达式求值顺序的代码" id="1_3_i" impl="MISRA2004-12_2_d" originalId="MISRA2004-12_2_d" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-12_2_d.rule"/>
            </rule>
            <rule header="在序列点之间，对象应该有通过表达式的求值至多修改一次的存储值" id="1_3_j" impl="MISRA2004-12_2_e" originalId="MISRA2004-12_2_e" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-12_2_e.rule"/>
            </rule>
            <rule header="不要在一个表达式中使用多个 volatile " id="1_3_k" impl="MISRA2004-12_2_f" originalId="MISRA2004-12_2_f" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-12_2_f.rule"/>
            </rule>
            <rule header="不要编写依赖于函数调用的求值顺序的代码" id="1_3_l" impl="MISRA2004-12_2_g" originalId="MISRA2004-12_2_g" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-12_2_g.rule"/>
            </rule>
            <rule header="函数不应返回指向非静态局部对象的指针或引用" id="1_3_m" impl="MISRA2004-17_6_a" originalId="MISRA2004-17_6_a" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-17_6_a.rule"/>
            </rule>
            <rule header="具有能自动存储的对象的地址不应分配给在对象不存在后仍然存在的对象" id="1_3_n" impl="MISRA2004-17_6_b" originalId="MISRA2004-17_6_b" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-17_6_b.rule"/>
            </rule>
            <rule header="右移操作符的左操作数不应为负值" id="1_3_o" impl="PB-29" originalId="PB-29" quickfix="false" scope="line" severity="2">
               <file path="PB\PB-29.rule"/>
            </rule>
            <rule header="宏 '__STDC_WANT_LIB_EXT1__' 不应定义为 '0' 以外的值" id="1_4_j" impl="CODSTA-215" originalId="CODSTA-215" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-215.rule"/>
            </rule>
            <rule header="不应使用 “rsize_t” 类型" id="1_4_k" impl="CODSTA-212" originalId="CODSTA-212" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-212.rule"/>
            </rule>
            <rule header="不应该使用 'errno_t' 类型" id="1_4_l" impl="CODSTA-217" originalId="CODSTA-217" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-217.rule"/>
            </rule>
            <rule header="不要使用以下宏：RSIZE_MAX，L_tmpnam_s，TMP_MAX_S" id="1_4_m" impl="CODSTA-218" originalId="CODSTA-218" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-218.rule"/>
            </rule>
            <rule header="不使用 ISO/IEC 9899:2011 标准的附件 K 中定义的函数" id="1_4_n" impl="CODSTA-219" originalId="CODSTA-219" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-219.rule"/>
            </rule>
            <rule header="在有内部联系的对象和函数的定义和声明中，应使用静态存储类指定器" id="1_5" impl="MISRA2004-8_11" originalId="MISRA2004-8_11" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-8_11.rule"/>
            </rule>
            <rule header="存储类型修改器应与类型相关，而不是与变量或函数相关" id="1_5_b" impl="CODSTA-10" originalId="CODSTA-10" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-10.rule"/>
            </rule>
            <rule header="函数类型应采用原型形式" id="1_5_c" impl="CODSTA-159" originalId="CODSTA-159" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-159.rule"/>
            </rule>
            <rule header="不要使用宏 ATOMIC_VAR_INIT" id="1_5_d" impl="CODSTA-209_b" originalId="CODSTA-209_b" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-209_b.rule"/>
            </rule>
            <rule header="不要在 #undef 指令中使用'bool'、'false'或'true'标识符" id="1_5_e" impl="PREPROC-27" originalId="PREPROC-27" quickfix="false" scope="line" severity="2">
               <file path="PREPROC\PREPROC-27.rule"/>
            </rule>
            <rule header="紧跟在 # 操作符后面的宏参数不应该紧跟在 ## 操作符后面" id="20_11" impl="PREPROC-16" originalId="PREPROC-16" quickfix="false" scope="line" severity="2">
               <file path="PREPROC\PREPROC-16.rule"/>
            </rule>
            <rule header="作为 # 或 ## 操作符的操作对象使用的宏参数，本身要进行进一步的宏替换，所以只能作为这些操作符的操作对象使用" id="20_12" impl="PREPROC-17" originalId="PREPROC-17" quickfix="false" scope="line" severity="2">
               <file path="PREPROC\PREPROC-17.rule"/>
            </rule>
            <rule header="第一个令牌为 # 的行应该是有效的预处理指令" id="20_13" impl="MISRA2004-19_16" originalId="MISRA2004-19_16" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-19_16.rule"/>
            </rule>
            <rule header="所有的 #else， #elif 和 #endif 预处理器指令应该与它们相关的 #if， #ifdef 或 #ifndef 指令驻留在同一个文件中" id="20_14" impl="MISRA2004-19_17" originalId="MISRA2004-19_17" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-19_17.rule"/>
            </rule>
            <rule header="在头文件名称中不应出现 '， &amp; 或者 \ 字符和 /* 或 // 字符序列" id="20_2_a" impl="NAMING-46" originalId="NAMING-46" quickfix="false" scope="line" severity="2">
               <file path="NAMING\NAMING-46.rule"/>
            </rule>
            <rule header="在头文件名称中不应出现 '， &amp; 或者 \ 字符和 /* 或 // 字符序列" id="20_2_b" impl="NAMING-48" originalId="NAMING-48" quickfix="false" scope="line" severity="2">
               <file path="NAMING\NAMING-48.rule"/>
            </rule>
            <rule header="#include 指令后面应该跟着一个 &lt;filename&gt; 或 &quot;filename&quot; 这样的序列" id="20_3" impl="MISRA-089" originalId="MISRA-089" quickfix="false" scope="line" severity="2">
               <file path="MISRA\MISRA-089.rule"/>
            </rule>
            <rule header="宏不能与关键字同名" id="20_4_a" impl="CODSTA-133_a" originalId="CODSTA-133_a" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-133_a.rule"/>
            </rule>
            <rule header="宏不能与关键字同名" id="20_4_b" impl="CODSTA-133_b" originalId="CODSTA-133_b" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-133_b.rule"/>
            </rule>
            <rule header="看起来像预处理指令的标记不应该出现在宏参数中" id="20_6" impl="MISRA2004-19_9" originalId="MISRA2004-19_9" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-19_9.rule"/>
            </rule>
            <rule header="宏参数展开产生的表达式应括在括号中" id="20_7" impl="MISRA2004-19_10" originalId="MISRA2004-19_10" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-19_10.rule"/>
            </rule>
            <rule header="一个 #if 或 #elif 预处理指令的控制表达式应取值为 0 或 1" id="20_8" impl="PREPROC-19" originalId="PREPROC-19" quickfix="false" scope="line" severity="2">
               <file path="PREPROC\PREPROC-19.rule"/>
            </rule>
            <rule header="在 #if 或 #elif 预处理指令的控制表达式中使用的所有标识符都应该在计算前进行 #define'd" id="20_9_b" impl="MISRA2004-19_11_b" originalId="MISRA2004-19_11_b" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-19_11_b.rule"/>
            </rule>
            <rule header="不应使用标准头文件&lt;time.h&gt;" id="21_10" impl="MISRA2004-20_12" originalId="MISRA2004-20_12" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-20_12.rule"/>
            </rule>
            <rule header="不应使用库&lt;time.h&gt;的时间处理函数和宏" id="21_10_b" impl="MISRA2004-20_12_b" originalId="MISRA2004-20_12_b" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-20_12_b.rule"/>
            </rule>
            <rule header="不应使用库中&lt;time.h&gt;定义的类型" id="21_10_c" impl="MISRA2004-20_12_c" originalId="MISRA2004-20_12_c" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-20_12_c.rule"/>
            </rule>
            <rule header="不得使用 &lt;tgmath.h&gt; 的标准头文件" id="21_11" impl="CODSTA-108" originalId="CODSTA-108" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-108.rule"/>
            </rule>
            <rule header="&lt;fenv.h&gt; 提供的功能不应被使用" id="21_12" impl="CODSTA-109" originalId="CODSTA-109" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-109.rule"/>
            </rule>
            <rule header="标准头文件 &lt;fenv.h&gt; 不应被使用" id="21_12_b" impl="CODSTA-109_b" originalId="CODSTA-109_b" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-109_b.rule"/>
            </rule>
            <rule header="指向标准库函数 'memcmp'， 'memmove' 和 'memcmp' 的指针参数应该是指向兼容类型的合格版或不合格版本的指针" id="21_15" impl="CODSTA-183" originalId="CODSTA-183" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-183.rule"/>
            </rule>
            <rule header="本质上，标准库函数 'memcmp' 的指针参数应该指向指针类型、有符号类型、无符号类型、布尔类型或枚举类型" id="21_16" impl="CODSTA-184" originalId="CODSTA-184" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-184.rule"/>
            </rule>
            <rule header="不得使用以下划线开头的有 #define 或 #undef 标识符这样的名称" id="21_1_a" impl="MISRA2004-20_1_a" originalId="MISRA2004-20_1_a" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-20_1_a.rule"/>
            </rule>
            <rule header="#define 和 #undef 不能用于预留标识符或预留宏名（对于 C90 代码）" id="21_1_b" impl="CODSTA-92_a" originalId="CODSTA-92_a" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-92_a.rule"/>
            </rule>
            <rule header="#define 和 #undef 不能用于预留标识符或预留宏名（对于 C99 代码）" id="21_1_c" impl="CODSTA-92_b" originalId="CODSTA-92_b" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-92_b.rule"/>
            </rule>
            <rule header="不得使用 #define 或 #undef 标识符 'defined'" id="21_1_d" impl="MISRA2004-20_1_e" originalId="MISRA2004-20_1_e" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-20_1_e.rule"/>
            </rule>
            <rule header="不得使用 &lt;stdlib.h&gt; 的 'system' 库函数" id="21_21" impl="SECURITY-48_b" originalId="SECURITY-48_b" quickfix="false" scope="line" severity="2">
               <file path="SECURITY\SECURITY-48_b.rule"/>
            </rule>
            <rule header="在&lt;tgmath.h&gt;中声明的任何多参数通用类型宏的所有参数应具有相同的标准类型" id="21_23" impl="CODSTA-108_d" originalId="CODSTA-108_d" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-108_d.rule"/>
            </rule>
            <rule header="不应使用&lt;stdlib.h&gt;的随机数生成函数" id="21_24" impl="SECURITY-02" originalId="SECURITY-02" quickfix="false" scope="line" severity="2">
               <file path="SECURITY\SECURITY-02.rule"/>
            </rule>
            <rule header="仅使用 'memory_order_seq_cst' 作为显式内存顺序参数" id="21_25" impl="CODSTA-MC-20" originalId="CODSTA-MC-20" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MC\CODSTA-MC-20.rule"/>
            </rule>
            <rule header="不应声明以下划线开头的名称标识符" id="21_2_a" impl="MISRA2004-20_2" originalId="MISRA2004-20_2" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-20_2.rule"/>
            </rule>
            <rule header="保留标识符或宏名不得声明（对于 C90 代码）" id="21_2_b" impl="MISRA2004-20_2_a" originalId="MISRA2004-20_2_a" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-20_2_a.rule"/>
            </rule>
            <rule header="保留标识符或宏名不得声明（对于 C99 代码）" id="21_2_c" impl="MISRA2004-20_2_b" originalId="MISRA2004-20_2_b" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-20_2_b.rule"/>
            </rule>
            <rule header="不得使用 &lt;stdlib.h&gt; 的内存分配和分配功能" id="21_3" impl="MISRA2004-20_4" originalId="MISRA2004-20_4" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-20_4.rule"/>
            </rule>
            <rule header="不得使用 &lt;setjmp.h&gt; 的标准头文件" id="21_4_a" impl="MISRA2004-20_7" originalId="MISRA2004-20_7" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-20_7.rule"/>
            </rule>
            <rule header="不得使用 &lt;setjmp.h&gt; 的标准头文件" id="21_4_b" impl="MISRA2004-20_7_b" originalId="MISRA2004-20_7_b" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-20_7_b.rule"/>
            </rule>
            <rule header="不得使用 &lt;signal.h&gt; 的标准头文件" id="21_5_a" impl="MISRA2004-20_8" originalId="MISRA2004-20_8" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-20_8.rule"/>
            </rule>
            <rule header="不得使用 &lt;signal.h&gt; 的标准头文件" id="21_5_b" impl="MISRA2004-20_8_b" originalId="MISRA2004-20_8_b" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-20_8_b.rule"/>
            </rule>
            <rule header="不得使用标准库的输入/输出函数" id="21_6" impl="CODSTA-110" originalId="CODSTA-110" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-110.rule"/>
            </rule>
            <rule header="不得使用 &lt;stdlib.h&gt; 的 atof， atoi， atol 和 atoll 功能" id="21_7" impl="MISRA2004-20_10" originalId="MISRA2004-20_10" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-20_10.rule"/>
            </rule>
            <rule header="不得使用 &lt;stdlib.h&gt; 的 'abort' 库函数" id="21_8" impl="PB-75" originalId="PB-75" quickfix="false" scope="line" severity="2">
               <file path="PB\PB-75.rule"/>
            </rule>
            <rule header="不得使用 &lt;stdlib.h&gt; 的 'exit' 库函数" id="21_8_b" impl="PB-75_b" originalId="PB-75_b" quickfix="false" scope="line" severity="2">
               <file path="PB\PB-75_b.rule"/>
            </rule>
            <rule header="不得使用 &lt;stdlib.h&gt; 的 'quick_exit' 和 '_Exit' 库函数" id="21_8_c" impl="PB-75_c" originalId="PB-75_c" quickfix="false" scope="line" severity="2">
               <file path="PB\PB-75_c.rule"/>
            </rule>
            <rule header="不得使用标准库 &lt;stdlib.h&gt; 包括检索和检索的功能" id="21_9" impl="CODSTA-107" originalId="CODSTA-107" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-107.rule"/>
            </rule>
            <rule header="非从宏中扩展出来的泛型选择，在控制表达式中不应该包含潜在的副作用" id="23_2" impl="CODSTA-MC-13" originalId="CODSTA-MC-13" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MC\CODSTA-MC-13.rule"/>
            </rule>
            <rule header="泛型关联应列出一个适当的类型" id="23_4" impl="CODSTA-MC-09" originalId="CODSTA-MC-09" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MC\CODSTA-MC-09.rule"/>
            </rule>
            <rule header="泛型选择的控制表达式应该有一个与其标准类型相匹配的基本类型" id="23_6" impl="CODSTA-MC-12" originalId="CODSTA-MC-12" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MC\CODSTA-MC-12.rule"/>
            </rule>
            <rule header="在泛型选择中，枚举类型不应该与整数类型混在一起" id="23_6_b" impl="CODSTA-MC-14" originalId="CODSTA-MC-14" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MC\CODSTA-MC-14.rule"/>
            </rule>
            <rule header="默认关联应作为泛型选择的第一个或最后一个关联出现" id="23_8" impl="CODSTA-MC-06" originalId="CODSTA-MC-06" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MC\CODSTA-MC-06.rule"/>
            </rule>
            <rule header="在 'else' 代码块中不应存在不可到达的代码" id="2_1_a" impl="MISRA2004-14_1_a" originalId="MISRA2004-14_1_a" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-14_1_a.rule"/>
            </rule>
            <rule header="在 'return'， 'break'， 'continue'，以及 'gotoThere' 语句之后，不应存在不可到达的代码" id="2_1_b" impl="MISRA2004-14_1_b" originalId="MISRA2004-14_1_b" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-14_1_b.rule"/>
            </rule>
            <rule header="在 'if'， 'else'， 'while'， 'for' 代码块中不应存在不可到达的代码" id="2_1_c" impl="MISRA2004-14_1_c" originalId="MISRA2004-14_1_c" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-14_1_c.rule"/>
            </rule>
            <rule header="'switch' 语句中不应存在不可到达的代码" id="2_1_d" impl="MISRA2004-14_1_d" originalId="MISRA2004-14_1_d" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-14_1_d.rule"/>
            </rule>
            <rule header="'for' 循环中不应存在不可到达的代码" id="2_1_e" impl="MISRA2004-14_1_e" originalId="MISRA2004-14_1_e" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-14_1_e.rule"/>
            </rule>
            <rule header="'if' 或 'switch' 语句后不应存在不可到达的代码" id="2_1_f" impl="MISRA2004-14_1_f" originalId="MISRA2004-14_1_f" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-14_1_f.rule"/>
            </rule>
            <rule header="在 'while'/'for'/'do...while'循环内的 'if'或 'switch'语句后面不会有无法访问的代码" id="2_1_g" impl="MISRA2004-14_1_g" originalId="MISRA2004-14_1_g" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-14_1_g.rule"/>
            </rule>
            <rule header="所有非空语句要么不管怎样执行至少有一个副作用，或者导致控制流程发生变化" id="2_2_a" impl="MISRA2004-14_2" originalId="MISRA2004-14_2" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-14_2.rule"/>
            </rule>
            <rule header="字符序列/*不得在 C 风格的注释中使用" id="3_1_a" impl="MISRA2004-2_3" originalId="MISRA2004-2_3" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-2_3.rule"/>
            </rule>
            <rule header="字符序列//不得在 C 风格的注释中使用" id="3_1_b" impl="COMMENT-11" originalId="COMMENT-11" quickfix="false" scope="line" severity="2">
               <file path="COMMENT\COMMENT-11.rule"/>
            </rule>
            <rule header="字符序列/*不得在 C++ 风格的注释中使用" id="3_1_c" impl="COMMENT-12" originalId="COMMENT-12" quickfix="false" scope="line" severity="2">
               <file path="COMMENT\COMMENT-12.rule"/>
            </rule>
            <rule header="不应在//注释中使用行拼接" id="3_2" impl="COMMENT-13" originalId="COMMENT-13" quickfix="false" scope="line" severity="2">
               <file path="COMMENT\COMMENT-13.rule"/>
            </rule>
            <rule header="应结束八进制和十六进制转义序列" id="4_1" impl="CODSTA-117" originalId="CODSTA-117" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-117.rule"/>
            </rule>
            <rule header="外部标识符应该是不同的" id="5_1" impl="CODSTA-178" originalId="CODSTA-178" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-178.rule"/>
            </rule>
            <rule header="在文件范围和同一命名空间中声明的标识符应是不同的（c90）" id="5_2_a_c90" impl="CODSTA-179_a_c90" originalId="CODSTA-179_a_c90" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-179_a_c90.rule"/>
            </rule>
            <rule header="在文件范围和同一命名空间中声明的标识符应是不同的（c99）" id="5_2_a_c99" impl="CODSTA-179_a_c99" originalId="CODSTA-179_a_c99" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-179_a_c99.rule"/>
            </rule>
            <rule header="在同一块范围和名称空间中声明的标识符应是不同的（c90）" id="5_2_b_c90" impl="CODSTA-179_b_c90" originalId="CODSTA-179_b_c90" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-179_b_c90.rule"/>
            </rule>
            <rule header="在同一块范围和命名空间中声明的标识符应是不同的（c99）" id="5_2_b_c99" impl="CODSTA-179_b_c99" originalId="CODSTA-179_b_c99" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-179_b_c99.rule"/>
            </rule>
            <rule header="在内部作用域中声明的标识符不应隐藏在外部作用域中声明的标识符" id="5_3_a" impl="MISRA2004-5_2_a" originalId="MISRA2004-5_2_a" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-5_2_a.rule"/>
            </rule>
            <rule header="在内部作用域中声明的标识符不应隐藏在外部作用域中声明的标识符" id="5_3_b" impl="MISRA2004-5_2_b" originalId="MISRA2004-5_2_b" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-5_2_b.rule"/>
            </rule>
            <rule header="宏的名称应与其参数的名称不同（c90）" id="5_4_a_c90" impl="CODSTA-171_c90" originalId="CODSTA-171_c90" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-171_c90.rule"/>
            </rule>
            <rule header="宏的名称应与其参数的名称不同（c99）" id="5_4_a_c99" impl="CODSTA-171_c99" originalId="CODSTA-171_c99" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-171_c99.rule"/>
            </rule>
            <rule header="宏的名称应与当前定义的其他宏的名称不同（c90）" id="5_4_b_c90" impl="CODSTA-172_c90" originalId="CODSTA-172_c90" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-172_c90.rule"/>
            </rule>
            <rule header="宏的名称应与当前定义的其他宏的名称不同（c99）" id="5_4_b_c99" impl="CODSTA-172_c99" originalId="CODSTA-172_c99" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-172_c99.rule"/>
            </rule>
            <rule header="标识符应与宏名称不同（c90）" id="5_5_c90" impl="CODSTA-170_c90" originalId="CODSTA-170_c90" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-170_c90.rule"/>
            </rule>
            <rule header="标识符应与宏名称不同（c99）" id="5_5_c99" impl="CODSTA-170_c99" originalId="CODSTA-170_c99" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-170_c99.rule"/>
            </rule>
            <rule header="位字段只能用适当的类型声明" id="6_1" impl="MISRA2004-6_4" originalId="MISRA2004-6_4" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-6_4.rule"/>
            </rule>
            <rule header="单个位命名的位字段不应是有符号类型" id="6_2" impl="CODSTA-71" originalId="CODSTA-71" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-71.rule"/>
            </rule>
            <rule header="一个位域不应被声明为一个union的成员" id="6_3" impl="CODSTA-02_b" originalId="CODSTA-02_b" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-02_b.rule"/>
            </rule>
            <rule header="不得使用八进制常数" id="7_1" impl="MISRA2004-7_1_a" originalId="MISRA2004-7_1_a" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-7_1_a.rule"/>
            </rule>
            <rule header="'u'或 'U'后缀应适用于以无符号类型表示的所有整数常量" id="7_2" impl="MISRA2004-10_6" originalId="MISRA2004-10_6" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-10_6.rule"/>
            </rule>
            <rule header="小写字母 'l'不得用于字面后缀" id="7_3" impl="PORT-01" originalId="PORT-01" quickfix="false" scope="line" severity="2">
               <file path="PORT\PORT-01.rule"/>
            </rule>
            <rule header="除非对象的类型是指向 const 限定 char 的指针，否则不应将字符串字面量赋值给对象" id="7_4" impl="PB-27" originalId="PB-27" quickfix="false" scope="line" severity="2">
               <file path="PB\PB-27.rule"/>
            </rule>
            <rule header="应使用静态存储类声明内联函数" id="8_10" impl="CODSTA-120" originalId="CODSTA-120" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-120.rule"/>
            </rule>
            <rule header="在枚举器列表中，隐式指定的枚举常量的值应该是唯一的" id="8_12" impl="PB-58" originalId="PB-58" quickfix="false" scope="line" severity="2">
               <file path="PB\PB-58.rule"/>
            </rule>
            <rule header="不应使用限制类型限定符" id="8_14" impl="CODSTA-121" originalId="CODSTA-121" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-121.rule"/>
            </rule>
            <rule header="所有具有外部链接的对象的声明和明确的对齐规范应指定相同的对齐方式" id="8_15_b" impl="CODSTA-MC-04" originalId="CODSTA-MC-04" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MC\CODSTA-MC-04.rule"/>
            </rule>
            <rule header="无论何时声明或定义函数，都应明确说明其类型" id="8_1_a" impl="MISRA2004-8_2_a" originalId="MISRA2004-8_2_a" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-8_2_a.rule"/>
            </rule>
            <rule header="无论何时声明或定义对象，都应明确说明其类型" id="8_1_b" impl="MISRA2004-8_2_b" originalId="MISRA2004-8_2_b" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-8_2_b.rule"/>
            </rule>
            <rule header="应为函数原型声明中的所有参数指定标识符" id="8_2_a" impl="MISRA2004-16_3" originalId="MISRA2004-16_3" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-16_3.rule"/>
            </rule>
            <rule header="函数类型应具有命名参数" id="8_2_b" impl="CODSTA-158" originalId="CODSTA-158" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-158.rule"/>
            </rule>
            <rule header="函数类型应为原型形式" id="8_2_c" impl="CODSTA-159" originalId="CODSTA-159" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-159.rule"/>
            </rule>
            <rule header="如果多次声明对象或函数，则它们的类型应兼容" id="8_3_a" impl="MISRA2004-8_4" originalId="MISRA2004-8_4" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-8_4.rule"/>
            </rule>
            <rule header="函数的声明和定义中使用的标识符应相同" id="8_3_b" impl="MISRA2004-16_4" originalId="MISRA2004-16_4" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-16_4.rule"/>
            </rule>
            <rule header="当有外部链接的对象或函数被定义时，兼容的声明应是可见的" id="8_4_a" impl="CODSTA-118" originalId="CODSTA-118" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-118.rule"/>
            </rule>
            <rule header="当有外部链接的对象或函数被定义时，兼容的声明应是可见的" id="8_4_b" impl="MISRA2004-8_4" originalId="MISRA2004-8_4" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-8_4.rule"/>
            </rule>
            <rule header="外部对象或函数在编译单元中不得有多个非定义声明" id="8_5" impl="CODSTA-154" originalId="CODSTA-154" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-154.rule"/>
            </rule>
            <rule header="静态存储类说明符应用于有内部链接对象和函数的所有声明中" id="8_8" impl="MISRA2004-8_11" originalId="MISRA2004-8_11" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-8_11.rule"/>
            </rule>
            <rule header="聚合体或联合体的初始化器应用括号括起来" id="9_2" impl="INIT-16" originalId="INIT-16" quickfix="false" scope="line" severity="2">
               <file path="INIT\INIT-16.rule"/>
            </rule>
            <rule header="数组不应部分初始化" id="9_3" impl="MISRA2004-9_2_b" originalId="MISRA2004-9_2_b" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-9_2_b.rule"/>
            </rule>
            <rule header="对象的元素不得多次初始化" id="9_4" impl="PB-69" originalId="PB-69" quickfix="false" scope="line" severity="2">
               <file path="PB\PB-69.rule"/>
            </rule>
            <rule header="如果使用指定的构造器初始化数组对象，数组的大小应该显式指定" id="9_5" impl="CODSTA-186" originalId="CODSTA-186" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-186.rule"/>
            </rule>
            <rule header="使用链式指示符的初始化器不应包含没有指示符的初始化器" id="9_6" impl="PB-80" originalId="PB-80" quickfix="false" scope="line" severity="2">
               <file path="PB\PB-80.rule"/>
            </rule>
            <rule header="不允许对枚举类型进行强制转换" id="10_5_a" impl="CODSTA-165_a" originalId="CODSTA-165_a" quickfix="false" scope="line" severity="4">
               <file path="CODSTA\CODSTA-165_a.rule"/>
            </rule>
            <rule header="不要从基本布尔类型转换或转换成基本布尔类型" id="10_5_b" impl="CODSTA-165_b" originalId="CODSTA-165_b" quickfix="false" scope="line" severity="4">
               <file path="CODSTA\CODSTA-165_b.rule"/>
            </rule>
            <rule header="不要在基本字符类型和基本浮动类型之间使用强制转换" id="10_5_c" impl="CODSTA-165_c" originalId="CODSTA-165_c" quickfix="false" scope="line" severity="4">
               <file path="CODSTA\CODSTA-165_c.rule"/>
            </rule>
            <rule header="不应该在指向对象的指针和整数类型之间执行转换" id="11_4" impl="CODSTA-127" originalId="CODSTA-127" quickfix="false" scope="line" severity="4">
               <file path="CODSTA\CODSTA-127.rule"/>
            </rule>
            <rule header="不应该执行从指针到无效指针对象的转换" id="11_5" impl="CODSTA-128" originalId="CODSTA-128" quickfix="false" scope="line" severity="4">
               <file path="CODSTA\CODSTA-128.rule"/>
            </rule>
            <rule header="使用括号，除非表达式中的所有运算符都相同" id="12_1_a" impl="MISRA2004-12_1_e" originalId="MISRA2004-12_1_e" quickfix="false" scope="line" severity="4">
               <file path="MISRA2004\MISRA2004-12_1_e.rule"/>
            </rule>
            <rule header="逻辑运算符 &amp;&amp;和||应该是基本表达式" id="12_1_b" impl="MISRA2004-12_5" originalId="MISRA2004-12_5" quickfix="false" scope="line" severity="4">
               <file path="MISRA2004\MISRA2004-12_5.rule"/>
            </rule>
            <rule header="括号应与 'sieof'语句一起使用" id="12_1_c" impl="FORMAT-25" originalId="FORMAT-25" quickfix="false" scope="line" severity="4">
               <file path="FORMAT\FORMAT-25.rule"/>
            </rule>
            <rule header="不应该使用逗号操作符" id="12_3" impl="MISRA2004-12_10" originalId="MISRA2004-12_10" quickfix="false" scope="line" severity="4">
               <file path="MISRA2004\MISRA2004-12_10.rule"/>
            </rule>
            <rule header="在 '+'、'-'、'*'运算符的常量表达式中的整数溢出或下溢" id="12_4_a" impl="PB-66_a" originalId="PB-66_a" quickfix="false" scope="line" severity="4">
               <file path="PB\PB-66_a.rule"/>
            </rule>
            <rule header="在 '&lt;&lt;'运算符的常量表达式中的整数溢出或下溢" id="12_4_b" impl="PB-66_b" originalId="PB-66_b" quickfix="false" scope="line" severity="4">
               <file path="PB\PB-66_b.rule"/>
            </rule>
            <rule header="包含递增（++）或递减（-）运算符的完整表达式除了由递增或递减运算符引起的副作用外，应该没有其他潜在的副作用" id="13_3" impl="CODSTA-123" originalId="CODSTA-123" quickfix="false" scope="line" severity="4">
               <file path="CODSTA\CODSTA-123.rule"/>
            </rule>
            <rule header="不应使用赋值运算符的结果" id="13_4" impl="CODSTA-138" originalId="CODSTA-138" quickfix="false" scope="line" severity="4">
               <file path="CODSTA\CODSTA-138.rule"/>
            </rule>
            <rule header="goto 语句不应该被使用" id="15_1" impl="MISRA2004-14_4" originalId="MISRA2004-14_4" quickfix="false" scope="line" severity="4">
               <file path="MISRA2004\MISRA2004-14_4.rule"/>
            </rule>
            <rule header="用于终止任何迭代语句的 break 或 goto 语句不应该超过一个" id="15_4" impl="CODSTA-79" originalId="CODSTA-79" quickfix="false" scope="line" severity="4">
               <file path="CODSTA\CODSTA-79.rule"/>
            </rule>
            <rule header="函数的末尾应该有一个单独的出口点" id="15_5" impl="MISRA2004-14_7" originalId="MISRA2004-14_7" quickfix="false" scope="line" severity="4">
               <file path="MISRA2004\MISRA2004-14_7.rule"/>
            </rule>
            <rule header="函数标识符只能与前面的&amp;,或者与带括号的参数列表一起使用" id="17_12" impl="MISRA2004-16_9" originalId="MISRA2004-16_9" quickfix="false" scope="line" severity="4">
               <file path="MISRA2004\MISRA2004-16_9.rule"/>
            </rule>
            <rule header="不应修改函数参数" id="17_8" impl="CODSTA-132" originalId="CODSTA-132" quickfix="false" scope="line" severity="4">
               <file path="CODSTA\CODSTA-132.rule"/>
            </rule>
            <rule header="不应将 +， -， += 和 -= 运算符应用于指针类型的表达式" id="18_4" impl="CODSTA-181" originalId="CODSTA-181" quickfix="false" scope="line" severity="4">
               <file path="CODSTA\CODSTA-181.rule"/>
            </rule>
            <rule header="声明应该包含不超过两层的指针嵌套" id="18_5" impl="MISRA2004-17_5" originalId="MISRA2004-17_5" quickfix="false" scope="line" severity="4">
               <file path="MISRA2004\MISRA2004-17_5.rule"/>
            </rule>
            <rule header="不应该使用 union 关键字" id="19_2" impl="CODSTA-111" originalId="CODSTA-111" quickfix="false" scope="line" severity="4">
               <file path="CODSTA\CODSTA-111.rule"/>
            </rule>
            <rule header="#include 指令前应该只有预处理指令或注释" id="20_1" impl="MISRA2004-19_1" originalId="MISRA2004-19_1" quickfix="false" scope="line" severity="4">
               <file path="MISRA2004\MISRA2004-19_1.rule"/>
            </rule>
            <rule header="不应该使用 # 和 ## 预处理器操作符" id="20_10" impl="MISRA2004-19_13" originalId="MISRA2004-19_13" quickfix="false" scope="line" severity="4">
               <file path="MISRA2004\MISRA2004-19_13.rule"/>
            </rule>
            <rule header="不应该使用 #undef" id="20_5" impl="PREPROC-25" originalId="PREPROC-25" quickfix="false" scope="line" severity="4">
               <file path="PREPROC\PREPROC-25.rule"/>
            </rule>
            <rule header="泛型选择只应从宏中展开" id="23_1" impl="CODSTA-MC-08" originalId="CODSTA-MC-08" quickfix="false" scope="line" severity="4">
               <file path="CODSTA-MC\CODSTA-MC-08.rule"/>
            </rule>
            <rule header="宏定义中使用的泛型选择应该在控制表达式中有一个宏参数" id="23_1_b" impl="CODSTA-MC-10" originalId="CODSTA-MC-10" quickfix="false" scope="line" severity="4">
               <file path="CODSTA-MC\CODSTA-MC-10.rule"/>
            </rule>
            <rule header="泛型选择应该至少包含一个非默认的关联" id="23_3" impl="CODSTA-MC-07" originalId="CODSTA-MC-07" quickfix="false" scope="line" severity="4">
               <file path="CODSTA-MC\CODSTA-MC-07.rule"/>
            </rule>
            <rule header="泛型选择不应该依赖于隐式的指针类型转换" id="23_5" impl="CODSTA-MC-11" originalId="CODSTA-MC-11" quickfix="false" scope="line" severity="4">
               <file path="CODSTA-MC\CODSTA-MC-11.rule"/>
            </rule>
            <rule header="从宏中展开的泛型选择应该只评估一次它的参数" id="23_7" impl="CODSTA-MC-15" originalId="CODSTA-MC-15" quickfix="false" scope="line" severity="4">
               <file path="CODSTA-MC\CODSTA-MC-15.rule"/>
            </rule>
            <rule header="函数不应包含未使用的类型声明" id="2_3_a" impl="CODSTA-175_a" originalId="CODSTA-175_a" quickfix="false" scope="line" severity="4">
               <file path="CODSTA\CODSTA-175_a.rule"/>
            </rule>
            <rule header="源文件不应包含未使用的类型声明" id="2_3_b" impl="CODSTA-175_b" originalId="CODSTA-175_b" quickfix="false" scope="line" severity="4">
               <file path="CODSTA\CODSTA-175_b.rule"/>
            </rule>
            <rule header="函数不应包含未使用的本地标记声明" id="2_4_a" impl="CODSTA-176_a" originalId="CODSTA-176_a" quickfix="false" scope="line" severity="4">
               <file path="CODSTA\CODSTA-176_a.rule"/>
            </rule>
            <rule header="源文件不应包含未使用的标记声明" id="2_4_b" impl="CODSTA-176_b" originalId="CODSTA-176_b" quickfix="false" scope="line" severity="4">
               <file path="CODSTA\CODSTA-176_b.rule"/>
            </rule>
            <rule header="源文件不应包含未使用的宏定义" id="2_5" impl="CODSTA-177" originalId="CODSTA-177" quickfix="false" scope="line" severity="4">
               <file path="CODSTA\CODSTA-177.rule"/>
            </rule>
            <rule header="函数不应包含未使用的标签声明" id="2_6" impl="OPT-37" originalId="OPT-37" quickfix="false" scope="line" severity="4">
               <file path="OPT\OPT-37.rule"/>
            </rule>
            <rule header="函数中应该没有未使用的参数" id="2_7" impl="OPT-38" originalId="OPT-38" quickfix="false" scope="line" severity="4">
               <file path="OPT\OPT-38.rule"/>
            </rule>
            <rule header="项目不应包含有内部链接的未使用变量" id="2_8_b" impl="OPT-43" originalId="OPT-43" quickfix="false" scope="line" severity="4">
               <file path="OPT\OPT-43.rule"/>
            </rule>
            <rule header="避免未使用的局部变量" id="2_8_c" impl="OPT-02" originalId="OPT-02" quickfix="false" scope="line" severity="4">
               <file path="OPT\OPT-02.rule"/>
            </rule>
            <rule header="不应使用三联符" id="4_2" impl="MISRA2004-4_2" originalId="MISRA2004-4_2" quickfix="false" scope="line" severity="4">
               <file path="MISRA2004\MISRA2004-4_2.rule"/>
            </rule>
            <rule header="不应使用最小宽度的整数常数宏的小整数变体" id="7_6" impl="CODSTA-220_b" originalId="CODSTA-220_b" quickfix="false" scope="line" severity="4">
               <file path="CODSTA\CODSTA-220_b.rule"/>
            </rule>
            <rule header="当声明具有外部链接的数组时，应明确指定其大小" id="8_11" impl="MISRA2004-8_12" originalId="MISRA2004-8_12" quickfix="false" scope="line" severity="4">
               <file path="MISRA2004\MISRA2004-8_12.rule"/>
            </rule>
            <rule header="如果指针不用于修改被寻址的对象，则应将函数原型中的指针参数声明为指向 const 的指针" id="8_13_a" impl="MISRA2004-16_7" originalId="MISRA2004-16_7" quickfix="false" scope="line" severity="4">
               <file path="MISRA2004\MISRA2004-16_7.rule"/>
            </rule>
            <rule header="如果指针不用于修改被寻址的对象，则将参数类型声明为 typedef 以指向 const" id="8_13_b" impl="MISRA2004-16_7_b" originalId="MISRA2004-16_7_b" quickfix="false" scope="line" severity="4">
               <file path="MISRA2004\MISRA2004-16_7_b.rule"/>
            </rule>
            <rule header="零的对齐规范不应出现在对象声明中" id="8_16" impl="CODSTA-MC-03" originalId="CODSTA-MC-03" quickfix="false" scope="line" severity="4">
               <file path="CODSTA-MC\CODSTA-MC-03.rule"/>
            </rule>
            <rule header="在一个对象的声明中，最多只能出现一个明确的对齐说明符" id="8_17" impl="CODSTA-MC-02" originalId="CODSTA-MC-02" quickfix="false" scope="line" severity="4">
               <file path="CODSTA-MC\CODSTA-MC-02.rule"/>
            </rule>
            <rule header="如果对象的标识符仅出现在单个函数中，则应在块作用域中定义该对象" id="8_9" impl="MISRA2004-8_7" originalId="MISRA2004-8_7" quickfix="false" scope="line" severity="4">
               <file path="MISRA2004\MISRA2004-8_7.rule"/>
            </rule>
         </category>
         <category description="MISRA C 2012 指令" name="DIR">
            <rule header="应采取预防措施，以防止头文件的内容被包含多次" id="4_10" impl="PFO-02" originalId="PFO-02" quickfix="false" scope="line" severity="2">
               <file path="PFO\PFO-02.rule"/>
            </rule>
            <rule header="不应使用动态内存分配" id="4_12" impl="MISRA2004-20_4" originalId="MISRA2004-20_4" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-20_4.rule"/>
            </rule>
            <rule header="汇编语言应该被封装和隔离" id="4_3" impl="MISRA2004-2_1" originalId="MISRA2004-2_1" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-2_1.rule"/>
            </rule>
            <rule header="所有汇编语言的使用都应记录下来" id="4_2" impl="COMMENT-09" originalId="COMMENT-09" quickfix="false" scope="line" severity="4">
               <file path="COMMENT\COMMENT-09.rule"/>
            </rule>
            <rule header="代码部分不应是 &quot;添加注释&quot;" id="4_4" impl="MISRA2004-2_4" originalId="MISRA2004-2_4" quickfix="false" scope="line" severity="4">
               <file path="MISRA2004\MISRA2004-2_4.rule"/>
            </rule>
            <rule header="在具有重叠可见性的同一名称空间中，标识符应在字面上是无歧义的" id="4_5" impl="NAMING-50" originalId="NAMING-50" quickfix="false" scope="line" severity="4">
               <file path="NAMING\NAMING-50.rule"/>
            </rule>
            <rule header="应该在基本类型 typedef 的名称中包含一些数字" id="4_6_a" impl="MISRA2004-6_3" originalId="MISRA2004-6_3" quickfix="false" scope="line" severity="4">
               <file path="MISRA2004\MISRA2004-6_3.rule"/>
            </rule>
            <rule header="typedef 应该被用来代替基本类型" id="4_6_b" impl="MISRA2004-6_3_b" originalId="MISRA2004-6_3_b" quickfix="false" scope="line" severity="4">
               <file path="MISRA2004\MISRA2004-6_3_b.rule"/>
            </rule>
            <rule header="应使用 stdint.h 中的 typedef，而不是用在 C99代码中自己声明的" id="4_6_c" impl="CODSTA-155" originalId="CODSTA-155" quickfix="false" scope="line" severity="4">
               <file path="CODSTA\CODSTA-155.rule"/>
            </rule>
            <rule header="如果指向结构或联合的指针从未在编译单元中解引用，那么对象的实现就被应该隐藏起来" id="4_8" impl="CODSTA-115" originalId="CODSTA-115" quickfix="false" scope="line" severity="4">
               <file path="CODSTA\CODSTA-115.rule"/>
            </rule>
            <rule header="当可互换的时候，比起类函数宏， 应优先使用函数" id="4_9" impl="MISRA2004-19_7" originalId="MISRA2004-19_7" quickfix="false" scope="line" severity="4">
               <file path="MISRA2004\MISRA2004-19_7.rule"/>
            </rule>
         </category>
      </category>
      <category description="MISRA C 2023 (MISRA C 2012)" name="MISRAC2012">
         <category description="Rule 12.5（强制）sizeof 运算符不应有被声明为 &quot;数组类型&quot; 的函数参数的操作数" name="RULE_12_5">
            <rule header="运算符'sizeof'的操作数不能是声明为&quot;array of type&quot;的函数参数" id="a" impl="CODSTA-182" originalId="CODSTA-182" quickfix="false" scope="line" severity="1">
               <file path="CODSTA\CODSTA-182.rule"/>
            </rule>
         </category>
         <category description="Rule 17.3（强制）函数不能隐式声明" name="RULE_17_3">
            <rule header="在函数调用时，函数总是有可见的原型" id="a" impl="MISRA-071_b" originalId="MISRA-071_b" quickfix="false" scope="line" severity="1">
               <file path="MISRA\MISRA-071_b.rule"/>
            </rule>
         </category>
         <category description="Rule 17.4（强制）所有 non-void 返回类型函数的出口路径都应具有带表达式的显式返回语句" name="RULE_17_4">
            <rule header="具有非空返回类型的函数的所有退出路径都应该有一个带有表达式的显式返回语句" id="a" impl="MISRA2004-16_8" originalId="MISRA2004-16_8" quickfix="false" scope="line" severity="1">
               <file path="MISRA2004\MISRA2004-16_8.rule"/>
            </rule>
            <rule header="具有非 void 返回类型的函数的所有退出路径，除 main() 外，都应具有带有表达式的显式返回语句" id="b" impl="MISRA2004-16_8_b" originalId="MISRA2004-16_8_b" quickfix="false" scope="line" severity="1">
               <file path="MISRA2004\MISRA2004-16_8_b.rule"/>
            </rule>
         </category>
         <category description="Rule 17.6（强制）数组参数的声明不应在 [ ] 之间包含静态关键字" name="RULE_17_6">
            <rule header="数组参数的声明不得在 [ ] 之间包含 'static' 关键字" id="a" impl="CODSTA-160" originalId="CODSTA-160" quickfix="false" scope="line" severity="1">
               <file path="CODSTA\CODSTA-160.rule"/>
            </rule>
         </category>
         <category description="Rule 18.10 (强制) 不应使用指向可变修改的数组类型的指针" name="RULE_18_10">
            <rule header="不应使用指向可变修改数组类型的指针" id="a" impl="CODSTA-112_b" originalId="CODSTA-112_b" quickfix="false" scope="line" severity="1">
               <file path="CODSTA\CODSTA-112_b.rule"/>
            </rule>
         </category>
         <category description="Rule 19.1（强制）一个对象不应被分配或复制到一个重叠的对象上" name="RULE_19_1">
            <rule header="不应该将结构体自身的一个成员变量赋给另一个成员变量" id="a" impl="MISRA2004-18_2" originalId="MISRA2004-18_2" quickfix="false" scope="line" severity="1">
               <file path="MISRA2004\MISRA2004-18_2.rule"/>
            </rule>
            <rule header="结构体的每个成员不应该赋值给自己的其他成员变量" id="b" impl="MISRA2004-18_2_b" originalId="MISRA2004-18_2_b" quickfix="false" scope="line" severity="1">
               <file path="MISRA2004\MISRA2004-18_2_b.rule"/>
            </rule>
         </category>
         <category description="Rule 21.19（强制）标准库函数localeconv，getenv，setlocale或strerror返回的指针只能用作指向 const 限定类型的指针" name="RULE_21_19">
            <rule header="标准库函数 'localeconv', 'getenv', 'setlocale' 或 'strerror' 返回的指针仅当它们具有指向 const 限定类型的指针时使用" id="a" impl="CODSTA-185_a" originalId="CODSTA-185_a" quickfix="false" scope="line" severity="1">
               <file path="CODSTA\CODSTA-185_a.rule"/>
            </rule>
            <rule header="由结构体 'lconv' 的成员指向的字符串不应该被修改" id="b" impl="CODSTA-185_b" originalId="CODSTA-185_b" quickfix="false" scope="line" severity="1">
               <file path="CODSTA\CODSTA-185_b.rule"/>
            </rule>
         </category>
         <category description="Rule 21.22 (强制) 在&lt;tgmath.h&gt;中声明的任何通用类型宏的所有参数应具有适当的基本类型" name="RULE_21_22">
            <rule header="在&lt;tgmath.h&gt;中声明的任何通用类型宏的所有参数都应具有适当的基本类型" id="a" impl="CODSTA-108_c" originalId="CODSTA-108_c" quickfix="false" scope="line" severity="1">
               <file path="CODSTA\CODSTA-108_c.rule"/>
            </rule>
         </category>
         <category description="Rule 22.12 (强制) 线程对象、线程同步对象和线程特有存储指针只能由相应的标准库函数访问" name="RULE_22_12">
            <rule header="线程对象、线程同步对象和线程特有存储指针只能由相应的标准库函数访问" id="a" impl="CODSTA-MC-22" originalId="CODSTA-MC-22" quickfix="false" scope="line" severity="1">
               <file path="CODSTA-MC\CODSTA-MC-22.rule"/>
            </rule>
         </category>
         <category description="Rule 22.14 (强制) 线程同步对象在访问之前应先初始化" name="RULE_22_14">
            <rule header="传递给 'mtx_init()' 函数的第二参数应为 'mtx_plain', 'mtx_timed', 'mtx_plain | mtx_recursive', 或 'mtx_timed | mtx_recursive'" id="b" impl="CODSTA-MC-21" originalId="CODSTA-MC-21" quickfix="false" scope="line" severity="1">
               <file path="CODSTA-MC\CODSTA-MC-21.rule"/>
            </rule>
         </category>
         <category description="Rule 22.5（强制）指向 FILE 对象的指针不得解除引用" name="RULE_22_5">
            <rule header="指向 FILE 对象的指针不应被解引用" id="a" impl="CODSTA-166_a" originalId="CODSTA-166_a" quickfix="false" scope="line" severity="1">
               <file path="CODSTA\CODSTA-166_a.rule"/>
            </rule>
            <rule header="指向 FILE 对象的指针不应由库函数解引用" id="b" impl="CODSTA-166_b" originalId="CODSTA-166_b" quickfix="false" scope="line" severity="1">
               <file path="CODSTA\CODSTA-166_b.rule"/>
            </rule>
         </category>
         <category description="Rule 7.5 (强制) 整数常数宏的参数应具有适当的形式" name="RULE_7_5">
            <rule header="整数常量宏的参数应为具有适当值的十进制，八进制或十六进制常量" id="a" impl="CODSTA-220" originalId="CODSTA-220" quickfix="false" scope="line" severity="1">
               <file path="CODSTA\CODSTA-220.rule"/>
            </rule>
         </category>
         <category description="Dir 4.10（必需）应采取预防措施，以防止头文件的内容被包含多次" name="DIR_4_10">
            <rule header="使用多个包含保护" id="a" impl="PFO-02" originalId="PFO-02" quickfix="false" scope="line" severity="2">
               <file path="PFO\PFO-02.rule"/>
            </rule>
         </category>
         <category description="Dir 4.12（必需）不应使用动态内存分配" name="DIR_4_12">
            <rule header="不应使用动态堆内存分配" id="a" impl="MISRA2004-20_4" originalId="MISRA2004-20_4" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-20_4.rule"/>
            </rule>
         </category>
         <category description="Dir 4.3（必需）汇编语言应封装和隔离" name="DIR_4_3">
            <rule header="汇编代码应该是封装且独立的" id="a" impl="MISRA2004-2_1" originalId="MISRA2004-2_1" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-2_1.rule"/>
            </rule>
         </category>
         <category description="Rule 10.1（必需）操作对象应是适当的基本类型" name="RULE_10_1">
            <rule header="当操作数被解释为布尔值时，应使用基本布尔类型的表达式" id="a" impl="CODSTA-161_a" originalId="CODSTA-161_a" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-161_a.rule"/>
            </rule>
            <rule header="当操作数被解释为数值时，不应使用本质上为布尔类型的操作数当操作数被解释为数值时，不应使用本质上为布尔类型的操作数" id="b" impl="CODSTA-161_b" originalId="CODSTA-161_b" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-161_b.rule"/>
            </rule>
            <rule header="字符类型的操作数不应该用在需要数类型的地方" id="c" impl="CODSTA-161_c" originalId="CODSTA-161_c" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-161_c.rule"/>
            </rule>
            <rule header="在算术运算中不应该使用枚举类型" id="d" impl="CODSTA-161_d" originalId="CODSTA-161_d" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-161_d.rule"/>
            </rule>
            <rule header="不要对有符号类型和枚举类型使用移位和位运算" id="e" impl="CODSTA-161_e" originalId="CODSTA-161_e" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-161_e.rule"/>
            </rule>
            <rule header="本质上带符号或枚举类型的操作数不应用作移位操作符的右侧操作数" id="f" impl="CODSTA-161_f" originalId="CODSTA-161_f" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-161_f.rule"/>
            </rule>
            <rule header="一元减运算符的操作数不应该是无符号类型" id="g" impl="CODSTA-161_g" originalId="CODSTA-161_g" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-161_g.rule"/>
            </rule>
            <rule header="不得显示（语法上）测试浮点表达式的等号（==）或不等号（！=）" id="h" impl="CODSTA-225" originalId="CODSTA-225" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-225.rule"/>
            </rule>
         </category>
         <category description="Rule 10.2（必需）在加法和减法运算中，基本字符类型的表达式要使用得当" name="RULE_10_2">
            <rule header="基本字符类型表达式不能用于加减运算符" id="a" impl="CODSTA-162" originalId="CODSTA-162" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-162.rule"/>
            </rule>
         </category>
         <category description="Rule 10.3（必需）表达式的值不应赋给更窄的基本类型或不同的基本类型类别的对象" name="RULE_10_3">
            <rule header="表达式的值不能赋给更小基本类型的对象" id="a" impl="CODSTA-163_a" originalId="CODSTA-163_a" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-163_a.rule"/>
            </rule>
            <rule header="表达式的值不应分配给不同基本类型类别的对象" id="b" impl="CODSTA-163_b" originalId="CODSTA-163_b" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-163_b.rule"/>
            </rule>
         </category>
         <category description="Rule 10.4（必需）在执行的常见算术转换中，运算符的两个操作数应具有相同的基本类型类别" name="RULE_10_4">
            <rule header="执行常规算术转换的运算符的两个操作数应具有相同的基本类型类别" id="a" impl="CODSTA-164_a" originalId="CODSTA-164_a" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-164_a.rule"/>
            </rule>
            <rule header="第二个和第三个三元操作符的操作数有相同的基本类型类别" id="b" impl="CODSTA-164_b" originalId="CODSTA-164_b" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-164_b.rule"/>
            </rule>
         </category>
         <category description="Rule 10.6（必需）复合表达式的值不应赋给具有更广泛的基本类型的对象" name="RULE_10_6">
            <rule header="复合表达式的值不应该赋值给宽数据类型的一个对象" id="a" impl="CODSTA-157" originalId="CODSTA-157" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-157.rule"/>
            </rule>
         </category>
         <category description="Rule 10.7（必需）在执行通常的算术转换中，如果一个复合表达式被用作运算符的一个操作数，那么另一个操作数不应具有更广泛的基本类型" name="RULE_10_7">
            <rule header="如果复合表达式用作执行通常算术转换的运算符的一个操作数，则另一个操作数不应具有更广泛的基本类型" id="a" impl="CODSTA-156_a" originalId="CODSTA-156_a" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-156_a.rule"/>
            </rule>
            <rule header="如果复合表达式用作执行通常算术转换的运算符的第一个(第二个或第三个)操作数，则另一个操作数不应具有更广泛的基本类型" id="b" impl="CODSTA-156_b" originalId="CODSTA-156_b" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-156_b.rule"/>
            </rule>
         </category>
         <category description="Rule 10.8（必需）复合表达式的值不应转换为不同的基本类型类别或更广泛的基本类型" name="RULE_10_8">
            <rule header="复合表达式的值不得传递给一个不同的基本类型类别或更广泛的基本类型" id="a" impl="CODSTA-152" originalId="CODSTA-152" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-152.rule"/>
            </rule>
         </category>
         <category description="Rule 11.1（必需）转换不能发生在函数指针和任何其他类型指针之间" name="RULE_11_1">
            <rule header="不得在指向函数的指针与指向函数的指针以外的任何类型之间执行转换" id="a" impl="CODSTA-124_a" originalId="CODSTA-124_a" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-124_a.rule"/>
            </rule>
            <rule header="函数类型的不兼容指针之间不能进行转换" id="b" impl="CODSTA-124_b" originalId="CODSTA-124_b" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-124_b.rule"/>
            </rule>
         </category>
         <category description="Rule 11.10 (必需) _Atomic 限定符不应适用于不完整的类型 void" name="RULE_11_10">
            <rule header="'_Atomic' 限定符不应与 'void' 一起使用" id="a" impl="CODSTA-MC-16" originalId="CODSTA-MC-16" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MC\CODSTA-MC-16.rule"/>
            </rule>
         </category>
         <category description="Rule 11.2（必需）转换不能发生在不完整类型指针和任何其他类型指针之间" name="RULE_11_2">
            <rule header="不能在指向不完整类型的指针和任何其他类型的指针之间进行转换" id="a" impl="CODSTA-125" originalId="CODSTA-125" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-125.rule"/>
            </rule>
         </category>
         <category description="Rule 11.3（必需）不应在某类型对象指针和不同类型对象指针之间进行转换" name="RULE_11_3">
            <rule header="不得在指向对象类型的指针和指向不同对象类型的指针之间执行强制转换" id="a" impl="CODSTA-126" originalId="CODSTA-126" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-126.rule"/>
            </rule>
         </category>
         <category description="Rule 11.6（必需）不应在 void 指针和算术类型之间进行强制转换" name="RULE_11_6">
            <rule header="不能在指向 void 的指针和算术类型之间执行强制类型转换" id="a" impl="CODSTA-129_a" originalId="CODSTA-129_a" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-129_a.rule"/>
            </rule>
         </category>
         <category description="Rule 11.7（必需）不应在对象指针和非整数算术类型之间进行强制转换" name="RULE_11_7">
            <rule header="不应在指向对象的指针和非整数算术类型之间执行强制转换" id="a" impl="CODSTA-130" originalId="CODSTA-130" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-130.rule"/>
            </rule>
         </category>
         <category description="Rule 11.9（必需）宏指令 NULL 应是整数空指针常量的唯一允许形式" name="RULE_11_9">
            <rule header="字面量 （0） 不应用作空指针常数" id="a" impl="CODSTA-CPP-63" originalId="CODSTA-CPP-63" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-63.rule"/>
            </rule>
            <rule header="使用 NULL 而不是文本零 （0） 作为空指针常量" id="b" impl="CODSTA-131" originalId="CODSTA-131" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-131.rule"/>
            </rule>
         </category>
         <category description="Rule 12.6 (必需) 原子对象的结构体和联合体成员不得直接访问" name="RULE_12_6">
            <rule header="结构和联合类型原子对象的成员不应直接访问" id="a" impl="CODSTA-MC-17" originalId="CODSTA-MC-17" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MC\CODSTA-MC-17.rule"/>
            </rule>
         </category>
         <category description="Rule 13.1（必需）初始化器列表不要包含持续性副作用" name="RULE_13_1">
            <rule header="初始化器列表不应该包含持久的副作用" id="a" impl="CODSTA-141_a" originalId="CODSTA-141_a" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-141_a.rule"/>
            </rule>
         </category>
         <category description="Rule 13.2（必需）在所有允许的求值顺序下，表达式的值及其持续性副作用应相同并独立于线程交叉" name="RULE_13_2">
            <rule header="表达式的值应该在任何标准允许的赋值顺序下是一样的" id="a" impl="MISRA2004-12_2_a" originalId="MISRA2004-12_2_a" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-12_2_a.rule"/>
            </rule>
            <rule header="不要编写依赖于函数参数求值顺序的代码" id="b" impl="MISRA2004-12_2_b" originalId="MISRA2004-12_2_b" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-12_2_b.rule"/>
            </rule>
            <rule header="不要编写依赖于函数标志符和函数参数的求值顺序的代码" id="c" impl="MISRA2004-12_2_c" originalId="MISRA2004-12_2_c" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-12_2_c.rule"/>
            </rule>
            <rule header="涉及一个函数调用时，不要编写依赖表达式求值顺序的代码" id="d" impl="MISRA2004-12_2_d" originalId="MISRA2004-12_2_d" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-12_2_d.rule"/>
            </rule>
            <rule header="在序列点之间，对象的存储值最多只能通过表达式的评估来修改一次" id="e" impl="MISRA2004-12_2_e" originalId="MISRA2004-12_2_e" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-12_2_e.rule"/>
            </rule>
            <rule header="不要在两个相邻的序列点之间使用多个 volatile" id="f" impl="MISRA2004-12_2_f" originalId="MISRA2004-12_2_f" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-12_2_f.rule"/>
            </rule>
            <rule header="不要编写依赖于函数调用求值顺序的代码" id="g" impl="MISRA2004-12_2_g" originalId="MISRA2004-12_2_g" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-12_2_g.rule"/>
            </rule>
            <rule header="原子类型的表达式的值应独立于线程交错" id="h" impl="CODSTA-MC-19" originalId="CODSTA-MC-19" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MC\CODSTA-MC-19.rule"/>
            </rule>
         </category>
         <category description="Rule 13.5（必需）逻辑 &amp;&amp; 或 || 运算符的右指针操作数不应包含持续性副作用" name="RULE_13_5">
            <rule header="逻辑&amp;&amp;或||运算符的右操作数不得含有副作用" id="a" impl="MISRA2004-12_4_a" originalId="MISRA2004-12_4_a" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-12_4_a.rule"/>
            </rule>
         </category>
         <category description="Rule 13.6（必需）sizeof 运算符的操作数不应包含任何具有潜在副作用的表达式" name="RULE_13_6">
            <rule header="sizeof 运算符的操作数不应包含任何有副作用的表达式" id="a" impl="MISRA2004-12_3" originalId="MISRA2004-12_3" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-12_3.rule"/>
            </rule>
            <rule header="不应在sizeof运算符的操作数中访问由volatile左值指定的对象" id="b" impl="MISRA2004-12_3_b" originalId="MISRA2004-12_3_b" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-12_3_b.rule"/>
            </rule>
            <rule header="函数调用不得是 sizeof 运算符的操作数" id="c" impl="CODSTA-137" originalId="CODSTA-137" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-137.rule"/>
            </rule>
         </category>
         <category description="Rule 14.1（必需）循环计数器不应该具有基本的浮动类型" name="RULE_14_1">
            <rule header="for循环的循环计数器不能是浮点类型" id="a" impl="CODSTA-167_a" originalId="CODSTA-167_a" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-167_a.rule"/>
            </rule>
            <rule header="在'while' 和 'do-while' 中的循环计数器不要使用浮点类型" id="b" impl="CODSTA-167_b" originalId="CODSTA-167_b" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-167_b.rule"/>
            </rule>
         </category>
         <category description="Rule 14.2（必需）for循环应是格式规范的" name="RULE_14_2">
            <rule header="'for' 循环中只能有一个循环计数器，而不能在 'for' 循环体中进行修改" id="a" impl="CODSTA-168" originalId="CODSTA-168" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-168.rule"/>
            </rule>
            <rule header="for循环的第一个判断条件应该是格式良好的" id="b" impl="CODSTA-169_a" originalId="CODSTA-169_a" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-169_a.rule"/>
            </rule>
            <rule header="'for' 循环的第二个子句应格式正确" id="c" impl="CODSTA-169_b" originalId="CODSTA-169_b" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-169_b.rule"/>
            </rule>
            <rule header="for 循环的第三部分应该是格式良好的" id="d" impl="CODSTA-169_c" originalId="CODSTA-169_c" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-169_c.rule"/>
            </rule>
         </category>
         <category description="Rule 14.4（必需）if 语句的控制表达式和迭代语句的控制表达式应具有 Boolean 类型" name="RULE_14_4">
            <rule header="测试一个值是否为零应该是显式的，除非操作数实际上是布尔值" id="a" impl="MISRA2004-13_2" originalId="MISRA2004-13_2" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-13_2.rule"/>
            </rule>
         </category>
         <category description="Rule 15.2（必需）goto 语句会跳转到之后在相同函数中声明的标签" name="RULE_15_2">
            <rule header="goto 语句应该跳转到同一个函数体中位于 goto 语句后面声明的标签" id="a" impl="CODSTA-77" originalId="CODSTA-77" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-77.rule"/>
            </rule>
         </category>
         <category description="Rule 15.3（必需）goto 语句引用的任何标签都应声明在同一个块中，或在包含goto语句的任何块中" name="RULE_15_3">
            <rule header="任何由 goto 语句引用的标签应该声明在同一个模块中，或者在一个包含 goto 语句的模块中" id="a" impl="CODSTA-78" originalId="CODSTA-78" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-78.rule"/>
            </rule>
         </category>
         <category description="Rule 15.6（必需）迭代语句或选择语句的主体应是复合语句" name="RULE_15_6">
            <rule header="'switch', 'while', 'do...while' 或 'for' 语句的主体应该是复合语句" id="a" impl="MISRA2004-14_8" originalId="MISRA2004-14_8" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-14_8.rule"/>
            </rule>
            <rule header="'if' 和 'else' 语句后应跟一个复合句" id="b" impl="MISRA2004-14_9" originalId="MISRA2004-14_9" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-14_9.rule"/>
            </rule>
         </category>
         <category description="Rule 15.7（必需）所有 if ... else if 结构应以 else 语句结束" name="RULE_15_7">
            <rule header="所有 'if...else-if' 结构应使用一个 'else' 子句终止" id="a" impl="MISRA2004-14_10" originalId="MISRA2004-14_10" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-14_10.rule"/>
            </rule>
         </category>
         <category description="Rule 16.1（必需）所有 switch 语句应是格式规范的" name="RULE_16_1">
            <rule header="switch 语句应该只包含 switch 标签和 switch 子句，不能包含其他代码" id="a" impl="MISRA2004-15_0_b" originalId="MISRA2004-15_0_b" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-15_0_b.rule"/>
            </rule>
            <rule header="只有当最紧密包围的复合语句是 switch 语句的主体时才能使用 switch 标签" id="b" impl="MISRA2004-15_1" originalId="MISRA2004-15_1" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-15_1.rule"/>
            </rule>
            <rule header="无条件的 break 语句应该作为每一个非空 case 子句的结束" id="c" impl="MISRA2004-15_2" originalId="MISRA2004-15_2" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-15_2.rule"/>
            </rule>
            <rule header="无条件的 break 语句应作为所有非空 default 条件的结束" id="d" impl="MISRA2004-15_2_b" originalId="MISRA2004-15_2_b" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-15_2_b.rule"/>
            </rule>
            <rule header="始终为 switch 语句提供一个 default 分支" id="e" impl="CODSTA-35" originalId="CODSTA-35" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-35.rule"/>
            </rule>
            <rule header="'default' 标签在终止 'break' 之前应有声明或注释" id="f" impl="CODSTA-119" originalId="CODSTA-119" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-119.rule"/>
            </rule>
            <rule header="'default' 标签（如果存在）应显示为 switch 语句的第一个或最后一个 switch 标签" id="g" impl="CODSTA-116" originalId="CODSTA-116" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-116.rule"/>
            </rule>
            <rule header="每一个 switch 语句应该含有至少两个 switch 子句" id="h" impl="OPT-39" originalId="OPT-39" quickfix="false" scope="line" severity="2">
               <file path="OPT\OPT-39.rule"/>
            </rule>
         </category>
         <category description="Rule 16.2（必需）switch 标签只能用在当前最紧密封闭的复合语句是 switch 语句的主体的时候" name="RULE_16_2">
            <rule header="只有当最紧密包围的复合语句是 switch 语句的主体时才能使用 switch 标签" id="a" impl="MISRA2004-15_1" originalId="MISRA2004-15_1" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-15_1.rule"/>
            </rule>
         </category>
         <category description="Rule 16.3（必需）无条件的 break 语句应该终止每个 switch 子句" name="RULE_16_3">
            <rule header="无条件的 break 语句应该作为每一个非空 case 子句的结束" id="a" impl="MISRA2004-15_2" originalId="MISRA2004-15_2" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-15_2.rule"/>
            </rule>
            <rule header="无条件的 break 语句应作为所有非空 default 条件的结束" id="b" impl="MISRA2004-15_2_b" originalId="MISRA2004-15_2_b" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-15_2_b.rule"/>
            </rule>
         </category>
         <category description="Rule 16.4（必需）每个 switch 语句都应有 default 标签" name="RULE_16_4">
            <rule header="始终为 switch 语句提供一个 default 分支" id="a" impl="CODSTA-35" originalId="CODSTA-35" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-35.rule"/>
            </rule>
            <rule header="'default' 标签在终止 'break' 之前应有声明或注释" id="b" impl="CODSTA-119" originalId="CODSTA-119" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-119.rule"/>
            </rule>
         </category>
         <category description="Rule 16.5（必需）default 标签应作为 switch 语句中的第一个或最后一个 switch 标签" name="RULE_16_5">
            <rule header="'default' 标签（如果存在）应显示为 switch 语句的第一个或最后一个 switch 标签" id="a" impl="CODSTA-116" originalId="CODSTA-116" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-116.rule"/>
            </rule>
         </category>
         <category description="Rule 16.6（必需）每个 switch 语句都应具有至少两个 switch 子句" name="RULE_16_6">
            <rule header="每一个 switch 语句应该含有至少两个 switch 子句" id="a" impl="OPT-39" originalId="OPT-39" quickfix="false" scope="line" severity="2">
               <file path="OPT\OPT-39.rule"/>
            </rule>
         </category>
         <category description="Rule 16.7（必需）switch 表达式不应具有基本的 Boolean 类型" name="RULE_16_7">
            <rule header="switch 表达式不应该出现一个实际为布尔的值" id="a" impl="MISRA2004-15_4" originalId="MISRA2004-15_4" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-15_4.rule"/>
            </rule>
            <rule header="switch 表达式不应该出现一个实际为布尔的值" id="b" impl="MISRA2004-15_4_b" originalId="MISRA2004-15_4_b" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-15_4_b.rule"/>
            </rule>
         </category>
         <category description="Rule 17.1（必需）不应使用 &lt;stdarg.h&gt; 的特性" name="RULE_17_1">
            <rule header="不应使用标识符 va_list, va_arg, va_start, va_end, va_copy" id="a" impl="CODSTA-136_a" originalId="CODSTA-136_a" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-136_a.rule"/>
            </rule>
            <rule header="不应使用标识符 va_list, va_arg, va_start, va_end" id="b" impl="CODSTA-136_b" originalId="CODSTA-136_b" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-136_b.rule"/>
            </rule>
            <rule header="不应使用标准头文件 &lt;stdarg.h&gt; 或 &lt;cstdarg&gt;" id="c" impl="CODSTA-136_c" originalId="CODSTA-136_c" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-136_c.rule"/>
            </rule>
         </category>
         <category description="Rule 17.10 (必需) 用_Noreturn函数说明符声明的函数应具有void返回类型" name="RULE_17_10">
            <rule header="声明为 'noreturn' 的函数应该具有 'void' 返回类型" id="a" impl="CODSTA-204" originalId="CODSTA-204" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-204.rule"/>
            </rule>
         </category>
         <category description="Rule 17.13 (必需) 一个函数类型不应该被类型限定" name="RULE_17_13">
            <rule header="函数类型的规范中不要包含任何类型限定符" id="a" impl="CODSTA-221" originalId="CODSTA-221" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-221.rule"/>
            </rule>
         </category>
         <category description="Rule 17.2（必需）函数不能调用其本身，不论是直接的还是间接的" name="RULE_17_2">
            <rule header="函数不应该直接或者间接地调用自己" id="a" impl="MISRA2004-16_2" originalId="MISRA2004-16_2" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-16_2.rule"/>
            </rule>
         </category>
         <category description="Rule 17.5（必需）与声明为数组类型的参数对应的函数参数应该有适当数量的元素" name="RULE_17_5">
            <rule header="函数参数对应的数组类型参数应该包含合适数量的元素" id="a" impl="CODSTA-134" originalId="CODSTA-134" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-134.rule"/>
            </rule>
         </category>
         <category description="Rule 17.7（必需）应使用具有 non-void 返回类型的函数的返回值" name="RULE_17_7">
            <rule header="应该使用具有非 void 返回类型的函数返回值" id="a" impl="CODSTA-122_a" originalId="CODSTA-122_a" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-122_a.rule"/>
            </rule>
            <rule header="应使用一个非 void 返回类型函数返回的值" id="b" impl="CODSTA-122_b" originalId="CODSTA-122_b" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-122_b.rule"/>
            </rule>
         </category>
         <category description="Rule 18.6（必需）具有自动存储或线程局域存储功能对象的地址不应复制到在第一个对象停止存在后仍然存在的另一个对象上" name="RULE_18_6">
            <rule header="不得从函数中返回具有自动存储的对象的地址" id="a" impl="MISRA2004-17_6_a" originalId="MISRA2004-17_6_a" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-17_6_a.rule"/>
            </rule>
            <rule header="自动存储对象的地址不应分配给在第一个对象不再存在后可能持久存在的另一个对象" id="b" impl="MISRA2004-17_6_b" originalId="MISRA2004-17_6_b" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-17_6_b.rule"/>
            </rule>
            <rule header="不要将具有线程存储期的对象的地址分配给具有静态存储期的对象" id="c" impl="CODSTA-231" originalId="CODSTA-231" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-231.rule"/>
            </rule>
         </category>
         <category description="Rule 18.7（必需）不应声明灵活的数组成员" name="RULE_18_7">
            <rule header="不得声明灵活的数组成员" id="a" impl="CODSTA-113" originalId="CODSTA-113" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-113.rule"/>
            </rule>
         </category>
         <category description="Rule 18.8（必需）不应使用可变长度数组" name="RULE_18_8">
            <rule header="不应使用变长数组" id="a" impl="CODSTA-112" originalId="CODSTA-112" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-112.rule"/>
            </rule>
         </category>
         <category description="Rule 18.9 (必需) 具有临时生命周期的对象不应进行数组到指针的转换" name="RULE_18_9">
            <rule header="不要修改具有临时生命周期的对象" id="a" impl="CODSTA-196" originalId="CODSTA-196" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-196.rule"/>
            </rule>
         </category>
         <category description="Rule 1.1（必需）程序不应包含 Standard C 的语法和约束的违规，也不应超过实现的编译限制" name="RULE_1_1">
            <rule header="程序不应超过标准 (c90) 强加的转换限制" id="a" impl="CODSTA-174_a_c90" originalId="CODSTA-174_a_c90" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-174_a_c90.rule"/>
            </rule>
            <rule header="程序不应超过施加的标准编译限制 (c99)" id="b" impl="CODSTA-174_a_c99" originalId="CODSTA-174_a_c99" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-174_a_c99.rule"/>
            </rule>
            <rule header="程序不应超过(c90)标准规定的编译限制" id="c" impl="CODSTA-174_b_c90" originalId="CODSTA-174_b_c90" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-174_b_c90.rule"/>
            </rule>
            <rule header="程序不应超过施加的标准编译限制 (c99)" id="d" impl="CODSTA-174_b_c99" originalId="CODSTA-174_b_c99" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-174_b_c99.rule"/>
            </rule>
         </category>
         <category description="Rule 1.3（必需）不得出现未定义的或未指定的行为" name="RULE_1_3">
            <rule header="表达式的值应该在任何标准允许的赋值顺序下是一样的" id="f" impl="MISRA2004-12_2_a" originalId="MISRA2004-12_2_a" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-12_2_a.rule"/>
            </rule>
            <rule header="不要编写依赖于函数参数求值顺序的代码" id="g" impl="MISRA2004-12_2_b" originalId="MISRA2004-12_2_b" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-12_2_b.rule"/>
            </rule>
            <rule header="不要编写依赖于函数标志符和函数参数的求值顺序的代码" id="h" impl="MISRA2004-12_2_c" originalId="MISRA2004-12_2_c" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-12_2_c.rule"/>
            </rule>
            <rule header="涉及一个函数调用时，不要编写依赖表达式求值顺序的代码" id="i" impl="MISRA2004-12_2_d" originalId="MISRA2004-12_2_d" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-12_2_d.rule"/>
            </rule>
            <rule header="在序列点之间，对象的存储值最多只能通过表达式的评估来修改一次" id="j" impl="MISRA2004-12_2_e" originalId="MISRA2004-12_2_e" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-12_2_e.rule"/>
            </rule>
            <rule header="不要在两个相邻的序列点之间使用多个 volatile" id="k" impl="MISRA2004-12_2_f" originalId="MISRA2004-12_2_f" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-12_2_f.rule"/>
            </rule>
            <rule header="不要编写依赖于函数调用求值顺序的代码" id="l" impl="MISRA2004-12_2_g" originalId="MISRA2004-12_2_g" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-12_2_g.rule"/>
            </rule>
            <rule header="不得从函数中返回具有自动存储的对象的地址" id="m" impl="MISRA2004-17_6_a" originalId="MISRA2004-17_6_a" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-17_6_a.rule"/>
            </rule>
            <rule header="自动存储对象的地址不应分配给在第一个对象不再存在后可能持久存在的另一个对象" id="n" impl="MISRA2004-17_6_b" originalId="MISRA2004-17_6_b" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-17_6_b.rule"/>
            </rule>
            <rule header="右移位操作符的左操作数不能是负数" id="o" impl="PB-29" originalId="PB-29" quickfix="false" scope="line" severity="2">
               <file path="PB\PB-29.rule"/>
            </rule>
         </category>
         <category description="Rule 1.4（必需）不得使用新兴的语言功能" name="RULE_1_4">
            <rule header="宏 '__STDC_WANT_LIB_EXT1__' 不应定义为 '0' 以外的值" id="j" impl="CODSTA-215" originalId="CODSTA-215" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-215.rule"/>
            </rule>
            <rule header="不应使用 “rsize_t” 类型" id="k" impl="CODSTA-212" originalId="CODSTA-212" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-212.rule"/>
            </rule>
            <rule header="不应该使用 'errno_t' 类型" id="l" impl="CODSTA-217" originalId="CODSTA-217" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-217.rule"/>
            </rule>
            <rule header="不要使用以下宏：RSIZE_MAX，L_tmpnam_s，TMP_MAX_S" id="m" impl="CODSTA-218" originalId="CODSTA-218" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-218.rule"/>
            </rule>
            <rule header="不使用 ISO/IEC 9899:2011 标准的附件 K 中定义的函数" id="n" impl="CODSTA-219" originalId="CODSTA-219" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-219.rule"/>
            </rule>
         </category>
         <category description="Rule 1.5 (必需) 不应使用过时的语言功能" name="RULE_1_5">
            <rule header="静态存储类说明符应该用于具有内部链接的对象和函数的定义和声明" id="a" impl="MISRA2004-8_11" originalId="MISRA2004-8_11" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-8_11.rule"/>
            </rule>
            <rule header="存储类型修饰符应该关联类型，而不是变量或函数" id="b" impl="CODSTA-10" originalId="CODSTA-10" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-10.rule"/>
            </rule>
            <rule header="函数类型应当为原型形式" id="c" impl="CODSTA-159" originalId="CODSTA-159" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-159.rule"/>
            </rule>
            <rule header="不要使用宏 ATOMIC_VAR_INIT" id="d" impl="CODSTA-209_b" originalId="CODSTA-209_b" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-209_b.rule"/>
            </rule>
            <rule header="不要在 #undef 指令中使用'bool'、'false'或'true'标识符" id="e" impl="PREPROC-27" originalId="PREPROC-27" quickfix="false" scope="line" severity="2">
               <file path="PREPROC\PREPROC-27.rule"/>
            </rule>
         </category>
         <category description="Rule 20.11（必需）紧跟在 # 运算符后面的宏参数不应该紧跟在 ## 运算符后" name="RULE_20_11">
            <rule header="一个紧跟在 # 操作符的宏参数不应该在其后紧跟或在其前加上 ## 操作符" id="a" impl="PREPROC-16" originalId="PREPROC-16" quickfix="false" scope="line" severity="2">
               <file path="PREPROC\PREPROC-16.rule"/>
            </rule>
         </category>
         <category description="Rule 20.12（必需）作为 # 或 ## 运算符的操作数使用的宏参数只能作为这些运算符的操作数使用，其本身要进行进一步的宏替换" name="RULE_20_12">
            <rule header="一个被用作 # 或者 ## 操作符的操作数的宏参数，并且它本身受制于进一步的宏替换，那么它应该只能被用作这些操作符的操作数" id="a" impl="PREPROC-17" originalId="PREPROC-17" quickfix="false" scope="line" severity="2">
               <file path="PREPROC\PREPROC-17.rule"/>
            </rule>
         </category>
         <category description="Rule 20.13（必需）第一个令牌为 # 的行应是有效的预处理指令" name="RULE_20_13">
            <rule header="预处理指令即使被预处理程序排除,在语法上也是有意义的" id="a" impl="MISRA2004-19_16" originalId="MISRA2004-19_16" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-19_16.rule"/>
            </rule>
         </category>
         <category description="Rule 20.14（必需）所有 #else， #elif 和 #endif 预处理器指令应该与它们相关的 #if， #ifdef 或 #ifndef 指令放在同一个文件里" name="RULE_20_14">
            <rule header="在同一个文件中 #else, #elif 和 #endif 必须对应有 #if 或 #ifdef 预处理指令" id="a" impl="MISRA2004-19_17" originalId="MISRA2004-19_17" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-19_17.rule"/>
            </rule>
         </category>
         <category description="Rule 20.2（必需）'， &quot; 或 \ 字符 和  /* 或 // 字符序列不应出现在一个头文件名中" name="RULE_20_2">
            <rule header="字符 ', &quot;, /* 或 // 不得出现在头文件的名称中" id="a" impl="NAMING-46" originalId="NAMING-46" quickfix="false" scope="line" severity="2">
               <file path="NAMING\NAMING-46.rule"/>
            </rule>
            <rule header="字符 \ 不得出现在头文件的名称中" id="b" impl="NAMING-48" originalId="NAMING-48" quickfix="false" scope="line" severity="2">
               <file path="NAMING\NAMING-48.rule"/>
            </rule>
         </category>
         <category description="Rule 20.3（必需）#include指令后面应该跟着 &lt;filename&gt; 或 &quot;filename&quot; 序列" name="RULE_20_3">
            <rule header="#include 指令后面应当添加 &lt;filename&gt; 或是 &quot;filename&quot;" id="a" impl="MISRA-089" originalId="MISRA-089" quickfix="false" scope="line" severity="2">
               <file path="MISRA\MISRA-089.rule"/>
            </rule>
         </category>
         <category description="Rule 20.4（必需）宏不能与关键字同名" name="RULE_20_4">
            <rule header="C90中规定宏不应该与关键字定义为相同名称" id="a" impl="CODSTA-133_a" originalId="CODSTA-133_a" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-133_a.rule"/>
            </rule>
            <rule header="C99中规定宏不应该与关键字定义为相同名称" id="b" impl="CODSTA-133_b" originalId="CODSTA-133_b" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-133_b.rule"/>
            </rule>
         </category>
         <category description="Rule 20.6（必需）看起来像预处理指令的令牌不应出现在宏参数中" name="RULE_20_6">
            <rule header="类似函数的宏的参数不应该包含类似预处理命令的标识" id="a" impl="MISRA2004-19_9" originalId="MISRA2004-19_9" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-19_9.rule"/>
            </rule>
         </category>
         <category description="Rule 20.7（必需）宏参数展开产生的表达式应括在括号中" name="RULE_20_7">
            <rule header="在类函数宏指令的定义中，参数的每个实例都应该用圆括号括起来，除非它用作 # 或者 ## 的运算对象" id="a" impl="MISRA2004-19_10" originalId="MISRA2004-19_10" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-19_10.rule"/>
            </rule>
         </category>
         <category description="Rule 20.8（必需）#if 或 #elif 预处理指令的控制表达式应取值为 0 或 1" name="RULE_20_8">
            <rule header="#if 或 #elif 预处理指令的控制表达式应评估为 0 或 1" id="a" impl="PREPROC-19" originalId="PREPROC-19" quickfix="false" scope="line" severity="2">
               <file path="PREPROC\PREPROC-19.rule"/>
            </rule>
         </category>
         <category description="Rule 20.9（必需）在 #if 或 #elif 预处理指令的控制表达式中使用的所有标识符都应该在计算前进行 #define'd" name="RULE_20_9">
            <rule header="不要使用在编译单元中未定义的预编译器指令 #if 和 #elif  宏" id="b" impl="MISRA2004-19_11_b" originalId="MISRA2004-19_11_b" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-19_11_b.rule"/>
            </rule>
         </category>
         <category description="Rule 21.1（必需）#define 和 #undef 不应用于存储标识符或宏的名称" name="RULE_21_1">
            <rule header="不要使用以下划线开头的带有#define 或 #undef 名称的标识符" id="a" impl="MISRA2004-20_1_a" originalId="MISRA2004-20_1_a" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-20_1_a.rule"/>
            </rule>
            <rule header="不应定义、重新定义、未定义标准程序库中的保留标识符、宏以及函数（C90代码）" id="b" impl="CODSTA-92_a" originalId="CODSTA-92_a" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-92_a.rule"/>
            </rule>
            <rule header="不应定义、重新定义、未定义标准库中的保留标识符、宏和函数(C99 code)" id="c" impl="CODSTA-92_b" originalId="CODSTA-92_b" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-92_b.rule"/>
            </rule>
            <rule header="不使用 #define 或 #undef 标识符 'defined'" id="d" impl="MISRA2004-20_1_e" originalId="MISRA2004-20_1_e" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-20_1_e.rule"/>
            </rule>
         </category>
         <category description="Rule 21.10（必需）不要使用标准库的时间和日期函数" name="RULE_21_10">
            <rule header="不应使用标准头文件 &lt;time.h&gt; 或 &lt;ctime&gt;" id="a" impl="MISRA2004-20_12" originalId="MISRA2004-20_12" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-20_12.rule"/>
            </rule>
            <rule header="不应使用库 &lt;time.h&gt; 中的时间处理函数和宏" id="b" impl="MISRA2004-20_12_b" originalId="MISRA2004-20_12_b" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-20_12_b.rule"/>
            </rule>
            <rule header="不应使用库 &lt;time.h&gt; 中定义的类型" id="c" impl="MISRA2004-20_12_c" originalId="MISRA2004-20_12_c" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-20_12_c.rule"/>
            </rule>
         </category>
         <category description="Rule 21.11（必需）不要使用标准头文件 &lt;tgmath.h&gt;" name="RULE_21_11">
            <rule header="不得使用标准头文件 &lt;tgmath.h&gt;" id="a" impl="CODSTA-108" originalId="CODSTA-108" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-108.rule"/>
            </rule>
         </category>
         <category description="Rule 21.12 (必需) 不应使用标准头文件 &lt;fenv.h&gt; " name="RULE_21_12">
            <rule header="&lt;fenv.h&gt; 提供的功能不应被使用" id="a" impl="CODSTA-109" originalId="CODSTA-109" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-109.rule"/>
            </rule>
            <rule header="标准头文件 &lt;fenv.h&gt; 不应被使用" id="b" impl="CODSTA-109_b" originalId="CODSTA-109_b" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-109_b.rule"/>
            </rule>
         </category>
         <category description="Rule 21.15（必需）Standard Library 函数 memcpy， memmove 和 memcmp 的指针参数应是 兼容类型的限定或非限定版本指针" name="RULE_21_15">
            <rule header="标准库函数 'memcmp', 'memmove' and 'memcmp' 的指针参数应该指向兼容的类型" id="a" impl="CODSTA-183" originalId="CODSTA-183" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-183.rule"/>
            </rule>
         </category>
         <category description="Rule 21.16（必需）Standard Library 函数 memcmp 的指针参数应是指针类型，有符号类型，无符号类型， Boolean 类型或枚举类型中的一个" name="RULE_21_16">
            <rule header="传入标准库函数 'memcmp' 的指针参数不能指向指针类型、无符号类型、有符号类型、布尔类型或枚举类型" id="a" impl="CODSTA-184" originalId="CODSTA-184" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-184.rule"/>
            </rule>
         </category>
         <category description="Rule 21.2（必需）不要声明已存储标识符或宏的名称" name="RULE_21_2">
            <rule header="标准库宏、对象和函数的名称不应该被重用" id="a" impl="MISRA2004-20_2" originalId="MISRA2004-20_2" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-20_2.rule"/>
            </rule>
            <rule header="不应该重复使用标准库中的宏，对象和函数(C90)" id="b" impl="MISRA2004-20_2_a" originalId="MISRA2004-20_2_a" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-20_2_a.rule"/>
            </rule>
            <rule header="标准库宏，对象和函数的名称不得重复使用（C99）" id="c" impl="MISRA2004-20_2_b" originalId="MISRA2004-20_2_b" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-20_2_b.rule"/>
            </rule>
         </category>
         <category description="Rule 21.21（必需）不得使用 &lt;stdlib.h&gt; 的标准库函数系统" name="RULE_21_21">
            <rule header="不得使用 'stdlib.h' 或 'cstdlib' 库中的 'system()' 函数" id="a" impl="SECURITY-48_b" originalId="SECURITY-48_b" quickfix="false" scope="line" severity="2">
               <file path="SECURITY\SECURITY-48_b.rule"/>
            </rule>
         </category>
         <category description="Rule 21.23 (必需) 在&lt;tgmath.h&gt;中声明的任何多参数通用类型宏的所有参数应具有相同的标准类型" name="RULE_21_23">
            <rule header="在 &lt;tgmath.h&gt; 中声明的任何多参数通用类型宏的所有参数应具有相同的标准类型" id="a" impl="CODSTA-108_d" originalId="CODSTA-108_d" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-108_d.rule"/>
            </rule>
         </category>
         <category description="Rule 21.24 (必需) 不应使用&lt;stdlib.h&gt;的随机数生成函数" name="RULE_21_24">
            <rule header="不应使用随机数函数'rand()'和'srand()'" id="a" impl="SECURITY-02" originalId="SECURITY-02" quickfix="false" scope="line" severity="2">
               <file path="SECURITY\SECURITY-02.rule"/>
            </rule>
         </category>
         <category description="Rule 21.25 (必需) 所有内存同步操作均应按顺序一致执行" name="RULE_21_25">
            <rule header="仅使用 'memory_order_seq_cst' 作为显式内存顺序参数" id="a" impl="CODSTA-MC-20" originalId="CODSTA-MC-20" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MC\CODSTA-MC-20.rule"/>
            </rule>
         </category>
         <category description="Rule 21.3（必需）不要使用 &lt;stdlib.h&gt; 的内存分配和分配功能" name="RULE_21_3">
            <rule header="不应使用动态堆内存分配" id="a" impl="MISRA2004-20_4" originalId="MISRA2004-20_4" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-20_4.rule"/>
            </rule>
         </category>
         <category description="Rule 21.4（必需）不要使用标准的头文件 &lt;setjmp.h&gt;" name="RULE_21_4">
            <rule header="不应使用 &lt;setjmp.h&gt; 提供的工具" id="a" impl="MISRA2004-20_7" originalId="MISRA2004-20_7" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-20_7.rule"/>
            </rule>
            <rule header="不应使用标准头文件 &lt;setjmp.h&gt; 或 &lt;csetjmp&gt;" id="b" impl="MISRA2004-20_7_b" originalId="MISRA2004-20_7_b" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-20_7_b.rule"/>
            </rule>
         </category>
         <category description="Rule 21.5（必需）不要使用标准的头文件 &lt;signal.h&gt;" name="RULE_21_5">
            <rule header="不应使用标准头文件 &lt;signal.h&gt; 或 &lt;csignal&gt;" id="a" impl="MISRA2004-20_8" originalId="MISRA2004-20_8" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-20_8.rule"/>
            </rule>
            <rule header="不应使用 &lt;signal.h&gt; 的信号处理工具" id="b" impl="MISRA2004-20_8_b" originalId="MISRA2004-20_8_b" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-20_8_b.rule"/>
            </rule>
         </category>
         <category description="Rule 21.6（必需）不要使用标准库的输入/输出函数" name="RULE_21_6">
            <rule header="不得使用标准的库的 input/output 函数" id="a" impl="CODSTA-110" originalId="CODSTA-110" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-110.rule"/>
            </rule>
         </category>
         <category description="Rule 21.7（必需）不要使用 &lt;stdlib.h&gt; 的 atof， atoi， atol 和 atoll 函数" name="RULE_21_7">
            <rule header="不得使用库stdlib.h中的库函数atof，atoi和atol" id="a" impl="MISRA2004-20_10" originalId="MISRA2004-20_10" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-20_10.rule"/>
            </rule>
         </category>
         <category description="Rule 21.8（必需）不要使用 &lt;stdlib.h&gt; 的标准库终止函数" name="RULE_21_8">
            <rule header="不得使用  'stdlib.h' 或者 'cstdlib' 库中的 'abort()' 函数" id="a" impl="PB-75" originalId="PB-75" quickfix="false" scope="line" severity="2">
               <file path="PB\PB-75.rule"/>
            </rule>
            <rule header="'stdlib.h' 或者 'cstdlib' 库中的 'exit()' 函数不应该被使用" id="b" impl="PB-75_b" originalId="PB-75_b" quickfix="false" scope="line" severity="2">
               <file path="PB\PB-75_b.rule"/>
            </rule>
            <rule header="不得使用 'stdlib.h' 或 'cstdlib' 库中的 'quick_exit()' 和 '_Exit()' 函数" id="c" impl="PB-75_c" originalId="PB-75_c" quickfix="false" scope="line" severity="2">
               <file path="PB\PB-75_c.rule"/>
            </rule>
         </category>
         <category description="Rule 21.9（必需）不要使用 &lt;stdlib.h&gt; 的库函数 bsearch 和 qsort" name="RULE_21_9">
            <rule header="不得使用在&lt;stdlib.h&gt;中的 bsearch 和 qsort 库函数" id="a" impl="CODSTA-107" originalId="CODSTA-107" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-107.rule"/>
            </rule>
         </category>
         <category description="Rule 23.2 (必需) 非从宏中扩展出来的泛型选择，在控制表达式中不应该包含潜在的副作用" name="RULE_23_2">
            <rule header="非从宏展开的泛型选择不应在控制表达式中包含潜在的副作用" id="a" impl="CODSTA-MC-13" originalId="CODSTA-MC-13" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MC\CODSTA-MC-13.rule"/>
            </rule>
         </category>
         <category description="Rule 23.4 (必需)泛型关联应列出一个适当的类型" name="RULE_23_4">
            <rule header="泛型关联应列出适当的类型" id="a" impl="CODSTA-MC-09" originalId="CODSTA-MC-09" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MC\CODSTA-MC-09.rule"/>
            </rule>
         </category>
         <category description="Rule 23.6 (必需) 泛型选择的控制表达式应该有一个与其标准类型相匹配的基本类型" name="RULE_23_6">
            <rule header="泛型选择的控制表达式应具有与其标准类型匹配的基本类型" id="a" impl="CODSTA-MC-12" originalId="CODSTA-MC-12" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MC\CODSTA-MC-12.rule"/>
            </rule>
            <rule header="枚举类型不应与泛型选择中的整数类型混合" id="b" impl="CODSTA-MC-14" originalId="CODSTA-MC-14" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MC\CODSTA-MC-14.rule"/>
            </rule>
         </category>
         <category description="Rule 23.8 (必需) 默认关联应作为泛型选择的第一个或最后一个关联出现" name="RULE_23_8">
            <rule header="默认关联应放在关联列表中的第一个或最后一个" id="a" impl="CODSTA-MC-06" originalId="CODSTA-MC-06" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MC\CODSTA-MC-06.rule"/>
            </rule>
         </category>
         <category description="Rule 2.1（必需）项目不应包含不可到达的代码" name="RULE_2_1">
            <rule header="在 &quot;else&quot; 语句块中不应存在执行不到的代码" id="a" impl="MISRA2004-14_1_a" originalId="MISRA2004-14_1_a" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-14_1_a.rule"/>
            </rule>
            <rule header="在 'return', 'break', 'continue', 和 'goto' 语句之后不应存在执行不到的代码" id="b" impl="MISRA2004-14_1_b" originalId="MISRA2004-14_1_b" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-14_1_b.rule"/>
            </rule>
            <rule header="在 &quot;if/else/while/for&quot; 语句块中不应存在执行不到的代码" id="c" impl="MISRA2004-14_1_c" originalId="MISRA2004-14_1_c" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-14_1_c.rule"/>
            </rule>
            <rule header="在 switch 语句中不应存在执行不到的代码" id="d" impl="MISRA2004-14_1_d" originalId="MISRA2004-14_1_d" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-14_1_d.rule"/>
            </rule>
            <rule header="在 'for' 循环中不应存在执行不到的代码" id="e" impl="MISRA2004-14_1_e" originalId="MISRA2004-14_1_e" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-14_1_e.rule"/>
            </rule>
            <rule header="在 'if' 或 'switch' 语句后不应存在不可访问的代码" id="f" impl="MISRA2004-14_1_f" originalId="MISRA2004-14_1_f" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-14_1_f.rule"/>
            </rule>
            <rule header="在 while/for/do...while 循环内的 &quot;if&quot; 或 &quot;switch&quot; 语句后不应存在执行不到的代码" id="g" impl="MISRA2004-14_1_g" originalId="MISRA2004-14_1_g" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-14_1_g.rule"/>
            </rule>
         </category>
         <category description="Rule 2.2（必需）项目不应包含死码" name="RULE_2_2">
            <rule header="所有非 null 语句无论如何执行都至少有一个副作用，或者导致控制流发生变化" id="a" impl="MISRA2004-14_2" originalId="MISRA2004-14_2" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-14_2.rule"/>
            </rule>
         </category>
         <category description="Rule 3.1（必需）字符序列 /* 和 // 不应在注释中使用" name="RULE_3_1">
            <rule header="禁止在 C 语言风格的注释中使用 /* 字符序列" id="a" impl="MISRA2004-2_3" originalId="MISRA2004-2_3" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-2_3.rule"/>
            </rule>
            <rule header="字符序列 // 不得被用于 C 语言风格的注释中" id="b" impl="COMMENT-11" originalId="COMMENT-11" quickfix="false" scope="line" severity="2">
               <file path="COMMENT\COMMENT-11.rule"/>
            </rule>
            <rule header="字符序列 /* 不得被用于 C++ 语言风格的注释中" id="c" impl="COMMENT-12" originalId="COMMENT-12" quickfix="false" scope="line" severity="2">
               <file path="COMMENT\COMMENT-12.rule"/>
            </rule>
         </category>
         <category description="Rule 3.2（必需）行拼接不应使用在 // 注释中" name="RULE_3_2">
            <rule header="不得在 // 注释中使用行合并" id="a" impl="COMMENT-13" originalId="COMMENT-13" quickfix="false" scope="line" severity="2">
               <file path="COMMENT\COMMENT-13.rule"/>
            </rule>
         </category>
         <category description="Rule 4.1（必需）应终止八进制和十六进制转义序列" name="RULE_4_1">
            <rule header="八进制和十六进制转义序列将被终止" id="a" impl="CODSTA-117" originalId="CODSTA-117" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-117.rule"/>
            </rule>
         </category>
         <category description="Rule 5.1（必需）外部标识符应是不同的" name="RULE_5_1">
            <rule header="外部标识符应不同" id="a" impl="CODSTA-178" originalId="CODSTA-178" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-178.rule"/>
            </rule>
         </category>
         <category description="Rule 5.2（必需）在同一作用域和名称空间中声明的标识符应是不同的" name="RULE_5_2">
            <rule header="在文件范围和命名空间中声明的不同标识符应该区分开来 (c90)" id="a" impl="CODSTA-179_a_c90" originalId="CODSTA-179_a_c90" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-179_a_c90.rule"/>
            </rule>
            <rule header="在文件范围和命名空间中声明的不同标识符应该区分开来 (c99)" id="b" impl="CODSTA-179_a_c99" originalId="CODSTA-179_a_c99" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-179_a_c99.rule"/>
            </rule>
            <rule header="在同样的块范围和命名空间中的标识符必须不相同 (c90)" id="c" impl="CODSTA-179_b_c90" originalId="CODSTA-179_b_c90" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-179_b_c90.rule"/>
            </rule>
            <rule header="在同样的块范围和命名空间中的标识符必须不相同 (c99)" id="d" impl="CODSTA-179_b_c99" originalId="CODSTA-179_b_c99" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-179_b_c99.rule"/>
            </rule>
         </category>
         <category description="Rule 5.3（必需）在内部作用域内声明的标识符不得隐藏在外部作用域内声明的标识符" name="RULE_5_3">
            <rule header="在局部或者函数原型体范围内声明的标识符不应该隐藏一个在全局或者命名空间范围内声明的标识符" id="a" impl="MISRA2004-5_2_a" originalId="MISRA2004-5_2_a" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-5_2_a.rule"/>
            </rule>
            <rule header="在内层的局部范围内声明的标识符不应该隐藏在外层的局部范围内声明的标识符" id="b" impl="MISRA2004-5_2_b" originalId="MISRA2004-5_2_b" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-5_2_b.rule"/>
            </rule>
         </category>
         <category description="Rule 5.4（必需）宏标识符应是不同的" name="RULE_5_4">
            <rule header="宏命名应该与参数区分开来（c90)" id="a" impl="CODSTA-171_c90" originalId="CODSTA-171_c90" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-171_c90.rule"/>
            </rule>
            <rule header="宏命名需要与它的参数名区分开来（c99)" id="b" impl="CODSTA-171_c99" originalId="CODSTA-171_c99" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-171_c99.rule"/>
            </rule>
            <rule header="宏的命名需要与当前定义的其他宏的命名区分开来（c90）" id="c" impl="CODSTA-172_c90" originalId="CODSTA-172_c90" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-172_c90.rule"/>
            </rule>
            <rule header="宏的名称应该有别于其他当前定义的宏的名称(c99)" id="d" impl="CODSTA-172_c99" originalId="CODSTA-172_c99" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-172_c99.rule"/>
            </rule>
         </category>
         <category description="Rule 5.5（必需）标识符应与宏名称不同" name="RULE_5_5">
            <rule header="在预处理之前的宏命名应该与预处理之后的标识符区分开来" id="a" impl="CODSTA-170_c90" originalId="CODSTA-170_c90" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-170_c90.rule"/>
            </rule>
            <rule header="在预处理之前的宏命名应该与预处理之后的标识符区分开来" id="b" impl="CODSTA-170_c99" originalId="CODSTA-170_c99" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-170_c99.rule"/>
            </rule>
         </category>
         <category description="Rule 6.1（必需）位字段只能用适当的类型声明" name="RULE_6_1">
            <rule header="只能将位域定义为有符号的整型或无符号的整型" id="a" impl="MISRA2004-6_4" originalId="MISRA2004-6_4" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-6_4.rule"/>
            </rule>
         </category>
         <category description="Rule 6.2（必需）位字段只能用适当的类型声明" name="RULE_6_2">
            <rule header="具有带符号的整数类型且已命名的位域应该有超过一位的长度" id="a" impl="CODSTA-71" originalId="CODSTA-71" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-71.rule"/>
            </rule>
         </category>
         <category description="Rule 6.3 (必需) 位域不应被声明为union的成员" name="RULE_6_3">
            <rule header="union 成员不应被声明为位域" id="a" impl="CODSTA-02_b" originalId="CODSTA-02_b" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-02_b.rule"/>
            </rule>
         </category>
         <category description="Rule 7.1（必需）不能使用八进制常数" name="RULE_7_1">
            <rule header="不应该使用八进制常数（除零外）" id="a" impl="MISRA2004-7_1_a" originalId="MISRA2004-7_1_a" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-7_1_a.rule"/>
            </rule>
         </category>
         <category description="Rule 7.2（必需） &quot;u&quot; 或者 &quot;U&quot; 后缀应该应用于以无符号类型表示的所有整数常量" name="RULE_7_2">
            <rule header="无符号类型的所有常量应该使用 'U' 后缀" id="a" impl="MISRA2004-10_6" originalId="MISRA2004-10_6" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-10_6.rule"/>
            </rule>
         </category>
         <category description="Rule 7.3（必需）小写字母 &quot;l&quot;不得使用文字后缀" name="RULE_7_3">
            <rule header="使用大写 'L' 而非小写 'l' 来指定长整型" id="a" impl="PORT-01" originalId="PORT-01" quickfix="false" scope="line" severity="2">
               <file path="PORT\PORT-01.rule"/>
            </rule>
         </category>
         <category description="Rule 7.4（必需）除非对象的类型是 &quot;指向 const 限定字符的指针&quot;，否则不能将字符串文字赋值给对象" name="RULE_7_4">
            <rule header="字符串字面量不应该被修改" id="a" impl="PB-27" originalId="PB-27" quickfix="false" scope="line" severity="2">
               <file path="PB\PB-27.rule"/>
            </rule>
         </category>
         <category description="Rule 7.6 (必需) 不应使用最小宽度整数常数宏的小整数变体" name="RULE_7_6">
            <rule header="不应使用最小宽度的整数常数宏的小整数变体" id="a" impl="CODSTA-220_b" originalId="CODSTA-220_b" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-220_b.rule"/>
            </rule>
         </category>
         <category description="Rule 8.1（必需）类型应明确指定" name="RULE_8_1">
            <rule header="声明或定义某个函数时，必须显式地规定其类型" id="a" impl="MISRA2004-8_2_a" originalId="MISRA2004-8_2_a" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-8_2_a.rule"/>
            </rule>
            <rule header="声明或定义某个对象时，必须显式地规定其类型" id="b" impl="MISRA2004-8_2_b" originalId="MISRA2004-8_2_b" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-8_2_b.rule"/>
            </rule>
         </category>
         <category description="Rule 8.10（必需）内联函数应用静态存储类声明" name="RULE_8_10">
            <rule header="内联函数应该声明为静态存储类" id="a" impl="CODSTA-120" originalId="CODSTA-120" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-120.rule"/>
            </rule>
         </category>
         <category description="Rule 8.12（必需）在枚举数列表中，隐式指定的枚举常数的值应是唯一的" name="RULE_8_12">
            <rule header="在枚举器列表中，隐式指定的枚举常量的值应该是唯一的" id="a" impl="PB-58" originalId="PB-58" quickfix="false" scope="line" severity="2">
               <file path="PB\PB-58.rule"/>
            </rule>
         </category>
         <category description="Rule 8.14（必需）不得使用限制类型的限定词" name="RULE_8_14">
            <rule header="不得使用严格的类型限定符" id="a" impl="CODSTA-121" originalId="CODSTA-121" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-121.rule"/>
            </rule>
         </category>
         <category description="Rule 8.15 (必需) 所有具有明确对齐规范的对象的声明应指定相同的对齐方式" name="RULE_8_15">
            <rule header="具有内部链接的对象的所有声明中的显示对齐说明符应相同" id="b" impl="CODSTA-MC-04" originalId="CODSTA-MC-04" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MC\CODSTA-MC-04.rule"/>
            </rule>
         </category>
         <category description="Rule 8.2（必需）函数类型应采用原型形式，并具有指定的参数" name="RULE_8_2">
            <rule header="在函数原型声明中应该为所有参数提供标识符" id="a" impl="MISRA2004-16_3" originalId="MISRA2004-16_3" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-16_3.rule"/>
            </rule>
            <rule header="函数类型应该包含具体名称的参数" id="b" impl="CODSTA-158" originalId="CODSTA-158" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-158.rule"/>
            </rule>
            <rule header="函数类型应当为原型形式" id="c" impl="CODSTA-159" originalId="CODSTA-159" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-159.rule"/>
            </rule>
         </category>
         <category description="Rule 8.3（必需）对象或函数的所有声明都应使用相同的名称和类型限定符" name="RULE_8_3">
            <rule header="如果对象或者函数被声明了一次以上，那么他们的类型应该是兼容的" id="a" impl="MISRA2004-8_4" originalId="MISRA2004-8_4" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-8_4.rule"/>
            </rule>
            <rule header="禁止函数声明中使用的标识符与实际定义中的标识符不一致" id="b" impl="MISRA2004-16_4" originalId="MISRA2004-16_4" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-16_4.rule"/>
            </rule>
         </category>
         <category description="Rule 8.4（必需）当定义具有外部链接的对象或函数时，兼容的声明应该是可见的" name="RULE_8_4">
            <rule header="当一个有外部链接的对象或函数被定义时，则声明应该为可见的" id="a" impl="CODSTA-118" originalId="CODSTA-118" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-118.rule"/>
            </rule>
            <rule header="如果对象或者函数被声明了一次以上，那么他们的类型应该是兼容的" id="b" impl="MISRA2004-8_4" originalId="MISRA2004-8_4" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-8_4.rule"/>
            </rule>
         </category>
         <category description="Rule 8.5（必需）外部对象或函数只能在一个文件中声明一次" name="RULE_8_5">
            <rule header="在转换单元中外部对象或函数不得有多个non-defining声明" id="a" impl="CODSTA-154" originalId="CODSTA-154" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-154.rule"/>
            </rule>
         </category>
         <category description="Rule 8.8（必需）静态存储类说明符应使用在具有内部链接的对象和函数的所有声明中" name="RULE_8_8">
            <rule header="静态存储类说明符应该用于具有内部链接的对象和函数的定义和声明" id="a" impl="MISRA2004-8_11" originalId="MISRA2004-8_11" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-8_11.rule"/>
            </rule>
         </category>
         <category description="Rule 9.2（必需）聚合或联合的初始化器应该用大括号括起来" name="RULE_9_2">
            <rule header="集合或联合的初始化程序应放在大括号中" id="a" impl="INIT-16" originalId="INIT-16" quickfix="false" scope="line" severity="2">
               <file path="INIT\INIT-16.rule"/>
            </rule>
         </category>
         <category description="Rule 9.3（必需）不应部分地初始化数组" name="RULE_9_3">
            <rule header="数组不应被部分初始化" id="a" impl="MISRA2004-9_2_b" originalId="MISRA2004-9_2_b" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-9_2_b.rule"/>
            </rule>
         </category>
         <category description="Rule 9.4（必需）对象的元素不能被初始化多次" name="RULE_9_4">
            <rule header="对象的一个元素不能被初始化超过一次" id="a" impl="PB-69" originalId="PB-69" quickfix="false" scope="line" severity="2">
               <file path="PB\PB-69.rule"/>
            </rule>
         </category>
         <category description="Rule 9.5（必需）如果使用指定的初始化器初始化数组对象，那么数组的大小应明确地指定" name="RULE_9_5">
            <rule header="指定的用来初始化数组对象的初始化器应明确指定数组对象的大小" id="a" impl="CODSTA-186" originalId="CODSTA-186" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-186.rule"/>
            </rule>
         </category>
         <category description="Rule 9.6 (必需) 使用链式指示符的初始化器不应包含没有指示符的初始化器" name="RULE_9_6">
            <rule header="使用链式指示符的初始化器不应包含没有指示符的初始化器" id="a" impl="PB-80" originalId="PB-80" quickfix="false" scope="line" severity="2">
               <file path="PB\PB-80.rule"/>
            </rule>
         </category>
         <category description="Dir 4.2（建议）所有汇编语言的使用都应记录下来" name="DIR_4_2">
            <rule header="应该注释说明所有汇编程序的使用" id="a" impl="COMMENT-09" originalId="COMMENT-09" quickfix="false" scope="line" severity="4">
               <file path="COMMENT\COMMENT-09.rule"/>
            </rule>
         </category>
         <category description="Dir 4.4（建议）代码部分不应是 &quot;添加注释&quot;" name="DIR_4_4">
            <rule header="代码段不应该被&quot;注释掉&quot;" id="a" impl="MISRA2004-2_4" originalId="MISRA2004-2_4" quickfix="false" scope="line" severity="4">
               <file path="MISRA2004\MISRA2004-2_4.rule"/>
            </rule>
         </category>
         <category description="Dir 4.5（建议）在具有重叠可见性的同一名称空间中，标识符应在字面上是无歧义的" name="DIR_4_5">
            <rule header="具有重叠可见性的同一命名空间中的标识符应该是排版明确的" id="a" impl="NAMING-50" originalId="NAMING-50" quickfix="false" scope="line" severity="4">
               <file path="NAMING\NAMING-50.rule"/>
            </rule>
         </category>
         <category description="Dir 4.6（建议）表示大小和符号的 typedef 应用来代替基本的数字类型" name="DIR_4_6">
            <rule header="typedef 定义基本类型应该在名称中包含数字" id="a" impl="MISRA2004-6_3" originalId="MISRA2004-6_3" quickfix="false" scope="line" severity="4">
               <file path="MISRA2004\MISRA2004-6_3.rule"/>
            </rule>
            <rule header="typedef 应该用于替代基本类型" id="b" impl="MISRA2004-6_3_b" originalId="MISRA2004-6_3_b" quickfix="false" scope="line" severity="4">
               <file path="MISRA2004\MISRA2004-6_3_b.rule"/>
            </rule>
            <rule header="应该使用C99中stdint.h的typedefs而不是个人自己的声明" id="c" impl="CODSTA-155" originalId="CODSTA-155" quickfix="false" scope="line" severity="4">
               <file path="CODSTA\CODSTA-155.rule"/>
            </rule>
         </category>
         <category description="Dir 4.8（建议）如果指向结构体或联合的指针从未在编译单元中解引用，那么对象的实现就应该隐藏起来" name="DIR_4_8">
            <rule header="如果指向一个结构体或联合体的指针在一个编译单元内从未被间接引用，那么该对象的实现应该被隐藏起来" id="a" impl="CODSTA-115" originalId="CODSTA-115" quickfix="false" scope="line" severity="4">
               <file path="CODSTA\CODSTA-115.rule"/>
            </rule>
         </category>
         <category description="Dir 4.9（建议）当可互换的时候，比起类函数宏， 应优先使用函数" name="DIR_4_9">
            <rule header="函数应该优先于宏函数的使用" id="a" impl="MISRA2004-19_7" originalId="MISRA2004-19_7" quickfix="false" scope="line" severity="4">
               <file path="MISRA2004\MISRA2004-19_7.rule"/>
            </rule>
         </category>
         <category description="Rule 10.5（建议）表达式的值应转换为适当的基本类型" name="RULE_10_5">
            <rule header="不允许对枚举类型进行转换操作" id="a" impl="CODSTA-165_a" originalId="CODSTA-165_a" quickfix="false" scope="line" severity="4">
               <file path="CODSTA\CODSTA-165_a.rule"/>
            </rule>
            <rule header="不要从基本布尔类型转换或转换为基本布尔类型" id="b" impl="CODSTA-165_b" originalId="CODSTA-165_b" quickfix="false" scope="line" severity="4">
               <file path="CODSTA\CODSTA-165_b.rule"/>
            </rule>
            <rule header="不要在基本字符类型和基本浮点类型之间使用强制类型转换" id="c" impl="CODSTA-165_c" originalId="CODSTA-165_c" quickfix="false" scope="line" severity="4">
               <file path="CODSTA\CODSTA-165_c.rule"/>
            </rule>
         </category>
         <category description="Rule 11.4（建议）转换不能发生在对象指针和整型之间" name="RULE_11_4">
            <rule header="不应在指向对象的指针和指向整数类型的指针之间转换" id="a" impl="CODSTA-127" originalId="CODSTA-127" quickfix="false" scope="line" severity="4">
               <file path="CODSTA\CODSTA-127.rule"/>
            </rule>
         </category>
         <category description="Rule 11.5（建议）不应把 void 指针转换成对象指针" name="RULE_11_5">
            <rule header="不应该执行从指向 void 的指针到指向对象的指针的转换" id="a" impl="CODSTA-128" originalId="CODSTA-128" quickfix="false" scope="line" severity="4">
               <file path="CODSTA\CODSTA-128.rule"/>
            </rule>
         </category>
         <category description="Rule 12.1（建议）应该明确表达式中运算符的优先级" name="RULE_12_1">
            <rule header="除非表达式中的所有运算符都相同，否则使用圆括号" id="a" impl="MISRA2004-12_1_e" originalId="MISRA2004-12_1_e" quickfix="false" scope="line" severity="4">
               <file path="MISRA2004\MISRA2004-12_1_e.rule"/>
            </rule>
            <rule header="逻辑运算符 &amp;&amp; 或者 || 的操作数应该是基本表达式" id="b" impl="MISRA2004-12_5" originalId="MISRA2004-12_5" quickfix="false" scope="line" severity="4">
               <file path="MISRA2004\MISRA2004-12_5.rule"/>
            </rule>
            <rule header="'sizeof' 运算符的操作数应括在括号中" id="c" impl="FORMAT-25" originalId="FORMAT-25" quickfix="false" scope="line" severity="4">
               <file path="FORMAT\FORMAT-25.rule"/>
            </rule>
         </category>
         <category description="Rule 12.3（建议）不应该使用逗号运算符" name="RULE_12_3">
            <rule header="不应该使用逗号运算符" id="a" impl="MISRA2004-12_10" originalId="MISRA2004-12_10" quickfix="false" scope="line" severity="4">
               <file path="MISRA2004\MISRA2004-12_10.rule"/>
            </rule>
         </category>
         <category description="Rule 12.4（建议）常量表达式的求值不应该导致无符号整数自动换行" name="RULE_12_4">
            <rule header="'+'， '-'， '*' 运算符常量表达式中的整数溢出或下溢" id="a" impl="PB-66_a" originalId="PB-66_a" quickfix="false" scope="line" severity="4">
               <file path="PB\PB-66_a.rule"/>
            </rule>
            <rule header="'&lt;&lt;' 运算符常量表达式中的整数溢出或下溢" id="b" impl="PB-66_b" originalId="PB-66_b" quickfix="false" scope="line" severity="4">
               <file path="PB\PB-66_b.rule"/>
            </rule>
         </category>
         <category description="Rule 13.3（建议）包含递增(++)或递减(--)运算符的完整表达式除了有递增或递减运算符引起的副作用之外，应该就没有其他潜在的副作用" name="RULE_13_3">
            <rule header="包含递增(++)或递减(--)运算符的完整表达式应该没有其他潜在的附带后果" id="a" impl="CODSTA-123" originalId="CODSTA-123" quickfix="false" scope="line" severity="4">
               <file path="CODSTA\CODSTA-123.rule"/>
            </rule>
         </category>
         <category description="Rule 13.4（建议）不应使用赋值运算符的结果" name="RULE_13_4">
            <rule header="不得使用一个内置赋值运算符的结果" id="a" impl="CODSTA-138" originalId="CODSTA-138" quickfix="false" scope="line" severity="4">
               <file path="CODSTA\CODSTA-138.rule"/>
            </rule>
         </category>
         <category description="Rule 15.1（建议）不应该使用 goto 语句" name="RULE_15_1">
            <rule header="不应该使用 goto 语句" id="a" impl="MISRA2004-14_4" originalId="MISRA2004-14_4" quickfix="false" scope="line" severity="4">
               <file path="MISRA2004\MISRA2004-14_4.rule"/>
            </rule>
         </category>
         <category description="Rule 15.4（建议）用于终止任何迭代语句的 break 或 goto 语句不应超过一个" name="RULE_15_4">
            <rule header="对任何循环语句，都应存在不止一个用于循环终止的 break 或 goto 语句" id="a" impl="CODSTA-79" originalId="CODSTA-79" quickfix="false" scope="line" severity="4">
               <file path="CODSTA\CODSTA-79.rule"/>
            </rule>
         </category>
         <category description="Rule 15.5（建议）函数的末尾应有单一的退出点" name="RULE_15_5">
            <rule header="函数末端应只提供一个出口点" id="a" impl="MISRA2004-14_7" originalId="MISRA2004-14_7" quickfix="false" scope="line" severity="4">
               <file path="MISRA2004\MISRA2004-14_7.rule"/>
            </rule>
         </category>
         <category description="Rule 17.12 (建议) 函数标识符只能与前面的&amp;,或者与括号内的参数列表一起使用" name="RULE_17_12">
            <rule header="函数标识符只能与前面的  '&amp;' 一起使用，或者与括号中的参数列表一起使用，参数列表可以是空的" id="a" impl="MISRA2004-16_9" originalId="MISRA2004-16_9" quickfix="false" scope="line" severity="4">
               <file path="MISRA2004\MISRA2004-16_9.rule"/>
            </rule>
         </category>
         <category description="Rule 17.8（建议）不应修改函数参数" name="RULE_17_8">
            <rule header="不应该修改函数参数" id="a" impl="CODSTA-132" originalId="CODSTA-132" quickfix="false" scope="line" severity="4">
               <file path="CODSTA\CODSTA-132.rule"/>
            </rule>
         </category>
         <category description="Rule 18.4（建议）+， -， += 和 -= 运算符不应用于指针类型的表达式" name="RULE_18_4">
            <rule header="不要将+, -, += 和 -= 类型操作符应用于指针类型表达式" id="a" impl="CODSTA-181" originalId="CODSTA-181" quickfix="false" scope="line" severity="4">
               <file path="CODSTA\CODSTA-181.rule"/>
            </rule>
         </category>
         <category description="Rule 18.5（建议）声明应该包含不超过两层的指针嵌套" name="RULE_18_5">
            <rule header="对象的声明应该包含不超过 2 层的指针嵌套" id="a" impl="MISRA2004-17_5" originalId="MISRA2004-17_5" quickfix="false" scope="line" severity="4">
               <file path="MISRA2004\MISRA2004-17_5.rule"/>
            </rule>
         </category>
         <category description="Rule 19.2（建议）不应该使用 union 关键字" name="RULE_19_2">
            <rule header="不得使用联合体关键字" id="a" impl="CODSTA-111" originalId="CODSTA-111" quickfix="false" scope="line" severity="4">
               <file path="CODSTA\CODSTA-111.rule"/>
            </rule>
         </category>
         <category description="Rule 20.1（建议）#include 指令前应该只有预处理指令或注释" name="RULE_20_1">
            <rule header="#include 之前只允许有预处理命令和注释" id="a" impl="MISRA2004-19_1" originalId="MISRA2004-19_1" quickfix="false" scope="line" severity="4">
               <file path="MISRA2004\MISRA2004-19_1.rule"/>
            </rule>
         </category>
         <category description="Rule 20.10（建议）不应该使用 # 和 ## 预处理器运算符" name="RULE_20_10">
            <rule header="禁止使用预处理操作符 # 和 ##" id="a" impl="MISRA2004-19_13" originalId="MISRA2004-19_13" quickfix="false" scope="line" severity="4">
               <file path="MISRA2004\MISRA2004-19_13.rule"/>
            </rule>
         </category>
         <category description="Rule 20.5（建议）不应该使用 #undef" name="RULE_20_5">
            <rule header="不应使用 #undef" id="a" impl="PREPROC-25" originalId="PREPROC-25" quickfix="false" scope="line" severity="4">
               <file path="PREPROC\PREPROC-25.rule"/>
            </rule>
         </category>
         <category description="Rule 23.1 (建议) 泛型选择只应从宏中展开" name="RULE_23_1">
            <rule header="泛型选择只能从宏展开" id="a" impl="CODSTA-MC-08" originalId="CODSTA-MC-08" quickfix="false" scope="line" severity="4">
               <file path="CODSTA-MC\CODSTA-MC-08.rule"/>
            </rule>
            <rule header="宏定义中使用的泛型选择应在控制表达式中具有宏参数" id="b" impl="CODSTA-MC-10" originalId="CODSTA-MC-10" quickfix="false" scope="line" severity="4">
               <file path="CODSTA-MC\CODSTA-MC-10.rule"/>
            </rule>
         </category>
         <category description="Rule 23.3 (建议) 泛型选择应该至少包含一个非默认的关联" name="RULE_23_3">
            <rule header="泛型选择应指示至少一个非默认关联" id="a" impl="CODSTA-MC-07" originalId="CODSTA-MC-07" quickfix="false" scope="line" severity="4">
               <file path="CODSTA-MC\CODSTA-MC-07.rule"/>
            </rule>
         </category>
         <category description="Rule 23.5 (建议) 泛型选择不应该依赖于隐式的指针类型转换" name="RULE_23_5">
            <rule header="泛型选择不应依赖于隐式指针类型转换" id="a" impl="CODSTA-MC-11" originalId="CODSTA-MC-11" quickfix="false" scope="line" severity="4">
               <file path="CODSTA-MC\CODSTA-MC-11.rule"/>
            </rule>
         </category>
         <category description="Rule 23.7 (建议)从宏中展开的泛型选择应该只评估一次它的参数" name="RULE_23_7">
            <rule header="由宏展开的泛型选择只能计算一次其参数" id="a" impl="CODSTA-MC-15" originalId="CODSTA-MC-15" quickfix="false" scope="line" severity="4">
               <file path="CODSTA-MC\CODSTA-MC-15.rule"/>
            </rule>
         </category>
         <category description="Rule 2.3（建议）项目不应包含未使用的类型声明" name="RULE_2_3">
            <rule header="函数中不应该包含无用的类型声明" id="a" impl="CODSTA-175_a" originalId="CODSTA-175_a" quickfix="false" scope="line" severity="4">
               <file path="CODSTA\CODSTA-175_a.rule"/>
            </rule>
            <rule header="源文件中不能包含未使用的类型声明" id="b" impl="CODSTA-175_b" originalId="CODSTA-175_b" quickfix="false" scope="line" severity="4">
               <file path="CODSTA\CODSTA-175_b.rule"/>
            </rule>
         </category>
         <category description="Rule 2.4（建议）项目不应包含未使用的标签声明" name="RULE_2_4">
            <rule header="函数不应该包含无用的局部标签声明" id="a" impl="CODSTA-176_a" originalId="CODSTA-176_a" quickfix="false" scope="line" severity="4">
               <file path="CODSTA\CODSTA-176_a.rule"/>
            </rule>
            <rule header="源文件中不应该包含未使用的标签声明" id="b" impl="CODSTA-176_b" originalId="CODSTA-176_b" quickfix="false" scope="line" severity="4">
               <file path="CODSTA\CODSTA-176_b.rule"/>
            </rule>
         </category>
         <category description="Rule 2.5（建议）项目不应包含未使用的宏定义" name="RULE_2_5">
            <rule header="源文件不应包含未使用的宏定义" id="a" impl="CODSTA-177" originalId="CODSTA-177" quickfix="false" scope="line" severity="4">
               <file path="CODSTA\CODSTA-177.rule"/>
            </rule>
         </category>
         <category description="Rule 2.6（建议）函数不应包含未使用的标签声明" name="RULE_2_6">
            <rule header="函数不应该包含未使用的标签声明" id="a" impl="OPT-37" originalId="OPT-37" quickfix="false" scope="line" severity="4">
               <file path="OPT\OPT-37.rule"/>
            </rule>
         </category>
         <category description="Rule 2.7（建议）函数不应包含未使用的参数" name="RULE_2_7">
            <rule header="在函数中不应该有未使用的参数" id="a" impl="OPT-38" originalId="OPT-38" quickfix="false" scope="line" severity="4">
               <file path="OPT\OPT-38.rule"/>
            </rule>
         </category>
         <category description="Rule 2.8 (建议) 项目不应包含未使用的对象定义" name="RULE_2_8">
            <rule header="项目不应包含有内部链接的未使用变量" id="b" impl="OPT-43" originalId="OPT-43" quickfix="false" scope="line" severity="4">
               <file path="OPT\OPT-43.rule"/>
            </rule>
            <rule header="避免未使用的局部变量" id="c" impl="OPT-02" originalId="OPT-02" quickfix="false" scope="line" severity="4">
               <file path="OPT\OPT-02.rule"/>
            </rule>
         </category>
         <category description="Rule 4.2（建议）不应使用三字母词" name="RULE_4_2">
            <rule header="禁止使用三联符" id="a" impl="MISRA2004-4_2" originalId="MISRA2004-4_2" quickfix="false" scope="line" severity="4">
               <file path="MISRA2004\MISRA2004-4_2.rule"/>
            </rule>
         </category>
         <category description="Rule 8.11（建议）当声明具有外部链接的数组时，应该明确地指定其大小" name="RULE_8_11">
            <rule header="当数组声明具有外部链接，其大小应该显式地说明或者在初始化时隐性地定义" id="a" impl="MISRA2004-8_12" originalId="MISRA2004-8_12" quickfix="false" scope="line" severity="4">
               <file path="MISRA2004\MISRA2004-8_12.rule"/>
            </rule>
         </category>
         <category description="Rule 8.13（建议）只要可能，指针应指向 const 限定的类型" name="RULE_8_13">
            <rule header="如果函数参数中指针参数在函数中不用来修改地址对象，则应声明为常量类型" id="a" impl="MISRA2004-16_7" originalId="MISRA2004-16_7" quickfix="false" scope="line" severity="4">
               <file path="MISRA2004\MISRA2004-16_7.rule"/>
            </rule>
            <rule header="如果指针不用于修改指向地址的对象则声明参数的类型为 typedef 的 const 指针" id="b" impl="MISRA2004-16_7_b" originalId="MISRA2004-16_7_b" quickfix="false" scope="line" severity="4">
               <file path="MISRA2004\MISRA2004-16_7_b.rule"/>
            </rule>
         </category>
         <category description="Rule 8.16 (建议) 零的对齐规范不应出现在对象声明中" name="RULE_8_16">
            <rule header="不应在对象声明中使用零对齐说明符" id="a" impl="CODSTA-MC-03" originalId="CODSTA-MC-03" quickfix="false" scope="line" severity="4">
               <file path="CODSTA-MC\CODSTA-MC-03.rule"/>
            </rule>
         </category>
         <category description="Rule 8.17 (建议) 在一个对象的声明中，最多只能出现一个明确的对齐说明符" name="RULE_8_17">
            <rule header="对象的声明最多应包含一个显式对齐说明符" id="a" impl="CODSTA-MC-02" originalId="CODSTA-MC-02" quickfix="false" scope="line" severity="4">
               <file path="CODSTA-MC\CODSTA-MC-02.rule"/>
            </rule>
         </category>
         <category description="Rule 8.9（建议）如果对象的标识符只出现在单个函数中，则应该在块的范围内声明对象" name="RULE_8_9">
            <rule header="如果仅从单个函数中访问对象，则应在块范围内定义对象" id="a" impl="MISRA2004-8_7" originalId="MISRA2004-8_7" quickfix="false" scope="line" severity="4">
               <file path="MISRA2004\MISRA2004-8_7.rule"/>
            </rule>
         </category>
      </category>
      <category description="内存和资源管理" name="MRM">
         <rule header="由于函数参数的评估顺序尚未定义，禁止在函数参数列表中进行资源分配" id="01" impl="MRM-01" quickfix="false" scope="line" severity="1">
            <file path="MRM\MRM-01.rule"/>
         </rule>
         <rule header="在对相应的 new/malloc 以及 delete/free 的调用中应使用相同的形式" id="06" impl="MRM-06" quickfix="false" scope="line" severity="1">
            <file path="MRM\MRM-06.rule"/>
         </rule>
         <rule header="禁止对含有构造函数的对象调用 malloc/realloc" id="08" impl="MRM-08" quickfix="false" scope="line" severity="1">
            <file path="MRM\MRM-08.rule"/>
         </rule>
         <rule header="避免隐藏全局new运算符" id="32" impl="MRM-32" quickfix="false" scope="line" severity="1">
            <file path="MRM\MRM-32.rule"/>
         </rule>
         <rule header="为动态分配内存的类声明一个复制赋值运算符" id="37" impl="MRM-37" quickfix="false" scope="line" severity="1">
            <file path="MRM\MRM-37.rule"/>
         </rule>
         <rule header="为动态分配内存的类声明拷贝构造函数" id="38" impl="MRM-38" quickfix="false" scope="line" severity="1">
            <file path="MRM\MRM-38.rule"/>
         </rule>
         <rule header="禁止返回函数范围内的new运算符初始化的解引用本地指针" id="23" impl="MRM-23" quickfix="false" scope="line" severity="2">
            <file path="MRM\MRM-23.rule"/>
         </rule>
         <rule header="在析构函数中对指针成员调用delete" id="33" impl="MRM-33" quickfix="false" scope="line" severity="2">
            <file path="MRM\MRM-33.rule"/>
         </rule>
         <rule header="在调用fopen函数的附近提供文件打开错误的错误处理机制" id="39" impl="MRM-39" quickfix="false" scope="line" severity="2">
            <file path="MRM\MRM-39.rule"/>
         </rule>
         <rule header="拷贝构造函数应复制所有的数据成员以及基类成员" id="41" impl="MRM-41" quickfix="false" scope="line" severity="2">
            <file path="MRM\MRM-41.rule"/>
         </rule>
         <rule header="在析构函数中调用 fclose() 函数来关闭用于打开文件的指针成员" id="42" impl="MRM-42" quickfix="false" scope="line" severity="2">
            <file path="MRM\MRM-42.rule"/>
         </rule>
         <rule header="赋值运算符必须对基类型中的成员进行赋值" id="43" impl="MRM-43" quickfix="false" scope="line" severity="2">
            <file path="MRM\MRM-43.rule"/>
         </rule>
         <rule header="不要传递存储容量不足或者没有对正在构造的对象进行适当的对齐以配置 'new' 的指针" id="55" impl="MRM-55" quickfix="false" scope="line" severity="2">
            <file path="MRM\MRM-55.rule"/>
         </rule>
         <rule header="不要在一条语句中分配多个资源" id="02" impl="MRM-02" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-02.rule"/>
         </rule>
         <rule header="所有的类应该包含赋值操作符或适当的注释" id="04" impl="MRM-04" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-04.rule"/>
         </rule>
         <rule header="所有的类必须包含拷贝构造函数或适当的注释" id="05" impl="MRM-05" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-05.rule"/>
         </rule>
         <rule header="不能对非 POD 使用 memcpy 或 memcmp" id="07" impl="MRM-07" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-07.rule"/>
         </rule>
         <rule header="始终将一个新值赋给指向已释放内存的表达式" id="09" impl="MRM-09" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-09.rule"/>
         </rule>
         <rule header="始终将一个新值赋给指向已释放内存的全局或成员变量" id="10" impl="MRM-10" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-10.rule"/>
         </rule>
         <rule header="总是为指向释放内存的参数或局部变量分配新值" id="11" impl="MRM-11" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-11.rule"/>
         </rule>
         <rule header="在编写 new 和 delete 函数时应该遵守规范" id="12" impl="MRM-12" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-12.rule"/>
         </rule>
         <rule header="在编写 new 函数时应该固守常规" id="13" impl="MRM-13" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-13.rule"/>
         </rule>
         <rule header="如果一个类定义了 new 操作符的任何重载，就应该提供 plain, in-place, 和 non-throwing 所有三种标准形式的 new 操作符重载" id="14" impl="MRM-14" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-14.rule"/>
         </rule>
         <rule header="如果一个类定义了 new[] 操作符的任何重载，就应该提供 plain, in-place, 和 non-throwing 所有三种标准形式的 new[] 操作符重载" id="15" impl="MRM-15" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-15.rule"/>
         </rule>
         <rule header="如果一个类定义了 new[] 操作符的任何重载，就应该提供 plain, in-place, 和 non-throwing 所有三种标准形式的 new[] 操作符重载" id="16" impl="MRM-16" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-16.rule"/>
         </rule>
         <rule header="如果一个类定义了 delete[] 操作符的任何重载，就应该提供 plain, in-place, 和 non-throwing 所有三种标准形式的 delete[] 操作符重载" id="17" impl="MRM-17" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-17.rule"/>
         </rule>
         <rule header="不要分配内存后期望其他人稍后去释放" id="18" impl="MRM-18" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-18.rule"/>
         </rule>
         <rule header="不要分配内存后期望其他人稍后去释放" id="19" impl="MRM-19" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-19.rule"/>
         </rule>
         <rule header="不要分配内存后期望其他人稍后去释放它" id="20" impl="MRM-20" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-20.rule"/>
         </rule>
         <rule header="使用对象来管理资源" id="21" impl="MRM-21" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-21.rule"/>
         </rule>
         <rule header="使用对象来管理资源" id="22" impl="MRM-22" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-22.rule"/>
         </rule>
         <rule header="以独立语句将 newed 对象置入智能指针" id="25" impl="MRM-25" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-25.rule"/>
         </rule>
         <rule header="如果写了 new 操作符应该对应写 delete 操作符" id="26" impl="MRM-26" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-26.rule"/>
         </rule>
         <rule header="如果写了 new[] 操作符应该对应写 delete[] 操作符" id="27" impl="MRM-27" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-27.rule"/>
         </rule>
         <rule header="始终同时提供 new 和 delete 操作符" id="28" impl="MRM-28" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-28.rule"/>
         </rule>
         <rule header="始终同时提供 new[] 和 delete[] 操作符" id="29" impl="MRM-29" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-29.rule"/>
         </rule>
         <rule header="使用声明进行内存分配，而不是 new 或者 malloc" id="30" impl="MRM-30" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-30.rule"/>
         </rule>
         <rule header="被释放的内存在任何情况下都不应该被访问" id="31" impl="MRM-31" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-31.rule"/>
         </rule>
         <rule header="不应该手动调用析构函数" id="31_b" impl="MRM-31_b" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-31_b.rule"/>
         </rule>
         <rule header="检查 new 的返回值" id="34" impl="MRM-34" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-34.rule"/>
         </rule>
         <rule header="释放非数组内存时 delete 不能使用括号([])" id="35" impl="MRM-35" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-35.rule"/>
         </rule>
         <rule header="释放数组内存时 delete 必须使用空括号([])" id="36" impl="MRM-36" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-36.rule"/>
         </rule>
         <rule header="复制和销毁一致" id="40" impl="MRM-40" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-40.rule"/>
         </rule>
         <rule header="声明复制构造函数时应声明复制赋值运算符（反之亦然）" id="40_a" impl="MRM-40_a" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-40_a.rule"/>
         </rule>
         <rule header="拷贝构造函数和拷贝赋值操作符应该具有相同的 public/protected/private 权限" id="40_b" impl="MRM-40_b" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-40_b.rule"/>
         </rule>
         <rule header="如果存在非平凡拷贝构造函数或拷贝赋值操作符，应声明一个析构函数" id="40_c" impl="MRM-40_c" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-40_c.rule"/>
         </rule>
         <rule header="复制构造函数和复制赋值运算符都应该为具有非平凡析构函数的类声明" id="40_d" impl="MRM-40_d" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-40_d.rule"/>
         </rule>
         <rule header="不要在指针类型上使用 sizeof 操作符来指定通过 'malloc'， 'calloc' 或 'realloc' 函数分配的内存大小" id="45" impl="MRM-45" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-45.rule"/>
         </rule>
         <rule header="不要使用 calloc, malloc, realloc 和 free 函数" id="46" impl="MRM-46" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-46.rule"/>
         </rule>
         <rule header="包含至少一个非静态成员变量的类应该声明赋值操作符或包含适当的注释" id="47" impl="MRM-47" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-47.rule"/>
         </rule>
         <rule header="包含至少一个非静态成员变量的类应该声明拷贝构造函数或包含适当的注释" id="48" impl="MRM-48" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-48.rule"/>
         </rule>
         <rule header="应为包含指向数据项或非平凡析构函数的指针的类声明一个拷贝构造函数和一个拷贝赋值操作符" id="49" impl="MRM-49" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-49.rule"/>
         </rule>
         <rule header="不要对指向一个void类型的指针使用'delete'" id="51" impl="MRM-51" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-51.rule"/>
         </rule>
         <rule header="当分配失败时，用户定义的'new'操作符应该抛出'std::bad_alloc'异常" id="53" impl="MRM-53" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-53.rule"/>
         </rule>
         <rule header="避免对过度对齐类型使用默认运算符 'new'" id="54" impl="MRM-54" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-54.rule"/>
         </rule>
         <rule header="当一个对象数组传递给配置 'new' 的分配作用时会存在开销" id="55_b" impl="MRM-55_b" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-55_b.rule"/>
         </rule>
         <rule header="拷贝赋值运算符不应有可能会影响复制对象的作用" id="56" impl="MRM-56" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-56.rule"/>
         </rule>
         <rule header="移动赋值运算符不应具有可能影响移动对象的副作用" id="57" impl="MRM-57" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-57.rule"/>
         </rule>
         <rule header="内存分配函数的结果应被立即转换" id="58_a" impl="MRM-58_a" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-58_a.rule"/>
         </rule>
         <rule header="私有的拷贝构造函数和拷贝赋值运算符要同时声明" id="50" impl="MRM-50" quickfix="false" scope="line" severity="4">
            <file path="MRM\MRM-50.rule"/>
         </rule>
         <rule header="使用 RAII 防止资源泄漏" id="52" impl="MRM-52" quickfix="false" scope="line" severity="4">
            <file path="MRM\MRM-52.rule"/>
         </rule>
         <rule header="内存分配函数的结果应该立即被转换为指向被分配类型的指针" id="58_b" impl="MRM-58_b" quickfix="false" scope="line" severity="4">
            <file path="MRM\MRM-58_b.rule"/>
         </rule>
      </category>
      <category description="面向对象" name="OOP">
         <rule header="类不能多次继承其它类，除非是虚拟继承" id="03" impl="OOP-03" quickfix="false" scope="line" severity="1">
            <file path="OOP\OOP-03.rule"/>
         </rule>
         <rule header="要小心使用不是抽象接口的类的多重继承" id="07" impl="OOP-07" quickfix="false" scope="line" severity="1">
            <file path="OOP\OOP-07.rule"/>
         </rule>
         <rule header="确保派生类最多具有一个不是接口类的基类" id="07_c" impl="OOP-07_c" quickfix="false" scope="line" severity="1">
            <file path="OOP\OOP-07_c.rule"/>
         </rule>
         <rule header="禁止构造函数直接访问全局数据" id="08" impl="OOP-08" quickfix="false" scope="line" severity="1">
            <file path="OOP\OOP-08.rule"/>
         </rule>
         <rule header="避免从构造函数调用虚函数" id="16" impl="OOP-16" quickfix="false" scope="line" severity="1">
            <file path="OOP\OOP-16.rule"/>
         </rule>
         <rule header="避免从析构函数调用虚函数" id="16_b" impl="OOP-16_b" quickfix="false" scope="line" severity="1">
            <file path="OOP\OOP-16_b.rule"/>
         </rule>
         <rule header="在具有虚函数的基类中定义虚拟析构函数" id="22" impl="OOP-22" quickfix="false" scope="line" severity="1">
            <file path="OOP\OOP-22.rule"/>
         </rule>
         <rule header="在基类中将析构函数设置为虚拟的" id="24" impl="OOP-24" quickfix="false" scope="line" severity="1">
            <file path="OOP\OOP-24.rule"/>
         </rule>
         <rule header="指向抽象类的指针不能被转换为指向继承于该类的子类的指针" id="29" impl="OOP-29" quickfix="false" scope="line" severity="1">
            <file path="OOP\OOP-29.rule"/>
         </rule>
         <rule header="设置基类的析构函数为 public、virtual 或者 protected、nonvirtual" id="31" impl="OOP-31" quickfix="false" scope="line" severity="1">
            <file path="OOP\OOP-31.rule"/>
         </rule>
         <rule header="如果调用了某个类的析构函数并且该类含有虚拟函数，那么该类也应该含有虚拟析构函数" id="38" impl="OOP-38" quickfix="false" scope="line" severity="1">
            <file path="OOP\OOP-38.rule"/>
         </rule>
         <rule header="禁止对多态类型进行从基类型到衍生类的强制类型转换" id="49" impl="OOP-49" quickfix="false" scope="line" severity="1">
            <file path="OOP\OOP-49.rule"/>
         </rule>
         <rule header="禁止使用多重继承" id="05" impl="OOP-05" quickfix="false" scope="line" severity="2">
            <file path="OOP\OOP-05.rule"/>
         </rule>
         <rule header="多重继承应该限制为之多1个受保护的实现" id="07_a" impl="OOP-07_a" quickfix="false" scope="line" severity="2">
            <file path="OOP\OOP-07_a.rule"/>
         </rule>
         <rule header="多重继承不应该使用任何public实现" id="07_b" impl="OOP-07_b" quickfix="false" scope="line" severity="2">
            <file path="OOP\OOP-07_b.rule"/>
         </rule>
         <rule header="避免在成员函数中使用全局数据" id="10" impl="OOP-10" quickfix="false" scope="line" severity="2">
            <file path="OOP\OOP-10.rule"/>
         </rule>
         <rule header="避免 &quot;public&quot; 数据成员" id="18" impl="OOP-18" quickfix="false" scope="line" severity="2">
            <file path="OOP\OOP-18.rule"/>
         </rule>
         <rule header="避免 'protected' 数据成员" id="19" impl="OOP-19" quickfix="false" scope="line" severity="2">
            <file path="OOP\OOP-19.rule"/>
         </rule>
         <rule header="如果类中含有虚拟函数，那么它也应该包含虚拟析构函数" id="23" impl="OOP-23" quickfix="false" scope="line" severity="2">
            <file path="OOP\OOP-23.rule"/>
         </rule>
         <rule header="避免向下转换继承层级结构" id="28" impl="OOP-28" quickfix="false" scope="line" severity="2">
            <file path="OOP\OOP-28.rule"/>
         </rule>
         <rule header="向下的强制转换(基类到衍生类的转换)是不允许的" id="35" impl="OOP-35" quickfix="false" scope="line" severity="2">
            <file path="OOP\OOP-35.rule"/>
         </rule>
         <rule header="有状态的虚拟类应该在每个访问该类的衍生类中进行显式地声明" id="39_b" impl="OOP-39_b" quickfix="false" scope="line" severity="2">
            <file path="OOP\OOP-39_b.rule"/>
         </rule>
         <rule header="在同一层次结构中，基类不能同时具有虚拟及非虚拟的属性" id="41" impl="OOP-41" quickfix="false" scope="line" severity="2">
            <file path="OOP\OOP-41.rule"/>
         </rule>
         <rule header="在基类中避免使用公共(public)拷贝构造函数和赋值运算符" id="01" impl="OOP-01" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-01.rule"/>
         </rule>
         <rule header="避免使用切片，基类中应该使用克隆而非拷贝" id="02" impl="OOP-02" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-02.rule"/>
         </rule>
         <rule header="不要从多于一个基类中派生出相同名字的函数" id="04" impl="OOP-04" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-04.rule"/>
         </rule>
         <rule header="对于多重继承使用虚公共基类" id="06" impl="OOP-06" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-06.rule"/>
         </rule>
         <rule header="避免在析构函数中使用全局对象" id="09" impl="OOP-09" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-09.rule"/>
         </rule>
         <rule header="避免使用友元(friend)机制" id="11" impl="OOP-11" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-11.rule"/>
         </rule>
         <rule header="除了比较运算符的声明外，不得使用友元声明" id="11_b" impl="OOP-11_b" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-11_b.rule"/>
         </rule>
         <rule header="受保护(Protected)的成员函数不得返回指向私有类数据的非 const 句柄(指针或引用)" id="12" impl="OOP-12" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-12.rule"/>
         </rule>
         <rule header="禁止使用不同的默认参数值来重定义继承的虚拟函数" id="13" impl="OOP-13" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-13.rule"/>
         </rule>
         <rule header="避免从衍生类到基类的显式类型转换" id="20" impl="OOP-20" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-20.rule"/>
         </rule>
         <rule header="如果子类型实现了虚拟函数，则应使用虚拟关键词" id="21" impl="OOP-21" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-21.rule"/>
         </rule>
         <rule header="避免把虚函数声明为内联函数" id="25" impl="OOP-25" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-25.rule"/>
         </rule>
         <rule header="禁止把指向派生类中对象的指针转化为指向虚基类的对象的指针" id="26" impl="OOP-26" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-26.rule"/>
         </rule>
         <rule header="为带有引用成员或常量成员的类声明拷贝赋值操作符" id="27" impl="OOP-27" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-27.rule"/>
         </rule>
         <rule header="未在类中声明复制构造函数以及拷贝赋值运算符为私有，而在特殊设计的基类型中进行声明" id="30" impl="OOP-30" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-30.rule"/>
         </rule>
         <rule header="禁止对继承的非虚拟函数进行重定义" id="32" impl="OOP-32" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-32.rule"/>
         </rule>
         <rule header="禁止对含有模板参数的继承非虚拟函数进行重定义" id="33" impl="OOP-33" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-33.rule"/>
         </rule>
         <rule header="公共成员函数不应该返回指向私有的/受保护的类数据的非常量句柄" id="36" impl="OOP-36" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-36.rule"/>
         </rule>
         <rule header="在抽象类中拷贝赋值运算符应该被声明为 protected 或 private" id="42" impl="OOP-42" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-42.rule"/>
         </rule>
         <rule header="在继承层次结构中，其每条路径中的每个虚拟函数应该有多个定义" id="44" impl="OOP-44" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-44.rule"/>
         </rule>
         <rule header="具有单一基本类型参数可调用的构造函数应该显式地声明" id="45" impl="OOP-45" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-45.rule"/>
         </rule>
         <rule header="拷贝构造函数应仅对其基类型及该类型的非静态成员进行初始化" id="46" impl="OOP-46" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-46.rule"/>
         </rule>
         <rule header="类不能从虚拟基类型中衍生" id="47" impl="OOP-47" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-47.rule"/>
         </rule>
         <rule header="非 POD 类型的成员数据应该为  private 类型" id="48" impl="OOP-48" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-48.rule"/>
         </rule>
         <rule header="指向虚拟基类型的指针只能通过dynamic_cast的方式转换为指向其衍生类的指针" id="50" impl="OOP-50" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-50.rule"/>
         </rule>
         <rule header="派生类里声明的成员函数不应该隐藏基类中声明的函数" id="53" impl="OOP-53" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-53.rule"/>
         </rule>
         <rule header="不要增加重写或隐藏方法的可访问性" id="54" impl="OOP-54" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-54.rule"/>
         </rule>
         <rule header="用户定义的赋值操作符不应是虚拟的" id="56" impl="OOP-56" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-56.rule"/>
         </rule>
         <rule header="结构体应该只包含公共数据成员，不应该是基类或继承" id="57" impl="OOP-57" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-57.rule"/>
         </rule>
         <rule header="Write a using declaration to redeclare overloaded functions" id="17" impl="OOP-17" quickfix="false" scope="line" severity="4">
            <file path="OOP\OOP-17.rule"/>
         </rule>
         <rule header="检查 operator= 中的自我赋值" id="34" impl="OOP-34" quickfix="false" scope="line" severity="4">
            <file path="OOP\OOP-34.rule"/>
         </rule>
         <rule header="有状态的虚拟类应该在每个访问该类的衍生类中进行显式地声明" id="39" impl="OOP-39" quickfix="false" scope="line" severity="4">
            <file path="OOP\OOP-39.rule"/>
         </rule>
         <rule header="层次结构应该基于抽象类" id="40" impl="OOP-40" quickfix="false" scope="line" severity="4">
            <file path="OOP\OOP-40.rule"/>
         </rule>
         <rule header="虚拟函数仅能被自身声明为纯虚拟的纯虚拟函数进行覆盖" id="43" impl="OOP-43" quickfix="false" scope="line" severity="4">
            <file path="OOP\OOP-43.rule"/>
         </rule>
         <rule header="执行类的指针不能被转换成指向另一个类的指针类型除非该类继承自另一个类" id="52" impl="OOP-52" quickfix="false" scope="line" severity="4">
            <file path="OOP\OOP-52.rule"/>
         </rule>
         <rule header="非 POD 类型应定义为类" id="55" impl="OOP-55" quickfix="false" scope="line" severity="4">
            <file path="OOP\OOP-55.rule"/>
         </rule>
         <rule header="使用组合 composition 而非使用私有继承" id="14" impl="OOP-14" quickfix="false" scope="line" severity="5">
            <file path="OOP\OOP-14.rule"/>
         </rule>
         <rule header="不使用继承的时候，最好使用复合关系" id="37" impl="OOP-37" quickfix="false" scope="line" severity="5">
            <file path="OOP\OOP-37.rule"/>
         </rule>
         <rule header="使用命名空间而不是类或只包含静态的功能结构体" id="51" impl="OOP-51" quickfix="false" scope="line" severity="5">
            <file path="OOP\OOP-51.rule"/>
         </rule>
      </category>
      <category description="潜在的缺陷" name="PB">
         <rule header="不要释放空指针" id="13" impl="PB-13" quickfix="false" scope="line" severity="1">
            <file path="PB\PB-13.rule"/>
         </rule>
         <rule header="提供正确的字符串终止符" id="21" impl="PB-21" quickfix="false" scope="line" severity="1">
            <file path="PB\PB-21.rule"/>
         </rule>
         <rule header="如果类具有非静态指针且没有声明的复制构造函数，则应通过引用传递类对象" id="23" impl="PB-23" quickfix="false" scope="line" severity="1">
            <file path="PB\PB-23.rule"/>
         </rule>
         <rule header="操作符不能使用引用返回值" id="09" impl="PB-09" quickfix="false" scope="line" severity="2">
            <file path="PB\PB-09.rule"/>
         </rule>
         <rule header="构造函数的定义中不能包含特定的缺省参数，这些参数可能产生与隐性声明的复制构造函数完全一样的签名" id="24" impl="PB-24" quickfix="false" scope="line" severity="2">
            <file path="PB\PB-24.rule"/>
         </rule>
         <rule header="不要使用无符号算术" id="25" impl="PB-25" quickfix="false" scope="line" severity="2">
            <file path="PB\PB-25.rule"/>
         </rule>
         <rule header="public 和 protected 的方法不应被类的构造函数调用" id="26" impl="PB-26" quickfix="false" scope="line" severity="2">
            <file path="PB\PB-26.rule"/>
         </rule>
         <rule header="字符串字面量不应该被修改" id="27" impl="PB-27" quickfix="false" scope="line" severity="2">
            <file path="PB\PB-27.rule"/>
         </rule>
         <rule header="下列的字符序列不得出现在头文件名中： ', \, /*, //, 或 &quot;" id="28" impl="PB-28" quickfix="false" scope="line" severity="2">
            <file path="PB\PB-28.rule"/>
         </rule>
         <rule header="右移位操作符的左操作数不能是负数" id="29" impl="PB-29" quickfix="false" scope="line" severity="2">
            <file path="PB\PB-29.rule"/>
         </rule>
         <rule header="映射过程中不要从不完整类映射，或者映射到不完整类" id="54" impl="PB-54" quickfix="false" scope="line" severity="2">
            <file path="PB\PB-54.rule"/>
         </rule>
         <rule header="不要在删除点上时删除类不完整的对象" id="55" impl="PB-55" quickfix="false" scope="line" severity="2">
            <file path="PB\PB-55.rule"/>
         </rule>
         <rule header="由于只有零或非零常量的枚举，布尔条件总是计算为相同的值" id="68" impl="PB-68" quickfix="false" scope="line" severity="2">
            <file path="PB\PB-68.rule"/>
         </rule>
         <rule header="不要使用解引用指针类型的表达式" id="01" impl="PB-01" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-01.rule"/>
         </rule>
         <rule header="不要在 a(b), a[b] 和类型转换语句内部使用赋值" id="02" impl="PB-02" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-02.rule"/>
         </rule>
         <rule header="不允许在三元运算符中使用混合类型" id="03" impl="PB-03" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-03.rule"/>
         </rule>
         <rule header="函数的返回值必须与声明的返回类型一致" id="05" impl="PB-05" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-05.rule"/>
         </rule>
         <rule header="赋值运算符应该具有兼容类型的操作数" id="06" impl="PB-06" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-06.rule"/>
         </rule>
         <rule header="不给不兼容类型的变量赋函数返回值" id="07" impl="PB-07" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-07.rule"/>
         </rule>
         <rule header="不允许将有符号常量赋值给无符号整型变量" id="08" impl="PB-08" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-08.rule"/>
         </rule>
         <rule header="不要以多态方式处理数组" id="10" impl="PB-10" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-10.rule"/>
         </rule>
         <rule header="函数声明的形参类型和实参类型必须匹配" id="11" impl="PB-11" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-11.rule"/>
         </rule>
         <rule header="不要将有符号字符强制转换成无符号整型" id="12" impl="PB-12" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-12.rule"/>
         </rule>
         <rule header="不正确的 EOS(串尾)定义" id="14" impl="PB-14" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-14.rule"/>
         </rule>
         <rule header="不能将两个整数相除之后的结果赋给浮点类型" id="15" impl="PB-15" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-15.rule"/>
         </rule>
         <rule header="避免无意地丢弃整数除法的余数" id="15_b" impl="PB-15_b" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-15_b.rule"/>
         </rule>
         <rule header="避免将越界数值赋值给字符类型" id="16" impl="PB-16" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-16.rule"/>
         </rule>
         <rule header="避免将越界数值赋值给无符号字符类型" id="17" impl="PB-17" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-17.rule"/>
         </rule>
         <rule header="避免在指针和数字类型上重载类方法。" id="18" impl="PB-18" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-18.rule"/>
         </rule>
         <rule header="不应创建带有局部静态数据的内联非成员函数" id="19" impl="PB-19" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-19.rule"/>
         </rule>
         <rule header="避免切片函数参数/返回值" id="20" impl="PB-20" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-20.rule"/>
         </rule>
         <rule header="不能在 a(b),a[b] 和类型转换中使用自增或自减表达式" id="22" impl="PB-22" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-22.rule"/>
         </rule>
         <rule header="多于一个枚举('enum')类型应该用作 switch 的条件或 case 语句的标签" id="30" impl="PB-30" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-30.rule"/>
         </rule>
         <rule header="不要在常量上调用 'sizeof'" id="31" impl="PB-31" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-31.rule"/>
         </rule>
         <rule header="不要在指针类型上调用'sizeof'" id="32" impl="PB-32" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-32.rule"/>
         </rule>
         <rule header="避免使用枚举类型隐式类型转换" id="33" impl="PB-33" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-33.rule"/>
         </rule>
         <rule header="在涉及枚举类型的比较中避免隐式类型转换" id="33_b" impl="PB-33_b" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-33_b.rule"/>
         </rule>
         <rule header="'memcpy'/'strncpy'/'memmove' 的第三个参数不应该依赖于第二个参数" id="34" impl="PB-34" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-34.rule"/>
         </rule>
         <rule header="赋值操作符不得使用在没有括号的条件中" id="35" impl="PB-35" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-35.rule"/>
         </rule>
         <rule header="不得使用库 &lt;cstring&gt; 的无界函数" id="37" impl="PB-37" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-37.rule"/>
         </rule>
         <rule header="窄字符串和宽字符串不应该串联在一起" id="38" impl="PB-38" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-38.rule"/>
         </rule>
         <rule header="不应连接具有不同编码前缀的字符串文字" id="38_b" impl="PB-38_b" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-38_b.rule"/>
         </rule>
         <rule header="函数不得返回一个引用或指针给通过引用或常数引用传递的参数" id="39" impl="PB-39" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-39.rule"/>
         </rule>
         <rule header="函数不应返回对常量引用传递的指针或参数的引用" id="39_b" impl="PB-39_b" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-39_b.rule"/>
         </rule>
         <rule header="作为函数实参传递的数组类型标识符不得退化为一个指针" id="41" impl="PB-41" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-41.rule"/>
         </rule>
         <rule header="不要将具有数组类型的表达式传递给一个具有指针或者数组类型参数的函数" id="41_b" impl="PB-41_b" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-41_b.rule"/>
         </rule>
         <rule header="对象不能赋值给一个重叠的对象" id="42" impl="PB-42" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-42.rule"/>
         </rule>
         <rule header="一个类的所有构造函数应该显式地为它的所有直接基类和所有虚拟基类调用一个构造函数" id="43" impl="PB-43" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-43.rule"/>
         </rule>
         <rule header="使用 'std::atexit()' 或 'std::at_quick_exit()' 注册函数的执行不应异常退出" id="44" impl="PB-44" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-44.rule"/>
         </rule>
         <rule header="格式字符串中的 '%s' 和 '%c' 格式说明符与其在调用字符串格式化函数时的相应参数之间不应存在不匹配" id="45" impl="PB-45" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-45.rule"/>
         </rule>
         <rule header="格式字符串中的'％f'格式说明符与调用字符串格式函数的相应参数之间不应存在不匹配" id="46" impl="PB-46" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-46.rule"/>
         </rule>
         <rule header="格式字符串中的'％f'格式说明符与调用字符串格式函数的相应参数之间不应存在不匹配" id="47" impl="PB-47" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-47.rule"/>
         </rule>
         <rule header="在调用字符串格式化函数时，格式字符串中的'%u'格式说明符及其对应的参数之间不应存在不匹配" id="48" impl="PB-48" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-48.rule"/>
         </rule>
         <rule header="在调用字符串格式化函数时，格式字符串中的'%p'格式说明符及其对应的参数之间不应存在不匹配" id="49" impl="PB-49" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-49.rule"/>
         </rule>
         <rule header="格式字符串中的格式说明符的数量和调用字符串格式化函数时相应的参数的数量应该相等" id="50" impl="PB-50" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-50.rule"/>
         </rule>
         <rule header="指针运算不得用于指向非数组类型变量的指针" id="51" impl="PB-51" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-51.rule"/>
         </rule>
         <rule header="避免在指针和数值类型上重载全局函数" id="52" impl="PB-52" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-52.rule"/>
         </rule>
         <rule header="避免在指针和数值类型上重载命名空间函数" id="53" impl="PB-53" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-53.rule"/>
         </rule>
         <rule header="避免从有符号类型到无符号类型的隐式变换" id="56" impl="PB-56" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-56.rule"/>
         </rule>
         <rule header="指向派生类对象数组的指针不应转换为基类指针" id="57" impl="PB-57" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-57.rule"/>
         </rule>
         <rule header="在枚举器列表中，隐式指定的枚举常量的值应该是唯一的" id="58" impl="PB-58" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-58.rule"/>
         </rule>
         <rule header="字符串数组初始化时缺失逗号" id="59" impl="PB-59" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-59.rule"/>
         </rule>
         <rule header="可疑的动态内存分配参数" id="60" impl="PB-60" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-60.rule"/>
         </rule>
         <rule header="不得在新分配的内存上执行指针算术运算" id="61" impl="PB-61" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-61.rule"/>
         </rule>
         <rule header="避免参数顺序不正确的函数调用" id="62" impl="PB-62" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-62.rule"/>
         </rule>
         <rule header="函数地址不应与零相比较" id="63" impl="PB-63" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-63.rule"/>
         </rule>
         <rule header="字符串比较的返回值仅和0比较" id="64" impl="PB-64" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-64.rule"/>
         </rule>
         <rule header="避免将表达式的结果赋给更大整数类型的变量，这可能出现整数溢出" id="65" impl="PB-65" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-65.rule"/>
         </rule>
         <rule header="避免将表达式的结果与更广泛的整数类型的表达式进行比较，可能会整数溢出" id="65_b" impl="PB-65_b" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-65_b.rule"/>
         </rule>
         <rule header="'+'， '-'， '*' 运算符常量表达式中的整数溢出或下溢" id="66_a" impl="PB-66_a" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-66_a.rule"/>
         </rule>
         <rule header="if-else 语句的两个分支中的代码(预处理后)相同" id="67" impl="PB-67" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-67.rule"/>
         </rule>
         <rule header="对象的一个元素不能被初始化超过一次" id="69" impl="PB-69" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-69.rule"/>
         </rule>
         <rule header="带有枚举底层类型的表达式只能具有与枚举的枚举数相对应的值" id="70" impl="PB-70" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-70.rule"/>
         </rule>
         <rule header="不要复制包含柔性数组成员的结构体的实例" id="71" impl="PB-71" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-71.rule"/>
         </rule>
         <rule header="不要使用错误的参数类型调用va_arg" id="72" impl="PB-72" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-72.rule"/>
         </rule>
         <rule header="不得使用  'stdlib.h' 或者 'cstdlib' 库中的 'abort()' 函数" id="75" impl="PB-75" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-75.rule"/>
         </rule>
         <rule header="'stdlib.h' 或者 'cstdlib' 库中的 'exit()' 函数不应该被使用" id="75_b" impl="PB-75_b" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-75_b.rule"/>
         </rule>
         <rule header="不得使用 'stdlib.h' 或 'cstdlib' 库中的 'quick_exit()' 和 '_Exit()' 函数" id="75_c" impl="PB-75_c" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-75_c.rule"/>
         </rule>
         <rule header="不能使用 C 风格的字符串" id="76" impl="PB-76" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-76.rule"/>
         </rule>
         <rule header="表达式语句不能只显式调用临时对象的构造函数" id="77" impl="PB-77" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-77.rule"/>
         </rule>
         <rule header="在程序员定义的整数类型上使用 intmax_t 或 uintmax_t 进行格式化 IO" id="78" impl="PB-78" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-78.rule"/>
         </rule>
         <rule header="避免语法上有歧义的函数声明" id="79" impl="PB-79" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-79.rule"/>
         </rule>
         <rule header="使用链式指示符的初始化器不应包含没有指示符的初始化器" id="80" impl="PB-80" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-80.rule"/>
         </rule>
         <rule header="'&lt;&lt;' 运算符常量表达式中的整数溢出或下溢" id="66_b" impl="PB-66_b" quickfix="false" scope="line" severity="4">
            <file path="PB\PB-66_b.rule"/>
         </rule>
         <rule header="不要从迭代器中添加或减去一个值大于1的常量" id="74" impl="PB-74" quickfix="false" scope="line" severity="4">
            <file path="PB\PB-74.rule"/>
         </rule>
         <rule header="对常量无符号整数表达式的求值不应该导致循环" id="73" impl="PB-73" quickfix="false" scope="line" severity="5">
            <file path="PB\PB-73.rule"/>
         </rule>
      </category>
      <category description="Qt 最佳实践" name="QT">
         <rule header="SIGNAL 和 SLOT 宏中的方法必须存在" id="04" impl="QT-04" quickfix="false" scope="line" severity="1">
            <file path="QT\QT-04.rule"/>
         </rule>
         <rule header="不要通过调用 QThread::terminate() 来强制线程终止" id="07" impl="QT-07" quickfix="false" scope="line" severity="1">
            <file path="QT\QT-07.rule"/>
         </rule>
         <rule header="在 QMutexLocker 上不调用 new" id="09" impl="QT-09" quickfix="false" scope="line" severity="1">
            <file path="QT\QT-09.rule"/>
         </rule>
         <rule header="不要直接设置由 Qt 内核设置的特定 Widget 属性" id="12" impl="QT-12" quickfix="false" scope="line" severity="1">
            <file path="QT\QT-12.rule"/>
         </rule>
         <rule header="每个QObject子类都应该包含一个Q_OBJECT宏" id="01" impl="QT-01" quickfix="false" scope="line" severity="3">
            <file path="QT\QT-01.rule"/>
         </rule>
         <rule header="QObject 不得多次继承" id="02" impl="QT-02" quickfix="false" scope="line" severity="3">
            <file path="QT\QT-02.rule"/>
         </rule>
         <rule header="只能将一个信号连接到一个槽或一个信号连接到另一个信号" id="03" impl="QT-03" quickfix="false" scope="line" severity="3">
            <file path="QT\QT-03.rule"/>
         </rule>
         <rule header="用关键字 &quot;emit&quot; 标记信号发射( signal emission )，以区分信号发射和普通方法调用" id="05" impl="QT-05" quickfix="false" scope="line" severity="3">
            <file path="QT\QT-05.rule"/>
         </rule>
         <rule header="不要为 QThreads 设置 Idle 或 Critical 优先级。只使用 High/Low/Med" id="06" impl="QT-06" quickfix="false" scope="line" severity="3">
            <file path="QT\QT-06.rule"/>
         </rule>
         <rule header="如果在函数中对互斥使用锁，则释放同一函数中的锁" id="08" impl="QT-08" quickfix="false" scope="line" severity="3">
            <file path="QT\QT-08.rule"/>
         </rule>
         <rule header="为任何具有指针的Qt继承对象声明一个复制构造函数和操作符=" id="10" impl="QT-10" quickfix="false" scope="line" severity="3">
            <file path="QT\QT-10.rule"/>
         </rule>
         <rule header="永远不要在赋值中混用常量和非常量迭代器" id="13" impl="QT-13" quickfix="false" scope="line" severity="3">
            <file path="QT\QT-13.rule"/>
         </rule>
         <rule header="如果使用 Q_DECLARE_FLAGS ，那么就必须使用 Q_DECLARE_OPERATORS_FOR_FLAGS" id="14" impl="QT-14" quickfix="false" scope="line" severity="3">
            <file path="QT\QT-14.rule"/>
         </rule>
         <rule header="Q_DECLARE_OPERATORS_FOR_FLAGS 必须位于全局命名空间中，Q_DECLARE_FLAGS 必须位于枚举的命名空间中" id="15" impl="QT-15" quickfix="false" scope="line" severity="3">
            <file path="QT\QT-15.rule"/>
         </rule>
         <rule header="Q_PROPERTY 的 getter 和 setter 函数必须存在，且类型必须匹配" id="16" impl="QT-16" quickfix="false" scope="line" severity="3">
            <file path="QT\QT-16.rule"/>
         </rule>
         <rule header="枚举类型的属性必须使用 Q_ENUMS" id="17" impl="QT-17" quickfix="false" scope="line" severity="3">
            <file path="QT\QT-17.rule"/>
         </rule>
         <rule header="不应该在 Qt 对象上调用非常量函数" id="18" impl="QT-18" quickfix="false" scope="line" severity="3">
            <file path="QT\QT-18.rule"/>
         </rule>
         <rule header="不要在小部件上使用 setWindowFlags 函数" id="11" impl="QT-11" quickfix="false" scope="line" severity="4">
            <file path="QT\QT-11.rule"/>
         </rule>
      </category>
      <category description="安全性" name="SECURITY">
         <rule header="请勿使用 gets() 函数" id="16" impl="SECURITY-16" quickfix="false" scope="line" severity="1">
            <file path="SECURITY\SECURITY-16.rule"/>
         </rule>
         <rule header="谨慎使用以确保 LoadLibrary() 加载正确的库" id="04" impl="SECURITY-04" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-04.rule"/>
         </rule>
         <rule header="避免调用只有一个参数而不是字符串常量的函数 printf/wprintf" id="05" impl="SECURITY-05" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-05.rule"/>
         </rule>
         <rule header="当第二个参数是变量时，避免使用只有两个参数的函数 fprintf/fwprintf" id="08" impl="SECURITY-08" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-08.rule"/>
         </rule>
         <rule header="避免使用标准库中 'string' 类中的 data() 函数" id="09" impl="SECURITY-09" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-09.rule"/>
         </rule>
         <rule header="避免使用 'vfork()' 函数" id="10" impl="SECURITY-10" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-10.rule"/>
         </rule>
         <rule header="避免使用可能受到 shell 元字符影响的不安全 shell 函数" id="11" impl="SECURITY-11" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-11.rule"/>
         </rule>
         <rule header="避免使用可能导致缓冲区溢出的不安全字符串函数" id="12" impl="SECURITY-12" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-12.rule"/>
         </rule>
         <rule header="避免使用不安全的不检查界限的字符串函数" id="13" impl="SECURITY-13" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-13.rule"/>
         </rule>
         <rule header="不要在不指定可变大小的格式字符串的情况下使用 scanf 和 fscanf 函数" id="14" impl="SECURITY-14" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-14.rule"/>
         </rule>
         <rule header="不要将应用程序错误导致的潜在敏感信息打印到异常消息中" id="15" impl="SECURITY-15" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-15.rule"/>
         </rule>
         <rule header="避免将非常量参数或变量传递给 exec" id="17" impl="SECURITY-17" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-17.rule"/>
         </rule>
         <rule header="避免将动态生成的字符串传递给 exec" id="18" impl="SECURITY-18" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-18.rule"/>
         </rule>
         <rule header="不允许使用容易发生竞争的功能" id="19" impl="SECURITY-19" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-19.rule"/>
         </rule>
         <rule header="避免将用户的输入作为参数传递给方法" id="20" impl="SECURITY-20" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-20.rule"/>
         </rule>
         <rule header="不能将 'syslog' 函数用于日志记录目的" id="21" impl="SECURITY-21" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-21.rule"/>
         </rule>
         <rule header="不要使用 mbstowcs() 函数" id="22" impl="SECURITY-22" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-22.rule"/>
         </rule>
         <rule header="警惕使用那些返回当前目录或窗口目录的函数" id="23" impl="SECURITY-23" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-23.rule"/>
         </rule>
         <rule header="避免使用InitializeCriticalSection" id="24" impl="SECURITY-24" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-24.rule"/>
         </rule>
         <rule header="避免使用对线程不安全(thread-unsafe)的函数" id="25" impl="SECURITY-25" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-25.rule"/>
         </rule>
         <rule header="不要在源代码中使用 'setuid'" id="26" impl="SECURITY-26" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-26.rule"/>
         </rule>
         <rule header="不要使用 chmod(), chown(), chgrp()" id="27" impl="SECURITY-27" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-27.rule"/>
         </rule>
         <rule header="出于安全考虑，不应该使用标准随机数生成器来生成随机性" id="28" impl="SECURITY-28" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-28.rule"/>
         </rule>
         <rule header="不能使用已弃用的 C 程序 ulimit()" id="29" impl="SECURITY-29" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-29.rule"/>
         </rule>
         <rule header="避免在程序代码中使用 'getpw' 函数" id="30" impl="SECURITY-30" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-30.rule"/>
         </rule>
         <rule header="不要使用 'cuserid' 函数" id="31" impl="SECURITY-31" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-31.rule"/>
         </rule>
         <rule header="避免使用已经废弃的 C 程序 'usleep'" id="32" impl="SECURITY-32" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-32.rule"/>
         </rule>
         <rule header="禁止使用那些不能正确处理非空结束的字符串的函数" id="33" impl="SECURITY-33" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-33.rule"/>
         </rule>
         <rule header="避免使用环境变量" id="34" impl="SECURITY-34" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-34.rule"/>
         </rule>
         <rule header="不要相信任何可能被攻击者设置的命令行值" id="35" impl="SECURITY-35" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-35.rule"/>
         </rule>
         <rule header="禁止使用来自不信任用户的未经过滤的数据作为格式化参数" id="36" impl="SECURITY-36" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-36.rule"/>
         </rule>
         <rule header="请勿使用弱加密功能" id="37" impl="SECURITY-37" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-37.rule"/>
         </rule>
         <rule header="不可信任数据用作循环边界" id="38" impl="SECURITY-38" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-38.rule"/>
         </rule>
         <rule header="不应使用函数 'asctime()' 和 'asctime_r()'" id="01" impl="SECURITY-01" quickfix="false" scope="line" severity="3">
            <file path="SECURITY\SECURITY-01.rule"/>
         </rule>
         <rule header="不应使用随机数函数'rand()'和'srand()'" id="02" impl="SECURITY-02" quickfix="false" scope="line" severity="3">
            <file path="SECURITY\SECURITY-02.rule"/>
         </rule>
         <rule header="不要使用 rand() 函数来生成伪随机数" id="02_b" impl="SECURITY-02_b" quickfix="false" scope="line" severity="3">
            <file path="SECURITY\SECURITY-02_b.rule"/>
         </rule>
         <rule header="避免使用 MFC 库中的时间函数" id="06" impl="SECURITY-06" quickfix="false" scope="line" severity="3">
            <file path="SECURITY\SECURITY-06.rule"/>
         </rule>
         <rule header="不要使用不安全的 C 函数来写入未检查范围的缓冲区" id="07" impl="SECURITY-07" quickfix="false" scope="line" severity="3">
            <file path="SECURITY\SECURITY-07.rule"/>
         </rule>
         <rule header="使用安全的临时文件名称函数" id="39" impl="SECURITY-39" quickfix="false" scope="line" severity="3">
            <file path="SECURITY\SECURITY-39.rule"/>
         </rule>
         <rule header="如果文件是使用 'open' 或 'openat' 系统调用创建的，则指定访问权限位" id="42" impl="SECURITY-42" quickfix="false" scope="line" severity="3">
            <file path="SECURITY\SECURITY-42.rule"/>
         </rule>
         <rule header="不应该使用 'PTHREAD_CANCEL_ASYNCHRONOUS'参数来调用函数'pthread_setcanceltype()'" id="43" impl="SECURITY-43" quickfix="false" scope="line" severity="3">
            <file path="SECURITY\SECURITY-43.rule"/>
         </rule>
         <rule header="在放弃特权时遵守正确的撤销命令" id="44" impl="SECURITY-44" quickfix="false" scope="line" severity="3">
            <file path="SECURITY\SECURITY-44.rule"/>
         </rule>
         <rule header="确保成功地放弃特权" id="45" impl="SECURITY-45" quickfix="false" scope="line" severity="3">
            <file path="SECURITY\SECURITY-45.rule"/>
         </rule>
         <rule header="不应将指向结构体的指针传递给可将数据复制到用户空间的函数" id="46" impl="SECURITY-46" quickfix="false" scope="line" severity="3">
            <file path="SECURITY\SECURITY-46.rule"/>
         </rule>
         <rule header="检查 shift 操作符的右指针操作数时，请使用正确的整数精度" id="47" impl="SECURITY-47" quickfix="false" scope="line" severity="3">
            <file path="SECURITY\SECURITY-47.rule"/>
         </rule>
         <rule header="不要调用 'stdlib.h' 或 'cstdlib' 库中参数不为 '0'（空指针）的 'system()' 函数" id="48" impl="SECURITY-48" quickfix="false" scope="line" severity="3">
            <file path="SECURITY\SECURITY-48.rule"/>
         </rule>
         <rule header="不得使用 'stdlib.h' 或 'cstdlib' 库中的 'system()' 函数" id="48_b" impl="SECURITY-48_b" quickfix="false" scope="line" severity="3">
            <file path="SECURITY\SECURITY-48_b.rule"/>
         </rule>
         <rule header="不要使用 'char' 缓冲区来存储来自 'std::cin' 的输入" id="51" impl="SECURITY-51" quickfix="false" scope="line" severity="3">
            <file path="SECURITY\SECURITY-51.rule"/>
         </rule>
         <rule header="不得使用 'stdlib.h' 或 'cstdlib' 库中的 'getenv()' 函数" id="52" impl="SECURITY-52" quickfix="false" scope="line" severity="3">
            <file path="SECURITY\SECURITY-52.rule"/>
         </rule>
         <rule header="The 'pthread_kill', 'pthread_sigqueue' and 'tgkill' functions should not be used to send signals to threads" id="53" impl="SECURITY-53" quickfix="false" scope="line" severity="3">
            <file path="SECURITY\SECURITY-53.rule"/>
         </rule>
         <rule header="限制使用系统属性（环境变量）" id="03" impl="SECURITY-03" quickfix="false" scope="line" severity="4">
            <file path="SECURITY\SECURITY-03.rule"/>
         </rule>
         <rule header="在调用 'mkstemp' 之前调用 'umask'" id="40" impl="SECURITY-40" quickfix="false" scope="line" severity="4">
            <file path="SECURITY\SECURITY-40.rule"/>
         </rule>
         <rule header="如果你调用 'chroot' 请调用 'chdir'" id="41" impl="SECURITY-41" quickfix="false" scope="line" severity="4">
            <file path="SECURITY\SECURITY-41.rule"/>
         </rule>
         <rule header="使用带有唯一条件变量的 'cnd_signal()' 函数" id="49" impl="SECURITY-49" quickfix="false" scope="line" severity="4">
            <file path="SECURITY\SECURITY-49.rule"/>
         </rule>
         <rule header="当多个线程在等待同一个条件变量时，不要使用 'notify_one()' 函数" id="50" impl="SECURITY-50" quickfix="false" scope="line" severity="4">
            <file path="SECURITY\SECURITY-50.rule"/>
         </rule>
      </category>
      <category description="AUTOSAR C++14 编码指南" name="AUTOSAR">
         <category description="AUTOSAR A0-1-2 应使用有非 void 返回类型且不是重载运算符的函数返回的值" name="A0_1_2">
            <rule header="从不是重载运算符函数得到的非 void 类型的返回值应该始终被使用" id="a" impl="CODSTA-CPP-58" originalId="CODSTA-CPP-58" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-58.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A0-1-3 应使用匿名命名空间中定义的每个函数，或有内部链接的静态函数或私有成员函数" name="A0_1_3">
            <rule header="每个定义的具有内部链接的函数应该至少被使用一次" id="a" impl="OPT-30" originalId="OPT-30" quickfix="false" scope="line" severity="2">
               <file path="OPT\OPT-30.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A0-1-4 非虚函数中不应有未使用的命名参数" name="A0_1_4">
            <rule header="消除未使用的参数" id="a" impl="OPT-03" originalId="OPT-03" quickfix="false" scope="line" severity="2">
               <file path="OPT\OPT-03.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A0-1-5 在虚函数和重写虚函数的所有函数的参数集中，不应存在未使用的命名参数" name="A0_1_5">
            <rule header="在虚函数中不应有未使用的命名参数" id="a" impl="OPT-42" originalId="OPT-42" quickfix="false" scope="line" severity="2">
               <file path="OPT\OPT-42.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A0-4-2 不应使用 long double 类型" name="A0_4_2">
            <rule header="不应使用长双精度浮点型" id="a" impl="PORT-32" originalId="PORT-32" quickfix="false" scope="line" severity="2">
               <file path="PORT\PORT-32.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A10-1-1 类不得派生自多个非接口类的基类" name="A10_1_1">
            <rule header="要小心使用不是抽象接口的类的多重继承" id="a" impl="OOP-07" originalId="OOP-07" quickfix="false" scope="line" severity="2">
               <file path="OOP\OOP-07.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A10-2-1 非虚函数成员不得在派生类中重新定义" name="A10_2_1">
            <rule header="禁止对继承的非虚拟函数进行重定义" id="a" impl="OOP-32" originalId="OOP-32" quickfix="false" scope="line" severity="2">
               <file path="OOP\OOP-32.rule"/>
            </rule>
            <rule header="派生类里声明的成员函数不应该隐藏基类中声明的函数" id="b" impl="OOP-53" originalId="OOP-53" quickfix="false" scope="line" severity="2">
               <file path="OOP\OOP-53.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A10-3-1 虚函数声明应该恰好包含这三个说明符中的一个:" name="A10_3_1">
            <rule header="在成员函数声明中,只应该指定 virtual,override 或 final 中的一个" id="a" impl="CODSTA-MCPP-24" originalId="CODSTA-MCPP-24" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-24.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A10-3-2 每个重写虚函数都应使用 override 或 final 说明符声明" name="A10_3_2">
            <rule header="每个重载的虚函数都应使用 override 或 final 声明符声明。" id="a" impl="CODSTA-MCPP-05" originalId="CODSTA-MCPP-05" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-05.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A10-3-3 虚函数不得引入 final 类" name="A10_3_3">
            <rule header="不要在 final 类中引入 virtual 函数" id="a" impl="CODSTA-MCPP-52" originalId="CODSTA-MCPP-52" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-52.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A10-3-5 用户定义的赋值运算符不能是 virtual" name="A10_3_5">
            <rule header="用户定义的赋值操作符不应是虚拟的" id="a" impl="OOP-56" originalId="OOP-56" quickfix="false" scope="line" severity="2">
               <file path="OOP\OOP-56.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A11-0-2 定义为 struct 的类型应该:（1）只提供 public 数据成员，（2）不提供任何特殊的成员函数或方法，（3）不作为另一个结构或类的基位，（4）不从另一个结构或类继承" name="A11_0_2">
            <rule header="结构体应该只包含公共数据成员，不应该是基类或继承" id="a" impl="OOP-57" originalId="OOP-57" quickfix="false" scope="line" severity="2">
               <file path="OOP\OOP-57.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A11-3-1 不得使用 Friend 声明" name="A11_3_1">
            <rule header="除了比较运算符的声明外，不得使用友元声明" id="a" impl="OOP-11_b" originalId="OOP-11_b" quickfix="false" scope="line" severity="2">
               <file path="OOP\OOP-11_b.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A12-0-1 如果一个类通过 &quot;=default&quot;， &quot;=delete&quot;， 或用户提供的声明声明了一个复制或移动操作或析构函数， 那么这五个特殊成员函数中的所有其他函数也都应该声明" name="A12_0_1">
            <rule header="如果一个类通过 '=default'、'=delete' 或用户提供的声明声明了一个复制或移动操作或析构函数，那么这五个特殊成员函数中的所有其他函数也都应被声明" id="a" impl="CODSTA-MCPP-56" originalId="CODSTA-MCPP-56" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-56.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A12-0-2 不应在对象上执行按位操作和假定内存中的数据表示的操作" name="A12_0_2">
            <rule header="不要将可能包含填充位的类的对象与 C 标准库函数进行比较" id="a" impl="CODSTA-CPP-100" originalId="CODSTA-CPP-100" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-100.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A12-1-1 构造函数应显式初始化所有虚基类、所有直接非虚基类和所有非静态数据成员" name="A12_1_1">
            <rule header="一个类的所有构造函数应该显式地为它的所有直接基类和所有虚拟基类调用一个构造函数" id="a" impl="PB-43" originalId="PB-43" quickfix="false" scope="line" severity="2">
               <file path="PB\PB-43.rule"/>
            </rule>
            <rule header="所有成员变量都应该在构造函数中初始化" id="b" impl="INIT-06" originalId="INIT-06" quickfix="false" scope="line" severity="2">
               <file path="INIT\INIT-06.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A12-1-2 构造函数中的 NSDMI 和非静态成员的初始化器不能在同一类型中使用" name="A12_1_2">
            <rule header="构造函数中的 NSDMI 和非静态成员的初始化不能在同一类型中使用" id="a" impl="INIT-18" originalId="INIT-18" quickfix="false" scope="line" severity="2">
               <file path="INIT\INIT-18.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A12-1-3 如果所有用户定义的类构造器初始化数据成员时，使用的常量值在所有构造函数中都是相同的，则应使用 NSDMI 初始化数据成员" name="A12_1_3">
            <rule header="用户定义的构造函数如果在所有构造函数中用相同的常量值初始化数据成员，应该使用NSDMI进行初始化" id="a" impl="INIT-17_b" originalId="INIT-17_b" quickfix="false" scope="line" severity="2">
               <file path="INIT\INIT-17_b.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A12-1-4 所有可以使用基本类型的单个参数调用的构造函数都应显式声明" name="A12_1_4">
            <rule header="具有单一基本类型参数可调用的构造函数应该显式地声明" id="a" impl="OOP-45" originalId="OOP-45" quickfix="false" scope="line" severity="2">
               <file path="OOP\OOP-45.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A12-1-5 非常量成员的公共类初始化应由委托构造函数完成" name="A12_1_5">
            <rule header="使用委托构造函数来减少代码重复" id="a" impl="CODSTA-CPP-106" originalId="CODSTA-CPP-106" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-106.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A12-1-6 派生类不需要进一步显示初始化并要求所有基类中的构造器都应是使用可继承构造函数" name="A12_1_6">
            <rule header="析构类不需要进一步明确初始化，以及要求基类中的所有构造函数都应使用继承构造函数" id="a" impl="CODSTA-MCPP-37" originalId="CODSTA-MCPP-37" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-37.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A12-4-1 基类的析构函数应该是基类的析构函数应该是 public virtual， public override 或者 protected non-virtual" name="A12_4_1">
            <rule header="设置基类的析构函数为 public、virtual 或者 protected、nonvirtual" id="a" impl="OOP-31" originalId="OOP-31" quickfix="false" scope="line" severity="2">
               <file path="OOP\OOP-31.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A12-6-1 由构造函数初始化的所有类数据成员都应使用成员初始化器进行初始化" name="A12_6_1">
            <rule header="构造函数中推荐使用初始化列表而非赋值" id="a" impl="INIT-14" originalId="INIT-14" quickfix="false" scope="line" severity="2">
               <file path="INIT\INIT-14.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A12-7-1 如果用户定义的特殊成员函数的行为与隐式定义的特殊成员函数相同， 则应定义为 &quot;=default&quot; 或者不定义" name="A12_7_1">
            <rule header="当操作等同于编译器操作时，将特殊变量定义为 default" id="a" impl="CODSTA-CPP-105" originalId="CODSTA-CPP-105" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-105.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A12-8-1 移动和复制构造函数应该移动和分别复制一个类的基类和数据成员，不会有任何意外结果" name="A12_8_1">
            <rule header="拷贝构造函数应仅对其基类型及该类型的非静态成员进行初始化" id="a" impl="OOP-46" originalId="OOP-46" quickfix="false" scope="line" severity="2">
               <file path="OOP\OOP-46.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A12-8-4 移动构造函数不应使用复制语义初始化其类成员和基类" name="A12_8_4">
            <rule header="在右值(rvalue)引用上使用 std::move() 和在转发引用(forwarding references)上使用 std::forward()" id="a" impl="CODSTA-MCPP-13" originalId="CODSTA-MCPP-13" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-13.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A12-8-5 复制赋值和移动赋值运算符应处理自身赋值" name="A12_8_5">
            <rule header="检查 operator= 中的自我赋值" id="a" impl="OOP-34" originalId="OOP-34" quickfix="false" scope="line" severity="2">
               <file path="OOP\OOP-34.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A12-8-6 复制和移动构造函数以及复制赋值和移动赋值运算符在基类中应声明为 protected 或定义 '=delete'" name="A12_8_6">
            <rule header="在基类中避免使用公共(public)拷贝构造函数和赋值运算符" id="a" impl="OOP-01" originalId="OOP-01" quickfix="false" scope="line" severity="2">
               <file path="OOP\OOP-01.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A13-1-2 用户定义的字面量操作符的自定义后缀应该以下划线和一个或多个字母开头" name="A13_1_2">
            <rule header="用户定义的文字操作符的后缀应该以下划线和一个或多个字母开头" id="a" impl="NAMING-51" originalId="NAMING-51" quickfix="false" scope="line" severity="2">
               <file path="NAMING\NAMING-51.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A13-1-3 用户定义的字面量运算符只能执行传递参数的转换" name="A13_1_3">
            <rule header="用户定义的文字运算符只能执行传递参数的转换" id="a" impl="CODSTA-MCPP-33" originalId="CODSTA-MCPP-33" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-33.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A13-2-1 赋值运算符应返回对 'this' 的引用。" name="A13_2_1">
            <rule header="赋值操作符返回一个 *this 指向的引用；使赋值操作符的返回类型是指向自身 类类型的非常量引用" id="a" impl="CODSTA-CPP-02" originalId="CODSTA-CPP-02" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-02.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A13-2-2 二进制算术运算符和位运算符应返回 &quot;prvalue&quot;" name="A13_2_2">
            <rule header="二进制算术运算符和位运算符应返回一个 'prvalue'" id="a" impl="CODSTA-CPP-102" originalId="CODSTA-CPP-102" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-102.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A13-2-3 关系运算符应返回布尔值" name="A13_2_3">
            <rule header="关系运算符应返回布尔值" id="a" impl="CODSTA-CPP-101" originalId="CODSTA-CPP-101" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-101.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A13-3-1 包含 'forwarding reference' 的函数不应被重载" name="A13_3_1">
            <rule header="避免在转发引用上使用重载" id="a" impl="CODSTA-MCPP-14" originalId="CODSTA-MCPP-14" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-14.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A13-5-1 如果 'operator[]' 要被非 const 版本重载，const 版本也应被实现" name="A13_5_1">
            <rule header="重载 [] 运算符函数时，必须同时实现const和非const版本" id="a" impl="HICPP-13_2_4-a" originalId="HICPP-13_2_4-a" quickfix="false" scope="line" severity="2">
               <file path="HICPP\HICPP-13_2_4-a.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A13-5-2 所有用户定义的转换运算符都应明确定义" name="A13_5_2">
            <rule header="自定义类型转换函数需要使用标识符标识" id="a" impl="CODSTA-MCPP-01" originalId="CODSTA-MCPP-01" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-01.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A13-5-4 如果定义了两个相反的运算符， 则其中一个应根据另一个来定义" name="A13_5_4">
            <rule header="如果在一个类中定义了两个相反的相等运算符（'=='、'!='），则其中一个运算符应以另一个运算符的形式定义" id="b" impl="CODSTA-CPP-86" originalId="CODSTA-CPP-86" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-86.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A13-5-5 比较运算符应该是非成员函数， 具有相同的参数类型" name="A13_5_5">
            <rule header="比较运算符应为非成员函数" id="a" impl="CODSTA-CPP-107" originalId="CODSTA-CPP-107" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-107.rule"/>
            </rule>
            <rule header="比较运算符应为具有相同参数类型和 noexcept 的非成员函数" id="b" impl="CODSTA-CPP-107_b" originalId="CODSTA-CPP-107_b" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-107_b.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A13-6-1 数字序列分隔符 ' 只能用于以下情况:（1）十进制，每3位;（2）十六进制，每2位;（3）二进制，每4位" name="A13_6_1">
            <rule header="数字序列分隔符 ' 只能与相应的数值类型匹配使用" id="a" impl="CODSTA-MCPP-25" originalId="CODSTA-MCPP-25" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-25.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A14-5-1 模板构造函数不应参与对封闭类类型的单个参数的重载解析" name="A14_5_1">
            <rule header="当存在一个包含单个泛型参数的模板构造函数时，应声明拷贝构造函数" id="a" impl="TEMPL-07" originalId="TEMPL-07" quickfix="false" scope="line" severity="2">
               <file path="TEMPL\TEMPL-07.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A14-7-2 模板专门化应该作为用户定义的类型声明在与主模板（2）相同的文件（1）中，并为其声明专门化" name="A14_7_2">
            <rule header="模板专门化应声明在与主模板或用户定义类型相同的文件中，为其声明专门化" id="a" impl="TEMPL-16" originalId="TEMPL-16" quickfix="false" scope="line" severity="2">
               <file path="TEMPL\TEMPL-16.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A14-8-2 不应使用函数模板的显式专门化" name="A14_8_2">
            <rule header="重载函数模板不应显式特化" id="a" impl="TEMPL-09" originalId="TEMPL-09" quickfix="false" scope="line" severity="2">
               <file path="TEMPL\TEMPL-09.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A15-1-2 异常对象不应是指针" name="A15_1_2">
            <rule header="异常对象不应该有指针类型" id="a" impl="EXCEPT-09" originalId="EXCEPT-09" quickfix="false" scope="line" severity="2">
               <file path="EXCEPT\EXCEPT-09.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A15-1-5 不应越界执行抛出异常" name="A15_1_5">
            <rule header="不要越过执行边界抛出异常" id="a" impl="PORT-30" originalId="PORT-30" quickfix="false" scope="line" severity="2">
               <file path="PORT\PORT-30.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A15-2-1 在程序启动之前不应调用非 noexcept 的构造函数" name="A15_2_1">
            <rule header="在全局或命名空间作用域中调用的函数不能抛出未处理的异常" id="a" impl="EXCEPT-18" originalId="EXCEPT-18" quickfix="false" scope="line" severity="2">
               <file path="EXCEPT\EXCEPT-18.rule"/>
            </rule>
            <rule header="代码中显式抛出的每个异常都应在可能导致该点的所有调用路径中具有兼容类型的处理程序" id="b" impl="EXCEPT-13" originalId="EXCEPT-13" quickfix="false" scope="line" severity="2">
               <file path="EXCEPT\EXCEPT-13.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A15-3-2 如果函数抛出检查异常，则应在能采取有效的操作时进行处理，否则其将会传输。" name="A15_3_2">
            <rule header="代码中显式抛出的每个异常都应在可能导致该点的所有调用路径中具有兼容类型的处理程序" id="a" impl="EXCEPT-13" originalId="EXCEPT-13" quickfix="false" scope="line" severity="2">
               <file path="EXCEPT\EXCEPT-13.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A15-3-3 主函数和任务主函数应至少捕获: 来自所使用的所有第三方库的基类异常、std::exception 和所有其他未处理的异常" name="A15_3_3">
            <rule header="至少应该有一个异常处理程序来捕获所有其他未处理的异常" id="a" impl="EXCEPT-06" originalId="EXCEPT-06" quickfix="false" scope="line" severity="2">
               <file path="EXCEPT\EXCEPT-06.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A15-3-4 Catch-all（省略号和 std::exception）处理程序应只在以下情况中使用：（a）main中，（b） task main 函数中，（c）在应该隔离独立组件的函数中，（d）在调用第三方代码时，此代码使用不符合 AUTOSAR C++ 14 准则的异常" name="A15_3_4">
            <rule header="避免使用 catch-all 异常处理程序" id="a" impl="EXCEPT-26" originalId="EXCEPT-26" quickfix="false" scope="line" severity="2">
               <file path="EXCEPT\EXCEPT-26.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A15-3-5 一个 class 类型异常应通过引用或 const 引用捕获" name="A15_3_5">
            <rule header="一个类的类型异常应始终通过引用捕获" id="a" impl="EXCEPT-15" originalId="EXCEPT-15" quickfix="false" scope="line" severity="2">
               <file path="EXCEPT\EXCEPT-15.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A15-4-1 不得使用动态异常规范" name="A15_4_1">
            <rule header="不使用throw异常规范" id="a" impl="EXCEPT-23" originalId="EXCEPT-23" quickfix="false" scope="line" severity="2">
               <file path="EXCEPT\EXCEPT-23.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A15-4-4 未抛异常的函数的声明应包含 noexcept 规范" name="A15_4_4">
            <rule header="如果函数不抛出异常，则请使用关键字 'noexcept' 声明" id="a" impl="CODSTA-MCPP-09" originalId="CODSTA-MCPP-09" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-09.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A15-4-5 可以从函数抛出的已检查异常应与函数声明一起指定，并且在所有函数声明及其覆盖程序中，这些异常应是相同的" name="A15_4_5">
            <rule header="可以从函数中抛出的检测异常应在函数声明之前的注释中指定" id="a" impl="EXCEPT-22" originalId="EXCEPT-22" quickfix="false" scope="line" severity="2">
               <file path="EXCEPT\EXCEPT-22.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A15-5-1 所有用户提供的类析构函数、释放函数、移动构造函数、移动赋值运算符和交换函数都不能异常退出。应酌情在这些功能中添加 noexcept 异常规范" name="A15_5_1">
            <rule header="不允许从析构、释放和交换中抛出异常" id="a" impl="EXCEPT-01" originalId="EXCEPT-01" quickfix="false" scope="line" severity="2">
               <file path="EXCEPT\EXCEPT-01.rule"/>
            </rule>
            <rule header="所有用户提供的移动构造函数和移动分配操作符都不应异常退出" id="b" impl="EXCEPT-21" originalId="EXCEPT-21" quickfix="false" scope="line" severity="2">
               <file path="EXCEPT\EXCEPT-21.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A15-5-2 程序不得意外终止。尤其不应对 std::abort()，std::quick_exit()，std::_Exit()，std::terminate() 进行隐式或显式调用。" name="A15_5_2">
            <rule header="使用 'std::atexit()' 或 'std::at_quick_exit()' 注册函数的执行不应异常退出" id="a" impl="PB-44" originalId="PB-44" quickfix="false" scope="line" severity="2">
               <file path="PB\PB-44.rule"/>
            </rule>
            <rule header="不得使用  'stdlib.h' 或者 'cstdlib' 库中的 'abort()' 函数" id="b" impl="PB-75" originalId="PB-75" quickfix="false" scope="line" severity="2">
               <file path="PB\PB-75.rule"/>
            </rule>
            <rule header="不得使用 'stdlib.h' 或 'cstdlib' 库中的 'quick_exit()' 和 '_Exit()' 函数" id="c" impl="PB-75_c" originalId="PB-75_c" quickfix="false" scope="line" severity="2">
               <file path="PB\PB-75_c.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A15-5-3 不应隐式调用 std::terminate() 函数" name="A15_5_3">
            <rule header="使用 'std::atexit()' 或 'std::at_quick_exit()' 注册函数的执行不应异常退出" id="a" impl="PB-44" originalId="PB-44" quickfix="false" scope="line" severity="2">
               <file path="PB\PB-44.rule"/>
            </rule>
            <rule header="不允许从析构、释放和交换中抛出异常" id="b" impl="EXCEPT-01" originalId="EXCEPT-01" quickfix="false" scope="line" severity="2">
               <file path="EXCEPT\EXCEPT-01.rule"/>
            </rule>
            <rule header="不要从析构函数内抛出" id="c" impl="EXCEPT-03" originalId="EXCEPT-03" quickfix="false" scope="line" severity="2">
               <file path="EXCEPT\EXCEPT-03.rule"/>
            </rule>
            <rule header="至少应该有一个异常处理程序来捕获所有其他未处理的异常" id="d" impl="EXCEPT-06" originalId="EXCEPT-06" quickfix="false" scope="line" severity="2">
               <file path="EXCEPT\EXCEPT-06.rule"/>
            </rule>
            <rule header="空抛出(throw;)只能用于catch处理程序的复合语句中" id="e" impl="EXCEPT-07" originalId="EXCEPT-07" quickfix="false" scope="line" severity="2">
               <file path="EXCEPT\EXCEPT-07.rule"/>
            </rule>
            <rule header="只有在程序启动后和终止前才会出现异常情况" id="f" impl="EXCEPT-08" originalId="EXCEPT-08" quickfix="false" scope="line" severity="2">
               <file path="EXCEPT\EXCEPT-08.rule"/>
            </rule>
            <rule header="代码中显式抛出的每个异常都应在可能导致该点的所有调用路径中具有兼容类型的处理程序" id="g" impl="EXCEPT-13" originalId="EXCEPT-13" quickfix="false" scope="line" severity="2">
               <file path="EXCEPT\EXCEPT-13.rule"/>
            </rule>
            <rule header="如果函数的声明包含异常规范，则该函数只能抛出指定类型的异常" id="h" impl="EXCEPT-14" originalId="EXCEPT-14" quickfix="false" scope="line" severity="2">
               <file path="EXCEPT\EXCEPT-14.rule"/>
            </rule>
            <rule header="在全局或命名空间作用域中调用的函数不能抛出未处理的异常" id="i" impl="EXCEPT-18" originalId="EXCEPT-18" quickfix="false" scope="line" severity="2">
               <file path="EXCEPT\EXCEPT-18.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A16-0-1 预处理器应仅用于无条件和条件文件包含以及包含保护，并使用以下指令：（1） #ifndef，（2） #ifdef，（3） #if，（4） #if defined，（5） #elif，（6） #else，（7） #define，（8） #endif，（9） #include" name="A16_0_1">
            <rule header="#ifndef、#ifdef、#if、#elif、#else 和 #endif 预处理器指令只能用于条件文件包含和包含保护" id="a" impl="PREPROC-26" originalId="PREPROC-26" quickfix="false" scope="line" severity="2">
               <file path="PREPROC\PREPROC-26.rule"/>
            </rule>
            <rule header="不应使用 #error 指令" id="b" impl="PREPROC-22" originalId="PREPROC-22" quickfix="false" scope="line" severity="2">
               <file path="PREPROC\PREPROC-22.rule"/>
            </rule>
            <rule header="不应使用 #pragma 指令" id="c" impl="PREPROC-23" originalId="PREPROC-23" quickfix="false" scope="line" severity="2">
               <file path="PREPROC\PREPROC-23.rule"/>
            </rule>
            <rule header="避免使用宏定义" id="d" impl="PREPROC-01" originalId="PREPROC-01" quickfix="false" scope="line" severity="2">
               <file path="PREPROC\PREPROC-01.rule"/>
            </rule>
            <rule header="不应使用 #undef" id="e" impl="PREPROC-25" originalId="PREPROC-25" quickfix="false" scope="line" severity="2">
               <file path="PREPROC\PREPROC-25.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A16-2-1 字符 '， &quot;， /*， //， \ 不应出现在头文件名或  #include 指令中" name="A16_2_1">
            <rule header="下列的字符序列不得出现在头文件名中： ', \, /*, //, 或 &quot;" id="a" impl="PB-28" originalId="PB-28" quickfix="false" scope="line" severity="2">
               <file path="PB\PB-28.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A16-2-2 不得有未使用的  include 指令" name="A16_2_2">
            <rule header="文件应该只包含(include)具有编译该文件所需的声明和定义的头文件" id="a" impl="OPT-41" originalId="OPT-41" quickfix="false" scope="line" severity="2">
               <file path="OPT\OPT-41.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A16-6-1 不应使用 #error 指令" name="A16_6_1">
            <rule header="不应使用 #error 指令" id="a" impl="PREPROC-22" originalId="PREPROC-22" quickfix="false" scope="line" severity="2">
               <file path="PREPROC\PREPROC-22.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A16-7-1 不应使用 #pragma 指令" name="A16_7_1">
            <rule header="不应使用 #pragma 指令" id="a" impl="PREPROC-23" originalId="PREPROC-23" quickfix="false" scope="line" severity="2">
               <file path="PREPROC\PREPROC-23.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A17-0-1 不得定义、重新定义或未定义 C++ 标准库中的保留标识符、宏和函数" name="A17_0_1">
            <rule header="不使用 #define 或 #undef 标识符 'defined'" id="a" impl="MISRA2004-20_1_e" originalId="MISRA2004-20_1_e" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-20_1_e.rule"/>
            </rule>
            <rule header="不应定义、重新定义、未定义标准库中的保留标识符、宏和函数(C99 code)" id="b" impl="CODSTA-92_b" originalId="CODSTA-92_b" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-92_b.rule"/>
            </rule>
            <rule header="不应定义、重新定义、未定义标准程序库中的保留标识符、宏以及函数（C90代码）" id="c" impl="CODSTA-92_a" originalId="CODSTA-92_a" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-92_a.rule"/>
            </rule>
            <rule header="不要重新定义保留字" id="d" impl="MISRA2004-20_1_b" originalId="MISRA2004-20_1_b" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-20_1_b.rule"/>
            </rule>
            <rule header="不要使用以下划线开头的带有#define 或 #undef 名称的标识符" id="e" impl="MISRA2004-20_1_a" originalId="MISRA2004-20_1_a" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-20_1_a.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A17-1-1 C标准库的使用应封装和隔离" name="A17_1_1">
            <rule header="不得使用错误指示符 'errno'" id="a" impl="MISRA2004-20_5" originalId="MISRA2004-20_5" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-20_5.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A17-6-1 不应将非标准实体添加到标准名称空间中" name="A17_6_1">
            <rule header="不要修改标准命名空间 'std' 和 'posix'" id="a" impl="CODSTA-CPP-95" originalId="CODSTA-CPP-95" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-95.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A18-0-1 C 库设施只能通过 C++ 库的头文件访问" name="A18_0_1">
            <rule header="不能使用C语言库" id="a" impl="CODSTA-CPP-59" originalId="CODSTA-CPP-59" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-59.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A18-0-2 应检查从字符串转换到数值的错误状态" name="A18_0_2">
            <rule header="不得使用库stdlib.h中的库函数atof，atoi和atol" id="a" impl="MISRA2004-20_10" originalId="MISRA2004-20_10" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-20_10.rule"/>
            </rule>
            <rule header="不得使用库stdlib.h中的库函数atof，atoi和atol" id="b" impl="MISRA2004-20_10" originalId="MISRA2004-20_10" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-20_10.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A18-0-3 不得使用库 &lt;clocale&gt; (locale.h)和 setlocale 函数" name="A18_0_3">
            <rule header="不应包含 &lt;locale.h&gt; 头文件" id="a" impl="MISRA-121_b" originalId="MISRA-121_b" quickfix="false" scope="line" severity="2">
               <file path="MISRA\MISRA-121_b.rule"/>
            </rule>
            <rule header="不要使用 setlocale 函数" id="b" impl="MISRA-121_a" originalId="MISRA-121_a" quickfix="false" scope="line" severity="2">
               <file path="MISRA\MISRA-121_a.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A18-1-1 不应使用 C 风格的数组" name="A18_1_1">
            <rule header="不得使用 C 样式数组" id="a" impl="STL-37" originalId="STL-37" quickfix="false" scope="line" severity="2">
               <file path="STL\STL-37.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A18-1-2 不得使用  std::vector&lt;bool&gt;特化" name="A18_1_2">
            <rule header="避免使用 vector&lt;bool&gt;" id="a" impl="STL-14" originalId="STL-14" quickfix="false" scope="line" severity="2">
               <file path="STL\STL-14.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A18-1-3 不得使用  std::auto_ptr 类型" name="A18_1_3">
            <rule header="优先使用 std::unique_ptr 而不是 std::auto_ptr" id="a" impl="CODSTA-MCPP-16_d" originalId="CODSTA-MCPP-16_d" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-16_d.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A18-1-6 所有用户定义类型的 std::hash 专门化都应该有一个 noexcept 函数调用操作符" name="A18_1_6">
            <rule header="用户定义类型的所有std::hash专门化都应具有noexcept函数调用运算符" id="a" impl="CODSTA-MCPP-27" originalId="CODSTA-MCPP-27" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-27.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A18-5-1 禁止使用 malloc、calloc、realloc 和 free 函数" name="A18_5_1">
            <rule header="不要使用 calloc, malloc, realloc 和 free 函数" id="a" impl="MRM-46" originalId="MRM-46" quickfix="false" scope="line" severity="2">
               <file path="MRM\MRM-46.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A18-5-10 应仅使用正确对齐的指针来快速布局， 以获得足够的存储容量" name="A18_5_10">
            <rule header="不要传递存储容量不足或者没有对正在构造的对象进行适当的对齐以配置 'new' 的指针" id="a" impl="MRM-55" originalId="MRM-55" quickfix="false" scope="line" severity="2">
               <file path="MRM\MRM-55.rule"/>
            </rule>
            <rule header="当一个对象数组传递给配置 'new' 的分配作用时会存在开销" id="b" impl="MRM-55_b" originalId="MRM-55_b" quickfix="false" scope="line" severity="2">
               <file path="MRM\MRM-55_b.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A18-5-11 应共同定义 &quot;operator new&quot; 和 &quot;operator delete&quot; " name="A18_5_11">
            <rule header="如果写了 new 操作符应该对应写 delete 操作符" id="a" impl="MRM-26" originalId="MRM-26" quickfix="false" scope="line" severity="2">
               <file path="MRM\MRM-26.rule"/>
            </rule>
            <rule header="如果写了 new[] 操作符应该对应写 delete[] 操作符" id="b" impl="MRM-27" originalId="MRM-27" quickfix="false" scope="line" severity="2">
               <file path="MRM\MRM-27.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A18-5-2 不得使用新的未布局的表达式或删除表达式" name="A18_5_2">
            <rule header="不应使用动态堆内存分配" id="a" impl="MISRA2004-20_4" originalId="MISRA2004-20_4" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-20_4.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A18-5-3 delete 表达式的形式应与用于分配内存的 new 运算符的形式相匹配" name="A18_5_3">
            <rule header="释放非数组内存时 delete 不能使用括号([])" id="a" impl="MRM-35" originalId="MRM-35" quickfix="false" scope="line" severity="2">
               <file path="MRM\MRM-35.rule"/>
            </rule>
            <rule header="释放数组内存时 delete 必须使用空括号([])" id="b" impl="MRM-36" originalId="MRM-36" quickfix="false" scope="line" severity="2">
               <file path="MRM\MRM-36.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A18-5-4 如果项目有分级或未分级版本的 &quot;delete&quot;全局定义，分级版本和未分级版本都应定义" name="A18_5_4">
            <rule header="定义操作符 delete 的分级版本和未分级版本" id="a" impl="CODSTA-MCPP-31" originalId="CODSTA-MCPP-31" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-31.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A18-5-5 内存管理函数应确保以下内容：（a）由于存在最坏情况执行时间而导致的确定性行为，（b）避免内存碎片，（c）避免内存不足，（d）避免不匹配的分配或解除分配，（e）不依赖于对内核的非确定性调用" name="A18_5_5">
            <rule header="在对相应的 new/malloc 以及 delete/free 的调用中应使用相同的形式" id="a" impl="MRM-06" originalId="MRM-06" quickfix="false" scope="line" severity="2">
               <file path="MRM\MRM-06.rule"/>
            </rule>
            <rule header="被释放的内存在任何情况下都不应该被访问" id="b" impl="MRM-31" originalId="MRM-31" quickfix="false" scope="line" severity="2">
               <file path="MRM\MRM-31.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A18-5-8 功能失效的对象应具有自动存储持续时间" name="A18_5_8">
            <rule header="使用声明进行内存分配，而不是 new 或者 malloc" id="a" impl="MRM-30" originalId="MRM-30" quickfix="false" scope="line" severity="2">
               <file path="MRM\MRM-30.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A18-5-9 动态内存分配和释放函数的自定义实现应满足 C++ 标准中的相应 &quot; 必需行为 &quot; 语句中指定的语义要求。" name="A18_5_9">
            <rule header="当分配失败时，用户定义的'new'操作符应该抛出'std::bad_alloc'异常" id="a" impl="MRM-53" originalId="MRM-53" quickfix="false" scope="line" severity="2">
               <file path="MRM\MRM-53.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A18-9-1 不得使用 std::bind" name="A18_9_1">
            <rule header="优于 std::bind、std::bind1st 和 std::bind2nd 的 lambda" id="a" impl="CODSTA-MCPP-07" originalId="CODSTA-MCPP-07" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-07.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A18-9-2 将值转发给其他函数的方式有:（1）如果值为 rvalue 引用， std::move;（2）如果值为转发引用， std::forward" name="A18_9_2">
            <rule header="'std::forward' 函数应用来转发通用引用" id="a" impl="CODSTA-MCPP-13_b" originalId="CODSTA-MCPP-13_b" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-13_b.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A18-9-3 std::move 不得用于已声明的 const 或  const&amp; 对象" name="A18_9_3">
            <rule header="不要在以 const 或 const＆type 声明的对象上使用 std :: move" id="a" impl="CODSTA-MCPP-53" originalId="CODSTA-MCPP-53" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-53.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A1-1-1 所有代码应符合 ISO/IEC 14882:2014 - 编程语言 C++ 不应该使用已弃用的功能" name="A1_1_1">
            <rule header="不应使用'register'存储类说明符" id="a" impl="MISRA-028" originalId="MISRA-028" quickfix="false" scope="line" severity="2">
               <file path="MISRA\MISRA-028.rule"/>
            </rule>
            <rule header="声明复制构造函数时应声明复制赋值运算符（反之亦然）" id="b" impl="MRM-40_a" originalId="MRM-40_a" quickfix="false" scope="line" severity="2">
               <file path="MRM\MRM-40_a.rule"/>
            </rule>
            <rule header="复制构造函数和复制赋值运算符都应该为具有非平凡析构函数的类声明" id="c" impl="MRM-40_d" originalId="MRM-40_d" quickfix="false" scope="line" severity="2">
               <file path="MRM\MRM-40_d.rule"/>
            </rule>
            <rule header="不能使用C语言库" id="d" impl="CODSTA-CPP-59" originalId="CODSTA-CPP-59" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-59.rule"/>
            </rule>
            <rule header="优于 std::bind、std::bind1st 和 std::bind2nd 的 lambda" id="e" impl="CODSTA-MCPP-07" originalId="CODSTA-MCPP-07" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-07.rule"/>
            </rule>
            <rule header="不应该使用 'binder1st' 和 'binder2nd' 标识符" id="f" impl="CODSTA-MCPP-07_b" originalId="CODSTA-MCPP-07_b" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-07_b.rule"/>
            </rule>
            <rule header="优先使用 std::unique_ptr 而不是 std::auto_ptr" id="g" impl="CODSTA-MCPP-16_d" originalId="CODSTA-MCPP-16_d" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-16_d.rule"/>
            </rule>
            <rule header="不应该使用 'random_shuffle' 标识符" id="h" impl="CODSTA-MCPP-41" originalId="CODSTA-MCPP-41" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-41.rule"/>
            </rule>
            <rule header="不要在 'bool' 类型的操作数上使用递增操作符（++）" id="i" impl="CODSTA-MCPP-42" originalId="CODSTA-MCPP-42" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-42.rule"/>
            </rule>
            <rule header="不应该使用 'set_unexpected' 标识符" id="j" impl="CODSTA-MCPP-43" originalId="CODSTA-MCPP-43" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-43.rule"/>
            </rule>
            <rule header="不使用throw异常规范" id="k" impl="EXCEPT-23" originalId="EXCEPT-23" quickfix="false" scope="line" severity="2">
               <file path="EXCEPT\EXCEPT-23.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A20-8-2 std::unique_ptr 应用来代表独享所有权" name="A20_8_2">
            <rule header="当将指针传递给线程中的对象时，使用智能指针" id="a" impl="CODSTA-MCPP-29" originalId="CODSTA-MCPP-29" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-29.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A20-8-3 std::shared_ptr 应用来代表共享权" name="A20_8_3">
            <rule header="当将指针传递给线程中的对象时，使用智能指针" id="a" impl="CODSTA-MCPP-29" originalId="CODSTA-MCPP-29" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-29.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A20-8-4 std::unique_ptr 如果不需要所有权共享，则应在 std::shared_ptr 上使用 std::unique_ptr" name="A20_8_4">
            <rule header="考虑将本地对象的 'std::shared_ptr' 类型替换为 'std::unique_ptr' 类型" id="a" impl="CODSTA-MCPP-30" originalId="CODSTA-MCPP-30" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-30.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A20-8-5 std::make_unique 构造 std::unique_ptr 所拥有的对象" name="A20_8_5">
            <rule header="'std::make_unique'应该用来构造属于'std::unique_ptr'的对象" id="a" impl="CODSTA-MCPP-16_e" originalId="CODSTA-MCPP-16_e" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-16_e.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A20-8-6 std::make_shared 用来构造 std::shared_ptr 所拥有的对象" name="A20_8_6">
            <rule header="建议使用 'std::make_shared' 而不是直接使用 new" id="a" impl="CODSTA-MCPP-16_c" originalId="CODSTA-MCPP-16_c" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-16_c.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A23-0-1 iterator 不得隐式转换为 const_iterator" name="A23_0_1">
            <rule header="将结果立即转换为常量迭代器时，请使用常量容器调用" id="a" impl="CODSTA-MCPP-51" originalId="CODSTA-MCPP-51" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-51.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A25-1-1 不应复制与此对象标识相关状态的非静态数据成员或谓词函数对象的捕获值" name="A25_1_1">
            <rule header="使谓词常量成为纯函数" id="a" impl="STL-29" originalId="STL-29" quickfix="false" scope="line" severity="2">
               <file path="STL\STL-29.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A25-4-1 与关联容器和 STL 排序以及相关算法一起使用的排序谓词应遵循严格的弱排序关系" name="A25_4_1">
            <rule header="禁止对关联容器使用判定相等数值为 true 的比较函数" id="a" impl="STL-16" originalId="STL-16" quickfix="false" scope="line" severity="2">
               <file path="STL\STL-16.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A26-5-1 不得使用  std::rand() 生成伪随机数" name="A26_5_1">
            <rule header="不要使用 rand() 函数来生成伪随机数" id="a" impl="SECURITY-02_b" originalId="SECURITY-02_b" quickfix="false" scope="line" severity="2">
               <file path="SECURITY\SECURITY-02_b.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A27-0-1 应验证独立组件的输入" name="A27_0_1">
            <rule header="避免调用只有一个参数而不是字符串常量的函数 printf/wprintf" id="a" impl="SECURITY-05" originalId="SECURITY-05" quickfix="false" scope="line" severity="2">
               <file path="SECURITY\SECURITY-05.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A27-0-2 C 风格的字符串应保证有足够的空间用于数据和 null 终止符" name="A27_0_2">
            <rule header="不要使用 'char' 缓冲区来存储来自 'std::cin' 的输入" id="c" impl="SECURITY-51" originalId="SECURITY-51" quickfix="false" scope="line" severity="2">
               <file path="SECURITY\SECURITY-51.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A27-0-4 不应使用 C 风格的字符串" name="A27_0_4">
            <rule header="不要使用不安全的 C 函数来写入未检查范围的缓冲区" id="a" impl="SECURITY-07" originalId="SECURITY-07" quickfix="false" scope="line" severity="2">
               <file path="SECURITY\SECURITY-07.rule"/>
            </rule>
            <rule header="避免使用不安全的不检查界限的字符串函数" id="b" impl="SECURITY-13" originalId="SECURITY-13" quickfix="false" scope="line" severity="2">
               <file path="SECURITY\SECURITY-13.rule"/>
            </rule>
            <rule header="不要使用 'char' 缓冲区来存储来自 'std::cin' 的输入" id="c" impl="SECURITY-51" originalId="SECURITY-51" quickfix="false" scope="line" severity="2">
               <file path="SECURITY\SECURITY-51.rule"/>
            </rule>
            <rule header="不能使用 C 风格的字符串" id="d" impl="PB-76" originalId="PB-76" quickfix="false" scope="line" severity="2">
               <file path="PB\PB-76.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A2-10-1 在内部作用域声明的标识符， 不得隐藏在外部作用域声明的标识符" name="A2_10_1">
            <rule header="在局部或者函数原型体范围内声明的标识符不应该隐藏一个在全局或者命名空间范围内声明的标识符" id="a" impl="MISRA2004-5_2_a" originalId="MISRA2004-5_2_a" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-5_2_a.rule"/>
            </rule>
            <rule header="在内层的局部范围内声明的标识符不应该隐藏在外层的局部范围内声明的标识符" id="b" impl="MISRA2004-5_2_b" originalId="MISRA2004-5_2_b" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-5_2_b.rule"/>
            </rule>
            <rule header="在一个局部范围内声明的标识符不应该隐藏在一个类作用域中声明的标识符" id="c" impl="CODSTA-CPP-83" originalId="CODSTA-CPP-83" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-83.rule"/>
            </rule>
            <rule header="在类的作用域中声明的标识符不应该隐藏在全局或命名空间范围内声明的标识符" id="d" impl="CODSTA-CPP-84" originalId="CODSTA-CPP-84" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-84.rule"/>
            </rule>
            <rule header="在一个内部类作用域中声明的标识符不应该隐藏在外部类作用域中声明的标识符" id="e" impl="CODSTA-CPP-85" originalId="CODSTA-CPP-85" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-85.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A2-10-6 类或枚举名称不应被同一范围内的变量、函数或枚举器声明隐藏" name="A2_10_6">
            <rule header="如果标识符指的是一个类型，它不应也指向同一范围内的对象或函数" id="a" impl="CODSTA-CPP-87_c" originalId="CODSTA-CPP-87_c" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-87_c.rule"/>
            </rule>
            <rule header="如果标识符指的是一个类型，它不应也指向同一范围内的对象或函数" id="b" impl="CODSTA-CPP-87_b" originalId="CODSTA-CPP-87_b" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-87_b.rule"/>
            </rule>
            <rule header="如果标识符指的是一个类型，它不应也指向同一范围内的对象或函数" id="c" impl="CODSTA-CPP-87_a" originalId="CODSTA-CPP-87_a" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-87_a.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A2-11-1 不得使用 Volatile 关键字" name="A2_11_1">
            <rule header="不要使用 volatile 关键字" id="a" impl="MISRA-046_a" originalId="MISRA-046_a" quickfix="false" scope="line" severity="2">
               <file path="MISRA\MISRA-046_a.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A2-13-1 应使用那些只在 ISO/IEC 14882:2014 中定义的转义序列" name="A2_13_1">
            <rule header="仅应使用 ISO/IEC 14882:2014 中定义的转义序列" id="a" impl="CODSTA-CPP-60_b" originalId="CODSTA-CPP-60_b" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-60_b.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A2-13-2 不应连接具有不同编码前缀的字符串字面量" name="A2_13_2">
            <rule header="不应连接具有不同编码前缀的字符串文字" id="a" impl="PB-38_b" originalId="PB-38_b" quickfix="false" scope="line" severity="2">
               <file path="PB\PB-38_b.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A2-13-3 不应使用 wchar_t 类型" name="A2_13_3">
            <rule header="不应使用 wchar_t 类型" id="a" impl="PORT-33" originalId="PORT-33" quickfix="false" scope="line" severity="2">
               <file path="PORT\PORT-33.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A2-13-4 字符串字面量不应分配给非常量指针" name="A2_13_4">
            <rule header="字符串字面量不应该被修改" id="a" impl="PB-27" originalId="PB-27" quickfix="false" scope="line" severity="2">
               <file path="PB\PB-27.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A2-13-6 通用字符名称应仅使用在字符或字符串字面量内" name="A2_13_6">
            <rule header="通用字符名称仅应在字符或字符串字面量内使用" id="a" impl="NAMING-52" originalId="NAMING-52" quickfix="false" scope="line" severity="2">
               <file path="NAMING\NAMING-52.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A2-3-1 在源代码中， 应使用那些只在 C++ 语言标准的基本源代码字符集中指定的字符" name="A2_3_1">
            <rule header="只使用 ISO C 标准中定义的字符" id="a" impl="MISRA-005" originalId="MISRA-005" quickfix="false" scope="line" severity="2">
               <file path="MISRA\MISRA-005.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A2-5-1 不得使用三联符" name="A2_5_1">
            <rule header="禁止使用三联符" id="a" impl="MISRA2004-4_2" originalId="MISRA2004-4_2" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-4_2.rule"/>
            </rule>
            <rule header="禁止使用三联符" id="b" impl="MISRA2004-4_2" originalId="MISRA2004-4_2" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-4_2.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A2-5-2 不得使用双字符" name="A2_5_2">
            <rule header="请勿使用以下双字符组：&lt;%, %&gt;, &lt;:, :&gt;, %:, %:%:" id="a" impl="CODSTA-48" originalId="CODSTA-48" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-48.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A2-7-1 字符 \ 不应作为  C++ 注释的最后一个字符出现" name="A2_7_1">
            <rule header="不得在 // 注释中使用行合并" id="a" impl="COMMENT-13" originalId="COMMENT-13" quickfix="false" scope="line" severity="2">
               <file path="COMMENT\COMMENT-13.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A2-7-2 代码段不应 &quot;添加注释&quot;" name="A2_7_2">
            <rule header="代码段不应该被&quot;注释掉&quot;" id="a" impl="MISRA2004-2_4" originalId="MISRA2004-2_4" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-2_4.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A2-7-3 所有 &quot;user-defined&quot; 类型、静态和非静态的数据成员、函数和方法的声明之前都应使用 &quot;///&quot; 注释和 &quot;@tag&quot; 标签文档" name="A2_7_3">
            <rule header="所有类型、数据成员和函数的声明之前都应该有一个注释，注释使用 '@brief' 标记" id="a" impl="COMMENT-14" originalId="COMMENT-14" quickfix="false" scope="line" severity="2">
               <file path="COMMENT\COMMENT-14.rule"/>
            </rule>
            <rule header="函数参数和返回类型应该记录在函数声明之前的注释中" id="b" impl="COMMENT-14_b" originalId="COMMENT-14_b" quickfix="false" scope="line" severity="2">
               <file path="COMMENT\COMMENT-14_b.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A2-8-1 如果头文件声明了类型， 那么它的头文件名称应该与其声明的类型名称相同" name="A2_8_1">
            <rule header="对应类的包含文件应采用 &lt;类名&gt; 加扩展名的格式" id="a" impl="NAMING-32" originalId="NAMING-32" quickfix="false" scope="line" severity="2">
               <file path="NAMING\NAMING-32.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A3-1-1 应该可以在多个编译单元中包含任何头文件而不违反一个定义规则" name="A3_1_1">
            <rule header="在头文件中不能定义具有链接属性的实体" id="a" impl="PFO-01" originalId="PFO-01" quickfix="false" scope="line" severity="2">
               <file path="PFO\PFO-01.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A3-1-2 项目中本地定义的头文件应有 &quot;.h&quot;， &quot;.hpp&quot; 或  &quot;.hxx&quot; 中其中一个的扩展文件名" name="A3_1_2">
            <rule header="头文件的文件扩展名应该是: &quot;.h&quot;, &quot;.hpp&quot; 或 &quot;.hxx&quot;" id="a" impl="NAMING-53" originalId="NAMING-53" quickfix="false" scope="line" severity="2">
               <file path="NAMING\NAMING-53.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A3-1-4 当声明具有外部链接的数组时，应明确说明其大小" name="A3_1_4">
            <rule header="当数组声明具有外部链接，其大小应该显式地说明或者在初始化时隐性地定义" id="a" impl="MISRA2004-8_12" originalId="MISRA2004-8_12" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-8_12.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A3-1-5 只有当（1）函数是内联的（2）是成员函数模板（3）是类模板的成员函数的时候， 函数定义才应该放在类定义中" name="A3_1_5">
            <rule header="除非打算内联函数，否则函数定义不应放在类规范中" id="a" impl="CODSTA-CPP-32" originalId="CODSTA-CPP-32" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-32.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A3-3-1 有外部链接的对象或函数（包括命名空间的成员）应在头文件中声明" name="A3_3_1">
            <rule header="应该在头文件中声明具有外部链接的对象或函数" id="a" impl="MISRA-023" originalId="MISRA-023" quickfix="false" scope="line" severity="2">
               <file path="MISRA\MISRA-023.rule"/>
            </rule>
            <rule header="在头文件中不能定义具有链接属性的实体" id="b" impl="PFO-01" originalId="PFO-01" quickfix="false" scope="line" severity="2">
               <file path="PFO\PFO-01.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A3-3-2 静态对象和线程本地对象应不断初始化" name="A3_3_2">
            <rule header="静态对象和线程本地对象应不断初始化" id="a" impl="CODSTA-MCPP-32" originalId="CODSTA-MCPP-32" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-32.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A3-8-1 对象在其生命周期之外不得被访问" name="A3_8_1">
            <rule header="不得从函数中返回具有自动存储的对象的地址" id="b" impl="MISRA2004-17_6_a" originalId="MISRA2004-17_6_a" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-17_6_a.rule"/>
            </rule>
            <rule header="自动存储对象的地址不应分配给在第一个对象不再存在后可能持久存在的另一个对象" id="c" impl="MISRA2004-17_6_b" originalId="MISRA2004-17_6_b" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-17_6_b.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A3-9-1 来自 &lt;cstdint&gt;的固定宽度整数类型，表示大小和符号，应用于代替基本数字类型" name="A3_9_1">
            <rule header="&lt;cstdint&gt; 中的固定宽度整数类型，指示大小和符号，应用于代替基本数字类型" id="b" impl="CODSTA-223" originalId="CODSTA-223" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-223.rule"/>
            </rule>
            <rule header="应使用 typedef 替代普通 char 类型" id="c" impl="CODSTA-223_b" originalId="CODSTA-223_b" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-223_b.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A4-10-1 只有 nullptr 字面量才能用作 null-pointer-constant" name="A4_10_1">
            <rule header="NULL 不得用作一个整数值" id="a" impl="CODSTA-CPP-62" originalId="CODSTA-CPP-62" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-62.rule"/>
            </rule>
            <rule header="使用 nullptr 代替 null 和 0" id="b" impl="CODSTA-MCPP-04" originalId="CODSTA-MCPP-04" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-04.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A4-5-1 类型枚举或枚举类的表达式不应用作内置和重载运算符的操作数，下标运算符[]，赋值运算符=，等于运算符==和!=，一元&amp;运算符和关系运算符&lt;， &lt;=， &gt;， &gt;= 除外" name="A4_5_1">
            <rule header="具有枚举类型的表达式不得用作除了 [ ],  =, ==, !=, &lt;, &lt;=, &gt;, &gt;=, 和一元 &amp; 运算符以外的内建运算符的操作数" id="a" impl="CODSTA-70" originalId="CODSTA-70" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-70.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A4-7-1 整数表达式不应导致数据丢失" name="A4_7_1">
            <rule header="避免从有符号类型到无符号类型的隐式变换" id="a" impl="PB-56" originalId="PB-56" quickfix="false" scope="line" severity="2">
               <file path="PB\PB-56.rule"/>
            </rule>
            <rule header="不应使用可能会导致信息丢失的从整数常量到浮点类型的隐式转换" id="b" impl="MISRA-043_d" originalId="MISRA-043_d" quickfix="false" scope="line" severity="2">
               <file path="MISRA\MISRA-043_d.rule"/>
            </rule>
            <rule header="避免将常量值转换为一个窄类型" id="c" impl="PORT-28" originalId="PORT-28" quickfix="false" scope="line" severity="2">
               <file path="PORT\PORT-28.rule"/>
            </rule>
            <rule header="不应使用可能导致信息丢失的从较宽到较窄的整数类型的隐式转换" id="d" impl="MISRA-043" originalId="MISRA-043" quickfix="false" scope="line" severity="2">
               <file path="MISRA\MISRA-043.rule"/>
            </rule>
            <rule header="避免宽字段到窄字段浮点型数据的隐式转换" id="e" impl="MISRA2004-10_2_b" originalId="MISRA2004-10_2_b" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-10_2_b.rule"/>
            </rule>
            <rule header="避免从浮点类型到整型的隐式转换" id="f" impl="MISRA2004-10_2_a" originalId="MISRA2004-10_2_a" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-10_2_a.rule"/>
            </rule>
            <rule header="不应使用可能导致信息丢失的从整型到浮点型的隐式转换" id="g" impl="MISRA-043_c" originalId="MISRA-043_c" quickfix="false" scope="line" severity="2">
               <file path="MISRA\MISRA-043_c.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A5-0-1 在标准允许的任何求值顺序下，表达式的值应相同" name="A5_0_1">
            <rule header="不要编写依赖于函数调用求值顺序的代码" id="a" impl="MISRA2004-12_2_g" originalId="MISRA2004-12_2_g" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-12_2_g.rule"/>
            </rule>
            <rule header="不要在两个相邻的序列点之间使用多个 volatile" id="b" impl="MISRA2004-12_2_f" originalId="MISRA2004-12_2_f" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-12_2_f.rule"/>
            </rule>
            <rule header="在序列点之间，对象的存储值最多只能通过表达式的评估来修改一次" id="c" impl="MISRA2004-12_2_e" originalId="MISRA2004-12_2_e" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-12_2_e.rule"/>
            </rule>
            <rule header="涉及一个函数调用时，不要编写依赖表达式求值顺序的代码" id="d" impl="MISRA2004-12_2_d" originalId="MISRA2004-12_2_d" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-12_2_d.rule"/>
            </rule>
            <rule header="不要编写依赖于函数标志符和函数参数的求值顺序的代码" id="e" impl="MISRA2004-12_2_c" originalId="MISRA2004-12_2_c" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-12_2_c.rule"/>
            </rule>
            <rule header="不要编写依赖于函数参数求值顺序的代码" id="f" impl="MISRA2004-12_2_b" originalId="MISRA2004-12_2_b" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-12_2_b.rule"/>
            </rule>
            <rule header="表达式的值应该在任何标准允许的赋值顺序下是一样的" id="g" impl="MISRA2004-12_2_a" originalId="MISRA2004-12_2_a" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-12_2_a.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A5-0-2 if 语句的条件和迭代语句的条件应具有布尔类型" name="A5_0_2">
            <rule header="if 语句的条件和循环语句的条件应该是布尔类型" id="a" impl="CODSTA-CPP-64" originalId="CODSTA-CPP-64" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-64.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A5-0-3 对象声明应包含不超过两级指针间接" name="A5_0_3">
            <rule header="对象的声明应该包含不超过 2 层的指针嵌套" id="a" impl="MISRA2004-17_5" originalId="MISRA2004-17_5" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-17_5.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A5-0-4 指针算术不应与指向非  final 类的指针一起使用" name="A5_0_4">
            <rule header="不要以多态方式处理数组" id="a" impl="PB-10" originalId="PB-10" quickfix="false" scope="line" severity="2">
               <file path="PB\PB-10.rule"/>
            </rule>
            <rule header="指向派生类对象数组的指针不应转换为基类指针" id="b" impl="PB-57" originalId="PB-57" quickfix="false" scope="line" severity="2">
               <file path="PB\PB-57.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A5-10-1 指向成员虚函数的指针应只测试是否与空指针常量相等" name="A5_10_1">
            <rule header="指向成员虚拟函数的指针只应该被测试是否与空指针常量相等" id="a" impl="CODSTA-MCPP-26" originalId="CODSTA-MCPP-26" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-26.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A5-16-1 三元条件运算符不得用作子表达式" name="A5_16_1">
            <rule header="条件运算符不应用作子表达式" id="a" impl="CODSTA-224" originalId="CODSTA-224" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-224.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A5-1-1 除了类型初始化之外，不应使用字面量值，而应使用符号名称" name="A5_1_1">
            <rule header="避免使用魔数" id="a" impl="CODSTA-26" originalId="CODSTA-26" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-26.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A5-1-2 不应在 lambda 表达式中隐式捕获变量" name="A5_1_2">
            <rule header="避免默认捕获模式" id="a" impl="CODSTA-MCPP-15_a" originalId="CODSTA-MCPP-15_a" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-15_a.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A5-1-3 参数列表（可能为  null）应包含在每个 lambda 表达式中" name="A5_1_3">
            <rule header="在每个 lambda 表达式中包含一个参数列表" id="a" impl="CODSTA-MCPP-46" originalId="CODSTA-MCPP-46" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-46.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A5-1-4 lambda 表达式对象的生命周期不应超过其任何引用捕获的对象" name="A5_1_4">
            <rule header="永远不要返回通过引用捕获本地对象的lambda" id="a" impl="CODSTA-MCPP-17" originalId="CODSTA-MCPP-17" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-17.rule"/>
            </rule>
            <rule header="永远不要通过引用从外部lambda捕获本地对象" id="b" impl="CODSTA-MCPP-17_b" originalId="CODSTA-MCPP-17_b" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-17_b.rule"/>
            </rule>
            <rule header="通过引用捕获本地对象的lambda不应被赋值给有更长生命周期的变量" id="c" impl="CODSTA-MCPP-17_c" originalId="CODSTA-MCPP-17_c" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-17_c.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A5-1-7 lambda 不应是 decltype 或 typeid 的操作数" name="A5_1_7">
            <rule header="lambda 不应是 typeid 的操作数" id="a" impl="CODSTA-MCPP-28" originalId="CODSTA-MCPP-28" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-28.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A5-2-2 不得使用传统 C 风格的强制转换" name="A5_2_2">
            <rule header="不应使用 C 风格强制转换" id="a" impl="CODSTA-CPP-11" originalId="CODSTA-CPP-11" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-11.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A5-2-3 强制转换不得从指针或引用的类型中移除任何 const 或 volatile 限定条件" name="A5_2_3">
            <rule header="强制转换不得从指针或引用类型中删除任何“const”或“volatile”限定条件" id="a" impl="MISRA2004-11_5" originalId="MISRA2004-11_5" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-11_5.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A5-2-4 不得使用 reinterpret_cast" name="A5_2_4">
            <rule header="避免使用强制类型转换符 reinterpret_cast" id="a" impl="CODSTA-CPP-09" originalId="CODSTA-CPP-09" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-09.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A5-2-6 如果操作数包含二进制运算符， 则应将逻辑运算符 &amp;&amp; 或 || 加上括弧" name="A5_2_6">
            <rule header="如果逻辑 &amp;&amp; 或 || 的操作数包含二元运算符则操作数应该被括起来" id="a" impl="CODSTA-104" originalId="CODSTA-104" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-104.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A5-3-1 对 typeid 操作符的操作数求值不应包含副作用" name="A5_3_1">
            <rule header="typeid 操作符的操作数不能包含任何有副作用的表达式" id="a" impl="CODSTA-CPP-104" originalId="CODSTA-CPP-104" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-104.rule"/>
            </rule>
            <rule header="'typeid' 操作符的操作数不应包含导致副作用的函数调用" id="b" impl="CODSTA-CPP-104_b" originalId="CODSTA-CPP-104_b" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-104_b.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A5-3-3 不应删除指向不完整类类型的指针" name="A5_3_3">
            <rule header="不要在删除点上时删除类不完整的对象" id="a" impl="PB-55" originalId="PB-55" quickfix="false" scope="line" severity="2">
               <file path="PB\PB-55.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A5-5-1 指向成员的指针不能访问不存在的类成员" name="A5_5_1">
            <rule header="强制类型转换不应将指向函数的指针转换为任何其他指针类型，包括指向函数类型的指针" id="a" impl="CODSTA-62" originalId="CODSTA-62" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-62.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A6-2-1 移动、复制赋值运算符在没有任何副作用的情况下，应移动或分别复制类的基类和数据成员" name="A6_2_1">
            <rule header="拷贝赋值运算符不应有可能会影响复制对象的作用" id="a" impl="MRM-56" originalId="MRM-56" quickfix="false" scope="line" severity="2">
               <file path="MRM\MRM-56.rule"/>
            </rule>
            <rule header="移动赋值运算符不应具有可能影响移动对象的副作用" id="b" impl="MRM-57" originalId="MRM-57" quickfix="false" scope="line" severity="2">
               <file path="MRM\MRM-57.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A6-2-2 表达式语句不能只显式调用临时对象的构造函数" name="A6_2_2">
            <rule header="表达式语句不能只显式调用临时对象的构造函数" id="a" impl="PB-77" originalId="PB-77" quickfix="false" scope="line" severity="2">
               <file path="PB\PB-77.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A6-4-1 switch 语句应至少有两个 case 语句，与 default 标签不同" name="A6_4_1">
            <rule header="每个 switch 语句至少有两个 case 分支和一个潜在的 default 分支" id="a" impl="CODSTA-54" originalId="CODSTA-54" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-54.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A6-5-1 不得使用循环遍历容器所有元素且不使用其循环计数器的 for 循环" name="A6_5_1">
            <rule header="不应使用循环遍历容器中的所有元素而不使用循环计数器的 for 循环" id="a" impl="CODSTA-MCPP-50" originalId="CODSTA-MCPP-50" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-50.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A6-5-2 for 循环应包含一个没有浮点类型的循环计数器" name="A6_5_2">
            <rule header="for 循环应该包含一个没有浮动类型的单一的循环计数器" id="a" impl="CODSTA-CPP-69" originalId="CODSTA-CPP-69" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-69.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A6-6-1 不得使用 goto 语句" name="A6_6_1">
            <rule header="不应该使用 goto 语句" id="a" impl="MISRA2004-14_4" originalId="MISRA2004-14_4" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-14_4.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A7-1-1 Constexpr 或 const 说明符应用于不可变数据声明" name="A7_1_1">
            <rule header="尽可能将局部变量声明为 const" id="a" impl="CODSTA-CPP-53" originalId="CODSTA-CPP-53" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-53.rule"/>
            </rule>
            <rule header="尽可能将参数声明为 const" id="b" impl="CODSTA-CPP-53_b" originalId="CODSTA-CPP-53_b" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-53_b.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A7-1-2 应在编译时确定值是否可使用 constexpr 说明符" name="A7_1_2">
            <rule header="尽量使用 constexpr 声明常量类型变量" id="a" impl="CODSTA-MCPP-11_a_cpp11" originalId="CODSTA-MCPP-11_a_cpp11" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-11_a_cpp11.rule"/>
            </rule>
            <rule header="尽量使用 constexpr 来声明函数" id="b" impl="CODSTA-MCPP-11_b_cpp11" originalId="CODSTA-MCPP-11_b_cpp11" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-11_b_cpp11.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A7-1-3 CV 限定符应该放在 typedef  类型或使用名称的右边" name="A7_1_3">
            <rule header="CV 限定符应放置在类型为声明类型(typedef)或使用名称(using name)的右侧" id="a" impl="FORMAT-47_b" originalId="FORMAT-47_b" quickfix="false" scope="line" severity="2">
               <file path="FORMAT\FORMAT-47_b.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A7-1-4 不应使用 register 关键字" name="A7_1_4">
            <rule header="不应使用'register'存储类说明符" id="a" impl="MISRA-028" originalId="MISRA-028" quickfix="false" scope="line" severity="2">
               <file path="MISRA\MISRA-028.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A7-1-5 除下列情况外，不得使用自动说明符：（1）声明变量具有与函数调用共返回类型相同的类型，（2）声明变量具有与非基本类型的初始化器相同的类型 ，（3）声明通用 lambda 表达式参数，（4）声明使用 trailing 返回类型语法的函数模板" name="A7_1_5">
            <rule header="不要过度使用 'auto' 说明符" id="a" impl="CODSTA-MCPP-40" originalId="CODSTA-MCPP-40" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-40.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A7-1-6 不得使用 typedef 说明符" name="A7_1_6">
            <rule header="不能使用typedef定义类型" id="a" impl="CODSTA-MCPP-02" originalId="CODSTA-MCPP-02" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-02.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A7-1-7 每个表达式语句和标识符声明应放在单独的行上" name="A7_1_7">
            <rule header="每行只允许一个语句" id="a" impl="FORMAT-06" originalId="FORMAT-06" quickfix="false" scope="line" severity="2">
               <file path="FORMAT\FORMAT-06.rule"/>
            </rule>
            <rule header="不允许在同一行声明多个变量" id="b" impl="FORMAT-29" originalId="FORMAT-29" quickfix="false" scope="line" severity="2">
               <file path="FORMAT\FORMAT-29.rule"/>
            </rule>
            <rule header="每个变量都要在单独的声明语句中被声明" id="c" impl="FORMAT-33" originalId="FORMAT-33" quickfix="false" scope="line" severity="2">
               <file path="FORMAT\FORMAT-33.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A7-1-8 在声明中，非类型说明符应放在类型说明符之前" name="A7_1_8">
            <rule header="在声明中不要将类型说明符放在非类型说明符之前" id="a" impl="HICPP-7_1_3-a" originalId="HICPP-7_1_3-a" quickfix="false" scope="line" severity="2">
               <file path="HICPP\HICPP-7_1_3-a.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A7-1-9 类、结构体或枚举不应在其类型的定义中声明" name="A7_1_9">
            <rule header="类，结构体或枚举不应该在其类型定义中被声明" id="a" impl="CODSTA-CPP-56" originalId="CODSTA-CPP-56" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-56.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A7-2-1 具有枚举基础类型的表达式只能具有与枚举的枚举器相对应的值" name="A7_2_1">
            <rule header="带有枚举底层类型的表达式只能具有与枚举的枚举数相对应的值" id="a" impl="PB-70" originalId="PB-70" quickfix="false" scope="line" severity="2">
               <file path="PB\PB-70.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A7-2-2 应明确定义枚举基础类型" name="A7_2_2">
            <rule header="使用明确的枚举基础并确保它足够大以存储所有枚举器" id="a" impl="HICPP-7_2_1-a" originalId="HICPP-7_2_1-a" quickfix="false" scope="line" severity="2">
               <file path="HICPP\HICPP-7_2_1-a.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A7-2-3 枚举应声明为作用域枚举类" name="A7_2_3">
            <rule header="使用作用域枚举类型" id="a" impl="CODSTA-MCPP-03" originalId="CODSTA-MCPP-03" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-03.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A7-2-4 在枚举中，要么（1）没有，（2）第一个或者（3）所有的枚举器应初始化" name="A7_2_4">
            <rule header="在枚举类型中，要么仅对第一个元素进行显式地初始化，要么所有元素都进行显式的初始化" id="a" impl="MISRA2004-9_3" originalId="MISRA2004-9_3" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-9_3.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A7-3-1 函数的所有重载在调用它的地方都是可见的" name="A7_3_1">
            <rule header="派生类里声明的成员函数不应该隐藏基类中声明的函数" id="a" impl="OOP-53" originalId="OOP-53" quickfix="false" scope="line" severity="2">
               <file path="OOP\OOP-53.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A7-4-1 不得使用 asm 声明" name="A7_4_1">
            <rule header="不要使用asm声明" id="a" impl="HICPP-7_5_1-a" originalId="HICPP-7_5_1-a" quickfix="false" scope="line" severity="2">
               <file path="HICPP\HICPP-7_5_1-a.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A7-5-1 函数不应该返回一个对 const 引用传递参数的引用或指针" name="A7_5_1">
            <rule header="函数不应返回对常量引用传递的指针或参数的引用" id="a" impl="PB-39_b" originalId="PB-39_b" quickfix="false" scope="line" severity="2">
               <file path="PB\PB-39_b.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A7-5-2 函数不得直接或间接调用自身" name="A7_5_2">
            <rule header="函数不应该直接或者间接地调用自己" id="a" impl="MISRA2004-16_2" originalId="MISRA2004-16_2" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-16_2.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A8-2-1 在生命函数模板时，如果返回类型取决于参数类型，则应使用 trailing 返回类型语法" name="A8_2_1">
            <rule header="如果返回类型前面带有 'typename' 关键字，使用尾随返回类型语法" id="a" impl="TEMPL-17" originalId="TEMPL-17" quickfix="false" scope="line" severity="2">
               <file path="TEMPL\TEMPL-17.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A8-4-1 不能使用省略号表示法定义函数" name="A8_4_1">
            <rule header="避免使用有可变数量参数的函数" id="a" impl="MISRA-069" originalId="MISRA-069" quickfix="false" scope="line" severity="2">
               <file path="MISRA\MISRA-069.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A8-4-11 智能指针只有在表示生存期语义时才可以用作参数类型" name="A8_4_11">
            <rule header="智能指针只有在表示生存期语义时才可以用作参数类型" id="a" impl="CODSTA-MCPP-34" originalId="CODSTA-MCPP-34" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-34.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A8-4-12 std::unique_ptr 应该作为一个函数传递:（1）表示函数具有所有权的一个副本 （2）表示函数替换了托管对象的一个 lvalue 引用" name="A8_4_12">
            <rule header="不要传递 const 引用类型的 std::unique_ptr 对象" id="a" impl="HICPP-8_2_4-a" originalId="HICPP-8_2_4-a" quickfix="false" scope="line" severity="2">
               <file path="HICPP\HICPP-8_2_4-a.rule"/>
            </rule>
            <rule header="智能指针只有在表示生存期语义时才可以用作参数类型" id="b" impl="CODSTA-MCPP-34" originalId="CODSTA-MCPP-34" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-34.rule"/>
            </rule>
            <rule header="如果函数代替被管理的对象，参数应该只声明为对 'std::shared_ptr' 或 'std::unique_ptr' 的非常量左值(const Ivalue)引用" id="c" impl="CODSTA-MCPP-35" originalId="CODSTA-MCPP-35" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-35.rule"/>
            </rule>
            <rule header="不要将参数类型声明为 'std::shared_ptr' 或 'std::unique_ptr' 的 rvalue 引用" id="d" impl="CODSTA-MCPP-36" originalId="CODSTA-MCPP-36" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-36.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A8-4-13 std::shared_ptr 应作为以下传递给函数:（1）表示函数共享所有权的副本（2）表示函数替换被管理对象的 lvalue 引用（3）表示函数保留引用计数的 const lvalue 引用" name="A8_4_13">
            <rule header="智能指针只有在表示生存期语义时才可以用作参数类型" id="a" impl="CODSTA-MCPP-34" originalId="CODSTA-MCPP-34" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-34.rule"/>
            </rule>
            <rule header="如果函数代替被管理的对象，参数应该只声明为对 'std::shared_ptr' 或 'std::unique_ptr' 的非常量左值(const Ivalue)引用" id="b" impl="CODSTA-MCPP-35" originalId="CODSTA-MCPP-35" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-35.rule"/>
            </rule>
            <rule header="不要将参数类型声明为 'std::shared_ptr' 或 'std::unique_ptr' 的 rvalue 引用" id="c" impl="CODSTA-MCPP-36" originalId="CODSTA-MCPP-36" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-36.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A8-4-2 有非 void 返回类型函数的所有退出路径都应具有带表达式的显式 return 语句" name="A8_4_2">
            <rule header="具有非 void 返回类型的函数的所有退出路径，除 main() 外，都应具有带有表达式的显式返回语句" id="a" impl="MISRA2004-16_8_b" originalId="MISRA2004-16_8_b" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-16_8_b.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A8-4-5 参数 &quot;consume&quot; 声明为  X &amp;&amp; 将永远被移出" name="A8_4_5">
            <rule header="在右值(rvalue)引用上使用 std::move() 和在转发引用(forwarding references)上使用 std::forward()" id="a" impl="CODSTA-MCPP-13" originalId="CODSTA-MCPP-13" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-13.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A8-4-6 参数 &quot;forward&quot; 声明为  T &amp;&amp; 总是被转发" name="A8_4_6">
            <rule header="在右值(rvalue)引用上使用 std::move() 和在转发引用(forwarding references)上使用 std::forward()" id="a" impl="CODSTA-MCPP-13" originalId="CODSTA-MCPP-13" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-13.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A8-4-7 应按值传递用于 &quot;cheap to copy&quot; 的  &quot;in&quot; 参数类型" name="A8_4_7">
            <rule header="使用 const 引用 'cheap to copy' 类型的参数应按值传递" id="a" impl="CODSTA-CPP-108" originalId="CODSTA-CPP-108" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-108.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A8-4-8 不应使用输出参数" name="A8_4_8">
            <rule header="不得使用输出参数" id="a" impl="CODSTA-CPP-103" originalId="CODSTA-CPP-103" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-103.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A8-4-9 参数 &quot;in-out&quot; 声明为 T &amp; 应该被修改" name="A8_4_9">
            <rule header="尽可能将引用参数声明为 const 引用" id="a" impl="CODSTA-CPP-43" originalId="CODSTA-CPP-43" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-43.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A8-5-1 在初始化列表中，初始化顺序如下：（1）虚基类的深度和继承图从左到右的顺序，（2）继承列表从左到右顺序的直接基类，（3）按照在类定义中声明顺序的非静态数据成员" name="A8_5_1">
            <rule header="在初始化列表中按声明成员的顺序列出成员" id="a" impl="INIT-10" originalId="INIT-10" quickfix="false" scope="line" severity="2">
               <file path="INIT\INIT-10.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A8-5-2 没有等号标记的大括号形式初始化 {}，应用于变量初始化" name="A8_5_2">
            <rule header="带括号但不带等号的初始化{}，应用于变量的初始化" id="a" impl="CODSTA-MCPP-38" originalId="CODSTA-MCPP-38" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-38.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A8-5-3 不应使用 {} 或 ={} 大括号的初始化形式初始化自动类型的变量" name="A8_5_3">
            <rule header="不应使用 '{}' 或 '= {}' 括号初始化来初始化 auto 类型的变量" id="a" impl="CODSTA-MCPP-39" originalId="CODSTA-MCPP-39" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-39.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A9-3-1 成员函数不得返回非 const 的 'raw' 指针或对类所拥有的 private 或 protected 数据的引用" name="A9_3_1">
            <rule header="公共成员函数不应该返回指向私有的/受保护的类数据的非常量句柄" id="a" impl="OOP-36" originalId="OOP-36" quickfix="false" scope="line" severity="2">
               <file path="OOP\OOP-36.rule"/>
            </rule>
            <rule header="受保护(Protected)的成员函数不得返回指向私有类数据的非 const 句柄(指针或引用)" id="b" impl="OOP-12" originalId="OOP-12" quickfix="false" scope="line" severity="2">
               <file path="OOP\OOP-12.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A9-5-1 不得使用Unions" name="A9_5_1">
            <rule header="禁止使用联合体" id="a" impl="MISRA2004-18_4" originalId="MISRA2004-18_4" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-18_4.rule"/>
            </rule>
            <rule header="禁止使用联合体" id="b" impl="MISRA2004-18_4" originalId="MISRA2004-18_4" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-18_4.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A9-6-1 用于与硬件接口或符合通信协议的数据类型应该是无关紧要的、标准布局的， 并且只包含具有定义大小的类型的成员" name="A9_6_1">
            <rule header="只能将位域定义为有符号的整型或无符号的整型" id="a" impl="MISRA2004-6_4" originalId="MISRA2004-6_4" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-6_4.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A9-6-2 位域应仅在与硬件接口或符合通信协议时使用" name="A9_6_2">
            <rule header="不要将成员变量声明为位域" id="a" impl="CODSTA-02" originalId="CODSTA-02" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-02.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M0-1-1 项目不得包含无法访问的代码" name="M0_1_1">
            <rule header="在 &quot;if/else/while/for&quot; 语句块中不应存在执行不到的代码" id="a" impl="MISRA2004-14_1_c" originalId="MISRA2004-14_1_c" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-14_1_c.rule"/>
            </rule>
            <rule header="在 'return', 'break', 'continue', 和 'goto' 语句之后不应存在执行不到的代码" id="b" impl="MISRA2004-14_1_b" originalId="MISRA2004-14_1_b" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-14_1_b.rule"/>
            </rule>
            <rule header="在 &quot;else&quot; 语句块中不应存在执行不到的代码" id="c" impl="MISRA2004-14_1_a" originalId="MISRA2004-14_1_a" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-14_1_a.rule"/>
            </rule>
            <rule header="在 while/for/do...while 循环内的 &quot;if&quot; 或 &quot;switch&quot; 语句后不应存在执行不到的代码" id="d" impl="MISRA2004-14_1_g" originalId="MISRA2004-14_1_g" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-14_1_g.rule"/>
            </rule>
            <rule header="在 'if' 或 'switch' 语句后不应存在不可访问的代码" id="e" impl="MISRA2004-14_1_f" originalId="MISRA2004-14_1_f" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-14_1_f.rule"/>
            </rule>
            <rule header="在 'for' 循环中不应存在执行不到的代码" id="f" impl="MISRA2004-14_1_e" originalId="MISRA2004-14_1_e" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-14_1_e.rule"/>
            </rule>
            <rule header="在 switch 语句中不应存在执行不到的代码" id="g" impl="MISRA2004-14_1_d" originalId="MISRA2004-14_1_d" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-14_1_d.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M0-1-2 项目不得包含不可行的路径" name="M0_1_2">
            <rule header="不允许其结果是不变的布尔运算" id="a" impl="MISRA2004-13_7_ab" originalId="MISRA2004-13_7_ab" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-13_7_ab.rule"/>
            </rule>
            <rule header="不允许其结果是不变的布尔运算" id="aa" impl="MISRA2004-13_7_aj" originalId="MISRA2004-13_7_aj" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-13_7_aj.rule"/>
            </rule>
            <rule header="不允许其结果是不变的布尔运算" id="ab" impl="MISRA2004-13_7_k" originalId="MISRA2004-13_7_k" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-13_7_k.rule"/>
            </rule>
            <rule header="不允许其结果是不变的布尔运算" id="b" impl="MISRA2004-13_7_v" originalId="MISRA2004-13_7_v" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-13_7_v.rule"/>
            </rule>
            <rule header="不允许其结果是不变的布尔运算" id="c" impl="MISRA2004-13_7_z" originalId="MISRA2004-13_7_z" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-13_7_z.rule"/>
            </rule>
            <rule header="不允许其结果是不变的布尔运算" id="d" impl="MISRA2004-13_7_n" originalId="MISRA2004-13_7_n" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-13_7_n.rule"/>
            </rule>
            <rule header="不允许其结果是不变的布尔运算" id="e" impl="MISRA2004-13_7_s" originalId="MISRA2004-13_7_s" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-13_7_s.rule"/>
            </rule>
            <rule header="不允许其结果是不变的布尔运算" id="f" impl="MISRA2004-13_7_t" originalId="MISRA2004-13_7_t" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-13_7_t.rule"/>
            </rule>
            <rule header="不允许其结果是不变的布尔运算" id="g" impl="MISRA2004-13_7_u" originalId="MISRA2004-13_7_u" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-13_7_u.rule"/>
            </rule>
            <rule header="不允许其结果是不变的布尔运算" id="h" impl="MISRA2004-13_7_j" originalId="MISRA2004-13_7_j" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-13_7_j.rule"/>
            </rule>
            <rule header="不允许其结果是不变的布尔运算" id="i" impl="MISRA2004-13_7_l" originalId="MISRA2004-13_7_l" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-13_7_l.rule"/>
            </rule>
            <rule header="不允许其结果是不变的布尔运算" id="j" impl="MISRA2004-13_7_m" originalId="MISRA2004-13_7_m" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-13_7_m.rule"/>
            </rule>
            <rule header="不允许结果不变的布尔运算" id="k" impl="MISRA2004-13_7_w" originalId="MISRA2004-13_7_w" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-13_7_w.rule"/>
            </rule>
            <rule header="不允许其结果是不变的布尔运算" id="l" impl="MISRA2004-13_7_x" originalId="MISRA2004-13_7_x" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-13_7_x.rule"/>
            </rule>
            <rule header="不允许其结果是不变的布尔运算" id="m" impl="MISRA2004-13_7_y" originalId="MISRA2004-13_7_y" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-13_7_y.rule"/>
            </rule>
            <rule header="不允许其结果是不变的布尔运算" id="n" impl="MISRA2004-13_7_ac" originalId="MISRA2004-13_7_ac" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-13_7_ac.rule"/>
            </rule>
            <rule header="不允许其结果是不变的布尔运算" id="o" impl="MISRA2004-13_7_ad" originalId="MISRA2004-13_7_ad" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-13_7_ad.rule"/>
            </rule>
            <rule header="不允许其结果是不变的布尔运算" id="p" impl="MISRA2004-13_7_ae" originalId="MISRA2004-13_7_ae" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-13_7_ae.rule"/>
            </rule>
            <rule header="不允许其结果是不变的布尔运算" id="q" impl="MISRA2004-13_7_af" originalId="MISRA2004-13_7_af" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-13_7_af.rule"/>
            </rule>
            <rule header="不允许其结果是不变的布尔运算" id="r" impl="MISRA2004-13_7_a" originalId="MISRA2004-13_7_a" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-13_7_a.rule"/>
            </rule>
            <rule header="不允许其结果是不变的布尔运算" id="s" impl="MISRA2004-13_7_aa" originalId="MISRA2004-13_7_aa" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-13_7_aa.rule"/>
            </rule>
            <rule header="不允许其结果是不变的布尔运算" id="t" impl="MISRA2004-13_7_ak" originalId="MISRA2004-13_7_ak" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-13_7_ak.rule"/>
            </rule>
            <rule header="不允许其结果是不变的布尔运算" id="u" impl="MISRA2004-13_7_b" originalId="MISRA2004-13_7_b" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-13_7_b.rule"/>
            </rule>
            <rule header="不允许其结果是不变的布尔运算" id="v" impl="MISRA2004-13_7_c" originalId="MISRA2004-13_7_c" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-13_7_c.rule"/>
            </rule>
            <rule header="不允许其结果是不变的布尔运算" id="w" impl="MISRA2004-13_7_d" originalId="MISRA2004-13_7_d" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-13_7_d.rule"/>
            </rule>
            <rule header="不允许其结果是不变的布尔运算" id="x" impl="MISRA2004-13_7_ag" originalId="MISRA2004-13_7_ag" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-13_7_ag.rule"/>
            </rule>
            <rule header="不允许其结果是不变的布尔运算" id="y" impl="MISRA2004-13_7_ah" originalId="MISRA2004-13_7_ah" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-13_7_ah.rule"/>
            </rule>
            <rule header="不允许其结果是不变的布尔运算" id="z" impl="MISRA2004-13_7_ai" originalId="MISRA2004-13_7_ai" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-13_7_ai.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M0-1-3 项目不得包含未使用的变量" name="M0_1_3">
            <rule header="避免未使用的局部变量" id="a" impl="OPT-02" originalId="OPT-02" quickfix="false" scope="line" severity="2">
               <file path="OPT\OPT-02.rule"/>
            </rule>
            <rule header="避免使用不必要的局部变量" id="b" impl="OPT-06" originalId="OPT-06" quickfix="false" scope="line" severity="2">
               <file path="OPT\OPT-06.rule"/>
            </rule>
            <rule header="避免使用未使用的私有成员变量" id="c" impl="OPT-05" originalId="OPT-05" quickfix="false" scope="line" severity="2">
               <file path="OPT\OPT-05.rule"/>
            </rule>
            <rule header="项目不应包含有内部链接的未使用变量" id="e" impl="OPT-43" originalId="OPT-43" quickfix="false" scope="line" severity="2">
               <file path="OPT\OPT-43.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M0-1-8 有 void 返回类型的所有函数都应有外部副作用" name="M0_1_8">
            <rule header="所有具有 viod 返回类型的非空函数应该具有外部作用" id="a" impl="OPT-32" originalId="OPT-32" quickfix="false" scope="line" severity="2">
               <file path="OPT\OPT-32.rule"/>
            </rule>
            <rule header="具有 void 返回值类型的函数不能为空" id="b" impl="OPT-32_b" originalId="OPT-32_b" quickfix="false" scope="line" severity="2">
               <file path="OPT\OPT-32_b.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M0-1-9 不得有无用代码" name="M0_1_9">
            <rule header="所有非 null 语句无论如何执行都至少有一个副作用，或者导致控制流发生变化" id="a" impl="MISRA2004-14_2" originalId="MISRA2004-14_2" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-14_2.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M0-2-1 不应将对象赋值给重叠对象" name="M0_2_1">
            <rule header="结构体的每个成员不应该赋值给自己的其他成员变量" id="a" impl="MISRA2004-18_2_b" originalId="MISRA2004-18_2_b" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-18_2_b.rule"/>
            </rule>
            <rule header="对象不能赋值给一个重叠的对象" id="b" impl="PB-42" originalId="PB-42" quickfix="false" scope="line" severity="2">
               <file path="PB\PB-42.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M0-3-2 如果函数生成错误信息，则应测试该错误信息" name="M0_3_2">
            <rule header="如果函数返回了错误信息，那么错误信息应该进行测试" id="a" impl="MISRA2004-16_10" originalId="MISRA2004-16_10" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-16_10.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M0-4-2 应记录浮点运算的使用" name="M0_4_2">
            <rule header="使用对浮点运算注释说明" id="a" impl="COMMENT-10" originalId="COMMENT-10" quickfix="false" scope="line" severity="2">
               <file path="COMMENT\COMMENT-10.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M10-1-3 可访问的基类在同一层次结构中不应同时为virtual和非virtual" name="M10_1_3">
            <rule header="在同一层次结构中，基类不能同时具有虚拟及非虚拟的属性" id="a" impl="OOP-41" originalId="OOP-41" quickfix="false" scope="line" severity="2">
               <file path="OOP\OOP-41.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M10-3-3 如果虚函数本身被声明为纯虚函数，则它只能被纯虚函数重写" name="M10_3_3">
            <rule header="虚拟函数仅能被自身声明为纯虚拟的纯虚拟函数进行覆盖" id="a" impl="OOP-43" originalId="OOP-43" quickfix="false" scope="line" severity="2">
               <file path="OOP\OOP-43.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M11-0-1 非 POD 类类型的成员数据应为 private" name="M11_0_1">
            <rule header="非 POD 类型的成员数据应该为  private 类型" id="a" impl="OOP-48" originalId="OOP-48" quickfix="false" scope="line" severity="2">
               <file path="OOP\OOP-48.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M14-5-3 当模板赋值运算符的参数是 generic 参数时，应声明复制赋值运算符" name="M14_5_3">
            <rule header="存在一个包含泛型参数的模板赋值运算符时，拷贝赋值运算符应该被声明" id="a" impl="TEMPL-11" originalId="TEMPL-11" quickfix="false" scope="line" severity="2">
               <file path="TEMPL\TEMPL-11.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M14-6-1 在有从属基础的类模板中，任何可能在该从属基础中找到的名称都应使用qualified-id或this-&gt;来引用。" name="M14_6_1">
            <rule header="在含有依赖基础的类模板中，任何可能在这个依赖类中被发现的名称都应该引用使用限定标识（qualified-id）或 -&gt;" id="a" impl="TEMPL-12" originalId="TEMPL-12" quickfix="false" scope="line" severity="2">
               <file path="TEMPL\TEMPL-12.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M15-0-3 控制不应使用 goto 或 switch 语句转移到 try 或 catch 块中" name="M15_0_3">
            <rule header="不得使用 goto 或 switch 开关语句将控制传递到 try 或 catch 模块中" id="a" impl="EXCEPT-10" originalId="EXCEPT-10" quickfix="false" scope="line" severity="2">
               <file path="EXCEPT\EXCEPT-10.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M15-1-1 throw语句的赋值表达式本身不会导致抛出异常" name="M15_1_1">
            <rule header="throw 语句的赋值表达式不得自身引起一个异常抛出" id="a" impl="EXCEPT-11" originalId="EXCEPT-11" quickfix="false" scope="line" severity="2">
               <file path="EXCEPT\EXCEPT-11.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M15-1-2 不应明确抛出 NULL" name="M15_1_2">
            <rule header="NULL 不得被显式地抛出" id="a" impl="EXCEPT-12" originalId="EXCEPT-12" quickfix="false" scope="line" severity="2">
               <file path="EXCEPT\EXCEPT-12.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M15-1-3 null 的 throw (throw;)只能在 catch 处理程序的复合语句中使用" name="M15_1_3">
            <rule header="空抛出(throw;)只能用于catch处理程序的复合语句中" id="a" impl="EXCEPT-07" originalId="EXCEPT-07" quickfix="false" scope="line" severity="2">
               <file path="EXCEPT\EXCEPT-07.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M15-3-1 只能在启动后和终止前抛出异常" name="M15_3_1">
            <rule header="只有在程序启动后和终止前才会出现异常情况" id="a" impl="EXCEPT-08" originalId="EXCEPT-08" quickfix="false" scope="line" severity="2">
               <file path="EXCEPT\EXCEPT-08.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M15-3-3 类构造函数或析构函数的 function-try-block 实现的处理程序不应引用此类或其基类的非静态成员" name="M15_3_3">
            <rule header="以 function-try-block 实现的类构造函数或析构函数的处理程序不应引用该类或其基类的非静态成员" id="a" impl="EXCEPT-16" originalId="EXCEPT-16" quickfix="false" scope="line" severity="2">
               <file path="EXCEPT\EXCEPT-16.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M15-3-4 代码中显式抛出的每个异常在所有可能导致这一点的调用路径中都应该有一个兼容类型的处理程序" name="M15_3_4">
            <rule header="在全局或命名空间作用域中调用的函数不能抛出未处理的异常" id="a" impl="EXCEPT-18" originalId="EXCEPT-18" quickfix="false" scope="line" severity="2">
               <file path="EXCEPT\EXCEPT-18.rule"/>
            </rule>
            <rule header="代码中显式抛出的每个异常都应在可能导致该点的所有调用路径中具有兼容类型的处理程序" id="b" impl="EXCEPT-13" originalId="EXCEPT-13" quickfix="false" scope="line" severity="2">
               <file path="EXCEPT\EXCEPT-13.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M15-3-6 在一个派生类的 try-catch 语句或 function-try 块中提供了多个处理程序，并且为其部分或全部基类提供了这些处理程序" name="M15_3_6">
            <rule header="如果在一个 try-catch 语句或函数 try-block 中为派生类及其部分或全部基类提供多个处理程序，则应将派生程度最高的处理程序排序为派生程度最高的基类" id="a" impl="EXCEPT-17" originalId="EXCEPT-17" quickfix="false" scope="line" severity="2">
               <file path="EXCEPT\EXCEPT-17.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M15-3-7 如果在一个 try-catch 语句或 function-try-block 中提供多个处理程序，那么任何省略号（catch-all）处理程序都应最后执行" name="M15_3_7">
            <rule header="如果在 'try-catch' 语句或 'function-try-block' 中提供了多个处理程序，那么任何省略(catch-all)处理程序都应该是最后一个" id="a" impl="EXCEPT-24" originalId="EXCEPT-24" quickfix="false" scope="line" severity="2">
               <file path="EXCEPT\EXCEPT-24.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M16-0-1 # 在文件中包含指令前必须有其他预处理指令或注释" name="M16_0_1">
            <rule header="#include 之前只允许有预处理命令和注释" id="a" impl="MISRA2004-19_1" originalId="MISRA2004-19_1" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-19_1.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M16-0-2 宏只能在全局命名空间中被#define或#undef" name="M16_0_2">
            <rule header="禁止在块中使用 #define 或 #undef" id="a" impl="MISRA2004-19_5" originalId="MISRA2004-19_5" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-19_5.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M16-0-5 类函数宏的参数不应包含类似预处理指令的标记" name="M16_0_5">
            <rule header="类似函数的宏的参数不应该包含类似预处理命令的标识" id="a" impl="MISRA2004-19_9" originalId="MISRA2004-19_9" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-19_9.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M16-0-6 在类函数宏的定义中，参数的每个实例都应该括在括号中，除非它被用作#或##的操作数1" name="M16_0_6">
            <rule header="在类函数宏指令的定义中，参数的每个实例都应该用圆括号括起来，除非它用作 # 或者 ## 的运算对象" id="a" impl="MISRA2004-19_10" originalId="MISRA2004-19_10" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-19_10.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M16-0-7 在 #if 或 #elif 预处理器指令中不应使用未定义的宏标识符，除非作为已定义运算符的操作数" name="M16_0_7">
            <rule header="不要使用在编译单元中未定义的预编译器指令 #if 和 #elif  宏" id="a" impl="MISRA2004-19_11_b" originalId="MISRA2004-19_11_b" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-19_11_b.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M16-0-8 如果 # 作为第一个标记出现在一行中，那么它应该紧跟在预处理标记之后" name="M16_0_8">
            <rule header="预处理指令即使被预处理程序排除,在语法上也是有意义的" id="a" impl="MISRA2004-19_16" originalId="MISRA2004-19_16" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-19_16.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M16-1-1 所定义的预处理器运算符只能用于两种标准格式之一" name="M16_1_1">
            <rule header="预处理操作符只能用在两种标准格式之一" id="a" impl="MISRA2004-19_14" originalId="MISRA2004-19_14" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-19_14.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M16-1-2 所有的 #else、 #elif 和 #endif 预处理器指令应该与它们相关的 #if 或 #ifdef 指令存留在同一个文件中" name="M16_1_2">
            <rule header="在同一个文件中 #else, #elif 和 #endif 必须对应有 #if 或 #ifdef 预处理指令" id="a" impl="MISRA2004-19_17" originalId="MISRA2004-19_17" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-19_17.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M16-2-3 应提供 Include guards" name="M16_2_3">
            <rule header="使用多个包含保护" id="a" impl="PFO-02" originalId="PFO-02" quickfix="false" scope="line" severity="2">
               <file path="PFO\PFO-02.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M16-3-1 在单个宏定义中最多只能出现一个 # 或 ## 操作符" name="M16_3_1">
            <rule header="禁止宏定义中使用多个 # 和 ##" id="a" impl="MISRA2004-19_12" originalId="MISRA2004-19_12" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-19_12.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M17-0-2 标准库宏和对象的名称不能重复使用" name="M17_0_2">
            <rule header="不得重复使用标准库宏和对象的名称" id="a" impl="CODSTA-92" originalId="CODSTA-92" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-92.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M17-0-3 标准库函数的名称不应被重写" name="M17_0_3">
            <rule header="标准库函数的名称不应被重写" id="a" impl="CODSTA-93" originalId="CODSTA-93" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-93.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M17-0-5 不应使用 setjmp 宏和 longjmp 函数" name="M17_0_5">
            <rule header="不应使用 &lt;setjmp.h&gt; 提供的工具" id="a" impl="MISRA2004-20_7" originalId="MISRA2004-20_7" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-20_7.rule"/>
            </rule>
            <rule header="不应使用标准头文件 &lt;setjmp.h&gt; 或 &lt;csetjmp&gt;" id="b" impl="MISRA2004-20_7_b" originalId="MISRA2004-20_7_b" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-20_7_b.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M18-0-3 不应使用 &lt;cstdlib&gt; 库中的库函数abort， exit， getenv 和 system" name="M18_0_3">
            <rule header="不得使用  'stdlib.h' 或者 'cstdlib' 库中的 'abort()' 函数" id="a" impl="PB-75" originalId="PB-75" quickfix="false" scope="line" severity="2">
               <file path="PB\PB-75.rule"/>
            </rule>
            <rule header="'stdlib.h' 或者 'cstdlib' 库中的 'exit()' 函数不应该被使用" id="b" impl="PB-75_b" originalId="PB-75_b" quickfix="false" scope="line" severity="2">
               <file path="PB\PB-75_b.rule"/>
            </rule>
            <rule header="不得使用 'stdlib.h' 或 'cstdlib' 库中的 'system()' 函数" id="c" impl="SECURITY-48_b" originalId="SECURITY-48_b" quickfix="false" scope="line" severity="2">
               <file path="SECURITY\SECURITY-48_b.rule"/>
            </rule>
            <rule header="不得使用 'stdlib.h' 或 'cstdlib' 库中的 'getenv()' 函数" id="d" impl="SECURITY-52" originalId="SECURITY-52" quickfix="false" scope="line" severity="2">
               <file path="SECURITY\SECURITY-52.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M18-0-4 不应使用 &lt;ctime&gt; 库的时间处理函数" name="M18_0_4">
            <rule header="不应使用标准头文件 &lt;time.h&gt; 或 &lt;ctime&gt;" id="a" impl="MISRA2004-20_12" originalId="MISRA2004-20_12" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-20_12.rule"/>
            </rule>
            <rule header="不应使用库 &lt;time.h&gt; 中的时间处理函数和宏" id="b" impl="MISRA2004-20_12_b" originalId="MISRA2004-20_12_b" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-20_12_b.rule"/>
            </rule>
            <rule header="不应使用库 &lt;time.h&gt; 中定义的类型" id="c" impl="MISRA2004-20_12_c" originalId="MISRA2004-20_12_c" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-20_12_c.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M18-0-5 不应使用 &lt;cstring&gt; 库中的无界函数" name="M18_0_5">
            <rule header="不得使用库 &lt;cstring&gt; 的无界函数" id="a" impl="PB-37" originalId="PB-37" quickfix="false" scope="line" severity="2">
               <file path="PB\PB-37.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M18-2-1 不得使用宏 offsetof" name="M18_2_1">
            <rule header="不应该使用库文件 stddef.h 中的 offsetof 宏" id="a" impl="MISRA2004-20_6" originalId="MISRA2004-20_6" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-20_6.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M18-7-1 不应使用 &lt;csignal&gt; 中的信号处理设备" name="M18_7_1">
            <rule header="不应使用 &lt;signal.h&gt; 的信号处理工具" id="a" impl="MISRA2004-20_8_b" originalId="MISRA2004-20_8_b" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-20_8_b.rule"/>
            </rule>
            <rule header="不应使用标准头文件 &lt;signal.h&gt; 或 &lt;csignal&gt;" id="b" impl="MISRA2004-20_8" originalId="MISRA2004-20_8" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-20_8.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M19-3-1 不应使用系统错误代码指示器" name="M19_3_1">
            <rule header="不得使用错误指示符 'errno'" id="a" impl="MISRA2004-20_5" originalId="MISRA2004-20_5" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-20_5.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M27-0-1 不得使用流输入/输出库 &lt;cstdio&gt;" name="M27_0_1">
            <rule header="禁止使用库文件 stdio.h 中的输入/输出函数" id="a" impl="MISRA2004-20_9" originalId="MISRA2004-20_9" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-20_9.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M2-10-1 不同的标识符应明确排版" name="M2_10_1">
            <rule header="不同的标识符应该是书写明确的" id="a" impl="NAMING-47" originalId="NAMING-47" quickfix="false" scope="line" severity="2">
               <file path="NAMING\NAMING-47.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M2-13-2 八进制常数（除了零）和八进制转义序列（除了 &quot;\0&quot;）不得使用" name="M2_13_2">
            <rule header="不应该使用八进制常数（除零外）" id="a" impl="MISRA2004-7_1_a" originalId="MISRA2004-7_1_a" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-7_1_a.rule"/>
            </rule>
            <rule header="八进制转义序列不应该被使用" id="b" impl="MISRA2004-7_1_b" originalId="MISRA2004-7_1_b" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-7_1_b.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M2-13-3 一个 &quot;U&quot;后缀应用于所有无符号类型的八进制或十六进制整数" name="M2_13_3">
            <rule header="后缀 &quot;U&quot; 应该适用于所有无符号类型的八进制或十六进制整型字面量" id="a" impl="CODSTA-68" originalId="CODSTA-68" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-68.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M2-13-4 文字后缀应该是大写字母" name="M2_13_4">
            <rule header="字母后缀应使用大写字母而不是小写字母" id="a" impl="CODSTA-51" originalId="CODSTA-51" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-51.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M2-7-1 字符序列  /* 不能在 C 风格的注释中使用" name="M2_7_1">
            <rule header="禁止在 C 语言风格的注释中使用 /* 字符序列" id="a" impl="MISRA2004-2_3" originalId="MISRA2004-2_3" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-2_3.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M3-1-2 不能在块范围内声明函数" name="M3_1_2">
            <rule header="始终在文件的范围内声明函数" id="a" impl="MISRA2004-8_6" originalId="MISRA2004-8_6" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-8_6.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M3-3-2 如果一个函数有内部链接，那么所有的重新声明都应该包括静态存储类说明符" name="M3_3_2">
            <rule header="如果一个函数有内部链接，那么所有的重新声明都应该包括'static'存储类说明符" id="a" impl="CODSTA-81" originalId="CODSTA-81" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-81.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M3-4-1 声明为对象或类型的标识符应在块中定义，以最小化其可见性" name="M3_4_1">
            <rule header="尽可能地声明局部变量" id="a" impl="OPT-01" originalId="OPT-01" quickfix="false" scope="line" severity="2">
               <file path="OPT\OPT-01.rule"/>
            </rule>
            <rule header="如果仅从单个函数中访问对象，则应在块范围内定义对象" id="b" impl="MISRA2004-8_7" originalId="MISRA2004-8_7" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-8_7.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M3-9-1 用于对象、函数返回类型或函数参数的类型在所有声明和重新声明中都应该是 token-for-token 完全一致的" name="M3_9_1">
            <rule header="用于对象，函数返回类型，或函数参数的类型在所有声明和重新声明中应该对应完全相同" id="a" impl="CODSTA-67" originalId="CODSTA-67" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-67.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M3-9-3 不应使用浮点值的底层位表示" name="M3_9_3">
            <rule header="禁止对浮点数值进行位操作" id="a" impl="MISRA2004-12_12" originalId="MISRA2004-12_12" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-12_12.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M4-10-1 NULL不能用作整数值" name="M4_10_1">
            <rule header="NULL 不得用作一个整数值" id="a" impl="CODSTA-CPP-62" originalId="CODSTA-CPP-62" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-62.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M4-10-2 文字零（0）不能用作空指针间常数" name="M4_10_2">
            <rule header="字面量 （0） 不应用作空指针常数" id="a" impl="CODSTA-CPP-63" originalId="CODSTA-CPP-63" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-63.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M4-5-1 除了赋值运算符=、逻辑运算符 &amp;&amp;， ||， !、等式运算符==和!=、一元运算符 &amp; 和条件运算符外，带有 bool 类型的表达式不能用作内置运算符的操作数" name="M4_5_1">
            <rule header="有效布尔值的表达式不应该用作除 (&amp;&amp;, ||, !, =, ==, !=, ?:) 之外的运算符的操作数。" id="a" impl="MISRA2004-12_6_b" originalId="MISRA2004-12_6_b" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-12_6_b.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M4-5-3 除了赋值运算符=、等式运算符==和!=以及一元运算符 &amp; 外，带有 (plain) char 和 wchar_t 类型的表达式不能用作内置运算符的操作数" name="M4_5_3">
            <rule header="带有类型(普通) char 和 wchar_t 的表达式不能作为内建运算符的操作数，除了 =, ==, != 和一元 &amp; 运算符" id="a" impl="CODSTA-69" originalId="CODSTA-69" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-69.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M5-0-10 如果将位操作符 ~ 和 &lt;&lt;应用于无符号字符或无符号短整型的操作数，则结果应立即转换为操作数的底层类型" name="M5_0_10">
            <rule header="如果对无符号字符型或无符号短整型进行 ~  和 &lt;&lt; 位运算后，其结果应立即强制转换成操作数的基本类型" id="a" impl="MISRA2004-10_5" originalId="MISRA2004-10_5" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-10_5.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M5-0-11 普通字符类型只能用于存储和使用字符值" name="M5_0_11">
            <rule header="普通字符(plain char)类型只能用于存储和使用字符值" id="a" impl="MISRA2004-6_1" originalId="MISRA2004-6_1" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-6_1.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M5-0-12 有符号字符和无符号字符类型只能用于存储和使用数值" name="M5_0_12">
            <rule header="带符号的 char 和 不带符号的 char 类型只能用于存储和数值类型" id="a" impl="MISRA2004-6_2" originalId="MISRA2004-6_2" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-6_2.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M5-0-14 条件运算符的第一个操作数应该具有布尔类型" name="M5_0_14">
            <rule header="条件运算符的第一个操作数应该具有布尔类型" id="a" impl="CODSTA-CPP-65" originalId="CODSTA-CPP-65" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-65.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M5-0-15 数组索引应该是指针算法的唯一形式" name="M5_0_15">
            <rule header="只有数组索引才能进行算术指针操作" id="a" impl="MISRA2004-17_4" originalId="MISRA2004-17_4" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-17_4.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M5-0-20 二进制位操作符的非常数操作数应该具有相同的基础类型" name="M5_0_20">
            <rule header="二进制位运算符的非常量的操作数应该具有相同的基本类型" id="a" impl="CODSTA-66" originalId="CODSTA-66" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-66.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M5-0-21 位操作符只能应用于无符号基础类型的操作数" name="M5_0_21">
            <rule header="位运算符应只适用于无符号的基本类型操作数" id="a" impl="CODSTA-63" originalId="CODSTA-63" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-63.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M5-0-3 cvalue 表达式不能隐式转换为不同的基础类型" name="M5_0_3">
            <rule header="避免隐式的复合表达式的类型转换" id="a" impl="MISRA2004-10_1_f" originalId="MISRA2004-10_1_f" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-10_1_f.rule"/>
            </rule>
            <rule header="避免隐式的复合表达式的数据类型转换" id="b" impl="MISRA2004-10_1_c" originalId="MISRA2004-10_1_c" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-10_1_c.rule"/>
            </rule>
            <rule header="避免隐式的复合表达式的数据类型转换" id="c" impl="MISRA2004-10_1_i" originalId="MISRA2004-10_1_i" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-10_1_i.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M5-0-4 隐式积分转换不能改变基础类型的符号" name="M5_0_4">
            <rule header="避免在有符号和无符号整数类型之间进行隐式转换" id="a" impl="MISRA2004-10_1_a" originalId="MISRA2004-10_1_a" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-10_1_a.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M5-0-5 不应该有隐含的浮点-积分转换" name="M5_0_5">
            <rule header="不存在从整型到浮点型的隐式转换" id="a" impl="MISRA2004-10_1_b" originalId="MISRA2004-10_1_b" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-10_1_b.rule"/>
            </rule>
            <rule header="避免从浮点类型到整型的隐式转换" id="b" impl="MISRA2004-10_2_a" originalId="MISRA2004-10_2_a" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-10_2_a.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M5-0-6 隐式积分或浮点数转换不能减少基础类型的大小" name="M5_0_6">
            <rule header="避免隐式整体从大范围的类型转换到小范围的类型转换" id="a" impl="CODSTA-222" originalId="CODSTA-222" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-222.rule"/>
            </rule>
            <rule header="避免宽字段到窄字段浮点型数据的隐式转换" id="b" impl="MISRA2004-10_2_b" originalId="MISRA2004-10_2_b" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-10_2_b.rule"/>
            </rule>
            <rule header="避免将浮点数从较宽的浮点类型隐式转换为较窄的浮点类型" id="c" impl="MISRA2004-10_2_d" originalId="MISRA2004-10_2_d" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-10_2_d.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M5-0-7 cvalue表达式不应有显式的浮点-积分转换" name="M5_0_7">
            <rule header="浮点型复杂表达式的值不应转换为整数类型" id="a" impl="CODSTA-198_b" originalId="CODSTA-198_b" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-198_b.rule"/>
            </rule>
            <rule header="整型复合表达式的值只能被强制转换到较短的类型，或者与该表达式类型相同的有符号类型" id="b" impl="MISRA2004-10_3" originalId="MISRA2004-10_3" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-10_3.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M5-0-8 显式积分或浮点数转换不应增加 cvalue 表达式的基础类型的大小" name="M5_0_8">
            <rule header="整型复合表达式的值只能被强制转换到较短的类型，或者与该表达式类型相同的有符号类型" id="a" impl="MISRA2004-10_3" originalId="MISRA2004-10_3" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-10_3.rule"/>
            </rule>
            <rule header="浮点型复杂表达式的值不应转换为更广泛的浮点型" id="b" impl="CODSTA-198" originalId="CODSTA-198" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-198.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M5-0-9 显式积分转换不应改变cvalue表达式的基础类型的符号" name="M5_0_9">
            <rule header="整型复合表达式的值只能被强制转换到较短的类型，或者与该表达式类型相同的有符号类型" id="a" impl="MISRA2004-10_3" originalId="MISRA2004-10_3" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-10_3.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M5-14-1 逻辑运算符 &amp;&amp;||的右操作数不应包含副作用" name="M5_14_1">
            <rule header="逻辑&amp;&amp;或||运算符的右操作数不得含有副作用" id="a" impl="MISRA2004-12_4_a" originalId="MISRA2004-12_4_a" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-12_4_a.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M5-17-1 保留二进制运算符及其赋值运算符形式之间的语义等价性" name="M5_17_1">
            <rule header="二进制过载操作符应该用其对应的复合赋值运算符实现" id="a" impl="CODSTA-CPP-91" originalId="CODSTA-CPP-91" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-91.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M5-18-1 不应使用逗号操作符" name="M5_18_1">
            <rule header="不应该使用逗号运算符" id="a" impl="MISRA2004-12_10" originalId="MISRA2004-12_10" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-12_10.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M5-19-1 常量无符号整数表达式的计算不应导致环绕" name="M5_19_1">
            <rule header="'&lt;&lt;' 运算符常量表达式中的整数溢出或下溢" id="a" impl="PB-66_b" originalId="PB-66_b" quickfix="false" scope="line" severity="2">
               <file path="PB\PB-66_b.rule"/>
            </rule>
            <rule header="'+'， '-'， '*' 运算符常量表达式中的整数溢出或下溢" id="b" impl="PB-66_a" originalId="PB-66_a" quickfix="false" scope="line" severity="2">
               <file path="PB\PB-66_a.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M5-2-10 在表达式中，递增(++)和递减(--) 运算符不应与其他运算符混用" name="M5_2_10">
            <rule header="在表达式中，增量（++）和减量（--）运算符不应该与算术运算符混合使用" id="a" impl="CODSTA-232" originalId="CODSTA-232" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-232.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M5-2-11 逗号操作符、 &amp;&amp;操作符和||操作符不得重载" name="M5_2_11">
            <rule header="避免重载逗号运算符 &quot;,&quot;" id="a" impl="CODSTA-CPP-80" originalId="CODSTA-CPP-80" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-80.rule"/>
            </rule>
            <rule header="避免重载逻辑操作符AND, OR (&amp;&amp;, ||)" id="b" impl="CODSTA-CPP-08" originalId="CODSTA-CPP-08" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-08.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M5-2-12 作为函数参数传递的数组类型的标识符不应衰减为指针" name="M5_2_12">
            <rule header="作为函数实参传递的数组类型标识符不得退化为一个指针" id="a" impl="PB-41" originalId="PB-41" quickfix="false" scope="line" severity="2">
               <file path="PB\PB-41.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M5-2-2 指向虚拟基类的指针只能通过 dynamic_cast 转换为指向派生类的指针" name="M5_2_2">
            <rule header="指向虚拟基类型的指针只能通过dynamic_cast的方式转换为指向其衍生类的指针" id="a" impl="OOP-50" originalId="OOP-50" quickfix="false" scope="line" severity="2">
               <file path="OOP\OOP-50.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M5-2-6 强制类型转换不应将指向函数的指针转换为任何其他指针类型，包括指向函数类型的指针" name="M5_2_6">
            <rule header="强制类型转换不应将指向函数的指针转换为任何其他指针类型，包括指向函数类型的指针" id="a" impl="CODSTA-62" originalId="CODSTA-62" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-62.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M5-2-8 具有整数类型的对象或指向 void 类型的指针不能转换为具有指针类型的对象" name="M5_2_8">
            <rule header="具有整数类型的对象或指向 void 类型的指针不应转换为具有指针类型的对象" id="a" impl="CODSTA-65" originalId="CODSTA-65" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-65.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M5-2-9 强制转换不能将指针类型转换为整数类型" name="M5_2_9">
            <rule header="不允许指针类型和整数类型之间进行类型转换" id="a" impl="MISRA2004-11_3_a" originalId="MISRA2004-11_3_a" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-11_3_a.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M5-3-1 ! 运算符，逻辑运算符 &amp;&amp;或||的每一个操作数应具有布尔类型" name="M5_3_1">
            <rule header="! 运算符，逻辑 &amp;&amp; 或逻辑 || 运算符的每个操作数应该都是布尔类型" id="a" impl="CODSTA-CPP-67" originalId="CODSTA-CPP-67" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-67.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M5-3-2 一元减号运算符不能应用于其基础类型为无符号的表达式" name="M5_3_2">
            <rule header="一元减法运算符不得适用于其原始类型是无符号型的表达式" id="a" impl="MISRA2004-12_9" originalId="MISRA2004-12_9" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-12_9.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M5-3-3 一元运算符&amp;不得重载" name="M5_3_3">
            <rule header="一元 &amp; 运算符不得被重载" id="a" impl="CODSTA-CPP-68" originalId="CODSTA-CPP-68" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-68.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M5-3-4 对 sizeof 运算符求值的操作数不应包含副作用" name="M5_3_4">
            <rule header="sizeof 运算符的操作数不应包含任何有副作用的表达式" id="a" impl="MISRA2004-12_3" originalId="MISRA2004-12_3" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-12_3.rule"/>
            </rule>
            <rule header="不应在sizeof运算符的操作数中访问由volatile左值指定的对象" id="b" impl="MISRA2004-12_3_b" originalId="MISRA2004-12_3_b" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-12_3_b.rule"/>
            </rule>
            <rule header="会导致副作用的函数调用不应该用作 sizeof 运算符的操作数" id="c" impl="MISRA2004-12_3_c" originalId="MISRA2004-12_3_c" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-12_3_c.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M5-8-1 移位运算符的右操作数应该位于零到1之间，小于左操作数的基础类型的位的宽度" name="M5_8_1">
            <rule header="一个移位操作符的右操作数应该位于 0 与左操作数底层类型的位宽减 1之间" id="a" impl="MISRA2004-12_8" originalId="MISRA2004-12_8" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-12_8.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M6-2-1 子表达式中不应使用赋值运算符" name="M6_2_1">
            <rule header="禁止在产生布尔值的表达式中使用赋值运算符" id="a" impl="MISRA2004-13_1" originalId="MISRA2004-13_1" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-13_1.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M6-2-2 浮点表达式不应直接或间接地检验等式或不等式" name="M6_2_2">
            <rule header="禁止对浮点数类型的表达式做相等或不相等的比较" id="a" impl="MISRA2004-13_3" originalId="MISRA2004-13_3" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-13_3.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M6-2-3 在预处理前，null 语句只能单独出现在一行中;如果 null 语句后面的第一个字符是空白字符，那么后面可能跟着一条注释" name="M6_2_3">
            <rule header="空语句应单独一行出现，或其后跟有注释" id="a" impl="MISRA2004-14_3" originalId="MISRA2004-14_3" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-14_3.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M6-3-1 构成switch， while， do ... while或for主体的语句应是复合语句" name="M6_3_1">
            <rule header="'switch', 'while', 'do...while' 或 'for' 语句的主体应该是复合语句" id="a" impl="MISRA2004-14_8" originalId="MISRA2004-14_8" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-14_8.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M6-4-1 if （条件）结构应后接复合语句.else 关键字后面应该跟着一个复合语句，或者另一个if语句" name="M6_4_1">
            <rule header="'if' 和 'else' 语句后应跟一个复合句" id="a" impl="MISRA2004-14_9" originalId="MISRA2004-14_9" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-14_9.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M6-4-2 所有 if ... else if 结构应以 else 子句终止" name="M6_4_2">
            <rule header="所有 'if...else-if' 结构应使用一个 'else' 子句终止" id="a" impl="MISRA2004-14_10" originalId="MISRA2004-14_10" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-14_10.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M6-4-3 switch 语句应该符合语法规范" name="M6_4_3">
            <rule header="非条件 throw 或 break 语句应终止每个非空的 switch 语句" id="a" impl="CODSTA-64" originalId="CODSTA-64" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-64.rule"/>
            </rule>
            <rule header="除非所有枚举值都经过测试，否则 switch 语句的最后一个子句应为 default-clause" id="b" impl="CODSTA-61" originalId="CODSTA-61" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-61.rule"/>
            </rule>
            <rule header="只有当最紧密包围的复合语句是 switch 语句的主体时才能使用 switch 标签" id="c" impl="MISRA2004-15_1" originalId="MISRA2004-15_1" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-15_1.rule"/>
            </rule>
            <rule header="每一个 switch 语句至少有一个 case 子句" id="d" impl="MISRA2004-15_5" originalId="MISRA2004-15_5" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-15_5.rule"/>
            </rule>
            <rule header="switch 表达式不应该出现一个实际为布尔的值" id="e" impl="MISRA2004-15_4" originalId="MISRA2004-15_4" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-15_4.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M6-4-4 switch 标签只能在最接近的复合语句是 switch 语句的主体时使用" name="M6_4_4">
            <rule header="只有当最紧密包围的复合语句是 switch 语句的主体时才能使用 switch 标签" id="a" impl="MISRA2004-15_1" originalId="MISRA2004-15_1" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-15_1.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M6-4-5 无条件抛出或中断语句将终止每个非空 switch 子句" name="M6_4_5">
            <rule header="非条件 throw 或 break 语句应终止每个非空的 switch 语句" id="a" impl="CODSTA-64" originalId="CODSTA-64" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-64.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M6-4-6 switch 语句的 final 子句应为 default 子句" name="M6_4_6">
            <rule header="除非所有枚举值都经过测试，否则 switch 语句的最后一个子句应为 default-clause" id="a" impl="CODSTA-61" originalId="CODSTA-61" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-61.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M6-4-7 switch语句的条件不应具有布尔类型" name="M6_4_7">
            <rule header="switch 表达式不应该出现一个实际为布尔的值" id="a" impl="MISRA2004-15_4" originalId="MISRA2004-15_4" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-15_4.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M6-5-2 如果循环计数器不被--或++修改，那么在条件允许的情况下，循环计数器只能用作 &lt;=， &lt;， &gt; 或 &gt;= 的操作数" name="M6_5_2">
            <rule header="如果循环计数器不是被 -- 或 ++ 修改，那么在条件中此循环计数器应该只能被用作 &lt;=, &lt;, &gt; 或 &gt;= 的操作数" id="a" impl="CODSTA-CPP-70" originalId="CODSTA-CPP-70" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-70.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M6-5-3 循环计数器不能在条件或声明中被修改" name="M6_5_3">
            <rule header="禁止在循环体中修改循环计数器" id="a" impl="MISRA2004-13_6" originalId="MISRA2004-13_6" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-13_6.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M6-5-4 在循环过程中 n 保持不变的地方，循环计数器应修改为: --，++，-= n，或+= n其中之一" name="M6_5_4">
            <rule header="循环计数器应该被 --, ++, -=n, 或 +=n 之一修改；这里的 n 在整个循环期间保持不变" id="a" impl="CODSTA-CPP-71" originalId="CODSTA-CPP-71" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-71.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M6-5-5 除循环计数器外的循环控变量不得在条件或表达式中进行修改" name="M6_5_5">
            <rule header="循环计数器以外的循环控制变量不得在判定条件或运算表达式中被修改" id="a" impl="CODSTA-CPP-72" originalId="CODSTA-CPP-72" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-72.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M6-5-6 除语句中修改的循环计数器外的循环控制变量应具有布尔类型" name="M6_5_6">
            <rule header="在循环体语句中被修改的循环计数器以外的循环控制变量应该是布尔类型的" id="a" impl="CODSTA-CPP-73" originalId="CODSTA-CPP-73" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-73.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M6-6-1 goto语句引用的任何标签都应声明在同一个语句块中，或在语句块中封闭goto语句" name="M6_6_1">
            <rule header="任何由 goto 语句引用的标签应该声明在同一个模块中，或者在一个包含 goto 语句的模块中" id="a" impl="CODSTA-78" originalId="CODSTA-78" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-78.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M6-6-2 在相同函数体中，goto语句应跳转到稍后声明的标签中" name="M6_6_2">
            <rule header="goto 语句应该跳转到同一个函数体中位于 goto 语句后面声明的标签" id="a" impl="CODSTA-77" originalId="CODSTA-77" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-77.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M6-6-3 continue语句只能在符合语法规则的for循环中使用" name="M6_6_3">
            <rule header="continue 语句只应该被用于具有良好格式的 for 循环中" id="a" impl="CODSTA-80" originalId="CODSTA-80" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-80.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M7-1-2 函数中的指针或引用参数如果不修改相应的对象，函数中的指针或引用参数应声明为指向 const 的指针或对 const 的引用" name="M7_1_2">
            <rule header="如果指针不用于修改指向地址的对象则声明参数的类型为 typedef 的 const 指针" id="a" impl="MISRA2004-16_7_b" originalId="MISRA2004-16_7_b" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-16_7_b.rule"/>
            </rule>
            <rule header="如果函数参数中指针参数在函数中不用来修改地址对象，则应声明为常量类型" id="b" impl="MISRA2004-16_7" originalId="MISRA2004-16_7" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-16_7.rule"/>
            </rule>
            <rule header="尽可能将引用参数声明为 const 引用" id="c" impl="CODSTA-CPP-43" originalId="CODSTA-CPP-43" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-43.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M7-3-1 全局名称空间应只包含 main，命名空间声明和外部的 'C'声明" name="M7_3_1">
            <rule header="全局命名空间应该只包含 main() 和命名空间声明" id="a" impl="CODSTA-CPP-36" originalId="CODSTA-CPP-36" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-36.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M7-3-2 main 标识符不能用于全局函数 main 以外的函数" name="M7_3_2">
            <rule header="标识符 main 不得用于除了全局的 main 函数以外的其它函数" id="a" impl="CODSTA-76" originalId="CODSTA-76" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-76.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M7-3-3 头文件中不应有未命名的名称空间" name="M7_3_3">
            <rule header="头文件中不应有未命名的命名空间" id="a" impl="CODSTA-CPP-74" originalId="CODSTA-CPP-74" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-74.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M7-3-4 不得使用应用指令" name="M7_3_4">
            <rule header="不得使用 using 指示符" id="a" impl="CODSTA-CPP-75" originalId="CODSTA-CPP-75" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-75.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M7-3-6 头文件中不应使用应用指令和使用声明（不包括类作用域或函数作用域应用声明）" name="M7_3_6">
            <rule header="不应该在头文件中使用 'using' 指令和 'using' 声明(除了类和函数范围内的 using 声明)" id="a" impl="CODSTA-CPP-90" originalId="CODSTA-CPP-90" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-90.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M7-4-1 汇编程序的所有使用应记录在案" name="M7_4_1">
            <rule header="应该注释说明所有汇编程序的使用" id="a" impl="COMMENT-09" originalId="COMMENT-09" quickfix="false" scope="line" severity="2">
               <file path="COMMENT\COMMENT-09.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M7-4-2 汇编指令只能通过asm声明引入" name="M7_4_2">
            <rule header="汇编指令应该只能使用 asm 声明来引入" id="a" impl="CODSTA-73" originalId="CODSTA-73" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-73.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M7-4-3 汇编语言应该被封装和隔离" name="M7_4_3">
            <rule header="汇编语言应该封装在 C/C++ 函数中并被隔离" id="a" impl="CODSTA-114" originalId="CODSTA-114" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-114.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M7-5-1 函数不应返回一个引用或指向函数中定义的自动变量（包括参数）的指针" name="M7_5_1">
            <rule header="不得从函数中返回具有自动存储的对象的地址" id="a" impl="MISRA2004-17_6_a" originalId="MISRA2004-17_6_a" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-17_6_a.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M7-5-2 具有自动存储功能的对象的地址不应分配给另一个对象，该对象可能在第一个对象停用后仍然存在" name="M7_5_2">
            <rule header="自动存储对象的地址不应分配给在第一个对象不再存在后可能持久存在的另一个对象" id="a" impl="MISRA2004-17_6_b" originalId="MISRA2004-17_6_b" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-17_6_b.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M8-0-1 初始化声明列表或成员声明列表应分别由单个初始化声明符或成员声名符组成" name="M8_0_1">
            <rule header="每个变量都要在单独的声明语句中被声明" id="a" impl="FORMAT-33" originalId="FORMAT-33" quickfix="false" scope="line" severity="2">
               <file path="FORMAT\FORMAT-33.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M8-3-1 覆盖虚拟函数中的参数要么使用与其覆盖的函数相同的默认参数，要么不指定任何默认参数" name="M8_3_1">
            <rule header="禁止使用不同的默认参数值来重定义继承的虚拟函数" id="a" impl="OOP-13" originalId="OOP-13" quickfix="false" scope="line" severity="2">
               <file path="OOP\OOP-13.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M8-4-2函数重声明中用于参数的标识符应与声明中的标识符相同" name="M8_4_2">
            <rule header="禁止函数声明中使用的标识符与实际定义中的标识符不一致" id="a" impl="MISRA2004-16_4" originalId="MISRA2004-16_4" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-16_4.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M8-4-4 函数标识符要么用于调用函数，要么在前面加上&amp;" name="M8_4_4">
            <rule header="函数标识符只能与前面的  '&amp;' 一起使用，或者与括号中的参数列表一起使用，参数列表可以是空的" id="a" impl="MISRA2004-16_9" originalId="MISRA2004-16_9" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-16_9.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M8-5-2 在数组和结构体的非零初始化中，应使用大括号来指示和匹配结构体" name="M8_5_2">
            <rule header="集合或联合的初始化程序应放在大括号中" id="a" impl="INIT-16" originalId="INIT-16" quickfix="false" scope="line" severity="2">
               <file path="INIT\INIT-16.rule"/>
            </rule>
            <rule header="数组不应被部分初始化" id="b" impl="MISRA2004-9_2_b" originalId="MISRA2004-9_2_b" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-9_2_b.rule"/>
            </rule>
            <rule header="结构体的非零初始化要求每个元素都有显示初始化器" id="c" impl="MISRA2004-9_2_c" originalId="MISRA2004-9_2_c" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-9_2_c.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M9-3-1 const 成员函数不应返回非 const 指针或对类数据的引用" name="M9_3_1">
            <rule header="Const 成员函数不得返回指向类数据的非 const 指针或引用" id="a" impl="CODSTA-CPP-77" originalId="CODSTA-CPP-77" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-77.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M9-3-3 如果一个成员函数可以是静态的，那么它就应该是静态的，否则如果它可以是 const，那么它就应该是 const" name="M9_3_3">
            <rule header="如果一个成员函数可以是 static，那么就应该定义为 static，否则，如果它可以是 const，那么它就应该被定义为 const" id="a" impl="CODSTA-CPP-78" originalId="CODSTA-CPP-78" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-78.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M9-6-4 带符号整数类型的命名位字段的长度应大于一位" name="M9_6_4">
            <rule header="具有带符号的整数类型且已命名的位域应该有超过一位的长度" id="a" impl="CODSTA-71" originalId="CODSTA-71" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-71.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A10-4-1 层次结构应该基于接口类" name="A10_4_1">
            <rule header="层次结构应该基于抽象类" id="a" impl="OOP-40" originalId="OOP-40" quickfix="false" scope="line" severity="4">
               <file path="OOP\OOP-40.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A11-0-1 非 POD 类型应该定义为类" name="A11_0_1">
            <rule header="非 POD 类型应定义为类" id="a" impl="OOP-55" originalId="OOP-55" quickfix="false" scope="line" severity="4">
               <file path="OOP\OOP-55.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A12-4-2 如果类的 public 析构函数是非虚拟的，则该类应该声明为 final" name="A12_4_2">
            <rule header="如果类的 public 析构函数是非虚拟的，则该类应该声明为 final" id="a" impl="CODSTA-MCPP-23" originalId="CODSTA-MCPP-23" quickfix="false" scope="line" severity="4">
               <file path="CODSTA-MCPP\CODSTA-MCPP-23.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A12-8-2 用户定义的复制和移动赋值操作符应该使用用户定义的无抛出交换函数" name="A12_8_2">
            <rule header="用户定义的复制和移动赋值运算符应使用用户定义的无抛出交换函数" id="a" impl="CODSTA-MCPP-49" originalId="CODSTA-MCPP-49" quickfix="false" scope="line" severity="4">
               <file path="CODSTA-MCPP\CODSTA-MCPP-49.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A12-8-7 赋值运算符应使用 ref-qualifier 声明  &amp;" name="A12_8_7">
            <rule header="使用引用修饰符&amp;(ref-qualifier)来声明赋值运算符" id="a" impl="CODSTA-MCPP-19" originalId="CODSTA-MCPP-19" quickfix="false" scope="line" severity="4">
               <file path="CODSTA-MCPP\CODSTA-MCPP-19.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A13-5-3 不应使用用户定义的转换操作符" name="A13_5_3">
            <rule header="不要使用用户自定义的转换函数" id="a" impl="CODSTA-CPP-05" originalId="CODSTA-CPP-05" quickfix="false" scope="line" severity="4">
               <file path="CODSTA-CPP\CODSTA-CPP-05.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A14-5-3 非成员泛型操作符只能在不包含类（结构体）类型、枚举类型或联合类型声明的命名空间中声明。" name="A14_5_3">
            <rule header="非成员泛型操作符只能在不包含类(结构体)类型、枚举类型或联合类型声明的命名空间中声明" id="a" impl="TEMPL-18" originalId="TEMPL-18" quickfix="false" scope="line" severity="4">
               <file path="TEMPL\TEMPL-18.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A15-1-1 应该只抛出从 std::exception 衍生出来的实例" name="A15_1_1">
            <rule header="只能使用 std::exception 异常" id="a" impl="HICPP-15_1_1-a" originalId="HICPP-15_1_1-a" quickfix="false" scope="line" severity="4">
               <file path="HICPP\HICPP-15_1_1-a.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A2-13-5 十六进制常量应该是大写的" name="A2_13_5">
            <rule header="十六进制常量应该全部使用大写字母表示" id="a" impl="CODSTA-50" originalId="CODSTA-50" quickfix="false" scope="line" severity="4">
               <file path="CODSTA\CODSTA-50.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A3-1-3 在项目中本地定义的实现文件的文件扩展名应为 '.cpp'" name="A3_1_3">
            <rule header="C++ 的实现文件应该总是具有扩展名 &quot;.cpp&quot;" id="a" impl="NAMING-49" originalId="NAMING-49" quickfix="false" scope="line" severity="4">
               <file path="NAMING\NAMING-49.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A3-1-6 常规的访问器和 mutator 函数应该内联" name="A3_1_6">
            <rule header="普通的访问器(accessor)和变值器(mutator)函数应该是内联的" id="a" impl="OPT-23" originalId="OPT-23" quickfix="false" scope="line" severity="4">
               <file path="OPT\OPT-23.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A5-1-6 应该显式指定非 void 返回类型 lambda 表达式的返回类型" name="A5_1_6">
            <rule header="应该显式指定非 void 返回类型 lambda 表达式的返回类型" id="a" impl="CODSTA-MCPP-45" originalId="CODSTA-MCPP-45" quickfix="false" scope="line" severity="4">
               <file path="CODSTA-MCPP\CODSTA-MCPP-45.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A5-1-8 Lambda 表达式不应该在另一个 Lambda 表达式中定义" name="A5_1_8">
            <rule header="lambda 表达式不应该在另一个 lambda 表达式中定义" id="a" impl="CODSTA-MCPP-44" originalId="CODSTA-MCPP-44" quickfix="false" scope="line" severity="4">
               <file path="CODSTA-MCPP\CODSTA-MCPP-44.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A5-2-1 不应使用 dynamic_cast" name="A5_2_1">
            <rule header="避免使用dynamic_casts" id="a" impl="CODSTA-CPP-35" originalId="CODSTA-CPP-35" quickfix="false" scope="line" severity="4">
               <file path="CODSTA-CPP\CODSTA-CPP-35.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A6-5-3 不应使用do语句" name="A6_5_3">
            <rule header="除了在类似函数的宏中，不应使用'Do'语句" id="a" impl="CODSTA-18_b" originalId="CODSTA-18_b" quickfix="false" scope="line" severity="4">
               <file path="CODSTA\CODSTA-18_b.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A6-5-4 init 语句和表达式不应该执行循环计数器初始化和修改以外的操作" name="A6_5_4">
            <rule header="除了初始化单个for循环参数的值外，for循环中的初始化表达式将不执行任何操作" id="a" impl="CODSTA-52" originalId="CODSTA-52" quickfix="false" scope="line" severity="4">
               <file path="CODSTA\CODSTA-52.rule"/>
            </rule>
            <rule header="在 for 循环中的增量表达式除了改变单个循环参数到下一个值外，不应该执行其他任何操作" id="b" impl="CODSTA-53" originalId="CODSTA-53" quickfix="false" scope="line" severity="4">
               <file path="CODSTA\CODSTA-53.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A7-2-5 枚举应该用来表示相关的命名常量集" name="A7_2_5">
            <rule header="Case 语句的标签应该使用枚举(enum)类型而不是使用整数类型(和常量)" id="a" impl="CODSTA-55" originalId="CODSTA-55" quickfix="false" scope="line" severity="4">
               <file path="CODSTA\CODSTA-55.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A8-4-3 应该使用传递参数的常用方法" name="A8_4_3">
            <rule header="非 'cheap to copy' 类型的参数应该通过引用来传递" id="a" impl="CODSTA-CPP-109" originalId="CODSTA-CPP-109" quickfix="false" scope="line" severity="4">
               <file path="CODSTA-CPP\CODSTA-CPP-109.rule"/>
            </rule>
            <rule header="尽可能将引用参数声明为 const 引用" id="b" impl="CODSTA-CPP-43" originalId="CODSTA-CPP-43" quickfix="false" scope="line" severity="4">
               <file path="CODSTA-CPP\CODSTA-CPP-43.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A8-4-4 一个函数的多个输出值应该以结构体或元组的形式返回" name="A8_4_4">
            <rule header="一个函数的多个输出值应该以结构体或元组的形式返回" id="a" impl="CODSTA-MCPP-48" originalId="CODSTA-MCPP-48" quickfix="false" scope="line" severity="4">
               <file path="CODSTA-MCPP\CODSTA-MCPP-48.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR A8-5-4 如果一个类有一个用户声明的构造函数，它接受 std::initializer_list类型的参数，那么它应该是除特殊成员函数构造函数之外的惟一构造函数" name="A8_5_4">
            <rule header="避免使用std::initializer_list重载构造函数" id="a" impl="CODSTA-MCPP-47" originalId="CODSTA-MCPP-47" quickfix="false" scope="line" severity="4">
               <file path="CODSTA-MCPP\CODSTA-MCPP-47.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M0-1-10 每个定义的函数至少应调用一次" name="M0_1_10">
            <rule header="每个定义的具有内部链接的函数应该至少被使用一次" id="b" impl="OPT-30" originalId="OPT-30" quickfix="false" scope="line" severity="4">
               <file path="OPT\OPT-30.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M10-1-1 类不应从虚基础派生" name="M10_1_1">
            <rule header="类不能从虚拟基类型中衍生" id="a" impl="OOP-47" originalId="OOP-47" quickfix="false" scope="line" severity="4">
               <file path="OOP\OOP-47.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M10-2-1 多继承层次结构中的所有可访问实体名称都应该是唯一的" name="M10_2_1">
            <rule header="多重继承层次中可访问的实例名必须独一无二" id="a" impl="CODSTA-CPP-92" originalId="CODSTA-CPP-92" quickfix="false" scope="line" severity="4">
               <file path="CODSTA-CPP\CODSTA-CPP-92.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M16-3-2 不应该使用 # 和 ## 操作符" name="M16_3_2">
            <rule header="禁止使用预处理操作符 # 和 ##" id="a" impl="MISRA2004-19_13" originalId="MISRA2004-19_13" quickfix="false" scope="line" severity="4">
               <file path="MISRA2004\MISRA2004-19_13.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M5-0-2 在表达式中，对 c++ 运算符优先规则的依赖是有限的" name="M5_0_2">
            <rule header="当赋值运算符包含赋值表达式时，将括号用于赋值运算符的右侧操作数" id="a" impl="MISRA2004-12_1_a" originalId="MISRA2004-12_1_a" quickfix="false" scope="line" severity="4">
               <file path="MISRA2004\MISRA2004-12_1_a.rule"/>
            </rule>
            <rule header="谨慎使用 C 语言中表达式的优先运算规则" id="b" impl="MISRA2004-12_1_b" originalId="MISRA2004-12_1_b" quickfix="false" scope="line" severity="4">
               <file path="MISRA2004\MISRA2004-12_1_b.rule"/>
            </rule>
            <rule header="一元运算符的操作数不需要括号" id="c" impl="MISRA2004-12_1_c" originalId="MISRA2004-12_1_c" quickfix="false" scope="line" severity="4">
               <file path="MISRA2004\MISRA2004-12_1_c.rule"/>
            </rule>
            <rule header="谨慎使用 C 语言中表达式的优先运算规则" id="d" impl="MISRA2004-12_1_d" originalId="MISRA2004-12_1_d" quickfix="false" scope="line" severity="4">
               <file path="MISRA2004\MISRA2004-12_1_d.rule"/>
            </rule>
            <rule header="除非表达式中的所有运算符都相同，否则使用圆括号" id="e" impl="MISRA2004-12_1_e" originalId="MISRA2004-12_1_e" quickfix="false" scope="line" severity="4">
               <file path="MISRA2004\MISRA2004-12_1_e.rule"/>
            </rule>
            <rule header="谨慎使用 C 语言中表达式的优先运算规则" id="f" impl="MISRA2004-12_1_f" originalId="MISRA2004-12_1_f" quickfix="false" scope="line" severity="4">
               <file path="MISRA2004\MISRA2004-12_1_f.rule"/>
            </rule>
         </category>
         <category description="AUTOSAR M5-2-3 从基类到派生类的转换不应该在多态类型上执行" name="M5_2_3">
            <rule header="禁止对多态类型进行从基类型到衍生类的强制类型转换" id="a" impl="OOP-49" originalId="OOP-49" quickfix="false" scope="line" severity="4">
               <file path="OOP\OOP-49.rule"/>
            </rule>
         </category>
      </category>
      <category description="注释" name="COMMENT">
         <rule header="不得在 // 注释中使用行合并" id="13" impl="COMMENT-13" quickfix="false" scope="line" severity="2">
            <file path="COMMENT\COMMENT-13.rule"/>
         </rule>
         <rule header="推荐使用 C++ 风格的注释" id="01" impl="COMMENT-01" quickfix="false" scope="line" severity="3">
            <file path="COMMENT\COMMENT-01.rule"/>
         </rule>
         <rule header="提供版权信息" id="02" impl="COMMENT-02" quickfix="false" scope="line" severity="3">
            <file path="COMMENT\COMMENT-02.rule"/>
         </rule>
         <rule header="每个源文件需要注释文件信息" id="03" impl="COMMENT-03" quickfix="false" scope="line" severity="3">
            <file path="COMMENT\COMMENT-03.rule"/>
         </rule>
         <rule header="在函数定义之前的注释中记录函数" id="04" impl="COMMENT-04" quickfix="false" scope="line" severity="3">
            <file path="COMMENT\COMMENT-04.rule"/>
         </rule>
         <rule header="在函数声明之前的注释中记录函数" id="04_b" impl="COMMENT-04_b" quickfix="false" scope="line" severity="3">
            <file path="COMMENT\COMMENT-04_b.rule"/>
         </rule>
         <rule header="每一个变量声明都应该进行注解" id="05" impl="COMMENT-05" quickfix="false" scope="line" severity="3">
            <file path="COMMENT\COMMENT-05.rule"/>
         </rule>
         <rule header="每一个类型定义(typedef)都应该进行注释" id="06" impl="COMMENT-06" quickfix="false" scope="line" severity="3">
            <file path="COMMENT\COMMENT-06.rule"/>
         </rule>
         <rule header="每一个枚举值都应该进行注释" id="07" impl="COMMENT-07" quickfix="false" scope="line" severity="3">
            <file path="COMMENT\COMMENT-07.rule"/>
         </rule>
         <rule header="每一个结构体成员变量都应该进行注释" id="08" impl="COMMENT-08" quickfix="false" scope="line" severity="3">
            <file path="COMMENT\COMMENT-08.rule"/>
         </rule>
         <rule header="应该注释说明所有汇编程序的使用" id="09" impl="COMMENT-09" quickfix="false" scope="line" severity="3">
            <file path="COMMENT\COMMENT-09.rule"/>
         </rule>
         <rule header="使用对浮点运算注释说明" id="10" impl="COMMENT-10" quickfix="false" scope="line" severity="3">
            <file path="COMMENT\COMMENT-10.rule"/>
         </rule>
         <rule header="字符序列 // 不得被用于 C 语言风格的注释中" id="11" impl="COMMENT-11" quickfix="false" scope="line" severity="3">
            <file path="COMMENT\COMMENT-11.rule"/>
         </rule>
         <rule header="字符序列 /* 不得被用于 C++ 语言风格的注释中" id="12" impl="COMMENT-12" quickfix="false" scope="line" severity="3">
            <file path="COMMENT\COMMENT-12.rule"/>
         </rule>
         <rule header="所有类型、数据成员和函数的声明之前都应该有一个注释，注释使用 '@brief' 标记" id="14" impl="COMMENT-14" quickfix="false" scope="line" severity="3">
            <file path="COMMENT\COMMENT-14.rule"/>
         </rule>
         <rule header="函数参数和返回类型应该记录在函数声明之前的注释中" id="14_b" impl="COMMENT-14_b" quickfix="false" scope="line" severity="3">
            <file path="COMMENT\COMMENT-14_b.rule"/>
         </rule>
      </category>
      <category description="联合攻击战斗机" name="JSF">
         <rule header="限制圈复杂度在 20 之内" id="003" impl="METRICS-28" originalId="METRICS-28" quickfix="false" scope="line" severity="2">
            <file path="METRICS\METRICS-28.rule"/>
         </rule>
         <rule header="遵循基本复杂度为 1 的限制" id="003_b" impl="METRICS-42" originalId="METRICS-42" quickfix="false" scope="line" severity="2">
            <file path="METRICS\METRICS-42.rule"/>
         </rule>
         <rule header="使用大写 'L' 而非小写 'l' 来指定长整型" id="014" impl="PORT-01" originalId="PORT-01" quickfix="false" scope="line" severity="2">
            <file path="PORT\PORT-01.rule"/>
         </rule>
         <rule header="应当作出适当的运行时检查的规定" id="015" impl="MISRA-004_a" originalId="MISRA-004_a" quickfix="false" scope="line" severity="2">
            <file path="MISRA\MISRA-004_a.rule"/>
         </rule>
         <rule header="不得使用错误指示符 'errno'" id="017" impl="MISRA2004-20_5" originalId="MISRA2004-20_5" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-20_5.rule"/>
         </rule>
         <rule header="不应该使用库文件 stddef.h 中的 offsetof 宏" id="018" impl="MISRA2004-20_6" originalId="MISRA2004-20_6" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-20_6.rule"/>
         </rule>
         <rule header="不要使用 setlocale 函数" id="019" impl="MISRA-121_a" originalId="MISRA-121_a" quickfix="false" scope="line" severity="2">
            <file path="MISRA\MISRA-121_a.rule"/>
         </rule>
         <rule header="不应包含 &lt;locale.h&gt; 头文件" id="019_b" impl="MISRA-121_b" originalId="MISRA-121_b" quickfix="false" scope="line" severity="2">
            <file path="MISRA\MISRA-121_b.rule"/>
         </rule>
         <rule header="不应使用 &lt;setjmp.h&gt; 提供的工具" id="020" impl="MISRA2004-20_7" originalId="MISRA2004-20_7" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-20_7.rule"/>
         </rule>
         <rule header="不应使用标准头文件 &lt;setjmp.h&gt; 或 &lt;csetjmp&gt;" id="020_b" impl="MISRA2004-20_7_b" originalId="MISRA2004-20_7_b" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-20_7_b.rule"/>
         </rule>
         <rule header="不应使用标准头文件 &lt;signal.h&gt; 或 &lt;csignal&gt;" id="021" impl="MISRA2004-20_8" originalId="MISRA2004-20_8" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-20_8.rule"/>
         </rule>
         <rule header="不应使用 &lt;signal.h&gt; 的信号处理工具" id="021_b" impl="MISRA2004-20_8_b" originalId="MISRA2004-20_8_b" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-20_8_b.rule"/>
         </rule>
         <rule header="不应该包含标准输入/输出库 stdio.h" id="022" impl="PREPROC-18" originalId="PREPROC-18" quickfix="false" scope="line" severity="2">
            <file path="PREPROC\PREPROC-18.rule"/>
         </rule>
         <rule header="不得使用库stdlib.h中的库函数atof，atoi和atol" id="023" impl="MISRA2004-20_10" originalId="MISRA2004-20_10" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-20_10.rule"/>
         </rule>
         <rule header="不得使用  'stdlib.h' 或者 'cstdlib' 库中的 'abort()' 函数" id="024" impl="PB-75" originalId="PB-75" quickfix="false" scope="line" severity="2">
            <file path="PB\PB-75.rule"/>
         </rule>
         <rule header="'stdlib.h' 或者 'cstdlib' 库中的 'exit()' 函数不应该被使用" id="024_b" impl="PB-75_b" originalId="PB-75_b" quickfix="false" scope="line" severity="2">
            <file path="PB\PB-75_b.rule"/>
         </rule>
         <rule header="不得使用 'stdlib.h' 或 'cstdlib' 库中的 'getenv()' 函数" id="024_c" impl="SECURITY-52" originalId="SECURITY-52" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-52.rule"/>
         </rule>
         <rule header="不得使用 'stdlib.h' 或 'cstdlib' 库中的 'system()' 函数" id="024_d" impl="SECURITY-48_b" originalId="SECURITY-48_b" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-48_b.rule"/>
         </rule>
         <rule header="不应使用标准头文件 &lt;time.h&gt; 或 &lt;ctime&gt;" id="025" impl="MISRA2004-20_12" originalId="MISRA2004-20_12" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-20_12.rule"/>
         </rule>
         <rule header="不应使用 #ifdef, #else, #elif 程序预处理指示字" id="026" impl="PREPROC-11" originalId="PREPROC-11" quickfix="false" scope="line" severity="2">
            <file path="PREPROC\PREPROC-11.rule"/>
         </rule>
         <rule header="不应使用 #if 程序预处理指示字" id="026_b" impl="PREPROC-11_b" originalId="PREPROC-11_b" quickfix="false" scope="line" severity="2">
            <file path="PREPROC\PREPROC-11_b.rule"/>
         </rule>
         <rule header="不应使用 #error 指令" id="026_c" impl="PREPROC-22" originalId="PREPROC-22" quickfix="false" scope="line" severity="2">
            <file path="PREPROC\PREPROC-22.rule"/>
         </rule>
         <rule header="不应使用 #pragma 指令" id="026_d" impl="PREPROC-23" originalId="PREPROC-23" quickfix="false" scope="line" severity="2">
            <file path="PREPROC\PREPROC-23.rule"/>
         </rule>
         <rule header="不应使用 #undef" id="026_e" impl="PREPROC-25" originalId="PREPROC-25" quickfix="false" scope="line" severity="2">
            <file path="PREPROC\PREPROC-25.rule"/>
         </rule>
         <rule header="函数应该优先于宏函数的使用" id="029" impl="MISRA2004-19_7" originalId="MISRA2004-19_7" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-19_7.rule"/>
         </rule>
         <rule header="不要通过 #define 定义常量" id="030" impl="CODSTA-03" originalId="CODSTA-03" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-03.rule"/>
         </rule>
         <rule header="#include 指令只能使用 &lt;filename.h&gt; 符号来包含头文件" id="033" impl="PREPROC-09" originalId="PREPROC-09" quickfix="false" scope="line" severity="2">
            <file path="PREPROC\PREPROC-09.rule"/>
         </rule>
         <rule header="用户指定的 C++ 外部标识符的前 64 个字符应不同" id="046_a" impl="PORT-34_a" originalId="PORT-34_a" quickfix="false" scope="line" severity="2">
            <file path="PORT\PORT-34_a.rule"/>
         </rule>
         <rule header="用户指定的 C++ 内部标识符应与前 64 个字符中的外部标识符不同" id="046_b" impl="PORT-34_b" originalId="PORT-34_b" quickfix="false" scope="line" severity="2">
            <file path="PORT\PORT-34_b.rule"/>
         </rule>
         <rule header="在相同范围内声明的用户指定的 C++ 内部标识符的前64个字符应不同" id="046_c" impl="PORT-34_c" originalId="PORT-34_c" quickfix="false" scope="line" severity="2">
            <file path="PORT\PORT-34_c.rule"/>
         </rule>
         <rule header="常量和枚举值的标识符应为小写" id="052" impl="NAMING-42" originalId="NAMING-42" quickfix="false" scope="line" severity="2">
            <file path="NAMING\NAMING-42.rule"/>
         </rule>
         <rule header="下列的字符序列不得出现在头文件名中： ', \, /*, //, 或 &quot;" id="053.1" impl="PB-28" originalId="PB-28" quickfix="false" scope="line" severity="2">
            <file path="PB\PB-28.rule"/>
         </rule>
         <rule header="'switch', 'while', 'do...while' 或 'for' 语句的主体应该是复合语句" id="059_a" impl="MISRA2004-14_8" originalId="MISRA2004-14_8" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-14_8.rule"/>
         </rule>
         <rule header="'if' 和 'else' 语句后应跟一个复合句" id="059_b" impl="MISRA2004-14_9" originalId="MISRA2004-14_9" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-14_9.rule"/>
         </rule>
         <rule header="私有的拷贝构造函数和拷贝赋值运算符要同时声明" id="068" impl="MRM-50" originalId="MRM-50" quickfix="false" scope="line" severity="2">
            <file path="MRM\MRM-50.rule"/>
         </rule>
         <rule header="被释放的内存在任何情况下都不应该被访问" id="070.1" impl="MRM-31" originalId="MRM-31" quickfix="false" scope="line" severity="2">
            <file path="MRM\MRM-31.rule"/>
         </rule>
         <rule header="不应该手动调用析构函数" id="070.1_b" impl="MRM-31_b" originalId="MRM-31_b" quickfix="false" scope="line" severity="2">
            <file path="MRM\MRM-31_b.rule"/>
         </rule>
         <rule header="public 和 protected 的方法不应被类的构造函数调用" id="071" impl="PB-26" originalId="PB-26" quickfix="false" scope="line" severity="2">
            <file path="PB\PB-26.rule"/>
         </rule>
         <rule header="避免从构造函数调用虚函数" id="071.1" impl="OOP-16" originalId="OOP-16" quickfix="false" scope="line" severity="2">
            <file path="OOP\OOP-16.rule"/>
         </rule>
         <rule header="避免从析构函数调用虚函数" id="071.1_b" impl="OOP-16_b" originalId="OOP-16_b" quickfix="false" scope="line" severity="2">
            <file path="OOP\OOP-16_b.rule"/>
         </rule>
         <rule header="所有成员变量都应该在构造函数中初始化" id="071_b" impl="INIT-06" originalId="INIT-06" quickfix="false" scope="line" severity="2">
            <file path="INIT\INIT-06.rule"/>
         </rule>
         <rule header="避免从构造函数调用虚函数" id="071_c" impl="OOP-16" originalId="OOP-16" quickfix="false" scope="line" severity="2">
            <file path="OOP\OOP-16.rule"/>
         </rule>
         <rule header="禁止在基类构造函数中使用未初始化的非静态成员变量" id="071_d" impl="INIT-13_a" originalId="INIT-13_a" quickfix="false" scope="line" severity="2">
            <file path="INIT\INIT-13_a.rule"/>
         </rule>
         <rule header="不要在虚拟基类构造函数中使用非虚拟基类未初始化的非静态成员变量" id="071_e" impl="INIT-13_b" originalId="INIT-13_b" quickfix="false" scope="line" severity="2">
            <file path="INIT\INIT-13_b.rule"/>
         </rule>
         <rule header="禁止在基类构造函数中使用基类的可能未初始化的非静态成员变量" id="071_f" impl="INIT-13_c" originalId="INIT-13_c" quickfix="false" scope="line" severity="2">
            <file path="INIT\INIT-13_c.rule"/>
         </rule>
         <rule header="在初始化列表中按声明成员的顺序列出成员" id="075" impl="INIT-10" originalId="INIT-10" quickfix="false" scope="line" severity="2">
            <file path="INIT\INIT-10.rule"/>
         </rule>
         <rule header="应为包含指向数据项或非平凡析构函数的指针的类声明一个拷贝构造函数和一个拷贝赋值操作符" id="076" impl="MRM-49" originalId="MRM-49" quickfix="false" scope="line" severity="2">
            <file path="MRM\MRM-49.rule"/>
         </rule>
         <rule header="拷贝构造函数应复制所有的数据成员以及基类成员" id="077" impl="MRM-41" originalId="MRM-41" quickfix="false" scope="line" severity="2">
            <file path="MRM\MRM-41.rule"/>
         </rule>
         <rule header="构造函数的定义中不能包含特定的缺省参数，这些参数可能产生与隐性声明的复制构造函数完全一样的签名" id="077.1" impl="PB-24" originalId="PB-24" quickfix="false" scope="line" severity="2">
            <file path="PB\PB-24.rule"/>
         </rule>
         <rule header="在具有虚函数的基类中定义虚拟析构函数" id="078" impl="OOP-22" originalId="OOP-22" quickfix="false" scope="line" severity="2">
            <file path="OOP\OOP-22.rule"/>
         </rule>
         <rule header="在析构函数中调用 fclose() 函数来关闭用于打开文件的指针成员" id="079" impl="MRM-42" originalId="MRM-42" quickfix="false" scope="line" severity="2">
            <file path="MRM\MRM-42.rule"/>
         </rule>
         <rule header="在析构函数中对指针成员调用delete" id="079_b" impl="MRM-33" originalId="MRM-33" quickfix="false" scope="line" severity="2">
            <file path="MRM\MRM-33.rule"/>
         </rule>
         <rule header="检查 operator= 中的自我赋值" id="081" impl="OOP-34" originalId="OOP-34" quickfix="false" scope="line" severity="2">
            <file path="OOP\OOP-34.rule"/>
         </rule>
         <rule header="赋值操作符返回一个 *this 指向的引用；使赋值操作符的返回类型是指向自身 类类型的非常量引用" id="082" impl="CODSTA-CPP-02" originalId="CODSTA-CPP-02" quickfix="false" scope="line" severity="2">
            <file path="CODSTA-CPP\CODSTA-CPP-02.rule"/>
         </rule>
         <rule header="赋值运算符应赋值所有数据成员" id="083_a" impl="INIT-11" originalId="INIT-11" quickfix="false" scope="line" severity="2">
            <file path="INIT\INIT-11.rule"/>
         </rule>
         <rule header="赋值运算符必须对基类型中的成员进行赋值" id="083_b" impl="MRM-43" originalId="MRM-43" quickfix="false" scope="line" severity="2">
            <file path="MRM\MRM-43.rule"/>
         </rule>
         <rule header="多重继承应该限制为之多1个受保护的实现" id="088" impl="OOP-07_a" originalId="OOP-07_a" quickfix="false" scope="line" severity="2">
            <file path="OOP\OOP-07_a.rule"/>
         </rule>
         <rule header="有状态的虚拟类应该在每个访问该类的衍生类中进行显式地声明" id="088.1" impl="OOP-39_b" originalId="OOP-39_b" quickfix="false" scope="line" severity="2">
            <file path="OOP\OOP-39_b.rule"/>
         </rule>
         <rule header="多重继承不应该使用任何public实现" id="088_b" impl="OOP-07_b" originalId="OOP-07_b" quickfix="false" scope="line" severity="2">
            <file path="OOP\OOP-07_b.rule"/>
         </rule>
         <rule header="在同一层次结构中，基类不能同时具有虚拟及非虚拟的属性" id="089" impl="OOP-41" originalId="OOP-41" quickfix="false" scope="line" severity="2">
            <file path="OOP\OOP-41.rule"/>
         </rule>
         <rule header="禁止对继承的非虚拟函数进行重定义" id="094" impl="OOP-32" originalId="OOP-32" quickfix="false" scope="line" severity="2">
            <file path="OOP\OOP-32.rule"/>
         </rule>
         <rule header="派生类里声明的成员函数不应该隐藏基类中声明的函数" id="094_b" impl="OOP-53" originalId="OOP-53" quickfix="false" scope="line" severity="2">
            <file path="OOP\OOP-53.rule"/>
         </rule>
         <rule header="禁止使用不同的默认参数值来重定义继承的虚拟函数" id="095" impl="OOP-13" originalId="OOP-13" quickfix="false" scope="line" severity="2">
            <file path="OOP\OOP-13.rule"/>
         </rule>
         <rule header="指向派生类对象数组的指针不应转换为基类指针" id="096" impl="PB-57" originalId="PB-57" quickfix="false" scope="line" severity="2">
            <file path="PB\PB-57.rule"/>
         </rule>
         <rule header="在接口中不应该使用数组类型参数" id="097" impl="CODSTA-CPP-55" originalId="CODSTA-CPP-55" quickfix="false" scope="line" severity="2">
            <file path="CODSTA-CPP\CODSTA-CPP-55.rule"/>
         </rule>
         <rule header="判等运算符 (== 或 !=)的任何一个操作数都不应该是一个指向虚成员函数的指针" id="097.1" impl="CODSTA-CPP-79" originalId="CODSTA-CPP-79" quickfix="false" scope="line" severity="2">
            <file path="CODSTA-CPP\CODSTA-CPP-79.rule"/>
         </rule>
         <rule header="私有方法和被保护的方法不应该用数组类型声明参数" id="097_b" impl="CODSTA-CPP-55_b" originalId="CODSTA-CPP-55_b" quickfix="false" scope="line" severity="2">
            <file path="CODSTA-CPP\CODSTA-CPP-55_b.rule"/>
         </rule>
         <rule header="全局函数不能声明数组类型的参数" id="097_c" impl="CODSTA-142" originalId="CODSTA-142" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-142.rule"/>
         </rule>
         <rule header="不要将具有数组类型的表达式传递给一个具有指针或者数组类型参数的函数" id="097_d" impl="PB-41_b" originalId="PB-41_b" quickfix="false" scope="line" severity="2">
            <file path="PB\PB-41_b.rule"/>
         </rule>
         <rule header="使用数组参数调用的函数不应该声明具有指针参数" id="097_e" impl="CODSTA-142_b" originalId="CODSTA-142_b" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-142_b.rule"/>
         </rule>
         <rule header="始终在文件的范围内声明函数" id="107" impl="MISRA2004-8_6" originalId="MISRA2004-8_6" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-8_6.rule"/>
         </rule>
         <rule header="避免使用有可变数量参数的函数" id="108" impl="MISRA-069" originalId="MISRA-069" quickfix="false" scope="line" severity="2">
            <file path="MISRA\MISRA-069.rule"/>
         </rule>
         <rule header="不得从函数中返回具有自动存储的对象的地址" id="111" impl="MISRA2004-17_6_a" originalId="MISRA2004-17_6_a" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-17_6_a.rule"/>
         </rule>
         <rule header="函数不应返回对常量引用传递的指针或参数的引用" id="111_a" impl="PB-39_b" originalId="PB-39_b" quickfix="false" scope="line" severity="2">
            <file path="PB\PB-39_b.rule"/>
         </rule>
         <rule header="具有非空返回类型的函数的所有退出路径都应该有一个带有表达式的显式返回语句" id="114" impl="MISRA2004-16_8" originalId="MISRA2004-16_8" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-16_8.rule"/>
         </rule>
         <rule header="函数不应该直接或者间接地调用自己" id="119" impl="MISRA2004-16_2" originalId="MISRA2004-16_2" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-16_2.rule"/>
         </rule>
         <rule header="推荐使用 C++ 风格的注释" id="126" impl="COMMENT-01" originalId="COMMENT-01" quickfix="false" scope="line" severity="2">
            <file path="COMMENT\COMMENT-01.rule"/>
         </rule>
         <rule header="代码段不应该被&quot;注释掉&quot;" id="127" impl="MISRA2004-2_4" originalId="MISRA2004-2_4" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-2_4.rule"/>
         </rule>
         <rule header="在局部或者函数原型体范围内声明的标识符不应该隐藏一个在全局或者命名空间范围内声明的标识符" id="135_a" impl="MISRA2004-5_2_a" originalId="MISRA2004-5_2_a" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-5_2_a.rule"/>
         </rule>
         <rule header="在内层的局部范围内声明的标识符不应该隐藏在外层的局部范围内声明的标识符" id="135_b" impl="MISRA2004-5_2_b" originalId="MISRA2004-5_2_b" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-5_2_b.rule"/>
         </rule>
         <rule header="在一个局部范围内声明的标识符不应该隐藏在一个类作用域中声明的标识符" id="135_c" impl="CODSTA-CPP-83" originalId="CODSTA-CPP-83" quickfix="false" scope="line" severity="2">
            <file path="CODSTA-CPP\CODSTA-CPP-83.rule"/>
         </rule>
         <rule header="在类的作用域中声明的标识符不应该隐藏在全局或命名空间范围内声明的标识符" id="135_d" impl="CODSTA-CPP-84" originalId="CODSTA-CPP-84" quickfix="false" scope="line" severity="2">
            <file path="CODSTA-CPP\CODSTA-CPP-84.rule"/>
         </rule>
         <rule header="在一个内部类作用域中声明的标识符不应该隐藏在外部类作用域中声明的标识符" id="135_e" impl="CODSTA-CPP-85" originalId="CODSTA-CPP-85" quickfix="false" scope="line" severity="2">
            <file path="CODSTA-CPP\CODSTA-CPP-85.rule"/>
         </rule>
         <rule header="标识符在同一编译单元中不能同时具有内部和外部链接" id="138_a" impl="MISRA-024" originalId="MISRA-024" quickfix="false" scope="line" severity="2">
            <file path="MISRA\MISRA-024.rule"/>
         </rule>
         <rule header="静态存储类说明符应该用于具有内部链接的对象和函数的定义和声明" id="138_b" impl="MISRA2004-8_11" originalId="MISRA2004-8_11" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-8_11.rule"/>
         </rule>
         <rule header="不应使用'register'存储类说明符" id="140" impl="MISRA-028" originalId="MISRA-028" quickfix="false" scope="line" severity="2">
            <file path="MISRA\MISRA-028.rule"/>
         </rule>
         <rule header="所有自动变量在使用之前都必须被赋值" id="142_a" impl="MISRA-030" originalId="MISRA-030" quickfix="false" scope="line" severity="2">
            <file path="MISRA\MISRA-030.rule"/>
         </rule>
         <rule header="初始化所有变量" id="142_b" impl="INIT-03" originalId="INIT-03" quickfix="false" scope="line" severity="2">
            <file path="INIT\INIT-03.rule"/>
         </rule>
         <rule header="集合或联合的初始化程序应放在大括号中" id="144" impl="INIT-16" originalId="INIT-16" quickfix="false" scope="line" severity="2">
            <file path="INIT\INIT-16.rule"/>
         </rule>
         <rule header="在枚举类型中，要么仅对第一个元素进行显式地初始化，要么所有元素都进行显式的初始化" id="145" impl="MISRA2004-9_3" originalId="MISRA2004-9_3" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-9_3.rule"/>
         </rule>
         <rule header="不得使用浮点型数向下转换表示" id="147" impl="MISRA-016" originalId="MISRA-016" quickfix="false" scope="line" severity="2">
            <file path="MISRA\MISRA-016.rule"/>
         </rule>
         <rule header="Case 语句的标签应该使用枚举(enum)类型而不是使用整数类型(和常量)" id="148" impl="CODSTA-55" originalId="CODSTA-55" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-55.rule"/>
         </rule>
         <rule header="不应该使用八进制常数（除零外）" id="149" impl="MISRA2004-7_1_a" originalId="MISRA2004-7_1_a" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-7_1_a.rule"/>
         </rule>
         <rule header="字符串字面量不应该被修改" id="151.1" impl="PB-27" originalId="PB-27" quickfix="false" scope="line" severity="2">
            <file path="PB\PB-27.rule"/>
         </rule>
         <rule header="不允许在同一行声明多个变量" id="152" impl="FORMAT-29" originalId="FORMAT-29" quickfix="false" scope="line" severity="2">
            <file path="FORMAT\FORMAT-29.rule"/>
         </rule>
         <rule header="禁止使用联合体" id="153" impl="MISRA2004-18_4" originalId="MISRA2004-18_4" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-18_4.rule"/>
         </rule>
         <rule header="位域只应该有显式的无符号整数或者枚举类型" id="154" impl="CODSTA-96" originalId="CODSTA-96" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-96.rule"/>
         </rule>
         <rule header="结构体或联合体或类的所有成员变量应该被命名" id="156" impl="MISRA-113" originalId="MISRA-113" quickfix="false" scope="line" severity="2">
            <file path="MISRA\MISRA-113.rule"/>
         </rule>
         <rule header="逻辑&amp;&amp;或||运算符的右操作数不得含有副作用" id="157" impl="MISRA2004-12_4_a" originalId="MISRA2004-12_4_a" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-12_4_a.rule"/>
         </rule>
         <rule header="如果逻辑 &amp;&amp; 或 || 的操作数包含二元运算符则操作数应该被括起来" id="158" impl="CODSTA-104" originalId="CODSTA-104" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-104.rule"/>
         </rule>
         <rule header="避免重载逻辑操作符AND, OR (&amp;&amp;, ||)" id="159" impl="CODSTA-CPP-08" originalId="CODSTA-CPP-08" quickfix="false" scope="line" severity="2">
            <file path="CODSTA-CPP\CODSTA-CPP-08.rule"/>
         </rule>
         <rule header="一元 &amp; 运算符不得被重载" id="159_b" impl="CODSTA-CPP-68" originalId="CODSTA-CPP-68" quickfix="false" scope="line" severity="2">
            <file path="CODSTA-CPP\CODSTA-CPP-68.rule"/>
         </rule>
         <rule header="禁止在产生布尔值的表达式中使用赋值运算符" id="160" impl="MISRA2004-13_1" originalId="MISRA2004-13_1" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-13_1.rule"/>
         </rule>
         <rule header="在比较运算中不允许混合使用有符号值和无符号值" id="162_a" impl="CODSTA-99" originalId="CODSTA-99" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-99.rule"/>
         </rule>
         <rule header="在条件运算符的第二个和第三个操作数中不允许混合使用有符号和无符号值" id="162_b" impl="CODSTA-101" originalId="CODSTA-101" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-101.rule"/>
         </rule>
         <rule header="在算术运算中不允许混合使用有符号值和无符号值" id="162_c" impl="CODSTA-100" originalId="CODSTA-100" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-100.rule"/>
         </rule>
         <rule header="不要使用无符号算术" id="163" impl="PB-25" originalId="PB-25" quickfix="false" scope="line" severity="2">
            <file path="PB\PB-25.rule"/>
         </rule>
         <rule header="右移位操作符的左操作数不能是负数" id="164.1" impl="PB-29" originalId="PB-29" quickfix="false" scope="line" severity="2">
            <file path="PB\PB-29.rule"/>
         </rule>
         <rule header="一元减法运算符不得适用于其原始类型是无符号型的表达式" id="165" impl="MISRA2004-12_9" originalId="MISRA2004-12_9" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-12_9.rule"/>
         </rule>
         <rule header="不能将两个整数相除之后的结果赋给浮点类型" id="167_a" impl="PB-15" originalId="PB-15" quickfix="false" scope="line" severity="2">
            <file path="PB\PB-15.rule"/>
         </rule>
         <rule header="不应该使用逗号运算符" id="168_b" impl="MISRA2004-12_10" originalId="MISRA2004-12_10" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-12_10.rule"/>
         </rule>
         <rule header="对象的声明应该包含不超过 2 层的指针嵌套" id="170" impl="MISRA2004-17_5" originalId="MISRA2004-17_5" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-17_5.rule"/>
         </rule>
         <rule header="自动存储对象的地址不应分配给在第一个对象不再存在后可能持久存在的另一个对象" id="173" impl="MISRA2004-17_6_b" originalId="MISRA2004-17_6_b" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-17_6_b.rule"/>
         </rule>
         <rule header="空指针不应取消引用" id="174_a" impl="MISRA-107_a" originalId="MISRA-107_a" quickfix="false" scope="line" severity="2">
            <file path="MISRA\MISRA-107_a.rule"/>
         </rule>
         <rule header="空指针不应取消引用" id="174_b" impl="MISRA-107_b" originalId="MISRA-107_b" quickfix="false" scope="line" severity="2">
            <file path="MISRA\MISRA-107_b.rule"/>
         </rule>
         <rule header="不要使用 NULL 标识符; 而是使用 0 替代" id="175" impl="CODSTA-17" originalId="CODSTA-17" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-17.rule"/>
         </rule>
         <rule header="向下的强制转换(基类到衍生类的转换)是不允许的" id="178" impl="OOP-35" originalId="OOP-35" quickfix="false" scope="line" severity="2">
            <file path="OOP\OOP-35.rule"/>
         </rule>
         <rule header="指向虚拟基类型的指针只能通过dynamic_cast的方式转换为指向其衍生类的指针" id="179" impl="OOP-50" originalId="OOP-50" quickfix="false" scope="line" severity="2">
            <file path="OOP\OOP-50.rule"/>
         </rule>
         <rule header="不应使用可能导致信息丢失的从较宽到较窄的整数类型的隐式转换" id="180_a" impl="MISRA-043" originalId="MISRA-043" quickfix="false" scope="line" severity="2">
            <file path="MISRA\MISRA-043.rule"/>
         </rule>
         <rule header="避免从浮点类型到整型的隐式转换" id="180_b" impl="MISRA2004-10_2_a" originalId="MISRA2004-10_2_a" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-10_2_a.rule"/>
         </rule>
         <rule header="避免宽字段到窄字段浮点型数据的隐式转换" id="180_c" impl="MISRA2004-10_2_b" originalId="MISRA2004-10_2_b" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-10_2_b.rule"/>
         </rule>
         <rule header="避免将常量值转换为一个窄类型" id="180_d" impl="PORT-28" originalId="PORT-28" quickfix="false" scope="line" severity="2">
            <file path="PORT\PORT-28.rule"/>
         </rule>
         <rule header="避免从有符号类型到无符号类型的隐式变换" id="180_e" impl="PB-56" originalId="PB-56" quickfix="false" scope="line" severity="2">
            <file path="PB\PB-56.rule"/>
         </rule>
         <rule header="不应使用可能导致信息丢失的从整型到浮点型的隐式转换" id="180_f" impl="MISRA-043_c" originalId="MISRA-043_c" quickfix="false" scope="line" severity="2">
            <file path="MISRA\MISRA-043_c.rule"/>
         </rule>
         <rule header="不应使用可能会导致信息丢失的从整数常量到浮点类型的隐式转换" id="180_g" impl="MISRA-043_d" originalId="MISRA-043_d" quickfix="false" scope="line" severity="2">
            <file path="MISRA\MISRA-043_d.rule"/>
         </rule>
         <rule header="不得使用从任何类型到指针或者指针到任何类型的类型转换" id="182" impl="CODSTA-135" originalId="CODSTA-135" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-135.rule"/>
         </rule>
         <rule header="避免从浮点类型到整型的隐式转换" id="184_a" impl="MISRA2004-10_2_a" originalId="MISRA2004-10_2_a" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-10_2_a.rule"/>
         </rule>
         <rule header="不得使用 C 语言风格的强制类型转换(除 void 强制类型转换外)和函数符号式强制类型转换(除了显式的构造函数调用外)" id="185" impl="CODSTA-CPP-66" originalId="CODSTA-CPP-66" quickfix="false" scope="line" severity="2">
            <file path="CODSTA-CPP\CODSTA-CPP-66.rule"/>
         </rule>
         <rule header="在 &quot;else&quot; 语句块中不应存在执行不到的代码" id="186_a" impl="MISRA2004-14_1_a" originalId="MISRA2004-14_1_a" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-14_1_a.rule"/>
         </rule>
         <rule header="在 'return', 'break', 'continue', 和 'goto' 语句之后不应存在执行不到的代码" id="186_b" impl="MISRA2004-14_1_b" originalId="MISRA2004-14_1_b" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-14_1_b.rule"/>
         </rule>
         <rule header="在 &quot;if/else/while/for&quot; 语句块中不应存在执行不到的代码" id="186_c" impl="MISRA2004-14_1_c" originalId="MISRA2004-14_1_c" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-14_1_c.rule"/>
         </rule>
         <rule header="在 switch 语句中不应存在执行不到的代码" id="186_d" impl="MISRA2004-14_1_d" originalId="MISRA2004-14_1_d" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-14_1_d.rule"/>
         </rule>
         <rule header="在 'for' 循环中不应存在执行不到的代码" id="186_e" impl="MISRA2004-14_1_e" originalId="MISRA2004-14_1_e" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-14_1_e.rule"/>
         </rule>
         <rule header="在 'if' 或 'switch' 语句后不应存在不可访问的代码" id="186_f" impl="MISRA2004-14_1_f" originalId="MISRA2004-14_1_f" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-14_1_f.rule"/>
         </rule>
         <rule header="在 while/for/do...while 循环内的 &quot;if&quot; 或 &quot;switch&quot; 语句后不应存在执行不到的代码" id="186_g" impl="MISRA2004-14_1_g" originalId="MISRA2004-14_1_g" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-14_1_g.rule"/>
         </rule>
         <rule header="每个定义的具有内部链接的函数应该至少被使用一次" id="186_h" impl="OPT-30" originalId="OPT-30" quickfix="false" scope="line" severity="2">
            <file path="OPT\OPT-30.rule"/>
         </rule>
         <rule header="所有非 null 语句无论如何执行都至少有一个副作用，或者导致控制流发生变化" id="187" impl="MISRA2004-14_2" originalId="MISRA2004-14_2" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-14_2.rule"/>
         </rule>
         <rule header="不应该使用 goto 语句" id="189" impl="MISRA2004-14_4" originalId="MISRA2004-14_4" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-14_4.rule"/>
         </rule>
         <rule header="不要使用 continue 语句" id="190" impl="MISRA2004-14_5" originalId="MISRA2004-14_5" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-14_5.rule"/>
         </rule>
         <rule header="请勿使用 break 语句" id="191" impl="MISRA-058" originalId="MISRA-058" quickfix="false" scope="line" severity="2">
            <file path="MISRA\MISRA-058.rule"/>
         </rule>
         <rule header="对任何循环语句，都应存在不止一个用于循环终止的 break 或 goto 语句" id="191_a" impl="CODSTA-79" originalId="CODSTA-79" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-79.rule"/>
         </rule>
         <rule header="无条件的 break 语句应该作为每一个非空 case 子句的结束" id="193" impl="MISRA2004-15_2" originalId="MISRA2004-15_2" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-15_2.rule"/>
         </rule>
         <rule header="除非所有枚举值都经过测试，否则 switch 语句的最后一个子句应为 default-clause" id="194" impl="CODSTA-61" originalId="CODSTA-61" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-61.rule"/>
         </rule>
         <rule header="不得使用浮点变量作为循环计数器" id="197" impl="MISRA-065" originalId="MISRA-065" quickfix="false" scope="line" severity="2">
            <file path="MISRA\MISRA-065.rule"/>
         </rule>
         <rule header="禁止在循环体中修改循环计数器" id="201" impl="MISRA2004-13_6" originalId="MISRA2004-13_6" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-13_6.rule"/>
         </rule>
         <rule header="禁止对浮点数类型的表达式做相等或不相等的比较" id="202" impl="MISRA2004-13_3" originalId="MISRA2004-13_3" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-13_3.rule"/>
         </rule>
         <rule header="对常量无符号整数表达式的求值不应该导致循环" id="203" impl="PB-73" originalId="PB-73" quickfix="false" scope="line" severity="2">
            <file path="PB\PB-73.rule"/>
         </rule>
         <rule header="表达式的值应该在任何标准允许的赋值顺序下是一样的" id="204.1_a" impl="MISRA2004-12_2_a" originalId="MISRA2004-12_2_a" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-12_2_a.rule"/>
         </rule>
         <rule header="不要编写依赖于函数参数求值顺序的代码" id="204.1_b" impl="MISRA2004-12_2_b" originalId="MISRA2004-12_2_b" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-12_2_b.rule"/>
         </rule>
         <rule header="不要编写依赖于函数标志符和函数参数的求值顺序的代码" id="204.1_c" impl="MISRA2004-12_2_c" originalId="MISRA2004-12_2_c" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-12_2_c.rule"/>
         </rule>
         <rule header="涉及一个函数调用时，不要编写依赖表达式求值顺序的代码" id="204.1_d" impl="MISRA2004-12_2_d" originalId="MISRA2004-12_2_d" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-12_2_d.rule"/>
         </rule>
         <rule header="在序列点之间，对象的存储值最多只能通过表达式的评估来修改一次" id="204.1_e" impl="MISRA2004-12_2_e" originalId="MISRA2004-12_2_e" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-12_2_e.rule"/>
         </rule>
         <rule header="不要在两个相邻的序列点之间使用多个 volatile" id="204.1_f" impl="MISRA2004-12_2_f" originalId="MISRA2004-12_2_f" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-12_2_f.rule"/>
         </rule>
         <rule header="不要编写依赖于函数调用求值顺序的代码" id="204.1_g" impl="MISRA2004-12_2_g" originalId="MISRA2004-12_2_g" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-12_2_g.rule"/>
         </rule>
         <rule header="可能会导致错误的单个运算符只能在适当的上下文中使用" id="204_a" impl="CODSTA-102" originalId="CODSTA-102" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-102.rule"/>
         </rule>
         <rule header="具有副作用的函数调用只能在适当的上下文中使用" id="204_b" impl="CODSTA-103" originalId="CODSTA-103" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-103.rule"/>
         </rule>
         <rule header="三元运算符 '?:' 的第二个或第三个操作数不得含有副作用" id="204_d" impl="CODSTA-105" originalId="CODSTA-105" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-105.rule"/>
         </rule>
         <rule header="不要使用 volatile 关键字" id="205" impl="MISRA-046_a" originalId="MISRA-046_a" quickfix="false" scope="line" severity="2">
            <file path="MISRA\MISRA-046_a.rule"/>
         </rule>
         <rule header="不应使用动态堆内存分配" id="206" impl="MISRA2004-20_4" originalId="MISRA2004-20_4" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-20_4.rule"/>
         </rule>
         <rule header="在程序中不要运用 C++ 异常处理函数(例如,不得使用 throw, catch 和 try 等)" id="208" impl="EXCEPT-05" originalId="EXCEPT-05" quickfix="false" scope="line" severity="2">
            <file path="EXCEPT\EXCEPT-05.rule"/>
         </rule>
         <rule header="typedef 定义基本类型应该在名称中包含数字" id="209" impl="MISRA2004-6_3" originalId="MISRA2004-6_3" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-6_3.rule"/>
         </rule>
         <rule header="typedef 应该用于替代基本类型" id="209_b" impl="MISRA2004-6_3_b" originalId="MISRA2004-6_3_b" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-6_3_b.rule"/>
         </rule>
         <rule header="算法中不应假设由访问标识符分隔的非静态数据成员的分配顺序" id="210.1" impl="PORT-26" originalId="PORT-26" quickfix="false" scope="line" severity="2">
            <file path="PORT\PORT-26.rule"/>
         </rule>
         <rule header="不应在指向对象类型的指针和指向对象类型的其他指针之间执行强制转换" id="211" impl="MISRA2004-11_4" originalId="MISRA2004-11_4" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-11_4.rule"/>
         </rule>
         <rule header="如果操作符的优先级低于算术运算符，应该使用圆括号明确表达式的操作顺序" id="213_e" impl="CODSTA-97" originalId="CODSTA-97" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-97.rule"/>
         </rule>
         <rule header="通过用局部静态对象替换非局部静态对象来避免跨越编译单元的初始化顺序问题" id="214" impl="INIT-12" originalId="INIT-12" quickfix="false" scope="line" severity="2">
            <file path="INIT\INIT-12.rule"/>
         </rule>
         <rule header="任何函数或方法应该不包含超过200行的逻辑代码行数 (L-SLOC)" id="001" impl="METRICS-25" originalId="METRICS-25" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-25.rule"/>
         </rule>
         <rule header="只使用 ISO C 标准中定义的字符" id="009" impl="MISRA-005" originalId="MISRA-005" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-005.rule"/>
         </rule>
         <rule header="字符类型值必须是严格定义和记录的 ISO 10646-1 标准的子集" id="010" impl="MISRA-006" originalId="MISRA-006" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-006.rule"/>
         </rule>
         <rule header="禁止使用三联符" id="011" impl="MISRA2004-4_2" originalId="MISRA2004-4_2" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-4_2.rule"/>
         </rule>
         <rule header="请勿使用以下双字符组：&lt;%, %&gt;, &lt;:, :&gt;, %:, %:%:" id="012" impl="CODSTA-48" originalId="CODSTA-48" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-48.rule"/>
         </rule>
         <rule header="不要使用宽字符串字面量" id="013" impl="MISRA-008" originalId="MISRA-008" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-008.rule"/>
         </rule>
         <rule header="使用多个包含保护" id="027" impl="PFO-02" originalId="PFO-02" quickfix="false" scope="line" severity="3">
            <file path="PFO\PFO-02.rule"/>
         </rule>
         <rule header="#ifndef 程序预处理指示字仅用于防止相同头文件的多个 inclusion" id="028" impl="PREPROC-10" originalId="PREPROC-10" quickfix="false" scope="line" severity="3">
            <file path="PREPROC\PREPROC-10.rule"/>
         </rule>
         <rule header="#endif 程序预处理指示字将仅用于防止同一头文件多个包含" id="028_b" impl="PREPROC-10_b" originalId="PREPROC-10_b" quickfix="false" scope="line" severity="3">
            <file path="PREPROC\PREPROC-10_b.rule"/>
         </rule>
         <rule header="避免使用宏定义" id="031" impl="PREPROC-01" originalId="PREPROC-01" quickfix="false" scope="line" severity="3">
            <file path="PREPROC\PREPROC-01.rule"/>
         </rule>
         <rule header="仅可以在包含头文件(*.h)时使用 #include 预处理指令" id="032" impl="PREPROC-08" originalId="PREPROC-08" quickfix="false" scope="line" severity="3">
            <file path="PREPROC\PREPROC-08.rule"/>
         </rule>
         <rule header="使用多个包含保护" id="035" impl="PFO-02" originalId="PFO-02" quickfix="false" scope="line" severity="3">
            <file path="PFO\PFO-02.rule"/>
         </rule>
         <rule header="在头文件中不能定义具有链接属性的实体" id="039_a" impl="PFO-01" originalId="PFO-01" quickfix="false" scope="line" severity="3">
            <file path="PFO\PFO-01.rule"/>
         </rule>
         <rule header="源代码行的长度不得超过120个字符" id="041" impl="METRICS-26" originalId="METRICS-26" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-26.rule"/>
         </rule>
         <rule header="每行只允许一个语句" id="042" impl="FORMAT-06" originalId="FORMAT-06" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-06.rule"/>
         </rule>
         <rule header="同级语句行应该缩进到相同的位置" id="044" impl="FORMAT-36" originalId="FORMAT-36" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-36.rule"/>
         </rule>
         <rule header="标识符的名字不能以一个下划线 (`_') 或两个下划线 (`__') 开头" id="047" impl="NAMING-33" originalId="NAMING-33" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-33.rule"/>
         </rule>
         <rule header="不能使用大小写字母，下划线区分标识符，也不能使用容易与数字混淆的字母做为标识符名字" id="048" impl="NAMING-45" originalId="NAMING-45" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-45.rule"/>
         </rule>
         <rule header="类，结构体，联合体，枚举和自定义类型(typedef)的名字必须以大写字母开头" id="050" impl="NAMING-09" originalId="NAMING-09" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-09.rule"/>
         </rule>
         <rule header="函数和变量名称中包含的所有字母将完全由小写字母组成" id="051" impl="NAMING-44" originalId="NAMING-44" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-44.rule"/>
         </rule>
         <rule header="确保头文件应该始终具有扩展名 '.h'" id="053" impl="NAMING-41" originalId="NAMING-41" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-41.rule"/>
         </rule>
         <rule header="C++ 的实现文件应该总是具有扩展名 &quot;.cpp&quot;" id="054" impl="NAMING-49" originalId="NAMING-49" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-49.rule"/>
         </rule>
         <rule header="在一个类中作用范围的顺序为: public 位置应在最前面" id="057_a" impl="CODSTA-CPP-46" originalId="CODSTA-CPP-46" quickfix="false" scope="line" severity="3">
            <file path="CODSTA-CPP\CODSTA-CPP-46.rule"/>
         </rule>
         <rule header="在一个类中作用范围的顺序: protected 位于 private 之前" id="057_b" impl="CODSTA-CPP-47" originalId="CODSTA-CPP-47" quickfix="false" scope="line" severity="3">
            <file path="CODSTA-CPP\CODSTA-CPP-47.rule"/>
         </rule>
         <rule header="当函数的形参超过两个的时候，前括号和第一个参数应该和函数名写在一行,其他参数应该再单独一行写一个" id="058" impl="FORMAT-38" originalId="FORMAT-38" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-38.rule"/>
         </rule>
         <rule header="用于包住一个代码模块的括号 (&quot;{}&quot;) 在同一行上除了注释以外不应该有其它代码" id="060_a" impl="FORMAT-42" originalId="FORMAT-42" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-42.rule"/>
         </rule>
         <rule header="大括号 (&quot;{}&quot;) 将把一个块放在同一列中" id="060_b" impl="FORMAT-43" originalId="FORMAT-43" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-43.rule"/>
         </rule>
         <rule header="用于包住一个代码模块的括号 (&quot;{}&quot;) 不允许在 &quot;{&quot; 之后或 &quot;}&quot; 之前有空行" id="060_c" impl="FORMAT-44" originalId="FORMAT-44" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-44.rule"/>
         </rule>
         <rule header="用于包住一个代码模块的括号 (&quot;{}&quot;) 在同一行上除了注释以外不应该有其它代码" id="061" impl="FORMAT-42" originalId="FORMAT-42" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-42.rule"/>
         </rule>
         <rule header="解引用运算符 '*' 和地址运算符 '&amp;' 应直接与类型连接在一起" id="062" impl="FORMAT-32" originalId="FORMAT-32" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-32.rule"/>
         </rule>
         <rule header="在 '.' 或 '-&gt;' 操作符之后不能有空白格" id="063_a" impl="FORMAT-17" originalId="FORMAT-17" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-17.rule"/>
         </rule>
         <rule header="在 '.' 或 '-&gt;' 操作符之前不能有空白格" id="063_b" impl="FORMAT-18" originalId="FORMAT-18" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-18.rule"/>
         </rule>
         <rule header="在一元运算符 &quot;!&quot; 或 &quot;~&quot; 及其操作数之间不能有空格" id="063_c" impl="FORMAT-21" originalId="FORMAT-21" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-21.rule"/>
         </rule>
         <rule header="在自增/自减运算符 (++/--) 和其操作数之间不能有空格" id="063_d" impl="FORMAT-22" originalId="FORMAT-22" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-22.rule"/>
         </rule>
         <rule header="在一元运算符 &quot;&amp;&quot;, &quot;*&quot;, &quot;+&quot;, &quot;-&quot; 及其操作数之间不能有空格" id="063_e" impl="FORMAT-45" originalId="FORMAT-45" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-45.rule"/>
         </rule>
         <rule header="在宏定义中的自增/自减运算符 (++/--) 及其操作数之间不能有空格" id="063_f" impl="FORMAT-46" originalId="FORMAT-46" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-46.rule"/>
         </rule>
         <rule header="成员函数应尽可能声明为常量" id="069" impl="CODSTA-CPP-54" originalId="CODSTA-CPP-54" quickfix="false" scope="line" severity="3">
            <file path="CODSTA-CPP\CODSTA-CPP-54.rule"/>
         </rule>
         <rule header="构造函数中推荐使用初始化列表而非赋值" id="074" impl="INIT-14" originalId="INIT-14" quickfix="false" scope="line" severity="3">
            <file path="INIT\INIT-14.rule"/>
         </rule>
         <rule header="当两个操作符是对立的(例如==和!=)时，可以同时定义它们" id="085" impl="CODSTA-CPP-16" originalId="CODSTA-CPP-16" quickfix="false" scope="line" severity="3">
            <file path="CODSTA-CPP\CODSTA-CPP-16.rule"/>
         </rule>
         <rule header="如果在一个类中定义了两个相反的相等运算符（'=='、'!='），则其中一个运算符应以另一个运算符的形式定义" id="085_a" impl="CODSTA-CPP-86" originalId="CODSTA-CPP-86" quickfix="false" scope="line" severity="3">
            <file path="CODSTA-CPP\CODSTA-CPP-86.rule"/>
         </rule>
         <rule header="命名空间的嵌套不能超过两层" id="099" impl="CODSTA-CPP-57" originalId="CODSTA-CPP-57" quickfix="false" scope="line" severity="3">
            <file path="CODSTA-CPP\CODSTA-CPP-57.rule"/>
         </rule>
         <rule header="模板所有的部分和显式专门化都应在与其主模板声明相同的文件中声明" id="104" impl="TEMPL-10" originalId="TEMPL-10" quickfix="false" scope="line" severity="3">
            <file path="TEMPL\TEMPL-10.rule"/>
         </rule>
         <rule header="不要使用多于 7 个参数的函数" id="110" impl="METRICS-27" originalId="METRICS-27" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-27.rule"/>
         </rule>
         <rule header="函数末端应只提供一个出口点" id="113" impl="MISRA2004-14_7" originalId="MISRA2004-14_7" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-14_7.rule"/>
         </rule>
         <rule header="如果函数返回了错误信息，那么错误信息应该进行测试" id="115" impl="MISRA2004-16_10" originalId="MISRA2004-16_10" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-16_10.rule"/>
         </rule>
         <rule header="每一个变量声明都应该进行注解" id="132_a" impl="COMMENT-05" originalId="COMMENT-05" quickfix="false" scope="line" severity="3">
            <file path="COMMENT\COMMENT-05.rule"/>
         </rule>
         <rule header="每一个类型定义(typedef)都应该进行注释" id="132_b" impl="COMMENT-06" originalId="COMMENT-06" quickfix="false" scope="line" severity="3">
            <file path="COMMENT\COMMENT-06.rule"/>
         </rule>
         <rule header="每一个枚举值都应该进行注释" id="132_c" impl="COMMENT-07" originalId="COMMENT-07" quickfix="false" scope="line" severity="3">
            <file path="COMMENT\COMMENT-07.rule"/>
         </rule>
         <rule header="每一个结构体成员变量都应该进行注释" id="132_d" impl="COMMENT-08" originalId="COMMENT-08" quickfix="false" scope="line" severity="3">
            <file path="COMMENT\COMMENT-08.rule"/>
         </rule>
         <rule header="每个源文件需要注释文件信息" id="133_a" impl="COMMENT-03" originalId="COMMENT-03" quickfix="false" scope="line" severity="3">
            <file path="COMMENT\COMMENT-03.rule"/>
         </rule>
         <rule header="提供版权信息" id="133_b" impl="COMMENT-02" originalId="COMMENT-02" quickfix="false" scope="line" severity="3">
            <file path="COMMENT\COMMENT-02.rule"/>
         </rule>
         <rule header="外部对象不得声明在多个文件中" id="139" impl="MISRA-027" originalId="MISRA-027" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-027.rule"/>
         </rule>
         <rule header="外部对象不应该在实现文件中声明" id="139_b" impl="MISRA-027_b" originalId="MISRA-027_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-027_b.rule"/>
         </rule>
         <rule header="类，结构体或枚举不应该在其类型定义中被声明" id="141" impl="CODSTA-CPP-56" originalId="CODSTA-CPP-56" quickfix="false" scope="line" severity="3">
            <file path="CODSTA-CPP\CODSTA-CPP-56.rule"/>
         </rule>
         <rule header="如果变量不能被初始化为有意义的值就不应引入" id="143" impl="OPT-26" originalId="OPT-26" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-26.rule"/>
         </rule>
         <rule header="避免未使用的局部变量" id="143_a" impl="OPT-02" originalId="OPT-02" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-02.rule"/>
         </rule>
         <rule header="十六进制常量应该全部使用大写字母表示" id="150" impl="CODSTA-50" originalId="CODSTA-50" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-50.rule"/>
         </rule>
         <rule header="避免使用魔数" id="151" impl="CODSTA-26" originalId="CODSTA-26" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-26.rule"/>
         </rule>
         <rule header="sizeof 运算符的操作数不应包含任何有副作用的表达式" id="166" impl="MISRA2004-12_3" originalId="MISRA2004-12_3" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_3.rule"/>
         </rule>
         <rule header="不应在sizeof运算符的操作数中访问由volatile左值指定的对象" id="166_b" impl="MISRA2004-12_3_b" originalId="MISRA2004-12_3_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_3_b.rule"/>
         </rule>
         <rule header="会导致副作用的函数调用不应该用作 sizeof 运算符的操作数" id="166_c" impl="MISRA2004-12_3_c" originalId="MISRA2004-12_3_c" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_3_c.rule"/>
         </rule>
         <rule header="文件整数除法" id="167" impl="MISRA-041" originalId="MISRA-041" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-041.rule"/>
         </rule>
         <rule header="当声明函数指针时使用 typedef 来简化程序语法" id="176" impl="CODSTA-34" originalId="CODSTA-34" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-34.rule"/>
         </rule>
         <rule header="不允许冗余显式转换为同一类型" id="181_a" impl="OPT-29" originalId="OPT-29" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-29.rule"/>
         </rule>
         <rule header="避免从衍生类到基类的显式类型转换" id="181_b" impl="OOP-20" originalId="OOP-20" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-20.rule"/>
         </rule>
         <rule header="避免使用标签" id="188" impl="MISRA-055" originalId="MISRA-055" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-055.rule"/>
         </rule>
         <rule header="所有的 'if...else if' 结构应该包含一个最后的 'else' 分支或明确的注释表示为什么不需要最后的 'else' 分支。" id="192" impl="CODSTA-98" originalId="CODSTA-98" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-98.rule"/>
         </rule>
         <rule header="switch 表达式不应该出现一个实际为布尔的值" id="195" impl="MISRA2004-15_4" originalId="MISRA2004-15_4" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-15_4.rule"/>
         </rule>
         <rule header="每个 switch 语句至少有两个 case 分支和一个潜在的 default 分支" id="196" impl="CODSTA-54" originalId="CODSTA-54" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-54.rule"/>
         </rule>
         <rule header="除了初始化单个for循环参数的值外，for循环中的初始化表达式将不执行任何操作" id="198" impl="CODSTA-52" originalId="CODSTA-52" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-52.rule"/>
         </rule>
         <rule header="在 for 循环中的增量表达式除了改变单个循环参数到下一个值外，不应该执行其他任何操作" id="199" impl="CODSTA-53" originalId="CODSTA-53" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-53.rule"/>
         </rule>
         <rule header="如果 'for' 语句中无初始化或者无增量表达式; 应该使用 while 循环替代" id="200" impl="CODSTA-49" originalId="CODSTA-49" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-49.rule"/>
         </rule>
         <rule header="避免未封装的全局变量 (包括在命名空间中声明的变量和公共静态成员)" id="207" impl="CODSTA-CPP-82" originalId="CODSTA-CPP-82" quickfix="false" scope="line" severity="3">
            <file path="CODSTA-CPP\CODSTA-CPP-82.rule"/>
         </rule>
         <rule header="文件应该只包含(include)具有编译该文件所需的声明和定义的头文件" id="037" impl="OPT-41" originalId="OPT-41" quickfix="false" scope="line" severity="4">
            <file path="OPT\OPT-41.rule"/>
         </rule>
         <rule header="禁止使用未用 ASCII 空格的制表符" id="043" impl="FORMAT-01" originalId="FORMAT-01" quickfix="false" scope="line" severity="4">
            <file path="FORMAT\FORMAT-01.rule"/>
         </rule>
         <rule header="避免 &quot;public&quot; 数据成员" id="067_a" impl="OOP-18" originalId="OOP-18" quickfix="false" scope="line" severity="4">
            <file path="OOP\OOP-18.rule"/>
         </rule>
         <rule header="避免 'protected' 数据成员" id="067_b" impl="OOP-19" originalId="OOP-19" quickfix="false" scope="line" severity="4">
            <file path="OOP\OOP-19.rule"/>
         </rule>
         <rule header="避免使用友元(friend)机制" id="070" impl="OOP-11" originalId="OOP-11" quickfix="false" scope="line" severity="4">
            <file path="OOP\OOP-11.rule"/>
         </rule>
         <rule header="层次结构应该基于抽象类" id="087" impl="OOP-40" originalId="OOP-40" quickfix="false" scope="line" severity="4">
            <file path="OOP\OOP-40.rule"/>
         </rule>
         <rule header="全局命名空间应该只包含 main() 和命名空间声明" id="098" impl="CODSTA-CPP-36" originalId="CODSTA-CPP-36" quickfix="false" scope="line" severity="4">
            <file path="CODSTA-CPP\CODSTA-CPP-36.rule"/>
         </rule>
         <rule header="不要在头文件中或 #include 之前写 namespace usings" id="100" impl="CODSTA-CPP-39" originalId="CODSTA-CPP-39" quickfix="false" scope="line" severity="4">
            <file path="CODSTA-CPP\CODSTA-CPP-39.rule"/>
         </rule>
         <rule header="在含有依赖基础的类模板中，任何可能在这个依赖类中被发现的名称都应该引用使用限定标识（qualified-id）或 -&gt;" id="105" impl="TEMPL-12" originalId="TEMPL-12" quickfix="false" scope="line" severity="4">
            <file path="TEMPL\TEMPL-12.rule"/>
         </rule>
         <rule header="除非打算内联函数，否则函数定义不应放在类规范中" id="109" impl="CODSTA-CPP-32" originalId="CODSTA-CPP-32" quickfix="false" scope="line" severity="4">
            <file path="CODSTA-CPP\CODSTA-CPP-32.rule"/>
         </rule>
         <rule header="禁止返回函数范围内的new运算符初始化的解引用本地指针" id="112" impl="MRM-23" originalId="MRM-23" quickfix="false" scope="line" severity="4">
            <file path="MRM\MRM-23.rule"/>
         </rule>
         <rule header="从不是重载运算符函数得到的非 void 类型的返回值应该始终被使用" id="115_a" impl="CODSTA-CPP-58" originalId="CODSTA-CPP-58" quickfix="false" scope="line" severity="4">
            <file path="CODSTA-CPP\CODSTA-CPP-58.rule"/>
         </rule>
         <rule header="通过值传递内置类型，除非你想要修改这些参数" id="116" impl="CODSTA-36" originalId="CODSTA-36" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-36.rule"/>
         </rule>
         <rule header="引用而不是值传递对象" id="117" impl="OPT-14" originalId="OPT-14" quickfix="false" scope="line" severity="4">
            <file path="OPT\OPT-14.rule"/>
         </rule>
         <rule header="尽可能将引用参数声明为 const 引用" id="117.1" impl="CODSTA-CPP-43" originalId="CODSTA-CPP-43" quickfix="false" scope="line" severity="4">
            <file path="CODSTA-CPP\CODSTA-CPP-43.rule"/>
         </rule>
         <rule header="避免切片函数参数/返回值" id="117_a" impl="PB-20" originalId="PB-20" quickfix="false" scope="line" severity="4">
            <file path="PB\PB-20.rule"/>
         </rule>
         <rule header="如果类具有非静态指针且没有声明的复制构造函数，则应通过引用传递类对象" id="117_b" impl="PB-23" originalId="PB-23" quickfix="false" scope="line" severity="4">
            <file path="PB\PB-23.rule"/>
         </rule>
         <rule header="如果函数参数中指针参数在函数中不用来修改地址对象，则应声明为常量类型" id="118" impl="MISRA2004-16_7" originalId="MISRA2004-16_7" quickfix="false" scope="line" severity="4">
            <file path="MISRA2004\MISRA2004-16_7.rule"/>
         </rule>
         <rule header="如果指针不用于修改指向地址的对象则声明参数的类型为 typedef 的 const 指针" id="118_b" impl="MISRA2004-16_7_b" originalId="MISRA2004-16_7_b" quickfix="false" scope="line" severity="4">
            <file path="MISRA2004\MISRA2004-16_7_b.rule"/>
         </rule>
         <rule header="应只将有 1 个或 2 个语句的函数考虑为内联函数的候选函数" id="121" impl="OPT-25" originalId="OPT-25" quickfix="false" scope="line" severity="4">
            <file path="OPT\OPT-25.rule"/>
         </rule>
         <rule header="普通的访问器(accessor)和变值器(mutator)函数应该是内联的" id="122" impl="OPT-23" originalId="OPT-23" quickfix="false" scope="line" severity="4">
            <file path="OPT\OPT-23.rule"/>
         </rule>
         <rule header="不允许仅存在 getters/setters(accessors/mutators) 的类" id="123" impl="CODSTA-CPP-81" originalId="CODSTA-CPP-81" quickfix="false" scope="line" severity="4">
            <file path="CODSTA-CPP\CODSTA-CPP-81.rule"/>
         </rule>
         <rule header="应该内联普通的转发函数" id="124" impl="OPT-24" originalId="OPT-24" quickfix="false" scope="line" severity="4">
            <file path="OPT\OPT-24.rule"/>
         </rule>
         <rule header="引用而不是值传递对象" id="125_a" impl="OPT-14" originalId="OPT-14" quickfix="false" scope="line" severity="4">
            <file path="OPT\OPT-14.rule"/>
         </rule>
         <rule header="在函数定义之前的注释中记录函数" id="134" impl="COMMENT-04" originalId="COMMENT-04" quickfix="false" scope="line" severity="4">
            <file path="COMMENT\COMMENT-04.rule"/>
         </rule>
         <rule header="在函数声明之前的注释中记录函数" id="134_b" impl="COMMENT-04_b" originalId="COMMENT-04_b" quickfix="false" scope="line" severity="4">
            <file path="COMMENT\COMMENT-04_b.rule"/>
         </rule>
         <rule header="如果仅从单个函数中访问对象，则应在块范围内定义对象" id="136_a" impl="MISRA2004-8_7" originalId="MISRA2004-8_7" quickfix="false" scope="line" severity="4">
            <file path="MISRA2004\MISRA2004-8_7.rule"/>
         </rule>
         <rule header="尽可能地声明局部变量" id="136_b" impl="OPT-01" originalId="OPT-01" quickfix="false" scope="line" severity="4">
            <file path="OPT\OPT-01.rule"/>
         </rule>
         <rule header="应该在头文件中声明具有外部链接的对象或函数" id="137" impl="MISRA-023" originalId="MISRA-023" quickfix="false" scope="line" severity="4">
            <file path="MISRA\MISRA-023.rule"/>
         </rule>
         <rule header="应该尽可能避免使用指向指针的指针" id="169" impl="CODSTA-05" originalId="CODSTA-05" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-05.rule"/>
         </rule>
         <rule header="不要使用用户自定义的转换函数" id="177" impl="CODSTA-CPP-05" originalId="CODSTA-CPP-05" quickfix="false" scope="line" severity="4">
            <file path="CODSTA-CPP\CODSTA-CPP-05.rule"/>
         </rule>
         <rule header="允许转换的构造函数应该是使用 explicit 修饰" id="177_b" impl="CODSTA-CPP-04" originalId="CODSTA-CPP-04" quickfix="false" scope="line" severity="4">
            <file path="CODSTA-CPP\CODSTA-CPP-04.rule"/>
         </rule>
         <rule header="避免使用显式类型转换(强制类型转换)" id="183" impl="CODSTA-31" originalId="CODSTA-31" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-31.rule"/>
         </rule>
         <rule header="避免在指针上使用 static_cast" id="183_a" impl="CODSTA-CPP-34" originalId="CODSTA-CPP-34" quickfix="false" scope="line" severity="4">
            <file path="CODSTA-CPP\CODSTA-CPP-34.rule"/>
         </rule>
         <rule header="避免使用强制类型转换符 reinterpret_cast" id="183_b" impl="CODSTA-CPP-09" originalId="CODSTA-CPP-09" quickfix="false" scope="line" severity="4">
            <file path="CODSTA-CPP\CODSTA-CPP-09.rule"/>
         </rule>
         <rule header="不应该使用指针算法" id="215" impl="MISRA-101" originalId="MISRA-101" quickfix="false" scope="line" severity="4">
            <file path="MISRA\MISRA-101.rule"/>
         </rule>
         <rule header="使用 op= 而非单独的操作符" id="125_b" impl="OPT-19" originalId="OPT-19" quickfix="false" scope="line" severity="5">
            <file path="OPT\OPT-19.rule"/>
         </rule>
      </category>
      <category description="MISRA C++ 2008" name="MISRA2008">
         <rule header="每个被定义的函数应该至少被调用一次" id="0_1_10" impl="OPT-30" originalId="OPT-30" quickfix="false" scope="line" severity="2">
            <file path="OPT\OPT-30.rule"/>
         </rule>
         <rule header="在非虚函数中不得存在没有被使用的参数（命名的和未命名的）" id="0_1_11" impl="OPT-31" originalId="OPT-31" quickfix="false" scope="line" severity="2">
            <file path="OPT\OPT-31.rule"/>
         </rule>
         <rule header="项目不得在 else 模块中包含不能到执行到的代码" id="0_1_1_a" impl="MISRA2004-14_1_a" originalId="MISRA2004-14_1_a" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-14_1_a.rule"/>
         </rule>
         <rule header="项目不得在 return， break， continue 和 goto 语句之后包含不能执行到的代码" id="0_1_1_b" impl="MISRA2004-14_1_b" originalId="MISRA2004-14_1_b" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-14_1_b.rule"/>
         </rule>
         <rule header="项目不得在 if/else/while/for 模块中包含不能执行到的代码" id="0_1_1_c" impl="MISRA2004-14_1_c" originalId="MISRA2004-14_1_c" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-14_1_c.rule"/>
         </rule>
         <rule header="项目不得在 switch 语句中包含不能执行到的代码" id="0_1_1_d" impl="MISRA2004-14_1_d" originalId="MISRA2004-14_1_d" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-14_1_d.rule"/>
         </rule>
         <rule header="项目不得在 for 循环中包含不能执行到的代码" id="0_1_1_e" impl="MISRA2004-14_1_e" originalId="MISRA2004-14_1_e" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-14_1_e.rule"/>
         </rule>
         <rule header="项目不得在 for/while/catch 模块外部的 if 或 switch 之后包含不能执行到的代码" id="0_1_1_f" impl="MISRA2004-14_1_f" originalId="MISRA2004-14_1_f" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-14_1_f.rule"/>
         </rule>
         <rule header="项目不得在 while/for/catch 模块内部的 if 或 switch 之后包含不能执行到的代码" id="0_1_1_g" impl="MISRA2004-14_1_g" originalId="MISRA2004-14_1_g" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-14_1_g.rule"/>
         </rule>
         <rule header="项目中不得包含不可执行到的路径" id="0_1_2_a" impl="MISRA2004-13_7_a" originalId="MISRA2004-13_7_a" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-13_7_a.rule"/>
         </rule>
         <rule header="项目中不得包含不可执行到的路径" id="0_1_2_b" impl="MISRA2004-13_7_aa" originalId="MISRA2004-13_7_aa" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-13_7_aa.rule"/>
         </rule>
         <rule header="项目中不得包含不可执行到的路径" id="0_1_2_c" impl="MISRA2004-13_7_ab" originalId="MISRA2004-13_7_ab" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-13_7_ab.rule"/>
         </rule>
         <rule header="项目中不得包含不可执行到的路径" id="0_1_2_d" impl="MISRA2004-13_7_ac" originalId="MISRA2004-13_7_ac" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-13_7_ac.rule"/>
         </rule>
         <rule header="项目中不得包含不可执行到的路径" id="0_1_2_e" impl="MISRA2004-13_7_ad" originalId="MISRA2004-13_7_ad" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-13_7_ad.rule"/>
         </rule>
         <rule header="项目中不得包含不可执行到的路径" id="0_1_2_f" impl="MISRA2004-13_7_ae" originalId="MISRA2004-13_7_ae" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-13_7_ae.rule"/>
         </rule>
         <rule header="项目中不得包含不可执行到的路径" id="0_1_2_g" impl="MISRA2004-13_7_af" originalId="MISRA2004-13_7_af" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-13_7_af.rule"/>
         </rule>
         <rule header="项目中不得包含不可执行到的路径" id="0_1_2_h" impl="MISRA2004-13_7_ag" originalId="MISRA2004-13_7_ag" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-13_7_ag.rule"/>
         </rule>
         <rule header="项目中不得包含不可执行到的路径" id="0_1_2_i" impl="MISRA2004-13_7_ah" originalId="MISRA2004-13_7_ah" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-13_7_ah.rule"/>
         </rule>
         <rule header="项目中不得包含不可执行到的路径" id="0_1_2_j" impl="MISRA2004-13_7_ai" originalId="MISRA2004-13_7_ai" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-13_7_ai.rule"/>
         </rule>
         <rule header="项目中不得包含不可执行到的路径" id="0_1_2_k" impl="MISRA2004-13_7_aj" originalId="MISRA2004-13_7_aj" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-13_7_aj.rule"/>
         </rule>
         <rule header="项目中不得包含不可执行到的路径" id="0_1_2_l" impl="MISRA2004-13_7_ak" originalId="MISRA2004-13_7_ak" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-13_7_ak.rule"/>
         </rule>
         <rule header="项目中不得包含不可执行到的路径" id="0_1_2_m" impl="MISRA2004-13_7_b" originalId="MISRA2004-13_7_b" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-13_7_b.rule"/>
         </rule>
         <rule header="项目中不得包含不可执行到的路径" id="0_1_2_n" impl="MISRA2004-13_7_c" originalId="MISRA2004-13_7_c" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-13_7_c.rule"/>
         </rule>
         <rule header="项目中不得包含不可执行到的路径" id="0_1_2_o" impl="MISRA2004-13_7_d" originalId="MISRA2004-13_7_d" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-13_7_d.rule"/>
         </rule>
         <rule header="项目中不得包含不可执行到的路径" id="0_1_2_p" impl="MISRA2004-13_7_j" originalId="MISRA2004-13_7_j" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-13_7_j.rule"/>
         </rule>
         <rule header="项目中不得包含不可执行到的路径" id="0_1_2_q" impl="MISRA2004-13_7_k" originalId="MISRA2004-13_7_k" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-13_7_k.rule"/>
         </rule>
         <rule header="项目中不得包含不可执行到的路径" id="0_1_2_r" impl="MISRA2004-13_7_l" originalId="MISRA2004-13_7_l" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-13_7_l.rule"/>
         </rule>
         <rule header="项目中不得包含不可执行到的路径" id="0_1_2_rz" impl="MISRA2004-13_7_z" originalId="MISRA2004-13_7_z" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-13_7_z.rule"/>
         </rule>
         <rule header="项目中不得包含不可执行到的路径" id="0_1_2_s" impl="MISRA2004-13_7_m" originalId="MISRA2004-13_7_m" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-13_7_m.rule"/>
         </rule>
         <rule header="项目中不得包含不可执行到的路径" id="0_1_2_sz" impl="MISRA2004-13_7_v" originalId="MISRA2004-13_7_v" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-13_7_v.rule"/>
         </rule>
         <rule header="项目中不得包含不可执行到的路径" id="0_1_2_t" impl="MISRA2004-13_7_n" originalId="MISRA2004-13_7_n" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-13_7_n.rule"/>
         </rule>
         <rule header="项目中不得包含不可执行到的路径" id="0_1_2_u" impl="MISRA2004-13_7_s" originalId="MISRA2004-13_7_s" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-13_7_s.rule"/>
         </rule>
         <rule header="项目中不得包含不可执行到的路径" id="0_1_2_v" impl="MISRA2004-13_7_t" originalId="MISRA2004-13_7_t" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-13_7_t.rule"/>
         </rule>
         <rule header="项目中不得包含不可执行到的路径" id="0_1_2_w" impl="MISRA2004-13_7_u" originalId="MISRA2004-13_7_u" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-13_7_u.rule"/>
         </rule>
         <rule header="项目中不得包含不可执行到的路径" id="0_1_2_x" impl="MISRA2004-13_7_w" originalId="MISRA2004-13_7_w" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-13_7_w.rule"/>
         </rule>
         <rule header="项目中不得包含不可执行到的路径" id="0_1_2_y" impl="MISRA2004-13_7_x" originalId="MISRA2004-13_7_x" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-13_7_x.rule"/>
         </rule>
         <rule header="项目中不得包含不可执行到的路径" id="0_1_2_z" impl="MISRA2004-13_7_y" originalId="MISRA2004-13_7_y" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-13_7_y.rule"/>
         </rule>
         <rule header="项目中不得包含未使用的变量" id="0_1_3_a" impl="OPT-02" originalId="OPT-02" quickfix="false" scope="line" severity="2">
            <file path="OPT\OPT-02.rule"/>
         </rule>
         <rule header="项目中不得包含未使用的变量" id="0_1_3_b" impl="OPT-06" originalId="OPT-06" quickfix="false" scope="line" severity="2">
            <file path="OPT\OPT-06.rule"/>
         </rule>
         <rule header="消除未使用的私有成员变量" id="0_1_3_c" impl="OPT-05" originalId="OPT-05" quickfix="false" scope="line" severity="2">
            <file path="OPT\OPT-05.rule"/>
         </rule>
         <rule header="项目不应包含有内部链接的未使用变量" id="0_1_3_e" impl="OPT-43" originalId="OPT-43" quickfix="false" scope="line" severity="2">
            <file path="OPT\OPT-43.rule"/>
         </rule>
         <rule header="从不是重载运算符函数得到的非 void 类型的返回值应该始终被使用" id="0_1_7" impl="CODSTA-CPP-58" originalId="CODSTA-CPP-58" quickfix="false" scope="line" severity="2">
            <file path="CODSTA-CPP\CODSTA-CPP-58.rule"/>
         </rule>
         <rule header="所有 void 返回类型的函数应该有外部的作用" id="0_1_8" impl="OPT-32" originalId="OPT-32" quickfix="false" scope="line" severity="2">
            <file path="OPT\OPT-32.rule"/>
         </rule>
         <rule header="所有具有 void 返回类型的函数应该具有外部副作用" id="0_1_8_b" impl="OPT-32_b" originalId="OPT-32_b" quickfix="false" scope="line" severity="2">
            <file path="OPT\OPT-32_b.rule"/>
         </rule>
         <rule header="所有非空语句至少有一个附带作用，要么无论如何被执行到要么导致控制流发生变化" id="0_1_9" impl="MISRA2004-14_2" originalId="MISRA2004-14_2" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-14_2.rule"/>
         </rule>
         <rule header="对象不能被指定给一个重叠的对象" id="0_2_1_a" impl="MISRA2004-18_2_b" originalId="MISRA2004-18_2_b" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-18_2_b.rule"/>
         </rule>
         <rule header="对象不能被指定给一个重叠的对象" id="0_2_1_b" impl="PB-42" originalId="PB-42" quickfix="false" scope="line" severity="2">
            <file path="PB\PB-42.rule"/>
         </rule>
         <rule header="如果一个函数生成错误信息，那么这个错误信息应该被测试" id="0_3_2" impl="MISRA2004-16_10" originalId="MISRA2004-16_10" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-16_10.rule"/>
         </rule>
         <rule header="能够访问的基础类在同一个层级中不得既是虚类又是非虚类" id="10_1_3" impl="OOP-41" originalId="OOP-41" quickfix="false" scope="line" severity="2">
            <file path="OOP\OOP-41.rule"/>
         </rule>
         <rule header="在通过继承层级的各条路径上每个虚函数不得有多于一个的定义" id="10_3_1" impl="OOP-44" originalId="OOP-44" quickfix="false" scope="line" severity="2">
            <file path="OOP\OOP-44.rule"/>
         </rule>
         <rule header="每个覆盖的虚函数应该被声明有虚拟关键字" id="10_3_2" impl="OOP-21" originalId="OOP-21" quickfix="false" scope="line" severity="2">
            <file path="OOP\OOP-21.rule"/>
         </rule>
         <rule header="如果一个虚函数本身被声明为纯虚函数，那它只能被纯虚函数所覆盖" id="10_3_3" impl="OOP-43" originalId="OOP-43" quickfix="false" scope="line" severity="2">
            <file path="OOP\OOP-43.rule"/>
         </rule>
         <rule header="非 POD 类的成员数据应该是私有的" id="11_0_1" impl="OOP-48" originalId="OOP-48" quickfix="false" scope="line" severity="2">
            <file path="OOP\OOP-48.rule"/>
         </rule>
         <rule header="能够通过单一基本类型实参调用的所有构造函数应该显式地被声明" id="12_1_3" impl="OOP-45" originalId="OOP-45" quickfix="false" scope="line" severity="2">
            <file path="OOP\OOP-45.rule"/>
         </rule>
         <rule header="拷贝构造函数应该只初始化它的基类和自身是类成员的非静态成员" id="12_8_1" impl="OOP-46" originalId="OOP-46" quickfix="false" scope="line" severity="2">
            <file path="OOP\OOP-46.rule"/>
         </rule>
         <rule header="在抽象类中拷贝赋值运算符应该被声明为受保护的或私有的" id="12_8_2" impl="OOP-42" originalId="OOP-42" quickfix="false" scope="line" severity="2">
            <file path="OOP\OOP-42.rule"/>
         </rule>
         <rule header="在相关命名空间中不得声明非成员通用函数" id="14_5_1" impl="TEMPL-13" originalId="TEMPL-13" quickfix="false" scope="line" severity="2">
            <file path="TEMPL\TEMPL-13.rule"/>
         </rule>
         <rule header="当存在一个包含单个泛型参数的模板构造函数时，拷贝构造函数应该被声明" id="14_5_2" impl="TEMPL-07" originalId="TEMPL-07" quickfix="false" scope="line" severity="2">
            <file path="TEMPL\TEMPL-07.rule"/>
         </rule>
         <rule header="当存在一个包含泛型参数的模板赋值运算符时，拷贝赋值运算符应该被声明 " id="14_5_3" impl="TEMPL-11" originalId="TEMPL-11" quickfix="false" scope="line" severity="2">
            <file path="TEMPL\TEMPL-11.rule"/>
         </rule>
         <rule header="在含有依赖基础的类模板中，任何可能在这个依赖类中被发现的名称都应该引用使用限定标识或 -&gt;" id="14_6_1" impl="TEMPL-12" originalId="TEMPL-12" quickfix="false" scope="line" severity="2">
            <file path="TEMPL\TEMPL-12.rule"/>
         </rule>
         <rule header="函数应该解析为在编译单元前面中声明的函数" id="14_6_2" impl="TEMPL-14" originalId="TEMPL-14" quickfix="false" scope="line" severity="2">
            <file path="TEMPL\TEMPL-14.rule"/>
         </rule>
         <rule header="一个模板的所有局部和显式的特化应该在它们原始模板的同一个文件中被定义" id="14_7_3" impl="TEMPL-10" originalId="TEMPL-10" quickfix="false" scope="line" severity="2">
            <file path="TEMPL\TEMPL-10.rule"/>
         </rule>
         <rule header="重载函数模板不得显式地特化" id="14_8_1" impl="TEMPL-09" originalId="TEMPL-09" quickfix="false" scope="line" severity="2">
            <file path="TEMPL\TEMPL-09.rule"/>
         </rule>
         <rule header="不得使用 goto 或 switch 开关语句将控制传递到 try 或 catch 模块中" id="15_0_3" impl="EXCEPT-10" originalId="EXCEPT-10" quickfix="false" scope="line" severity="2">
            <file path="EXCEPT\EXCEPT-10.rule"/>
         </rule>
         <rule header="throw 语句的赋值表达式不得自身引起一个异常抛出" id="15_1_1" impl="EXCEPT-11" originalId="EXCEPT-11" quickfix="false" scope="line" severity="2">
            <file path="EXCEPT\EXCEPT-11.rule"/>
         </rule>
         <rule header="NULL 不得被显式地抛出" id="15_1_2" impl="EXCEPT-12" originalId="EXCEPT-12" quickfix="false" scope="line" severity="2">
            <file path="EXCEPT\EXCEPT-12.rule"/>
         </rule>
         <rule header="null 的抛出 （throw;）应该只用于 catch 处理程序的复合语句中" id="15_1_3" impl="EXCEPT-07" originalId="EXCEPT-07" quickfix="false" scope="line" severity="2">
            <file path="EXCEPT\EXCEPT-07.rule"/>
         </rule>
         <rule header="应该只能在程序启动之后和终止之前引起异常" id="15_3_1" impl="EXCEPT-08" originalId="EXCEPT-08" quickfix="false" scope="line" severity="2">
            <file path="EXCEPT\EXCEPT-08.rule"/>
         </rule>
         <rule header="类的构造函数或析构函数中执行 try 功能模块的处理程序不得引用来自此类或其基础类的非静态成员" id="15_3_3" impl="EXCEPT-16" originalId="EXCEPT-16" quickfix="false" scope="line" severity="2">
            <file path="EXCEPT\EXCEPT-16.rule"/>
         </rule>
         <rule header="代码中显式地抛出的每个异常应该在可能导致这一点的所有调用路径上存在兼容类型的处理程序" id="15_3_4_a" impl="EXCEPT-13" originalId="EXCEPT-13" quickfix="false" scope="line" severity="2">
            <file path="EXCEPT\EXCEPT-13.rule"/>
         </rule>
         <rule header="代码中显式地抛出的每个异常应该在可能导致这一点的所有调用路径上存在兼容类型的处理程序" id="15_3_4_b" impl="EXCEPT-18" originalId="EXCEPT-18" quickfix="false" scope="line" severity="2">
            <file path="EXCEPT\EXCEPT-18.rule"/>
         </rule>
         <rule header="类类型的异常应该始终被引用捕获" id="15_3_5" impl="EXCEPT-15" originalId="EXCEPT-15" quickfix="false" scope="line" severity="2">
            <file path="EXCEPT\EXCEPT-15.rule"/>
         </rule>
         <rule header="如果在单独的 try-catch 语句或 try 功能模块中提供多个处理程序给派生类和部分或全部的基类时，这些处理程序应该遵循从最底层的派生类到基类的顺序。" id="15_3_6" impl="EXCEPT-17" originalId="EXCEPT-17" quickfix="false" scope="line" severity="2">
            <file path="EXCEPT\EXCEPT-17.rule"/>
         </rule>
         <rule header="如果在一个 try-catch 语句或 function-try-block 中提供多个处理程序，那么任何省略号（catch-all）处理程序都应最后执行" id="15_3_7" impl="EXCEPT-24" originalId="EXCEPT-24" quickfix="false" scope="line" severity="2">
            <file path="EXCEPT\EXCEPT-24.rule"/>
         </rule>
         <rule header="类的析构函数不得带有异常退出" id="15_5_1" impl="EXCEPT-03" originalId="EXCEPT-03" quickfix="false" scope="line" severity="2">
            <file path="EXCEPT\EXCEPT-03.rule"/>
         </rule>
         <rule header="如果一个函数的声明包括一个异常规范，这个函数应该只能抛出所指明类型的异常。" id="15_5_2" impl="EXCEPT-14" originalId="EXCEPT-14" quickfix="false" scope="line" severity="2">
            <file path="EXCEPT\EXCEPT-14.rule"/>
         </rule>
         <rule header="注册为 'std::atexit()' 或 'std::at_quick_exit()' 的函数的执行不应该通过异常退出" id="15_5_3" impl="PB-44" originalId="PB-44" quickfix="false" scope="line" severity="2">
            <file path="PB\PB-44.rule"/>
         </rule>
         <rule header="绝不允许从析构函数， 释放和交换抛出异常" id="15_5_3_b" impl="EXCEPT-01" originalId="EXCEPT-01" quickfix="false" scope="line" severity="2">
            <file path="EXCEPT\EXCEPT-01.rule"/>
         </rule>
         <rule header="不要从析构函数中抛出" id="15_5_3_c" impl="EXCEPT-03" originalId="EXCEPT-03" quickfix="false" scope="line" severity="2">
            <file path="EXCEPT\EXCEPT-03.rule"/>
         </rule>
         <rule header="至少应该有一个异常处理程序来捕获所有其他未处理的异常" id="15_5_3_d" impl="EXCEPT-06" originalId="EXCEPT-06" quickfix="false" scope="line" severity="2">
            <file path="EXCEPT\EXCEPT-06.rule"/>
         </rule>
         <rule header="空抛出 (throw;) 只能用于 catch 处理程序的复合语句中" id="15_5_3_e" impl="EXCEPT-07" originalId="EXCEPT-07" quickfix="false" scope="line" severity="2">
            <file path="EXCEPT\EXCEPT-07.rule"/>
         </rule>
         <rule header="只有在程序启动后和终止前才应该抛出异常" id="15_5_3_f" impl="EXCEPT-08" originalId="EXCEPT-08" quickfix="false" scope="line" severity="2">
            <file path="EXCEPT\EXCEPT-08.rule"/>
         </rule>
         <rule header="每个在代码中显式地抛出的异常都应该在所有可能导致这一点的调用路径中有一个兼容类型的处理程序" id="15_5_3_g" impl="EXCEPT-13" originalId="EXCEPT-13" quickfix="false" scope="line" severity="2">
            <file path="EXCEPT\EXCEPT-13.rule"/>
         </rule>
         <rule header="如果函数的声明包含异常规范，则该函数只能抛出指定类型的异常" id="15_5_3_h" impl="EXCEPT-14" originalId="EXCEPT-14" quickfix="false" scope="line" severity="2">
            <file path="EXCEPT\EXCEPT-14.rule"/>
         </rule>
         <rule header="在全局或命名空间作用域中调用的函数不能抛出未处理的异常" id="15_5_3_i" impl="EXCEPT-18" originalId="EXCEPT-18" quickfix="false" scope="line" severity="2">
            <file path="EXCEPT\EXCEPT-18.rule"/>
         </rule>
         <rule header="文件中的 #include 指示符应该只能在其他预处理指令或注释之前" id="16_0_1" impl="MISRA2004-19_1" originalId="MISRA2004-19_1" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-19_1.rule"/>
         </rule>
         <rule header="应该只能在全局的命名空间中使用 #define 或 #undef 宏" id="16_0_2" impl="MISRA2004-19_5" originalId="MISRA2004-19_5" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-19_5.rule"/>
         </rule>
         <rule header="不得使用 #undef" id="16_0_3" impl="PREPROC-25" originalId="PREPROC-25" quickfix="false" scope="line" severity="2">
            <file path="PREPROC\PREPROC-25.rule"/>
         </rule>
         <rule header="不得定义类函数宏" id="16_0_4" impl="MISRA2004-19_7" originalId="MISRA2004-19_7" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-19_7.rule"/>
         </rule>
         <rule header="传递给类函数宏的实参不得包括看起来像预处理指令的符号" id="16_0_5" impl="MISRA2004-19_9" originalId="MISRA2004-19_9" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-19_9.rule"/>
         </rule>
         <rule header="在类函数宏的定义中，每个参数的实例应该置于括号内，除非它是作为 # 或 ## 的操作数" id="16_0_6" impl="MISRA2004-19_10" originalId="MISRA2004-19_10" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-19_10.rule"/>
         </rule>
         <rule header="不要使用在编译单元中未定义的预编译器指令 #if 和 #elif  宏" id="16_0_7_b" impl="MISRA2004-19_11_b" originalId="MISRA2004-19_11_b" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-19_11_b.rule"/>
         </rule>
         <rule header="如果符号 # 作为一行的第一个符号出现，那么预处理符号应该紧接着" id="16_0_8" impl="MISRA2004-19_16" originalId="MISRA2004-19_16" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-19_16.rule"/>
         </rule>
         <rule header="defined 预处理运算符应该只能用于两个标准形式之一" id="16_1_1" impl="MISRA2004-19_14" originalId="MISRA2004-19_14" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-19_14.rule"/>
         </rule>
         <rule header="所有的 #else， #elif 和 #endif 预处理指令应该存在于和 #if 或 #ifdef 指示符相关的相同文件中" id="16_1_2" impl="MISRA2004-19_17" originalId="MISRA2004-19_17" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-19_17.rule"/>
         </rule>
         <rule header="避免使用宏定义" id="16_2_1_a" impl="PREPROC-01" originalId="PREPROC-01" quickfix="false" scope="line" severity="2">
            <file path="PREPROC\PREPROC-01.rule"/>
         </rule>
         <rule header="#ifndef 程序预处理指示字仅用于防止相同头文件的多个 inclusion" id="16_2_1_b" impl="PREPROC-10" originalId="PREPROC-10" quickfix="false" scope="line" severity="2">
            <file path="PREPROC\PREPROC-10.rule"/>
         </rule>
         <rule header="不应使用 #ifdef, #else, #elif 程序预处理指示字" id="16_2_1_c" impl="PREPROC-11" originalId="PREPROC-11" quickfix="false" scope="line" severity="2">
            <file path="PREPROC\PREPROC-11.rule"/>
         </rule>
         <rule header="#endif 程序预处理指示字将仅用于防止同一头文件多个包含" id="16_2_1_d" impl="PREPROC-10_b" originalId="PREPROC-10_b" quickfix="false" scope="line" severity="2">
            <file path="PREPROC\PREPROC-10_b.rule"/>
         </rule>
         <rule header="#if 程序预处理指示字仅用于防止相同头文件的多个 inclusion" id="16_2_1_e" impl="PREPROC-10_c" originalId="PREPROC-10_c" quickfix="false" scope="line" severity="2">
            <file path="PREPROC\PREPROC-10_c.rule"/>
         </rule>
         <rule header="不应使用 #error 指令" id="16_2_1_f" impl="PREPROC-22" originalId="PREPROC-22" quickfix="false" scope="line" severity="2">
            <file path="PREPROC\PREPROC-22.rule"/>
         </rule>
         <rule header="不应使用 #pragma 指令" id="16_2_1_g" impl="PREPROC-23" originalId="PREPROC-23" quickfix="false" scope="line" severity="2">
            <file path="PREPROC\PREPROC-23.rule"/>
         </rule>
         <rule header="不应使用 #undef" id="16_2_1_h" impl="PREPROC-25" originalId="PREPROC-25" quickfix="false" scope="line" severity="2">
            <file path="PREPROC\PREPROC-25.rule"/>
         </rule>
         <rule header="C++ 宏应该只能用于: 包含保护，类型修饰符，或存储类限定符" id="16_2_2" impl="PREPROC-12" originalId="PREPROC-12" quickfix="false" scope="line" severity="2">
            <file path="PREPROC\PREPROC-12.rule"/>
         </rule>
         <rule header="应该提供包含保护" id="16_2_3" impl="PFO-02" originalId="PFO-02" quickfix="false" scope="line" severity="2">
            <file path="PFO\PFO-02.rule"/>
         </rule>
         <rule header="字符 '， &quot;， /* 或 // 不得出现在头文件的名称中" id="16_2_4" impl="NAMING-46" originalId="NAMING-46" quickfix="false" scope="line" severity="2">
            <file path="NAMING\NAMING-46.rule"/>
         </rule>
         <rule header="包含 #include 指令应该遵循要么是 &lt;filename&gt; 要么是 &quot;filename&quot; 序列" id="16_2_6" impl="MISRA-089" originalId="MISRA-089" quickfix="false" scope="line" severity="2">
            <file path="MISRA\MISRA-089.rule"/>
         </rule>
         <rule header="在单个的宏定义中应该最多出现一个 # 或 ## 操作符" id="16_3_1" impl="MISRA2004-19_12" originalId="MISRA2004-19_12" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-19_12.rule"/>
         </rule>
         <rule header="不得定义，重定义或取消定义标准库中的保留标识符，宏和函数" id="17_0_1_a" impl="MISRA2004-20_1_a" originalId="MISRA2004-20_1_a" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-20_1_a.rule"/>
         </rule>
         <rule header="不得定义，重定义或取消定义标准库中的保留标识符，宏和函数" id="17_0_1_b" impl="MISRA2004-20_1_b" originalId="MISRA2004-20_1_b" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-20_1_b.rule"/>
         </rule>
         <rule header="不得定义，重定义或取消定义标准库中的保留标识符，宏和函数" id="17_0_1_c" impl="CODSTA-92_a" originalId="CODSTA-92_a" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-92_a.rule"/>
         </rule>
         <rule header="不得定义，重定义或取消定义标准库中的保留标识符，宏和函数" id="17_0_1_d" impl="CODSTA-92_b" originalId="CODSTA-92_b" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-92_b.rule"/>
         </rule>
         <rule header="不得定义，重定义或取消定义标准库中的保留标识符，宏和函数" id="17_0_1_e" impl="MISRA2004-20_1_e" originalId="MISRA2004-20_1_e" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-20_1_e.rule"/>
         </rule>
         <rule header="不得重复使用标准库宏和对象的名称" id="17_0_2" impl="CODSTA-92" originalId="CODSTA-92" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-92.rule"/>
         </rule>
         <rule header="不得覆盖标准库宏和对象的名称" id="17_0_3" impl="CODSTA-93" originalId="CODSTA-93" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-93.rule"/>
         </rule>
         <rule header="不得使用 setjmp 宏和 longjmp 函数" id="17_0_5" impl="MISRA2004-20_7" originalId="MISRA2004-20_7" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-20_7.rule"/>
         </rule>
         <rule header="不得使用标准数据头文件 &lt;setjmp.h&gt;" id="17_0_5_b" impl="MISRA2004-20_7_b" originalId="MISRA2004-20_7_b" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-20_7_b.rule"/>
         </rule>
         <rule header="不得使用 C 语言库" id="18_0_1" impl="CODSTA-CPP-59" originalId="CODSTA-CPP-59" quickfix="false" scope="line" severity="2">
            <file path="CODSTA-CPP\CODSTA-CPP-59.rule"/>
         </rule>
         <rule header="不得使用来自于 &lt;cstdlib&gt; 库的 atof， atoi 和 atol 库函数" id="18_0_2" impl="MISRA2004-20_10" originalId="MISRA2004-20_10" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-20_10.rule"/>
         </rule>
         <rule header="不得使用 &lt;stdlib.h&gt; 的 'abort' 库函数" id="18_0_3" impl="PB-75" originalId="PB-75" quickfix="false" scope="line" severity="2">
            <file path="PB\PB-75.rule"/>
         </rule>
         <rule header="不得使用 &lt;stdlib.h&gt; 的 'exit' 库函数" id="18_0_3_b" impl="PB-75_b" originalId="PB-75_b" quickfix="false" scope="line" severity="2">
            <file path="PB\PB-75_b.rule"/>
         </rule>
         <rule header="不得使用 &lt;stdlib.h&gt; 的 'getenv' 库函数" id="18_0_3_c" impl="SECURITY-52" originalId="SECURITY-52" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-52.rule"/>
         </rule>
         <rule header="不得使用 &lt;stdlib.h&gt; 的 'system' 库函数" id="18_0_3_d" impl="SECURITY-48_b" originalId="SECURITY-48_b" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-48_b.rule"/>
         </rule>
         <rule header="不应使用标准头文件&lt;ctime&gt;" id="18_0_4" impl="MISRA2004-20_12" originalId="MISRA2004-20_12" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-20_12.rule"/>
         </rule>
         <rule header="不应使用库&lt;ctime&gt; 中的时间处理函数和宏" id="18_0_4_b" impl="MISRA2004-20_12_b" originalId="MISRA2004-20_12_b" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-20_12_b.rule"/>
         </rule>
         <rule header="不应使用库中定义的类型&lt;ctime&gt;" id="18_0_4_c" impl="MISRA2004-20_12_c" originalId="MISRA2004-20_12_c" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-20_12_c.rule"/>
         </rule>
         <rule header="不得使用 &lt;cstring&gt; 库的无限制函数" id="18_0_5" impl="PB-37" originalId="PB-37" quickfix="false" scope="line" severity="2">
            <file path="PB\PB-37.rule"/>
         </rule>
         <rule header="不得使用 offsetof 宏" id="18_2_1" impl="MISRA2004-20_6" originalId="MISRA2004-20_6" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-20_6.rule"/>
         </rule>
         <rule header="不得使用动态堆内存分配" id="18_4_1" impl="MISRA2004-20_4" originalId="MISRA2004-20_4" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-20_4.rule"/>
         </rule>
         <rule header="不得使用 &lt;csignal&gt; 库的信号处理功能" id="18_7_1" impl="MISRA2004-20_8" originalId="MISRA2004-20_8" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-20_8.rule"/>
         </rule>
         <rule header="不得使用信号处理条件文件 &lt;csignal&gt; 中的处理函数" id="18_7_1_b" impl="MISRA2004-20_8_b" originalId="MISRA2004-20_8_b" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-20_8_b.rule"/>
         </rule>
         <rule header="不得使用 errno 错误标识" id="19_3_1" impl="MISRA2004-20_5" originalId="MISRA2004-20_5" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-20_5.rule"/>
         </rule>
         <rule header="不得使用 &lt;cstdio&gt; 库的输入/输出流" id="27_0_1" impl="MISRA2004-20_9" originalId="MISRA2004-20_9" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-20_9.rule"/>
         </rule>
         <rule header="不同的标识符应该是外观上可以清晰区别的" id="2_10_1" impl="NAMING-47" originalId="NAMING-47" quickfix="false" scope="line" severity="2">
            <file path="NAMING\NAMING-47.rule"/>
         </rule>
         <rule header="声明在内部范围的标识符不得掩盖声明在外部范围的标识符" id="2_10_2_a" impl="MISRA2004-5_2_a" originalId="MISRA2004-5_2_a" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-5_2_a.rule"/>
         </rule>
         <rule header="声明在内部范围的标识符不得掩盖声明在外部范围的标识符" id="2_10_2_b" impl="MISRA2004-5_2_b" originalId="MISRA2004-5_2_b" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-5_2_b.rule"/>
         </rule>
         <rule header="如果一个标识符指向一个类型，它不得再指向在同一个范围内的一个对象或函数" id="2_10_6_a" impl="CODSTA-CPP-87_a" originalId="CODSTA-CPP-87_a" quickfix="false" scope="line" severity="2">
            <file path="CODSTA-CPP\CODSTA-CPP-87_a.rule"/>
         </rule>
         <rule header="如果一个标识符指向一个类型，它不得再指向在同一个范围内的一个对象或函数" id="2_10_6_b" impl="CODSTA-CPP-87_b" originalId="CODSTA-CPP-87_b" quickfix="false" scope="line" severity="2">
            <file path="CODSTA-CPP\CODSTA-CPP-87_b.rule"/>
         </rule>
         <rule header="如果一个标识符指向一个类型，它不得再指向在同一个范围内的一个对象或函数" id="2_10_6_c" impl="CODSTA-CPP-87_c" originalId="CODSTA-CPP-87_c" quickfix="false" scope="line" severity="2">
            <file path="CODSTA-CPP\CODSTA-CPP-87_c.rule"/>
         </rule>
         <rule header="只得使用那些定义在 ISO/IEC 14882:2003 中的转义序列" id="2_13_1" impl="CODSTA-CPP-60" originalId="CODSTA-CPP-60" quickfix="false" scope="line" severity="2">
            <file path="CODSTA-CPP\CODSTA-CPP-60.rule"/>
         </rule>
         <rule header="不得使用八进制字面量（除了零）" id="2_13_2_a" impl="MISRA2004-7_1_a" originalId="MISRA2004-7_1_a" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-7_1_a.rule"/>
         </rule>
         <rule header="不得使用八进制转义序列（除了 &quot;\0&quot;）" id="2_13_2_b" impl="MISRA2004-7_1_b" originalId="MISRA2004-7_1_b" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-7_1_b.rule"/>
         </rule>
         <rule header="后缀 &quot;U&quot; 应该适用于所有无符号类型的八进制或十六进制整型字面量" id="2_13_3" impl="CODSTA-68" originalId="CODSTA-68" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-68.rule"/>
         </rule>
         <rule header="字面量后缀应该是大写" id="2_13_4" impl="CODSTA-51" originalId="CODSTA-51" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-51.rule"/>
         </rule>
         <rule header="不得级联狭义的和广义的字符串字面量" id="2_13_5" impl="PB-38" originalId="PB-38" quickfix="false" scope="line" severity="2">
            <file path="PB\PB-38.rule"/>
         </rule>
         <rule header="不得使用三元字符" id="2_3_1" impl="MISRA2004-4_2" originalId="MISRA2004-4_2" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-4_2.rule"/>
         </rule>
         <rule header="字符序列 /* 不得被用于 C 语言风格的注释中" id="2_7_1" impl="MISRA2004-2_3" originalId="MISRA2004-2_3" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-2_3.rule"/>
         </rule>
         <rule header="代码部分不得使用 C 语言风格的注释 &quot;添加注释 &quot;" id="2_7_2" impl="MISRA2004-2_4" originalId="MISRA2004-2_4" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-2_4.rule"/>
         </rule>
         <rule header="应该尽可能包含在多个不违反单定义规则的编译单元的任何头文件" id="3_1_1" impl="PFO-01" originalId="PFO-01" quickfix="false" scope="line" severity="2">
            <file path="PFO\PFO-01.rule"/>
         </rule>
         <rule header="函数不得声明在语句块范围内" id="3_1_2" impl="MISRA2004-8_6" originalId="MISRA2004-8_6" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-8_6.rule"/>
         </rule>
         <rule header="当一个数组被声明的时候，其大小应该被显式地指定或通过初始化隐式地定义" id="3_1_3" impl="MISRA2004-8_12" originalId="MISRA2004-8_12" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-8_12.rule"/>
         </rule>
         <rule header="具有外部链接的对象或函数应该被定义在头文件中" id="3_3_1" impl="MISRA-023" originalId="MISRA-023" quickfix="false" scope="line" severity="2">
            <file path="MISRA\MISRA-023.rule"/>
         </rule>
         <rule header="如果一个函数有内部链接，那么所有的再声明应该包括静态存储类限定符" id="3_3_2" impl="CODSTA-81" originalId="CODSTA-81" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-81.rule"/>
         </rule>
         <rule header="声明为一个对象或类型的标识符应该定义在一个模块中，以最小化其可见性" id="3_4_1_a" impl="OPT-01" originalId="OPT-01" quickfix="false" scope="line" severity="2">
            <file path="OPT\OPT-01.rule"/>
         </rule>
         <rule header="声明为一个对象或类型的标识符应该定义在一个模块中，以最小化其可见性" id="3_4_1_b" impl="MISRA2004-8_7" originalId="MISRA2004-8_7" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-8_7.rule"/>
         </rule>
         <rule header="作为对象，函数返回类型，或函数参数使用的类型在所有定义和再定义中字符应该相同" id="3_9_1" impl="CODSTA-67" originalId="CODSTA-67" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-67.rule"/>
         </rule>
         <rule header="不得使用表示浮点型的原始位" id="3_9_3" impl="MISRA2004-12_12" originalId="MISRA2004-12_12" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-12_12.rule"/>
         </rule>
         <rule header="NULL 不得用作一个整型值" id="4_10_1" impl="CODSTA-CPP-62" originalId="CODSTA-CPP-62" quickfix="false" scope="line" severity="2">
            <file path="CODSTA-CPP\CODSTA-CPP-62.rule"/>
         </rule>
         <rule header="字面量零 （0）不得用作空指针常量" id="4_10_2" impl="CODSTA-CPP-63" originalId="CODSTA-CPP-63" quickfix="false" scope="line" severity="2">
            <file path="CODSTA-CPP\CODSTA-CPP-63.rule"/>
         </rule>
         <rule header="布尔类型的表达式不得用作除了赋值运算符 = ，逻辑运算符 &amp;&amp;， ||， ! ，等号运算符 == 和 != ，一元 &amp; 运算符和条件运算符以外的内置运算符的操作数" id="4_5_1" impl="MISRA2004-12_6_b" originalId="MISRA2004-12_6_b" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-12_6_b.rule"/>
         </rule>
         <rule header="枚举类型的表达式不得用作除了 [ ]， =，  ==， !=， &lt;， &lt;=， &gt;， &gt;=， 和一元 &amp; 运算符以外的内置运算符的操作数" id="4_5_2" impl="CODSTA-70" originalId="CODSTA-70" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-70.rule"/>
         </rule>
         <rule header="普通的 char 类型和 wchar_t 型的表达式不得用作除了赋值运算符 = ， 等号运算符 == 和 !=， 一元 &amp; 运算符以外的内置运算符的操作数" id="4_5_3" impl="CODSTA-69" originalId="CODSTA-69" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-69.rule"/>
         </rule>
         <rule header="如果按位运算符 ~ 和 &lt;&lt; 适用于无符号字符型或无符号短整型的操作数，其结果应该立即强制转换成相应的原始类型" id="5_0_10" impl="MISRA2004-10_5" originalId="MISRA2004-10_5" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-10_5.rule"/>
         </rule>
         <rule header="普通的 char 类型应该只能用于字符值的存储和使用" id="5_0_11" impl="MISRA2004-6_1" originalId="MISRA2004-6_1" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-6_1.rule"/>
         </rule>
         <rule header="signed char 和 unsigned char 类型应该只能用于数值的存储和使用" id="5_0_12" impl="MISRA2004-6_2" originalId="MISRA2004-6_2" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-6_2.rule"/>
         </rule>
         <rule header="if 语句的条件和迭代语句的条件应该是布尔类型" id="5_0_13" impl="CODSTA-CPP-64" originalId="CODSTA-CPP-64" quickfix="false" scope="line" severity="2">
            <file path="CODSTA-CPP\CODSTA-CPP-64.rule"/>
         </rule>
         <rule header="条件运算符的第一个操作数应该是布尔类型" id="5_0_14" impl="CODSTA-CPP-65" originalId="CODSTA-CPP-65" quickfix="false" scope="line" severity="2">
            <file path="CODSTA-CPP\CODSTA-CPP-65.rule"/>
         </rule>
         <rule header="数组索引应该是指针运算的唯一形式" id="5_0_15" impl="MISRA2004-17_4" originalId="MISRA2004-17_4" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-17_4.rule"/>
         </rule>
         <rule header="对象的声明应该包含不超过二级的指针间接寻址" id="5_0_19" impl="MISRA2004-17_5" originalId="MISRA2004-17_5" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-17_5.rule"/>
         </rule>
         <rule header="表达式的值在标准允许的任何计算顺序下应该相同" id="5_0_1_a" impl="MISRA2004-12_2_a" originalId="MISRA2004-12_2_a" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-12_2_a.rule"/>
         </rule>
         <rule header="表达式的值在标准允许的任何计算顺序下应该相同" id="5_0_1_b" impl="MISRA2004-12_2_b" originalId="MISRA2004-12_2_b" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-12_2_b.rule"/>
         </rule>
         <rule header="表达式的值在标准允许的任何计算顺序下应该相同" id="5_0_1_c" impl="MISRA2004-12_2_c" originalId="MISRA2004-12_2_c" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-12_2_c.rule"/>
         </rule>
         <rule header="表达式的值在标准允许的任何计算顺序下应该相同" id="5_0_1_d" impl="MISRA2004-12_2_d" originalId="MISRA2004-12_2_d" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-12_2_d.rule"/>
         </rule>
         <rule header="表达式的值在标准允许的任何计算顺序下应该相同" id="5_0_1_e" impl="MISRA2004-12_2_e" originalId="MISRA2004-12_2_e" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-12_2_e.rule"/>
         </rule>
         <rule header="表达式的值在标准允许的任何计算顺序下应该相同" id="5_0_1_f" impl="MISRA2004-12_2_f" originalId="MISRA2004-12_2_f" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-12_2_f.rule"/>
         </rule>
         <rule header="表达式的值在标准允许的任何计算顺序下应该相同" id="5_0_1_g" impl="MISRA2004-12_2_g" originalId="MISRA2004-12_2_g" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-12_2_g.rule"/>
         </rule>
         <rule header="二进制位运算符的非常量的操作数应该具有相同的原始类型" id="5_0_20" impl="CODSTA-66" originalId="CODSTA-66" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-66.rule"/>
         </rule>
         <rule header="位运算符应该只能适用于无符号原始类型的操作数" id="5_0_21" impl="CODSTA-63" originalId="CODSTA-63" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-63.rule"/>
         </rule>
         <rule header="cvalue 表达式不得隐式地转换成不同的原始类型" id="5_0_3_a" impl="MISRA2004-10_1_c" originalId="MISRA2004-10_1_c" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-10_1_c.rule"/>
         </rule>
         <rule header="cvalue 表达式不得隐式地转换成不同的原始类型" id="5_0_3_b" impl="MISRA2004-10_1_f" originalId="MISRA2004-10_1_f" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-10_1_f.rule"/>
         </rule>
         <rule header="cvalue 表达式不得隐式地转换成不同的原始类型" id="5_0_3_c" impl="MISRA2004-10_1_i" originalId="MISRA2004-10_1_i" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-10_1_i.rule"/>
         </rule>
         <rule header="整型的隐式转换不得改变原始类型的符号属性" id="5_0_4_a" impl="MISRA2004-10_1_a" originalId="MISRA2004-10_1_a" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-10_1_a.rule"/>
         </rule>
         <rule header="不得有浮点型-整型的隐式转换" id="5_0_5_a" impl="MISRA2004-10_2_a" originalId="MISRA2004-10_2_a" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-10_2_a.rule"/>
         </rule>
         <rule header="不得有浮点型-整型的隐式转换" id="5_0_5_b" impl="MISRA2004-10_1_b" originalId="MISRA2004-10_1_b" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-10_1_b.rule"/>
         </rule>
         <rule header="整型或浮点型的隐式转换不得减少原始类型的长度" id="5_0_6_a" impl="CODSTA-222" originalId="CODSTA-222" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-222.rule"/>
         </rule>
         <rule header="整型或浮点型的隐式转换不得减少原始类型的长度" id="5_0_6_b" impl="MISRA2004-10_2_b" originalId="MISRA2004-10_2_b" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-10_2_b.rule"/>
         </rule>
         <rule header="整型或浮点型的隐式转换不得减少原始类型的长度" id="5_0_6_c" impl="MISRA2004-10_2_d" originalId="MISRA2004-10_2_d" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-10_2_d.rule"/>
         </rule>
         <rule header="cvalue 表达式不得有显式地浮点型-整型转换" id="5_0_7_a" impl="MISRA2004-10_3" originalId="MISRA2004-10_3" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-10_3.rule"/>
         </rule>
         <rule header="cvalue 表达式不得有显式地浮点型-整型转换" id="5_0_7_b" impl="CODSTA-198_b" originalId="CODSTA-198_b" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-198_b.rule"/>
         </rule>
         <rule header="整型或浮点型的显式转换不得增加 cvalue 表达式的原始类型的长度" id="5_0_8" impl="MISRA2004-10_3" originalId="MISRA2004-10_3" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-10_3.rule"/>
         </rule>
         <rule header="整型或浮点型的显式转换不得增加 cvalue 表达式的基础类型的大小" id="5_0_8_b" impl="CODSTA-198" originalId="CODSTA-198" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-198.rule"/>
         </rule>
         <rule header="整型或浮点型的显式转换不得增加 cvalue 表达式的原始类型的长度" id="5_0_9" impl="MISRA2004-10_3" originalId="MISRA2004-10_3" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-10_3.rule"/>
         </rule>
         <rule header="逻辑运算符 &amp;&amp; 或 || 的右边操作数不得包含副作用" id="5_14_1" impl="MISRA2004-12_4_a" originalId="MISRA2004-12_4_a" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-12_4_a.rule"/>
         </rule>
         <rule header="重载的二元运算符应该用相应的复合赋值运算符来实现" id="5_17_1" impl="CODSTA-CPP-91" originalId="CODSTA-CPP-91" quickfix="false" scope="line" severity="2">
            <file path="CODSTA-CPP\CODSTA-CPP-91.rule"/>
         </rule>
         <rule header="不得使用逗号操作符" id="5_18_1" impl="MISRA2004-12_10" originalId="MISRA2004-12_10" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-12_10.rule"/>
         </rule>
         <rule header="逻辑运算符 &amp;&amp; 或 || 的每个操作数应该都是后缀表达式" id="5_2_1" impl="CODSTA-90" originalId="CODSTA-90" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-90.rule"/>
         </rule>
         <rule header="&amp;&amp; 运算符和 || 运算符不得被重载" id="5_2_11" impl="CODSTA-CPP-08" originalId="CODSTA-CPP-08" quickfix="false" scope="line" severity="2">
            <file path="CODSTA-CPP\CODSTA-CPP-08.rule"/>
         </rule>
         <rule header="逗号 &quot;，&quot; 运算符不得被重载" id="5_2_11_b" impl="CODSTA-CPP-80" originalId="CODSTA-CPP-80" quickfix="false" scope="line" severity="2">
            <file path="CODSTA-CPP\CODSTA-CPP-80.rule"/>
         </rule>
         <rule header="作为函数实参传递的数组类型标识符不得退化为一个指针" id="5_2_12" impl="PB-41" originalId="PB-41" quickfix="false" scope="line" severity="2">
            <file path="PB\PB-41.rule"/>
         </rule>
         <rule header="指向虚基类的指针应该只能通过 dynamic_cast 的方式强制类型转换为指向派生类的指针" id="5_2_2" impl="OOP-50" originalId="OOP-50" quickfix="false" scope="line" severity="2">
            <file path="OOP\OOP-50.rule"/>
         </rule>
         <rule header="不得使用 C 语言风格的强制类型转换（除 void 强制类型转换）和函数符号式强制类型转换（除了显式的构造函数调用）" id="5_2_4" impl="CODSTA-CPP-66" originalId="CODSTA-CPP-66" quickfix="false" scope="line" severity="2">
            <file path="CODSTA-CPP\CODSTA-CPP-66.rule"/>
         </rule>
         <rule header="强制类型转换不得从指针或引用类型中移除任何 const 或 volatile 的修饰" id="5_2_5" impl="MISRA2004-11_5" originalId="MISRA2004-11_5" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-11_5.rule"/>
         </rule>
         <rule header="强制类型转换不得转换指向函数的指针为任何其他类型的指针，包括指向函数的指针" id="5_2_6" impl="CODSTA-62" originalId="CODSTA-62" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-62.rule"/>
         </rule>
         <rule header="一个指针类型的对象不得直接或间接地被转换为无关的指针类型" id="5_2_7" impl="MISRA2004-11_4" originalId="MISRA2004-11_4" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-11_4.rule"/>
         </rule>
         <rule header="整数类型的对象或指向 void 类型的指针的对象不得被转换为指针类型的对象" id="5_2_8" impl="CODSTA-65" originalId="CODSTA-65" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-65.rule"/>
         </rule>
         <rule header="! 运算符， 逻辑 &amp;&amp; 或逻辑 || 运算符的每个操作数应该都是布尔类型" id="5_3_1" impl="CODSTA-CPP-67" originalId="CODSTA-CPP-67" quickfix="false" scope="line" severity="2">
            <file path="CODSTA-CPP\CODSTA-CPP-67.rule"/>
         </rule>
         <rule header="一元减法运算符不得适用于其原始类型是无符号型的表达式" id="5_3_2" impl="MISRA2004-12_9" originalId="MISRA2004-12_9" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-12_9.rule"/>
         </rule>
         <rule header="一元 &amp; 运算符不得被重载" id="5_3_3" impl="CODSTA-CPP-68" originalId="CODSTA-CPP-68" quickfix="false" scope="line" severity="2">
            <file path="CODSTA-CPP\CODSTA-CPP-68.rule"/>
         </rule>
         <rule header="sizeof 运算符的操作数求值不得包含副作用" id="5_3_4" impl="MISRA2004-12_3" originalId="MISRA2004-12_3" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-12_3.rule"/>
         </rule>
         <rule header="sizeof 运算符的操作数求值不得包含副作用" id="5_3_4_b" impl="MISRA2004-12_3_b" originalId="MISRA2004-12_3_b" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-12_3_b.rule"/>
         </rule>
         <rule header="sizeof 运算符的操作数求值不得包含副作用" id="5_3_4_c" impl="MISRA2004-12_3_c" originalId="MISRA2004-12_3_c" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-12_3_c.rule"/>
         </rule>
         <rule header="移位运算符的右边操作数的位宽应该介于零和一个小于左操作数的原始类型的位宽之间" id="5_8_1" impl="MISRA2004-12_8" originalId="MISRA2004-12_8" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-12_8.rule"/>
         </rule>
         <rule header="赋值运算符不得被用于子表达式" id="6_2_1" impl="MISRA2004-13_1" originalId="MISRA2004-13_1" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-13_1.rule"/>
         </rule>
         <rule header="浮点表达式不得直接或间接地作为相等或不相等的判定" id="6_2_2" impl="MISRA2004-13_3" originalId="MISRA2004-13_3" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-13_3.rule"/>
         </rule>
         <rule header="预处理之前，空语句应该只能独自地出现在一行上；它可能后接一个注释，但是紧接空语句的第一个字符应该是空格" id="6_2_3" impl="MISRA2004-14_3" originalId="MISRA2004-14_3" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-14_3.rule"/>
         </rule>
         <rule header="构成 switch， while， do  while 或者 for 语句体的语句应该是一个复合语句" id="6_3_1" impl="MISRA2004-14_8" originalId="MISRA2004-14_8" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-14_8.rule"/>
         </rule>
         <rule header="if （条件） 结构应该后接一个复合语句。 else 关键字必须后接一个复合语句，或者另外的 if 语句" id="6_4_1" impl="MISRA2004-14_9" originalId="MISRA2004-14_9" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-14_9.rule"/>
         </rule>
         <rule header="所有的 if ... else if 结构应该由 else 子句结束" id="6_4_2" impl="MISRA2004-14_10" originalId="MISRA2004-14_10" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-14_10.rule"/>
         </rule>
         <rule header="switch 语句应该是一个格式规范的 switch 语句" id="6_4_3_a" impl="MISRA2004-15_1" originalId="MISRA2004-15_1" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-15_1.rule"/>
         </rule>
         <rule header="switch 语句应该是一个格式规范的 switch 语句" id="6_4_3_b" impl="CODSTA-64" originalId="CODSTA-64" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-64.rule"/>
         </rule>
         <rule header="switch 语句应该是一个格式规范的 switch 语句" id="6_4_3_c" impl="CODSTA-61" originalId="CODSTA-61" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-61.rule"/>
         </rule>
         <rule header="switch 语句应该是一个格式规范的 switch 语句" id="6_4_3_d" impl="MISRA2004-15_4" originalId="MISRA2004-15_4" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-15_4.rule"/>
         </rule>
         <rule header="switch 语句应该是一个格式规范的 switch 语句" id="6_4_3_e" impl="MISRA2004-15_5" originalId="MISRA2004-15_5" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-15_5.rule"/>
         </rule>
         <rule header="switch-标签应该只能用在当紧接着的复合语句是 switch 语句体的时候" id="6_4_4" impl="MISRA2004-15_1" originalId="MISRA2004-15_1" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-15_1.rule"/>
         </rule>
         <rule header="无条件的 throw 或 break 语句应该结束任何非 null 的 switch-子句" id="6_4_5" impl="CODSTA-64" originalId="CODSTA-64" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-64.rule"/>
         </rule>
         <rule header="switch 语句的最后子句应该是 default-子句" id="6_4_6" impl="CODSTA-61" originalId="CODSTA-61" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-61.rule"/>
         </rule>
         <rule header="switch 语句的条件不得含有布尔类型" id="6_4_7" impl="MISRA2004-15_4" originalId="MISRA2004-15_4" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-15_4.rule"/>
         </rule>
         <rule header="每个 switch 语句应该至少有一个 case-子句" id="6_4_8" impl="MISRA2004-15_5" originalId="MISRA2004-15_5" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-15_5.rule"/>
         </rule>
         <rule header="for 循环应该包含一个没有浮动类型的单一的循环计数器" id="6_5_1" impl="CODSTA-CPP-69" originalId="CODSTA-CPP-69" quickfix="false" scope="line" severity="2">
            <file path="CODSTA-CPP\CODSTA-CPP-69.rule"/>
         </rule>
         <rule header="如果循环计数器不是被 -- 或 ++ 修改，那么在条件中此循环计数器应该只能被用作 &lt;=， &lt;， &gt; or &gt;= 的操作数" id="6_5_2" impl="CODSTA-CPP-70" originalId="CODSTA-CPP-70" quickfix="false" scope="line" severity="2">
            <file path="CODSTA-CPP\CODSTA-CPP-70.rule"/>
         </rule>
         <rule header="循环计数器不得在判定条件或循环体语句中被修改" id="6_5_3" impl="MISRA2004-13_6" originalId="MISRA2004-13_6" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-13_6.rule"/>
         </rule>
         <rule header="循环计数器应该被 --， ++， -=n， 或 +=n; 之一修改；这里的 n 在整个循环期间保持不变" id="6_5_4" impl="CODSTA-CPP-71" originalId="CODSTA-CPP-71" quickfix="false" scope="line" severity="2">
            <file path="CODSTA-CPP\CODSTA-CPP-71.rule"/>
         </rule>
         <rule header="循环计数器以外的循环控制变量不得在判定条件或运算表达式中被修改" id="6_5_5" impl="CODSTA-CPP-72" originalId="CODSTA-CPP-72" quickfix="false" scope="line" severity="2">
            <file path="CODSTA-CPP\CODSTA-CPP-72.rule"/>
         </rule>
         <rule header="在循环体语句中被修改的非循环计数器的循环控制变量应该是布尔类型的" id="6_5_6" impl="CODSTA-CPP-73" originalId="CODSTA-CPP-73" quickfix="false" scope="line" severity="2">
            <file path="CODSTA-CPP\CODSTA-CPP-73.rule"/>
         </rule>
         <rule header="任何 goto 语句引用的标签应该被声明在相同的块中，或在关闭 goto 语句的块中" id="6_6_1" impl="CODSTA-78" originalId="CODSTA-78" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-78.rule"/>
         </rule>
         <rule header="goto 语句应该跳转到稍后在相同的函数体中声明的标签" id="6_6_2" impl="CODSTA-77" originalId="CODSTA-77" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-77.rule"/>
         </rule>
         <rule header="continue 语句应该只能被用于一个格式规范的 for 循环中" id="6_6_3" impl="CODSTA-80" originalId="CODSTA-80" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-80.rule"/>
         </rule>
         <rule header="对于任何迭代语句不得有超过一个用于循环终止的 break 或 goto 语句" id="6_6_4" impl="CODSTA-79" originalId="CODSTA-79" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-79.rule"/>
         </rule>
         <rule header="一个函数应该在函数末尾有单一的出口点" id="6_6_5" impl="MISRA2004-14_7" originalId="MISRA2004-14_7" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-14_7.rule"/>
         </rule>
         <rule header="尽可能将局部变量声明为 const" id="7_1_1" impl="CODSTA-CPP-53" originalId="CODSTA-CPP-53" quickfix="false" scope="line" severity="2">
            <file path="CODSTA-CPP\CODSTA-CPP-53.rule"/>
         </rule>
         <rule header="尽可能将参数声明为 const" id="7_1_1_b" impl="CODSTA-CPP-53_b" originalId="CODSTA-CPP-53_b" quickfix="false" scope="line" severity="2">
            <file path="CODSTA-CPP\CODSTA-CPP-53_b.rule"/>
         </rule>
         <rule header="如果函数的指针参数对应的对象没有被修改，函数中的指针参数应声明为指向 const 的指针" id="7_1_2_a" impl="MISRA2004-16_7" originalId="MISRA2004-16_7" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-16_7.rule"/>
         </rule>
         <rule header="如果函数的引用参数对应的对象没有被修改，函数中的引用参数应该被声明为指向 const 的引用" id="7_1_2_b" impl="CODSTA-CPP-43" originalId="CODSTA-CPP-43" quickfix="false" scope="line" severity="2">
            <file path="CODSTA-CPP\CODSTA-CPP-43.rule"/>
         </rule>
         <rule header="如果指针不用于修改指向地址的对象则声明参数的类型为 typedef 的 const 指针" id="7_1_2_c" impl="MISRA2004-16_7_b" originalId="MISRA2004-16_7_b" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-16_7_b.rule"/>
         </rule>
         <rule header="包含潜在枚举类型的表达式只应该具有与枚举的枚举器对应的值" id="7_2_1" impl="PB-70" originalId="PB-70" quickfix="false" scope="line" severity="2">
            <file path="PB\PB-70.rule"/>
         </rule>
         <rule header="全局的命名空间应该只能包含 main，命名空间的声明和外部的 &quot;C&quot; 声明" id="7_3_1" impl="CODSTA-CPP-36" originalId="CODSTA-CPP-36" quickfix="false" scope="line" severity="2">
            <file path="CODSTA-CPP\CODSTA-CPP-36.rule"/>
         </rule>
         <rule header="标识符 main 不得用于除全局 main 函数以外的函数" id="7_3_2" impl="CODSTA-76" originalId="CODSTA-76" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-76.rule"/>
         </rule>
         <rule header="在头文件中不得有不具名命名空间" id="7_3_3" impl="CODSTA-CPP-74" originalId="CODSTA-CPP-74" quickfix="false" scope="line" severity="2">
            <file path="CODSTA-CPP\CODSTA-CPP-74.rule"/>
         </rule>
         <rule header="不得使用 using-指示符" id="7_3_4" impl="CODSTA-CPP-75" originalId="CODSTA-CPP-75" quickfix="false" scope="line" severity="2">
            <file path="CODSTA-CPP\CODSTA-CPP-75.rule"/>
         </rule>
         <rule header="在同一个命名空间中标识符的多重声明不得跨越该标识符的 using-声明" id="7_3_5" impl="CODSTA-CPP-76" originalId="CODSTA-CPP-76" quickfix="false" scope="line" severity="2">
            <file path="CODSTA-CPP\CODSTA-CPP-76.rule"/>
         </rule>
         <rule header="在头文件中不得使用 using 指令和 using 声明（不包括类范围或函数范围的  using 声明）" id="7_3_6" impl="CODSTA-CPP-90" originalId="CODSTA-CPP-90" quickfix="false" scope="line" severity="2">
            <file path="CODSTA-CPP\CODSTA-CPP-90.rule"/>
         </rule>
         <rule header="汇编指令应该只能使用 asm 声明来引入" id="7_4_2" impl="CODSTA-73" originalId="CODSTA-73" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-73.rule"/>
         </rule>
         <rule header="汇编语言应该被封装和隔离" id="7_4_3" impl="CODSTA-114" originalId="CODSTA-114" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-114.rule"/>
         </rule>
         <rule header="函数不得返回一个指向定义在函数中自动变量的引用或指针（包括参数）" id="7_5_1" impl="MISRA2004-17_6_a" originalId="MISRA2004-17_6_a" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-17_6_a.rule"/>
         </rule>
         <rule header="具有自动存储方式的对象的地址不得被赋值给在第一个对象已不复存在之后还持续存在的对象" id="7_5_2_a" impl="MISRA2004-17_6_a" originalId="MISRA2004-17_6_a" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-17_6_a.rule"/>
         </rule>
         <rule header="具有自动存储方式的对象的地址不得被赋值给在第一个对象已不复存在之后还持续存在的对象" id="7_5_2_b" impl="MISRA2004-17_6_b" originalId="MISRA2004-17_6_b" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-17_6_b.rule"/>
         </rule>
         <rule header="函数不得返回一个指向通过引用或 const 引用传递参数的引用或指针" id="7_5_3" impl="PB-39" originalId="PB-39" quickfix="false" scope="line" severity="2">
            <file path="PB\PB-39.rule"/>
         </rule>
         <rule header="初始声明列表或成员声明列表应该分别由单一的初始声明或成员声明组成" id="8_0_1" impl="FORMAT-33" originalId="FORMAT-33" quickfix="false" scope="line" severity="2">
            <file path="FORMAT\FORMAT-33.rule"/>
         </rule>
         <rule header="在覆盖的虚函数中的参数应该使用同他们所覆盖的函数一样缺省的实参，否则不得指定任何缺省实参" id="8_3_1" impl="OOP-13" originalId="OOP-13" quickfix="false" scope="line" severity="2">
            <file path="OOP\OOP-13.rule"/>
         </rule>
         <rule header="函数不得使用省略符号定义" id="8_4_1" impl="MISRA-069" originalId="MISRA-069" quickfix="false" scope="line" severity="2">
            <file path="MISRA\MISRA-069.rule"/>
         </rule>
         <rule header="用于参数的标识符在函数的重声明中应该和声明中的相同" id="8_4_2" impl="MISRA2004-16_4" originalId="MISRA2004-16_4" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-16_4.rule"/>
         </rule>
         <rule header="非 void 返回类型函数的所有退出路径应该有显式表达式的返回语句" id="8_4_3" impl="MISRA2004-16_8" originalId="MISRA2004-16_8" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-16_8.rule"/>
         </rule>
         <rule header="函数的标示符应该要么用来调用函数或者在使用时被放在 '&amp;'操作符后" id="8_4_4" impl="MISRA2004-16_9" originalId="MISRA2004-16_9" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-16_9.rule"/>
         </rule>
         <rule header="所有变量在被使用之前应该有一个定义的值" id="8_5_1" impl="MISRA-030" originalId="MISRA-030" quickfix="false" scope="line" severity="2">
            <file path="MISRA\MISRA-030.rule"/>
         </rule>
         <rule header="括号应该被用于指明和匹配在数组和结构体的非零初始化中的结构" id="8_5_2" impl="INIT-16" originalId="INIT-16" quickfix="false" scope="line" severity="2">
            <file path="INIT\INIT-16.rule"/>
         </rule>
         <rule header="数组不应该被部分初始化" id="8_5_2_b" impl="MISRA2004-9_2_b" originalId="MISRA2004-9_2_b" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-9_2_b.rule"/>
         </rule>
         <rule header="结构体不应该被部分初始化" id="8_5_2_c" impl="MISRA2004-9_2_c" originalId="MISRA2004-9_2_c" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-9_2_c.rule"/>
         </rule>
         <rule header="在枚举成员列表中，不得使用 = 结构显式地初始化除第一个以外的成员，除非所有项目都显式地被初始化" id="8_5_3" impl="MISRA2004-9_3" originalId="MISRA2004-9_3" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-9_3.rule"/>
         </rule>
         <rule header="const 成员函数不得返回指向类数据成员的非 const 指针或引用" id="9_3_1" impl="CODSTA-CPP-77" originalId="CODSTA-CPP-77" quickfix="false" scope="line" severity="2">
            <file path="CODSTA-CPP\CODSTA-CPP-77.rule"/>
         </rule>
         <rule header="受保护 （Protected）的成员函数不得返回指向类数据的非 const 句柄（指针或引用）" id="9_3_2_a" impl="OOP-12" originalId="OOP-12" quickfix="false" scope="line" severity="2">
            <file path="OOP\OOP-12.rule"/>
         </rule>
         <rule header="public 成员函数不得返回指向类数据的非 const 句柄（指针或引用）" id="9_3_2_b" impl="OOP-36" originalId="OOP-36" quickfix="false" scope="line" severity="2">
            <file path="OOP\OOP-36.rule"/>
         </rule>
         <rule header="如果一个成员函数可以是 static 的那么就应该定义为 static，否则如果它可以是 const 那么它应该被定义为 const" id="9_3_3" impl="CODSTA-CPP-78" originalId="CODSTA-CPP-78" quickfix="false" scope="line" severity="2">
            <file path="CODSTA-CPP\CODSTA-CPP-78.rule"/>
         </rule>
         <rule header="不得使用联合体 （union）" id="9_5_1" impl="MISRA2004-18_4" originalId="MISRA2004-18_4" quickfix="false" scope="line" severity="2">
            <file path="MISRA2004\MISRA2004-18_4.rule"/>
         </rule>
         <rule header="位域应该是布尔类型或者显式地 unsigned 或 signed 整型" id="9_6_2" impl="CODSTA-75" originalId="CODSTA-75" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-75.rule"/>
         </rule>
         <rule header="位域不得有枚举类型" id="9_6_3" impl="CODSTA-74" originalId="CODSTA-74" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-74.rule"/>
         </rule>
         <rule header="由 signed 整型命名的位域应该有超过一位的长度" id="9_6_4" impl="CODSTA-71" originalId="CODSTA-71" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-71.rule"/>
         </rule>
         <rule header="类不得从虚类派生而来" id="10_1_1" impl="OOP-47" originalId="OOP-47" quickfix="false" scope="line" severity="4">
            <file path="OOP\OOP-47.rule"/>
         </rule>
         <rule header="多个继承层次结构中的所有可访问实体名称都应该是惟一的" id="10_2_1" impl="CODSTA-CPP-92" originalId="CODSTA-CPP-92" quickfix="false" scope="line" severity="4">
            <file path="CODSTA-CPP\CODSTA-CPP-92.rule"/>
         </rule>
         <rule header="一个类的所有构造函数应该显式地为它的所有直接基类和所有虚基类调用一个构造函数" id="12_1_2" impl="PB-43" originalId="PB-43" quickfix="false" scope="line" severity="4">
            <file path="PB\PB-43.rule"/>
         </rule>
         <rule header="函数调用的可行函数集合应该要么不包括函数特化，要么只包括函数特化" id="14_8_2" impl="TEMPL-08" originalId="TEMPL-08" quickfix="false" scope="line" severity="4">
            <file path="TEMPL\TEMPL-08.rule"/>
         </rule>
         <rule header="一个例外对象不得有指针类型" id="15_0_2" impl="EXCEPT-09" originalId="EXCEPT-09" quickfix="false" scope="line" severity="4">
            <file path="EXCEPT\EXCEPT-09.rule"/>
         </rule>
         <rule header="应该至少有一个异常处理程序来捕获所有其他未处理的异常" id="15_3_2" impl="EXCEPT-06" originalId="EXCEPT-06" quickfix="false" scope="line" severity="4">
            <file path="EXCEPT\EXCEPT-06.rule"/>
         </rule>
         <rule header="字符 \ 不得出现在头文件的名称中" id="16_2_5" impl="NAMING-48" originalId="NAMING-48" quickfix="false" scope="line" severity="4">
            <file path="NAMING\NAMING-48.rule"/>
         </rule>
         <rule header="不得使用 # 和 ## 操作符" id="16_3_2" impl="MISRA2004-19_13" originalId="MISRA2004-19_13" quickfix="false" scope="line" severity="4">
            <file path="MISRA2004\MISRA2004-19_13.rule"/>
         </rule>
         <rule header="不得使用二元字符" id="2_5_1" impl="CODSTA-48" originalId="CODSTA-48" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-48.rule"/>
         </rule>
         <rule header="代码部分不得使用 C++ 语言风格的注释 &quot;添加注释 &quot;" id="2_7_3" impl="MISRA2004-2_4" originalId="MISRA2004-2_4" quickfix="false" scope="line" severity="4">
            <file path="MISRA2004\MISRA2004-2_4.rule"/>
         </rule>
         <rule header="指定大小和符号属性的 typedef 应该用来代替基本数值类型" id="3_9_2" impl="MISRA-013" originalId="MISRA-013" quickfix="false" scope="line" severity="4">
            <file path="MISRA\MISRA-013.rule"/>
         </rule>
         <rule header="限制依赖 C++ 语言表达式中的运算符优先级规则" id="5_0_2_a" impl="MISRA2004-12_1_a" originalId="MISRA2004-12_1_a" quickfix="false" scope="line" severity="4">
            <file path="MISRA2004\MISRA2004-12_1_a.rule"/>
         </rule>
         <rule header="限制依赖 C++ 语言表达式中的运算符优先级规则" id="5_0_2_b" impl="MISRA2004-12_1_b" originalId="MISRA2004-12_1_b" quickfix="false" scope="line" severity="4">
            <file path="MISRA2004\MISRA2004-12_1_b.rule"/>
         </rule>
         <rule header="限制依赖 C++ 语言表达式中的运算符优先级规则" id="5_0_2_c" impl="MISRA2004-12_1_c" originalId="MISRA2004-12_1_c" quickfix="false" scope="line" severity="4">
            <file path="MISRA2004\MISRA2004-12_1_c.rule"/>
         </rule>
         <rule header="限制依赖 C++ 语言表达式中的运算符优先级规则" id="5_0_2_d" impl="MISRA2004-12_1_d" originalId="MISRA2004-12_1_d" quickfix="false" scope="line" severity="4">
            <file path="MISRA2004\MISRA2004-12_1_d.rule"/>
         </rule>
         <rule header="限制依赖 C++ 语言表达式中的运算符优先级规则" id="5_0_2_e" impl="MISRA2004-12_1_e" originalId="MISRA2004-12_1_e" quickfix="false" scope="line" severity="4">
            <file path="MISRA2004\MISRA2004-12_1_e.rule"/>
         </rule>
         <rule header="限制依赖 C++ 语言表达式中的运算符优先级规则" id="5_0_2_f" impl="MISRA2004-12_1_f" originalId="MISRA2004-12_1_f" quickfix="false" scope="line" severity="4">
            <file path="MISRA2004\MISRA2004-12_1_f.rule"/>
         </rule>
         <rule header="在 '+'， '-'， '*' 操作符的常量表达式中发生整数溢出或下溢" id="5_19_1_a" impl="PB-66_a" originalId="PB-66_a" quickfix="false" scope="line" severity="4">
            <file path="PB\PB-66_a.rule"/>
         </rule>
         <rule header="在 '&lt;&lt;' 操作符的常量表达式中发生整数溢出或下溢" id="5_19_1_b" impl="PB-66_b" originalId="PB-66_b" quickfix="false" scope="line" severity="4">
            <file path="PB\PB-66_b.rule"/>
         </rule>
         <rule header="在表达式中，增量（++）和减量（--）运算符不应该与算术运算符混合使用" id="5_2_10" impl="CODSTA-232" originalId="CODSTA-232" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-232.rule"/>
         </rule>
         <rule header="从基类到派生类的强制类型转换不得在多态类型上进行" id="5_2_3" impl="OOP-49" originalId="OOP-49" quickfix="false" scope="line" severity="4">
            <file path="OOP\OOP-49.rule"/>
         </rule>
         <rule header="强制类型转换不得转换一个指针类型为整型" id="5_2_9" impl="MISRA2004-11_3_a" originalId="MISRA2004-11_3_a" quickfix="false" scope="line" severity="4">
            <file path="MISRA2004\MISRA2004-11_3_a.rule"/>
         </rule>
         <rule header="函数不得调用它们本身，无论是直接或间接" id="7_5_4" impl="MISRA2004-16_2" originalId="MISRA2004-16_2" quickfix="false" scope="line" severity="4">
            <file path="MISRA2004\MISRA2004-16_2.rule"/>
         </rule>
         <rule header="使用浮点型算法应该被注释说明" id="0_4_2" impl="COMMENT-10" originalId="COMMENT-10" quickfix="false" scope="line" severity="5">
            <file path="COMMENT\COMMENT-10.rule"/>
         </rule>
         <rule header="所有使用 #pragma 指示符应该被注释说明" id="16_6_1" impl="MISRA2004-3_4" originalId="MISRA2004-3_4" quickfix="false" scope="line" severity="5">
            <file path="MISRA2004\MISRA2004-3_4.rule"/>
         </rule>
         <rule header="所有汇编程序的使用应该被注释说明" id="7_4_1" impl="COMMENT-09" originalId="COMMENT-09" quickfix="false" scope="line" severity="5">
            <file path="COMMENT\COMMENT-09.rule"/>
         </rule>
      </category>
      <category description="MISRA C++ 202X" name="MISRACPP202X">
         <category description="Rule 0025 (必需) 禁止在 C 语言风格的注释中使用  ''/* '' 字符序列" name="0025">
            <rule header="禁止在 C 语言风格的注释中使用 /* 字符序列" id="a" impl="MISRA2004-2_3" originalId="MISRA2004-2_3" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-2_3.rule"/>
            </rule>
         </category>
         <category description="Rule 0035 (必需) 不应该使用八进制常量" name="0035">
            <rule header="不应该使用八进制常数（除零外）" id="a" impl="MISRA2004-7_1_a" originalId="MISRA2004-7_1_a" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-7_1_a.rule"/>
            </rule>
         </category>
         <category description="Rule 0036 (必需) 无符号的整型字面量应该有适当的后缀" name="0036">
            <rule header="无符号类型的所有常量应该使用 'U' 后缀" id="a" impl="MISRA2004-10_6" originalId="MISRA2004-10_6" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-10_6.rule"/>
            </rule>
         </category>
         <category description="Rule 0042 (必需) 类似函数的宏不应被定义" name="0042">
            <rule header="函数应该优先于宏函数的使用" id="a" impl="MISRA2004-19_7" originalId="MISRA2004-19_7" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-19_7.rule"/>
            </rule>
         </category>
         <category description="Rule 0043 (必需) 看起来像预处理指令的标识不应出现在宏的参数中" name="0043">
            <rule header="类似函数的宏的参数不应该包含类似预处理命令的标识" id="a" impl="MISRA2004-19_9" originalId="MISRA2004-19_9" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-19_9.rule"/>
            </rule>
         </category>
         <category description="Rule 0045 (必需) 在控制表达式的 #if 或 #elif 预处理指令中使用的所有标识符应在求值时被 #define" name="0045">
            <rule header="不要使用在编译单元中未定义的预编译器指令 #if 和 #elif  宏" id="a" impl="MISRA2004-19_11_b" originalId="MISRA2004-19_11_b" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-19_11_b.rule"/>
            </rule>
         </category>
         <category description="Rule 0046 (必需) 一行的第一个标识是 &quot;#&quot;，应是一个有效的预处理指令" name="0046">
            <rule header="预处理指令即使被预处理程序排除,在语法上也是有意义的" id="a" impl="MISRA2004-19_16" originalId="MISRA2004-19_16" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-19_16.rule"/>
            </rule>
         </category>
         <category description="Rule 0064 (必需) &quot;nullptr&quot; 应是空指针常量的唯一形式" name="0064">
            <rule header="使用 nullptr 代替 null 和 0" id="a" impl="CODSTA-MCPP-04" originalId="CODSTA-MCPP-04" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-04.rule"/>
            </rule>
         </category>
         <category description="Rule 0087 (必需) 虚基类只能通过 dynamic_cast 的方式转换为派生类" name="0087">
            <rule header="指向虚拟基类型的指针只能通过dynamic_cast的方式转换为指向其衍生类的指针" id="a" impl="OOP-50" originalId="OOP-50" quickfix="false" scope="line" severity="2">
               <file path="OOP\OOP-50.rule"/>
            </rule>
         </category>
         <category description="Rule 0089 (必需) 不应使用 C 风格转换和函数符号转换" name="0089">
            <rule header="不得使用 C 语言风格的强制类型转换(除 void 强制类型转换外)和函数符号式强制类型转换(除了显式的构造函数调用外)" id="a" impl="CODSTA-CPP-66" originalId="CODSTA-CPP-66" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-66.rule"/>
            </rule>
         </category>
         <category description="Rule 0090 (必需) 强制转换不得从指针或引用类型中删除任何 const 或 volatile 限定条件" name="0090">
            <rule header="强制转换不得从指针或引用类型中删除任何“const”或“volatile”限定条件" id="a" impl="MISRA2004-11_5" originalId="MISRA2004-11_5" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-11_5.rule"/>
            </rule>
         </category>
         <category description="Rule 0096 (必需)  逗号、逻辑 AND 和逻辑 OR 运算符不得被重载" name="0096">
            <rule header="避免重载逻辑操作符AND, OR (&amp;&amp;, ||)" id="a" impl="CODSTA-CPP-08" originalId="CODSTA-CPP-08" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-08.rule"/>
            </rule>
            <rule header="避免重载逗号运算符 &quot;,&quot;" id="b" impl="CODSTA-CPP-80" originalId="CODSTA-CPP-80" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-80.rule"/>
            </rule>
         </category>
         <category description="Rule 0097 (必需) 数组作为函数参数传递时不应退化为一个指针" name="0097">
            <rule header="不要将具有数组类型的表达式传递给一个具有指针或者数组类型参数的函数" id="a" impl="PB-41_b" originalId="PB-41_b" quickfix="false" scope="line" severity="2">
               <file path="PB\PB-41_b.rule"/>
            </rule>
         </category>
         <category description="Rule 0100 (必需) address-of 操作符不应被重载" name="0100">
            <rule header="一元 &amp; 运算符不得被重载" id="a" impl="CODSTA-CPP-68" originalId="CODSTA-CPP-68" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-68.rule"/>
            </rule>
         </category>
         <category description="Rule 0110 (必需) 迭代语句或选择语句的主体应是一个复合语句" name="0110">
            <rule header="'switch', 'while', 'do...while' 或 'for' 语句的主体应该是复合语句" id="a" impl="MISRA2004-14_8" originalId="MISRA2004-14_8" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-14_8.rule"/>
            </rule>
            <rule header="'if' 和 'else' 语句后应跟一个复合句" id="b" impl="MISRA2004-14_9" originalId="MISRA2004-14_9" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-14_9.rule"/>
            </rule>
         </category>
         <category description="Rule 0125 (必需) 一个 goto 语句应引用在同一个块或一个封闭块中声明的标签" name="0125">
            <rule header="任何由 goto 语句引用的标签应该声明在同一个模块中，或者在一个包含 goto 语句的模块中" id="a" impl="CODSTA-78" originalId="CODSTA-78" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-78.rule"/>
            </rule>
         </category>
         <category description="Rule 0133 (必需) 全局命名空间的唯一声明应是main、命名空间声明和 extern &quot; C&quot;声明" name="0133">
            <rule header="全局命名空间应该只包含 main() 和命名空间声明" id="a" impl="CODSTA-CPP-36" originalId="CODSTA-CPP-36" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-36.rule"/>
            </rule>
         </category>
         <category description="Rule 0134 (必需) 标识符 main 不得用于全局函数 main 以外的函数" name="0134">
            <rule header="标识符 main 不得用于除了全局的 main 函数以外的其它函数" id="a" impl="CODSTA-76" originalId="CODSTA-76" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-76.rule"/>
            </rule>
         </category>
         <category description="Rule 0143 (必需) 自动存储的对象的地址不得分配给具有更长生命周期的对象" name="0143">
            <rule header="自动存储对象的地址不应分配给在第一个对象不再存在后可能持久存在的另一个对象" id="a" impl="MISRA2004-17_6_b" originalId="MISRA2004-17_6_b" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-17_6_b.rule"/>
            </rule>
            <rule header="通过引用捕获本地对象的lambda不应被赋值给有更长生命周期的变量" id="b" impl="CODSTA-MCPP-17_c" originalId="CODSTA-MCPP-17_c" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-17_c.rule"/>
            </rule>
         </category>
         <category description="Rule 0147 (必需) 虚函数覆盖中的参数不应引入不同的默认参数" name="0147">
            <rule header="禁止使用不同的默认参数值来重定义继承的虚拟函数" id="a" impl="OOP-13" originalId="OOP-13" quickfix="false" scope="line" severity="2">
               <file path="OOP\OOP-13.rule"/>
            </rule>
         </category>
         <category description="Rule 0148 (必需) 不得使用&quot;&lt;cstdarg&gt;&quot;的功能" name="0148">
            <rule header="不应使用标识符 va_list, va_arg, va_start, va_end, va_copy" id="a" impl="CODSTA-136_a" originalId="CODSTA-136_a" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-136_a.rule"/>
            </rule>
         </category>
         <category description="Rule 0150 (必需) 一个具有 non-void 返回类型的函数应在所有路径上返回一个值" name="0150">
            <rule header="具有非空返回类型的函数的所有退出路径都应该有一个带有表达式的显式返回语句" id="a" impl="MISRA2004-16_8" originalId="MISRA2004-16_8" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-16_8.rule"/>
            </rule>
         </category>
         <category description="Rule 0158 (必需) 不应使用 union 关键字" name="0158">
            <rule header="禁止使用联合体" id="a" impl="MISRA2004-18_4" originalId="MISRA2004-18_4" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-18_4.rule"/>
            </rule>
         </category>
         <category description="Rule 0162 (必需) 有符号的整数类型的命名位域的长度不得为一比特" name="0162">
            <rule header="具有带符号的整数类型且已命名的位域应该有超过一位的长度" id="a" impl="CODSTA-71" originalId="CODSTA-71" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-71.rule"/>
            </rule>
         </category>
         <category description="Rule 0163 (必需)类不得从虚基中派生" name="0163">
            <rule header="类不能从虚拟基类型中衍生" id="a" impl="OOP-47" originalId="OOP-47" quickfix="false" scope="line" severity="2">
               <file path="OOP\OOP-47.rule"/>
            </rule>
         </category>
         <category description="Rule 0165 (必需) 在同一层次结构中，一个可访问的基类不得同时是虚基类和非虚基类" name="0165">
            <rule header="在同一层次结构中，基类不能同时具有虚拟及非虚拟的属性" id="a" impl="OOP-41" originalId="OOP-41" quickfix="false" scope="line" severity="2">
               <file path="OOP\OOP-41.rule"/>
            </rule>
         </category>
         <category description="Rule 0173 (必需) 可以用一个参数调用的转换操作符和构造函数应是显式的" name="0173">
            <rule header="允许转换的构造函数应该是使用 explicit 修饰" id="a" impl="CODSTA-CPP-04" originalId="CODSTA-CPP-04" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-04.rule"/>
            </rule>
            <rule header="自定义类型转换函数需要使用标识符标识" id="b" impl="CODSTA-MCPP-01" originalId="CODSTA-MCPP-01" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-01.rule"/>
            </rule>
         </category>
         <category description="Rule 0187 (必需) 异常对象不应具有指针类型" name="0187">
            <rule header="异常对象不应该有指针类型" id="a" impl="EXCEPT-09" originalId="EXCEPT-09" quickfix="false" scope="line" severity="2">
               <file path="EXCEPT\EXCEPT-09.rule"/>
            </rule>
         </category>
         <category description="Rule 0207 (必需) 应采取措施预防一个头文件的内容被包含一次以上" name="0207">
            <rule header="使用多个包含保护" id="a" impl="PFO-02" originalId="PFO-02" quickfix="false" scope="line" severity="2">
               <file path="PFO\PFO-02.rule"/>
            </rule>
         </category>
         <category description="Rule 0208 (必需) 头文件名中不得出现&quot;'&quot;、&quot;&quot;或&quot;&quot;字符以及&quot;/*&quot;或&quot;//&quot;字符序列" name="0208">
            <rule header="非标准字符不应该用于 #include 指令的头文件名称中" id="a" impl="MISRA2004-19_2" originalId="MISRA2004-19_2" quickfix="false" scope="line" severity="2">
               <file path="MISRA2004\MISRA2004-19_2.rule"/>
            </rule>
         </category>
         <category description="Rule 0210 (必需) #include 指令后面应跟上一个&quot;&lt;文件名&gt;&quot;或&quot;&quot;文件名&quot;&quot;序列" name="0210">
            <rule header="#include 指令后面应当添加 &lt;filename&gt; 或是 &quot;filename&quot;" id="a" impl="MISRA-089" originalId="MISRA-089" quickfix="false" scope="line" severity="2">
               <file path="MISRA\MISRA-089.rule"/>
            </rule>
         </category>
         <category description="Rule 0239 (必需) 成员的潜在虚指针只应与&quot;nullptr&quot;比较" name="0239">
            <rule header="指向成员虚拟函数的指针只应该被测试是否与空指针常量相等" id="a" impl="CODSTA-MCPP-26" originalId="CODSTA-MCPP-26" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-26.rule"/>
            </rule>
         </category>
         <category description="Rule 0320 (必需) 八进制和十六进制的转义序列应被终止" name="0320">
            <rule header="八进制和十六进制转义序列将被终止" id="a" impl="CODSTA-117" originalId="CODSTA-117" quickfix="false" scope="line" severity="2">
               <file path="CODSTA\CODSTA-117.rule"/>
            </rule>
         </category>
         <category description="Rule 0324 (必需) 一个指向不完整的类类型的指针不应删除" name="0324">
            <rule header="不要在删除点上时删除类不完整的对象" id="a" impl="PB-55" originalId="PB-55" quickfix="false" scope="line" severity="2">
               <file path="PB\PB-55.rule"/>
            </rule>
         </category>
         <category description="Rule 0343 (必需) 成员函数的声明应适当地使用  virtual、override 和  final 修饰符" name="0343">
            <rule header="每个重载的虚函数都应使用 override 或 final 声明符声明。" id="a" impl="CODSTA-MCPP-05" originalId="CODSTA-MCPP-05" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-05.rule"/>
            </rule>
            <rule header="在成员函数声明中,只应该指定 virtual,override 或 final 中的一个" id="b" impl="CODSTA-MCPP-24" originalId="CODSTA-MCPP-24" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-24.rule"/>
            </rule>
         </category>
         <category description="Rule 0370 (必需) 作为&quot;#&quot;或&quot;#&quot;运算符的操作数使用的宏参数，其本身需要进一步进行宏替换，只能作为这些运算符的操作数使用" name="0370">
            <rule header="一个被用作 # 或者 ## 操作符的操作数的宏参数，并且它本身受制于进一步的宏替换，那么它应该只能被用作这些操作符的操作数" id="a" impl="PREPROC-17" originalId="PREPROC-17" quickfix="false" scope="line" severity="2">
               <file path="PREPROC\PREPROC-17.rule"/>
            </rule>
         </category>
         <category description="Rule 0023 (建议) 禁止使用三联符" name="0023">
            <rule header="禁止使用三联符" id="a" impl="MISRA2004-4_2" originalId="MISRA2004-4_2" quickfix="false" scope="line" severity="4">
               <file path="MISRA2004\MISRA2004-4_2.rule"/>
            </rule>
         </category>
         <category description="Rule 0039 (建议) #include 之前只允许有预处理命令和注释" name="0039">
            <rule header="#include 之前只允许有预处理命令和注释" id="a" impl="MISRA2004-19_1" originalId="MISRA2004-19_1" quickfix="false" scope="line" severity="4">
               <file path="MISRA2004\MISRA2004-19_1.rule"/>
            </rule>
         </category>
         <category description="Rule 0049 (建议) 当具有外部链接的数组被声明时，应显式地指定其大小" name="0049">
            <rule header="当数组声明具有外部链接，其大小应该显式地说明或者在初始化时隐性地定义" id="a" impl="MISRA2004-8_12" originalId="MISRA2004-8_12" quickfix="false" scope="line" severity="4">
               <file path="MISRA2004\MISRA2004-8_12.rule"/>
            </rule>
         </category>
         <category description="Rule 0105 (建议) 逗号操作符不应被使用" name="0105">
            <rule header="不应该使用逗号运算符" id="a" impl="MISRA2004-12_10" originalId="MISRA2004-12_10" quickfix="false" scope="line" severity="4">
               <file path="MISRA2004\MISRA2004-12_10.rule"/>
            </rule>
         </category>
         <category description="Rule 0135 (建议) 头文件中不应存在未命名的命名空间" name="0135">
            <rule header="头文件中不应有未命名的命名空间" id="a" impl="CODSTA-CPP-74" originalId="CODSTA-CPP-74" quickfix="false" scope="line" severity="4">
               <file path="CODSTA-CPP\CODSTA-CPP-74.rule"/>
            </rule>
         </category>
         <category description="Rule 0146 (建议) 一个声明不应声明一个以上的变量或成员变量" name="0146">
            <rule header="每个变量都要在单独的声明语句中被声明" id="a" impl="FORMAT-33" originalId="FORMAT-33" quickfix="false" scope="line" severity="4">
               <file path="FORMAT\FORMAT-33.rule"/>
            </rule>
         </category>
         <category description="Rule 0159 (建议) 比特字段不应该被声明" name="0159">
            <rule header="不要将成员变量声明为位域" id="a" impl="CODSTA-02" originalId="CODSTA-02" quickfix="false" scope="line" severity="4">
               <file path="CODSTA\CODSTA-02.rule"/>
            </rule>
         </category>
         <category description="Rule 0212 (建议) 不应使用&quot;#&quot;和&quot;##&quot;预处理程序操作符" name="0212">
            <rule header="禁止使用预处理操作符 # 和 ##" id="a" impl="MISRA2004-19_13" originalId="MISRA2004-19_13" quickfix="false" scope="line" severity="4">
               <file path="MISRA2004\MISRA2004-19_13.rule"/>
            </rule>
         </category>
      </category>
      <category description="命名规范" name="NAMING">
         <rule header="常量和枚举值的标识符应为小写" id="42" impl="NAMING-42" quickfix="false" scope="line" severity="2">
            <file path="NAMING\NAMING-42.rule"/>
         </rule>
         <rule header="所有使用 &quot;#define&quot; 定义的常量必须使用大写" id="01" impl="NAMING-01" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-01.rule"/>
         </rule>
         <rule header="在枚举列表中，列表成员(元素)应该是大写的，列表中的名称或标记应该是小写的" id="02" impl="NAMING-02" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-02.rule"/>
         </rule>
         <rule header="为文件名使用小写字母" id="03" impl="NAMING-03" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-03.rule"/>
         </rule>
         <rule header="带有全局前缀的名字仅能用作全局变量" id="04" impl="NAMING-04" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-04.rule"/>
         </rule>
         <rule header="局部变量名应以小写字母开头" id="05" impl="NAMING-05" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-05.rule"/>
         </rule>
         <rule header="全局变量名应以小写字母开头" id="06" impl="NAMING-06" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-06.rule"/>
         </rule>
         <rule header="成员变量名应以小写字母开头" id="07" impl="NAMING-07" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-07.rule"/>
         </rule>
         <rule header="所有布尔类型变量必须以字母 'b' 开头" id="08" impl="NAMING-08" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-08.rule"/>
         </rule>
         <rule header="类，结构体，联合体，枚举和自定义类型(typedef)的名字必须以大写字母开头" id="09" impl="NAMING-09" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-09.rule"/>
         </rule>
         <rule header="抽象数据类型，结构体，自定义类型(typedef)，枚举类型的名字必须以大写字母开头" id="10" impl="NAMING-10" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-10.rule"/>
         </rule>
         <rule header="枚举类型名称应以大写字母开头并以后缀 '_t' 结尾" id="11" impl="NAMING-11" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-11.rule"/>
         </rule>
         <rule header="结构类型名称应以大写字母开头并以后缀 '_t' 结尾" id="12" impl="NAMING-12" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-12.rule"/>
         </rule>
         <rule header="常量名以小写字母 'c' 开头'" id="13" impl="NAMING-13" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-13.rule"/>
         </rule>
         <rule header="类的数据成员名以 'its' 开头" id="14" impl="NAMING-14" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-14.rule"/>
         </rule>
         <rule header="双精类型变量名以小写字母 'd' 开头" id="15" impl="NAMING-15" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-15.rule"/>
         </rule>
         <rule header="浮点类型变量名以小写字母 'f' 开头" id="16" impl="NAMING-16" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-16.rule"/>
         </rule>
         <rule header="所有函数名字以大写字母开头" id="17" impl="NAMING-17" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-17.rule"/>
         </rule>
         <rule header="全局变量名以 'the' 开头" id="18" impl="NAMING-18" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-18.rule"/>
         </rule>
         <rule header="所有整型变量以小写字母 'i' 开头" id="19" impl="NAMING-19" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-19.rule"/>
         </rule>
         <rule header="以 'is' 开头的函数必须返回布尔值" id="20" impl="NAMING-20" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-20.rule"/>
         </rule>
         <rule header="所有长整型变量名以 'li' 开头" id="21" impl="NAMING-21" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-21.rule"/>
         </rule>
         <rule header="指针类型变量名以字母 'p' 为前缀" id="22" impl="NAMING-22" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-22.rule"/>
         </rule>
         <rule header="所有短整型变量以字母 'si' 开头" id="23" impl="NAMING-23" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-23.rule"/>
         </rule>
         <rule header="所有有符号字符变量以小写字母 'c' 开头" id="24" impl="NAMING-24" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-24.rule"/>
         </rule>
         <rule header="所有有尾字符串的变量名以 'sz' 开头" id="25" impl="NAMING-25" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-25.rule"/>
         </rule>
         <rule header="所有无符号字符类型变量名以 'uc' 开头" id="26" impl="NAMING-26" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-26.rule"/>
         </rule>
         <rule header="所有无符号整型变量以 'ui' 开头" id="27" impl="NAMING-27" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-27.rule"/>
         </rule>
         <rule header="结构和联合的成员名字使用小写字母" id="28" impl="NAMING-28" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-28.rule"/>
         </rule>
         <rule header="所有自定义类型的名字应以 &quot;_t&quot; 结尾" id="29" impl="NAMING-29" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-29.rule"/>
         </rule>
         <rule header="确保在 C 语言中实现文件始终具有文件扩展名 &quot;.c&quot;" id="30" impl="NAMING-30" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-30.rule"/>
         </rule>
         <rule header="不要使用字母的大小写区分数据类型" id="31" impl="NAMING-31" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-31.rule"/>
         </rule>
         <rule header="对应类的包含文件应采用 &lt;类名&gt; 加扩展名的格式" id="32" impl="NAMING-32" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-32.rule"/>
         </rule>
         <rule header="标识符的名字不能以一个下划线 (`_') 或两个下划线 (`__') 开头" id="33" impl="NAMING-33" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-33.rule"/>
         </rule>
         <rule header="全局函数名必须以小写字母开头" id="34" impl="NAMING-34" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-34.rule"/>
         </rule>
         <rule header="成员函数名必须以小写字母开头" id="35" impl="NAMING-35" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-35.rule"/>
         </rule>
         <rule header="函数声明中的参数名必须与函数定义中的参数名字一致" id="36" impl="NAMING-36" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-36.rule"/>
         </rule>
         <rule header="确保在 C++ 中包含文件始终具有扩展名 &quot;.hh&quot;" id="37" impl="NAMING-37" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-37.rule"/>
         </rule>
         <rule header="确保在 C++ 中实现文件始终具有文件扩展名 &quot;.cc&quot;" id="38" impl="NAMING-38" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-38.rule"/>
         </rule>
         <rule header="内联定义文件的扩展名必须为 &quot;.icc&quot;" id="39" impl="NAMING-39" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-39.rule"/>
         </rule>
         <rule header="类，结构体，命名空间，枚举或自定义类型(typedef)的名称中，只有第一个字母可以大写" id="40" impl="NAMING-40" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-40.rule"/>
         </rule>
         <rule header="确保头文件应该始终具有扩展名 '.h'" id="41" impl="NAMING-41" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-41.rule"/>
         </rule>
         <rule header="源文件的扩展名必须为 &quot;.cpp&quot; 或者&quot;.h&quot;" id="43" impl="NAMING-43" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-43.rule"/>
         </rule>
         <rule header="函数和变量名称中包含的所有字母将完全由小写字母组成" id="44" impl="NAMING-44" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-44.rule"/>
         </rule>
         <rule header="不能使用大小写字母，下划线区分标识符，也不能使用容易与数字混淆的字母做为标识符名字" id="45" impl="NAMING-45" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-45.rule"/>
         </rule>
         <rule header="字符 ', &quot;, /* 或 // 不得出现在头文件的名称中" id="46" impl="NAMING-46" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-46.rule"/>
         </rule>
         <rule header="不同的标识符应该是书写明确的" id="47" impl="NAMING-47" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-47.rule"/>
         </rule>
         <rule header="字符 \ 不得出现在头文件的名称中" id="48" impl="NAMING-48" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-48.rule"/>
         </rule>
         <rule header="用户定义的文字操作符的后缀应该以下划线和一个或多个字母开头" id="51" impl="NAMING-51" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-51.rule"/>
         </rule>
         <rule header="通用字符名称仅应在字符或字符串字面量内使用" id="52" impl="NAMING-52" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-52.rule"/>
         </rule>
         <rule header="头文件的文件扩展名应该是: &quot;.h&quot;, &quot;.hpp&quot; 或 &quot;.hxx&quot;" id="53" impl="NAMING-53" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-53.rule"/>
         </rule>
         <rule header="使用视觉上不同的标识符" id="54" impl="NAMING-54" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-54.rule"/>
         </rule>
         <category description="匈牙利记法" name="HN">
            <rule header="应该使用匈牙利命名法的数组变量和参数" id="01" impl="NAMING-HN-01" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-01.rule"/>
            </rule>
            <rule header="应该使用匈牙利命名法的布尔类型" id="02" impl="NAMING-HN-02" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-02.rule"/>
            </rule>
            <rule header="布尔型指针,数组,或引用类型的匈牙利命名法" id="03" impl="NAMING-HN-03" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-03.rule"/>
            </rule>
            <rule header="字节类型的匈牙利命名法" id="04" impl="NAMING-HN-04" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-04.rule"/>
            </rule>
            <rule header="字节指针、数组或引用类型应使用匈牙利命名法" id="05" impl="NAMING-HN-05" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-05.rule"/>
            </rule>
            <rule header="字符(char)类型应该使用匈牙利命名法" id="06" impl="NAMING-HN-06" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-06.rule"/>
            </rule>
            <rule header="字符类型数组的匈牙利命名法" id="07" impl="NAMING-HN-07" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-07.rule"/>
            </rule>
            <rule header="指针,数组或字符类型数组的引用的匈牙利命名法" id="08" impl="NAMING-HN-08" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-08.rule"/>
            </rule>
            <rule header="char类型指针、数组或引用类型应该用匈牙利符号" id="09" impl="NAMING-HN-09" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-09.rule"/>
            </rule>
            <rule header="char类型指针或引用类型应使用匈牙利命名法" id="10" impl="NAMING-HN-10" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-10.rule"/>
            </rule>
            <rule header="常量参数的匈牙利命名法" id="11" impl="NAMING-HN-11" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-11.rule"/>
            </rule>
            <rule header="双精度浮点类型的匈牙利命名法" id="12" impl="NAMING-HN-12" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-12.rule"/>
            </rule>
            <rule header="双精度浮点指针，数组或引用类型应该使用匈牙利命名法" id="13" impl="NAMING-HN-13" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-13.rule"/>
            </rule>
            <rule header="双字（dword）类型应该用匈牙利符号" id="14" impl="NAMING-HN-14" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-14.rule"/>
            </rule>
            <rule header="双字指针,数组,或引用类型的匈牙利命名法" id="15" impl="NAMING-HN-15" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-15.rule"/>
            </rule>
            <rule header="动态分配的数组的匈牙利命名法" id="16" impl="NAMING-HN-16" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-16.rule"/>
            </rule>
            <rule header="浮点类型应该使用匈牙利命名法" id="17" impl="NAMING-HN-17" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-17.rule"/>
            </rule>
            <rule header="浮点指针,数组,或引用类型的匈牙利命名法" id="18" impl="NAMING-HN-18" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-18.rule"/>
            </rule>
            <rule header="类声明的匈牙利命名法" id="19" impl="NAMING-HN-19" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-19.rule"/>
            </rule>
            <rule header="结构体声明的匈牙利命名法" id="20" impl="NAMING-HN-20" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-20.rule"/>
            </rule>
            <rule header="ifstream 类型的变量和参数应该使用匈牙利命名法" id="21" impl="NAMING-HN-21" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-21.rule"/>
            </rule>
            <rule header="整数(int)类型应该使用匈牙利命名法" id="22" impl="NAMING-HN-22" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-22.rule"/>
            </rule>
            <rule header="整数指针,数组,或引用类型的匈牙利命名法" id="23" impl="NAMING-HN-23" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-23.rule"/>
            </rule>
            <rule header="输入流类型的参数和变量的匈牙利命名法" id="24" impl="NAMING-HN-24" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-24.rule"/>
            </rule>
            <rule header="长整型（long int）应该使用匈牙利命名法" id="25" impl="NAMING-HN-25" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-25.rule"/>
            </rule>
            <rule header="长双精度浮点类型的匈牙利命名法" id="26" impl="NAMING-HN-26" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-26.rule"/>
            </rule>
            <rule header="长双精度浮点指针,数组,或引用类型的匈牙利命名法" id="27" impl="NAMING-HN-27" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-27.rule"/>
            </rule>
            <rule header="长整型指针,数组或引用类型的匈牙利命名法" id="28" impl="NAMING-HN-28" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-28.rule"/>
            </rule>
            <rule header="成员变量应该使用匈牙利命名法" id="29" impl="NAMING-HN-29" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-29.rule"/>
            </rule>
            <rule header="整数(int)类型应该使用匈牙利命名法" id="30" impl="NAMING-HN-30" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-30.rule"/>
            </rule>
            <rule header="整型指针,数组,或引用类型的匈牙利命名法" id="31" impl="NAMING-HN-31" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-31.rule"/>
            </rule>
            <rule header="输出文件流类型的参数和变量的匈牙利命名法" id="32" impl="NAMING-HN-32" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-32.rule"/>
            </rule>
            <rule header="ostream 类型的参数和变量应该使用匈牙利命名法" id="33" impl="NAMING-HN-33" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-33.rule"/>
            </rule>
            <rule header="指针应该使用匈牙利命名法" id="34" impl="NAMING-HN-34" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-34.rule"/>
            </rule>
            <rule header="引用参数的匈牙利命名法" id="35" impl="NAMING-HN-35" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-35.rule"/>
            </rule>
            <rule header="短整型的匈牙利命名法" id="36" impl="NAMING-HN-36" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-36.rule"/>
            </rule>
            <rule header="短整型指针，数组或引用类型应该使用匈牙利命名法" id="37" impl="NAMING-HN-37" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-37.rule"/>
            </rule>
            <rule header="静态变量的匈牙利命名法" id="38" impl="NAMING-HN-38" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-38.rule"/>
            </rule>
            <rule header="字符串类型的匈牙利命名法" id="39" impl="NAMING-HN-39" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-39.rule"/>
            </rule>
            <rule header="字符串指针,数组,或引用类型的匈牙利命名法" id="40" impl="NAMING-HN-40" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-40.rule"/>
            </rule>
            <rule header="无符号类型应该使用匈牙利命名法" id="41" impl="NAMING-HN-41" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-41.rule"/>
            </rule>
            <rule header="void 指针类型应该使用匈牙利命名法" id="42" impl="NAMING-HN-42" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-42.rule"/>
            </rule>
            <rule header="字类型的匈牙利命名法" id="43" impl="NAMING-HN-43" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-43.rule"/>
            </rule>
            <rule header="字指针,数组,或引用类型的匈牙利命名法" id="44" impl="NAMING-HN-44" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-44.rule"/>
            </rule>
         </category>
         <rule header="C++ 的实现文件应该总是具有扩展名 &quot;.cpp&quot;" id="49" impl="NAMING-49" quickfix="false" scope="line" severity="4">
            <file path="NAMING\NAMING-49.rule"/>
         </rule>
         <rule header="具有重叠可见性的同一命名空间中的标识符应该是排版明确的" id="50" impl="NAMING-50" quickfix="false" scope="line" severity="4">
            <file path="NAMING\NAMING-50.rule"/>
         </rule>
      </category>
      <category description="最优化" name="OPT">
         <rule header="消除未使用的参数" id="03" impl="OPT-03" quickfix="false" scope="line" severity="2">
            <file path="OPT\OPT-03.rule"/>
         </rule>
         <rule header="如果变量不能被初始化为有意义的值就不应引入" id="26" impl="OPT-26" quickfix="false" scope="line" severity="2">
            <file path="OPT\OPT-26.rule"/>
         </rule>
         <rule header="尽可能地声明局部变量" id="01" impl="OPT-01" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-01.rule"/>
         </rule>
         <rule header="规范使用 ++ 和 --。尽量使用前缀形式" id="04" impl="OPT-04" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-04.rule"/>
         </rule>
         <rule header="避免使用未使用的私有成员变量" id="05" impl="OPT-05" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-05.rule"/>
         </rule>
         <rule header="尽量使用 &quot;a @= b&quot; 的形式，而不应使用 &quot;a = a @ b&quot;，其中 &quot;@&quot; 可以是 +, -, *, /, %" id="07" impl="OPT-07" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-07.rule"/>
         </rule>
         <rule header="尽量使用 &quot;a @= b&quot; 的形式，而不应使用 &quot;a = a @ b&quot;，其中 &quot;@&quot; 可以是 &amp;, |, ^, &lt;&lt;, &gt;&gt;" id="08" impl="OPT-08" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-08.rule"/>
         </rule>
         <rule header="不要在 &quot;if&quot;, &quot;for&quot;, &quot;while&quot;, 和 &quot;do while&quot; 语句中声明变量" id="10" impl="OPT-10" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-10.rule"/>
         </rule>
         <rule header="如果一个文件级的静态变量仅在一个函数中被使用/引用，就应该只在该函数内部包含此变量" id="11" impl="OPT-11" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-11.rule"/>
         </rule>
         <rule header="如果一个文件级的静态变量仅在一个类中被使用/引用，就应该只在该类内部包含此变量" id="12" impl="OPT-12" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-12.rule"/>
         </rule>
         <rule header="按照降序顺序声明成员变量" id="13" impl="OPT-13" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-13.rule"/>
         </rule>
         <rule header="引用而不是值传递对象" id="14" impl="OPT-14" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-14.rule"/>
         </rule>
         <rule header="使用重载以避免隐式类型转换" id="15" impl="OPT-15" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-15.rule"/>
         </rule>
         <rule header="不应内联包含递归、循环或虚函数调用的全局函数" id="16" impl="OPT-16" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-16.rule"/>
         </rule>
         <rule header="避免使用内联构造函数和析构函数" id="17" impl="OPT-17" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-17.rule"/>
         </rule>
         <rule header="含有递归、循环的成员函数不应定义为内联的" id="18" impl="OPT-18" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-18.rule"/>
         </rule>
         <rule header="使用 op= 而非单独的操作符" id="19" impl="OPT-19" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-19.rule"/>
         </rule>
         <rule header="尽可能推迟变量定义" id="20" impl="OPT-20" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-20.rule"/>
         </rule>
         <rule header="任何一个 switch 语句都至少有一个非空 case 子句" id="21" impl="OPT-21" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-21.rule"/>
         </rule>
         <rule header="不允许使用无用的 case 语句" id="22" impl="OPT-22" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-22.rule"/>
         </rule>
         <rule header="'strlen' 函数不应该用来检查字符串是否为 NULL/非NULL" id="28" impl="OPT-28" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-28.rule"/>
         </rule>
         <rule header="每个定义的具有内部链接的函数应该至少被使用一次" id="30" impl="OPT-30" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-30.rule"/>
         </rule>
         <rule header="非虚函数中不应存在未使用的参数（命名或未命名）" id="31" impl="OPT-31" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-31.rule"/>
         </rule>
         <rule header="所有具有 viod 返回类型的非空函数应该具有外部作用" id="32" impl="OPT-32" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-32.rule"/>
         </rule>
         <rule header="不要将变量赋值给它自己" id="35" impl="OPT-35" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-35.rule"/>
         </rule>
         <rule header="不要在变量的初始化器里使用它" id="36" impl="OPT-36" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-36.rule"/>
         </rule>
         <rule header="每一个 switch 语句应该含有至少两个 switch 子句" id="39" impl="OPT-39" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-39.rule"/>
         </rule>
         <rule header="在虚函数中不应有未使用的命名参数" id="42" impl="OPT-42" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-42.rule"/>
         </rule>
         <rule header="避免未使用的局部变量" id="02" impl="OPT-02" quickfix="false" scope="line" severity="4">
            <file path="OPT\OPT-02.rule"/>
         </rule>
         <rule header="避免使用不必要的局部变量" id="06" impl="OPT-06" quickfix="false" scope="line" severity="4">
            <file path="OPT\OPT-06.rule"/>
         </rule>
         <rule header="普通的访问器(accessor)和变值器(mutator)函数应该是内联的" id="23" impl="OPT-23" quickfix="false" scope="line" severity="4">
            <file path="OPT\OPT-23.rule"/>
         </rule>
         <rule header="应该内联普通的转发函数" id="24" impl="OPT-24" quickfix="false" scope="line" severity="4">
            <file path="OPT\OPT-24.rule"/>
         </rule>
         <rule header="应只将有 1 个或 2 个语句的函数考虑为内联函数的候选函数" id="25" impl="OPT-25" quickfix="false" scope="line" severity="4">
            <file path="OPT\OPT-25.rule"/>
         </rule>
         <rule header="应尽量减少 accessor/mutator 函数的数目" id="27" impl="OPT-27" quickfix="false" scope="line" severity="4">
            <file path="OPT\OPT-27.rule"/>
         </rule>
         <rule header="不允许冗余显式转换为同一类型" id="29" impl="OPT-29" quickfix="false" scope="line" severity="4">
            <file path="OPT\OPT-29.rule"/>
         </rule>
         <rule header="具有 void 返回值类型的函数不能为空" id="32_b" impl="OPT-32_b" quickfix="false" scope="line" severity="4">
            <file path="OPT\OPT-32_b.rule"/>
         </rule>
         <rule header="函数不应该包含未使用的标签声明" id="37" impl="OPT-37" quickfix="false" scope="line" severity="4">
            <file path="OPT\OPT-37.rule"/>
         </rule>
         <rule header="在函数中不应该有未使用的参数" id="38" impl="OPT-38" quickfix="false" scope="line" severity="4">
            <file path="OPT\OPT-38.rule"/>
         </rule>
         <rule header="if-else-if 链的两个分支具有相同的代码（预处理之后）" id="40_a" impl="OPT-40_a" quickfix="false" scope="line" severity="4">
            <file path="OPT\OPT-40_a.rule"/>
         </rule>
         <rule header="在switch语句的不同子句中使用了相同的代码（预处理之后）" id="40_b" impl="OPT-40_b" quickfix="false" scope="line" severity="4">
            <file path="OPT\OPT-40_b.rule"/>
         </rule>
         <rule header="文件应该只包含(include)具有编译该文件所需的声明和定义的头文件" id="41" impl="OPT-41" quickfix="false" scope="line" severity="4">
            <file path="OPT\OPT-41.rule"/>
         </rule>
         <rule header="项目不应包含有内部链接的未使用变量" id="43" impl="OPT-43" quickfix="false" scope="line" severity="4">
            <file path="OPT\OPT-43.rule"/>
         </rule>
         <rule header="删除不必要的 '== true'" id="09" impl="OPT-09" quickfix="false" scope="line" severity="5">
            <file path="OPT\OPT-09.rule"/>
         </rule>
         <rule header="考虑通过引用而不是值来返回对象" id="33" impl="OPT-33" quickfix="false" scope="line" severity="5">
            <file path="OPT\OPT-33.rule"/>
         </rule>
      </category>
      <category description="OWASP 10 项最严重的  Web 应用程序安全风险 (2017)" name="OWASP2017">
         <category description="OWASP A10 记录&amp;监控不足风险" name="A10">
            <rule header="所有的异常应该重新抛出，或者用标准的日志记录器进行记录" id="a" impl="EXCEPT-04" originalId="EXCEPT-04" quickfix="false" scope="line" severity="2">
               <file path="EXCEPT\EXCEPT-04.rule"/>
            </rule>
         </category>
         <category description="OWASP A2 失效的身份验证" name="A2">
            <rule header="请勿使用弱加密功能" id="a" impl="SECURITY-37" originalId="SECURITY-37" quickfix="false" scope="line" severity="2">
               <file path="SECURITY\SECURITY-37.rule"/>
            </rule>
         </category>
         <category description="OWASP A5 失效的访问控制" name="A5">
            <rule header="在放弃特权时遵守正确的撤销命令" id="b" impl="SECURITY-44" originalId="SECURITY-44" quickfix="false" scope="line" severity="3">
               <file path="SECURITY\SECURITY-44.rule"/>
            </rule>
            <rule header="确保成功地放弃特权" id="c" impl="SECURITY-45" originalId="SECURITY-45" quickfix="false" scope="line" severity="3">
               <file path="SECURITY\SECURITY-45.rule"/>
            </rule>
         </category>
         <category description="OWASP A6 安全配置错误" name="A6">
            <rule header="如果在一个 try-catch 语句或函数 try-block 中为派生类及其部分或全部基类提供多个处理程序，则应将派生程度最高的处理程序排序为派生程度最高的基类" id="a" impl="EXCEPT-17" originalId="EXCEPT-17" quickfix="false" scope="line" severity="3">
               <file path="EXCEPT\EXCEPT-17.rule"/>
            </rule>
            <rule header="不要让 'catch' 块为空" id="b" impl="EXCEPT-25" originalId="EXCEPT-25" quickfix="false" scope="line" severity="3">
               <file path="EXCEPT\EXCEPT-25.rule"/>
            </rule>
         </category>
      </category>
      <category description="OWASP 10 项 API 安全风险（2019）" name="OWASP2019">
         <category description="OWASP API10 日志记录不足；监听" name="API10">
            <rule header="所有的异常应该重新抛出，或者用标准的日志记录器进行记录" id="a" impl="EXCEPT-04" originalId="EXCEPT-04" quickfix="false" scope="line" severity="2">
               <file path="EXCEPT\EXCEPT-04.rule"/>
            </rule>
            <rule header="不能将 'syslog' 函数用于日志记录目的" id="b" impl="SECURITY-21" originalId="SECURITY-21" quickfix="false" scope="line" severity="2">
               <file path="SECURITY\SECURITY-21.rule"/>
            </rule>
         </category>
         <category description="OWASP API2 损坏的用户身份验证" name="API2">
            <rule header="请勿使用弱加密功能" id="a" impl="SECURITY-37" originalId="SECURITY-37" quickfix="false" scope="line" severity="2">
               <file path="SECURITY\SECURITY-37.rule"/>
            </rule>
         </category>
         <category description="OWASP API3 数据泄露过多" name="API3">
            <rule header="不要将应用程序错误导致的潜在敏感信息打印到异常消息中" id="p" impl="SECURITY-15" originalId="SECURITY-15" quickfix="false" scope="line" severity="2">
               <file path="SECURITY\SECURITY-15.rule"/>
            </rule>
            <rule header="避免使用 MFC 库中的时间函数" id="o" impl="SECURITY-06" originalId="SECURITY-06" quickfix="false" scope="line" severity="3">
               <file path="SECURITY\SECURITY-06.rule"/>
            </rule>
            <rule header="不应将指向结构体的指针传递给可将数据复制到用户空间的函数" id="q" impl="SECURITY-46" originalId="SECURITY-46" quickfix="false" scope="line" severity="3">
               <file path="SECURITY\SECURITY-46.rule"/>
            </rule>
            <rule header="限制使用系统属性（环境变量）" id="n" impl="SECURITY-03" originalId="SECURITY-03" quickfix="false" scope="line" severity="4">
               <file path="SECURITY\SECURITY-03.rule"/>
            </rule>
         </category>
         <category description="OWASP API8 注入" name="API8">
            <rule header="谨慎使用以确保 LoadLibrary() 加载正确的库" id="h" impl="SECURITY-04" originalId="SECURITY-04" quickfix="false" scope="line" severity="2">
               <file path="SECURITY\SECURITY-04.rule"/>
            </rule>
            <rule header="避免将动态生成的字符串传递给 exec" id="i" impl="SECURITY-18" originalId="SECURITY-18" quickfix="false" scope="line" severity="2">
               <file path="SECURITY\SECURITY-18.rule"/>
            </rule>
            <rule header="避免将用户的输入作为参数传递给方法" id="j" impl="SECURITY-20" originalId="SECURITY-20" quickfix="false" scope="line" severity="2">
               <file path="SECURITY\SECURITY-20.rule"/>
            </rule>
         </category>
         <category description="OWASP API7 安全性配置错误" name="API7">
            <rule header="如果在一个 try-catch 语句或函数 try-block 中为派生类及其部分或全部基类提供多个处理程序，则应将派生程度最高的处理程序排序为派生程度最高的基类" id="b" impl="EXCEPT-17" originalId="EXCEPT-17" quickfix="false" scope="line" severity="3">
               <file path="EXCEPT\EXCEPT-17.rule"/>
            </rule>
            <rule header="不要让 'catch' 块为空" id="c" impl="EXCEPT-25" originalId="EXCEPT-25" quickfix="false" scope="line" severity="3">
               <file path="EXCEPT\EXCEPT-25.rule"/>
            </rule>
         </category>
         <category description="OWASP API9 资产管理不当" name="API9">
            <rule header="应该注释说明所有汇编程序的使用" id="c" impl="COMMENT-09" originalId="COMMENT-09" quickfix="false" scope="line" severity="3">
               <file path="COMMENT\COMMENT-09.rule"/>
            </rule>
            <rule header="使用对浮点运算注释说明" id="d" impl="COMMENT-10" originalId="COMMENT-10" quickfix="false" scope="line" severity="3">
               <file path="COMMENT\COMMENT-10.rule"/>
            </rule>
            <rule header="使用 #pragma 指令必须进行注释并说明" id="g" impl="MISRA2004-3_4" originalId="MISRA2004-3_4" quickfix="false" scope="line" severity="3">
               <file path="MISRA2004\MISRA2004-3_4.rule"/>
            </rule>
            <rule header="应该在头文件中声明具有外部链接的对象或函数" id="e" impl="MISRA-023" originalId="MISRA-023" quickfix="false" scope="line" severity="4">
               <file path="MISRA\MISRA-023.rule"/>
            </rule>
            <rule header="广泛地使用断言证明内部假设和不变式" id="a" impl="CODSTA-11" originalId="CODSTA-11" quickfix="false" scope="line" severity="5">
               <file path="CODSTA\CODSTA-11.rule"/>
            </rule>
            <rule header="当使用枚举类型 enum 时，必须显式声明每个成员的值" id="b" impl="CODSTA-21" originalId="CODSTA-21" quickfix="false" scope="line" severity="5">
               <file path="CODSTA\CODSTA-21.rule"/>
            </rule>
            <rule header="文件整数除法" id="f" impl="MISRA-041" originalId="MISRA-041" quickfix="false" scope="line" severity="5">
               <file path="MISRA\MISRA-041.rule"/>
            </rule>
         </category>
      </category>
      <category description="OWASP 10 项最关键的  Web 应用程序安全风险（2021 年）" name="OWASP2021">
         <category description="OWASP A7 识别和认证失败" name="A7">
            <rule header="请勿使用弱加密功能" id="a" impl="SECURITY-37" originalId="SECURITY-37" quickfix="false" scope="line" severity="2">
               <file path="SECURITY\SECURITY-37.rule"/>
            </rule>
         </category>
         <category description="OWASP A8 软件和数据完整性故障" name="A8">
            <rule header="谨慎使用以确保 LoadLibrary() 加载正确的库" id="a" impl="SECURITY-04" originalId="SECURITY-04" quickfix="false" scope="line" severity="2">
               <file path="SECURITY\SECURITY-04.rule"/>
            </rule>
         </category>
         <category description="OWASP A9 安全日志记录和监控失败" name="A9">
            <rule header="所有的异常应该重新抛出，或者用标准的日志记录器进行记录" id="a" impl="EXCEPT-04" originalId="EXCEPT-04" quickfix="false" scope="line" severity="2">
               <file path="EXCEPT\EXCEPT-04.rule"/>
            </rule>
         </category>
         <category description="OWASP A1 损坏的访问控制" name="A1">
            <rule header="在放弃特权时遵守正确的撤销命令" id="b" impl="SECURITY-44" originalId="SECURITY-44" quickfix="false" scope="line" severity="3">
               <file path="SECURITY\SECURITY-44.rule"/>
            </rule>
            <rule header="确保成功地放弃特权" id="c" impl="SECURITY-45" originalId="SECURITY-45" quickfix="false" scope="line" severity="3">
               <file path="SECURITY\SECURITY-45.rule"/>
            </rule>
         </category>
         <category description="OWASP A5 安全配置错误" name="A5">
            <rule header="如果在一个 try-catch 语句或函数 try-block 中为派生类及其部分或全部基类提供多个处理程序，则应将派生程度最高的处理程序排序为派生程度最高的基类" id="a" impl="EXCEPT-17" originalId="EXCEPT-17" quickfix="false" scope="line" severity="3">
               <file path="EXCEPT\EXCEPT-17.rule"/>
            </rule>
            <rule header="不要让 'catch' 块为空" id="b" impl="EXCEPT-25" originalId="EXCEPT-25" quickfix="false" scope="line" severity="3">
               <file path="EXCEPT\EXCEPT-25.rule"/>
            </rule>
         </category>
      </category>
      <category description="可移植性" name="PORT">
         <rule header="不能在结构体中使用硬编码的数值作为偏移量" id="03" impl="PORT-03" quickfix="false" scope="line" severity="2">
            <file path="PORT\PORT-03.rule"/>
         </rule>
         <rule header="不要使用十六进制常数 '0xffffffff' 作为一个错误标识符" id="04" impl="PORT-04" quickfix="false" scope="line" severity="2">
            <file path="PORT\PORT-04.rule"/>
         </rule>
         <rule header="指向 long 的指针不能强制转换成指向int型的指针" id="05" impl="PORT-05" quickfix="false" scope="line" severity="2">
            <file path="PORT\PORT-05.rule"/>
         </rule>
         <rule header="不能将整型指针强制类型转化成长整型指针" id="11" impl="PORT-11" quickfix="false" scope="line" severity="2">
            <file path="PORT\PORT-11.rule"/>
         </rule>
         <rule header="算法中不应假设由访问标识符分隔的非静态数据成员的分配顺序" id="26" impl="PORT-26" quickfix="false" scope="line" severity="2">
            <file path="PORT\PORT-26.rule"/>
         </rule>
         <rule header="如果将整型操作的结果赋值给 long，其中至少一个整型必须强制转换成 long" id="02" impl="PORT-02" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-02.rule"/>
         </rule>
         <rule header="不能将长整型赋值给整型" id="06" impl="PORT-06" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-06.rule"/>
         </rule>
         <rule header="不能在函数调用中将 long 类型强制转换后传递给整型" id="07" impl="PORT-07" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-07.rule"/>
         </rule>
         <rule header="对 long 的常量赋值不应涉及 int 字面量" id="08" impl="PORT-08" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-08.rule"/>
         </rule>
         <rule header="不能使用整型直接初始化长整型" id="10" impl="PORT-10" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-10.rule"/>
         </rule>
         <rule header="不能将 32 位乘法运算的数值赋值给长整型" id="12" impl="PORT-12" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-12.rule"/>
         </rule>
         <rule header="整型 int 类型必须声明为无符号整型或者有符号整型" id="13" impl="PORT-13" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-13.rule"/>
         </rule>
         <rule header="避免在赋值操作中从&quot;短&quot;(&quot;shorter&quot;)的类型转换成&quot;长&quot;(&quot;longer&quot;)的类型" id="14" impl="PORT-14" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-14.rule"/>
         </rule>
         <rule header="不能将 &quot;短&quot;(&quot;shorter&quot;) 类型强制转换成 &quot;长&quot;(&quot;longer&quot;) 类型" id="15" impl="PORT-15" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-15.rule"/>
         </rule>
         <rule header="避免在函数调用中从&quot;短&quot;(&quot;shorter&quot;)的类型转换成&quot;长&quot;(&quot;longer&quot;)的类型" id="16" impl="PORT-16" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-16.rule"/>
         </rule>
         <rule header="不能直接使用 'i64' 或者 'L' 后缀" id="17" impl="PORT-17" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-17.rule"/>
         </rule>
         <rule header="不要在表达式中将长类型操作符强制转换成整型，将表达式的结果进行强制转换" id="19" impl="PORT-19" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-19.rule"/>
         </rule>
         <rule header="不能直接声明长整型的变量" id="20" impl="PORT-20" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-20.rule"/>
         </rule>
         <rule header="不能将长整型赋值给双精度浮点型" id="21" impl="PORT-21" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-21.rule"/>
         </rule>
         <rule header="标识符名称不得超过 64 个字符" id="25" impl="PORT-25" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-25.rule"/>
         </rule>
         <rule header="避免隐式转换为一种更窄的类型" id="27" impl="PORT-27" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-27.rule"/>
         </rule>
         <rule header="避免将常量值转换为一个窄类型" id="28" impl="PORT-28" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-28.rule"/>
         </rule>
         <rule header="指向结构体的指针不应该传递给向文件写入数据的函数" id="29" impl="PORT-29" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-29.rule"/>
         </rule>
         <rule header="不应使用长双精度浮点型" id="32" impl="PORT-32" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-32.rule"/>
         </rule>
         <rule header="不应使用 wchar_t 类型" id="33" impl="PORT-33" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-33.rule"/>
         </rule>
         <rule header="用户指定的 C++ 外部标识符的前 64 个字符应不同" id="34_a" impl="PORT-34_a" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-34_a.rule"/>
         </rule>
         <rule header="用户指定的 C++ 内部标识符应与前 64 个字符中的外部标识符不同" id="34_b" impl="PORT-34_b" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-34_b.rule"/>
         </rule>
         <rule header="在相同范围内声明的用户指定的 C++ 内部标识符的前64个字符应不同" id="34_c" impl="PORT-34_c" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-34_c.rule"/>
         </rule>
         <rule header="用户指定的 C 外部标识符的前 31 个字符应不同" id="35_a" impl="PORT-35_a" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-35_a.rule"/>
         </rule>
         <rule header="用户指定的C内部标识符应与前31个字符中的外部标识符不同" id="35_b" impl="PORT-35_b" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-35_b.rule"/>
         </rule>
         <rule header="在相同范围内声明的用户指定的C内部标识符的前31个字符应不同" id="35_c" impl="PORT-35_c" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-35_c.rule"/>
         </rule>
         <rule header="标识符名称不得超过31个字符" id="36_a" impl="PORT-36_a" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-36_a.rule"/>
         </rule>
         <rule header="宏标识符的名称不能超过31个字符" id="36_b" impl="PORT-36_b" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-36_b.rule"/>
         </rule>
         <rule header="不要越过执行边界抛出异常" id="30" impl="PORT-30" quickfix="false" scope="line" severity="4">
            <file path="PORT\PORT-30.rule"/>
         </rule>
         <rule header="不要跨越执行边界传递非标准布局类型的对象" id="31" impl="PORT-31" quickfix="false" scope="line" severity="4">
            <file path="PORT\PORT-31.rule"/>
         </rule>
         <rule header="使用大写 'L' 而非小写 'l' 来指定长整型" id="01" impl="PORT-01" quickfix="false" scope="line" severity="5">
            <file path="PORT\PORT-01.rule"/>
         </rule>
         <rule header="使用整型数组而非使用长整型的大数组" id="22" impl="PORT-22" quickfix="false" scope="line" severity="5">
            <file path="PORT\PORT-22.rule"/>
         </rule>
         <rule header="使用整型数组而非使用动态分配的长整型的大数组" id="23" impl="PORT-23" quickfix="false" scope="line" severity="5">
            <file path="PORT\PORT-23.rule"/>
         </rule>
         <rule header="不能使用指向布尔、字符、短整型、整型和单精度浮点类型的指针的大数组" id="24" impl="PORT-24" quickfix="false" scope="line" severity="5">
            <file path="PORT\PORT-24.rule"/>
         </rule>
      </category>
      <category description="预处理" name="PREPROC">
         <rule header="不应在 include 语句中使用宏" id="02" impl="PREPROC-02" quickfix="false" scope="line" severity="2">
            <file path="PREPROC\PREPROC-02.rule"/>
         </rule>
         <rule header="在宏函数中，应使用括号将乘法和除法操作括起来" id="05" impl="PREPROC-05" quickfix="false" scope="line" severity="2">
            <file path="PREPROC\PREPROC-05.rule"/>
         </rule>
         <rule header="在 #include 语句中不允许绝对或相对路径名" id="06" impl="PREPROC-06" quickfix="false" scope="line" severity="2">
            <file path="PREPROC\PREPROC-06.rule"/>
         </rule>
         <rule header="#include 指令只能使用 &lt;filename.h&gt; 符号来包含头文件" id="09" impl="PREPROC-09" quickfix="false" scope="line" severity="2">
            <file path="PREPROC\PREPROC-09.rule"/>
         </rule>
         <rule header="避免使用宏定义" id="01" impl="PREPROC-01" quickfix="false" scope="line" severity="3">
            <file path="PREPROC\PREPROC-01.rule"/>
         </rule>
         <rule header="仅可以在包含头文件(*.h)时使用 #include 预处理指令" id="08" impl="PREPROC-08" quickfix="false" scope="line" severity="3">
            <file path="PREPROC\PREPROC-08.rule"/>
         </rule>
         <rule header="#ifndef 程序预处理指示字仅用于防止相同头文件的多个 inclusion" id="10" impl="PREPROC-10" quickfix="false" scope="line" severity="3">
            <file path="PREPROC\PREPROC-10.rule"/>
         </rule>
         <rule header="#endif 程序预处理指示字将仅用于防止同一头文件多个包含" id="10_b" impl="PREPROC-10_b" quickfix="false" scope="line" severity="3">
            <file path="PREPROC\PREPROC-10_b.rule"/>
         </rule>
         <rule header="#if 程序预处理指示字仅用于防止相同头文件的多个 inclusion" id="10_c" impl="PREPROC-10_c" quickfix="false" scope="line" severity="3">
            <file path="PREPROC\PREPROC-10_c.rule"/>
         </rule>
         <rule header="不应使用 #ifdef, #else, #elif 程序预处理指示字" id="11" impl="PREPROC-11" quickfix="false" scope="line" severity="3">
            <file path="PREPROC\PREPROC-11.rule"/>
         </rule>
         <rule header="不应使用 #if 程序预处理指示字" id="11_b" impl="PREPROC-11_b" quickfix="false" scope="line" severity="3">
            <file path="PREPROC\PREPROC-11_b.rule"/>
         </rule>
         <rule header="C++ 宏应该只能用于包含保护(include guards)，类型修饰符，或存储类限定符" id="12" impl="PREPROC-12" quickfix="false" scope="line" severity="3">
            <file path="PREPROC\PREPROC-12.rule"/>
         </rule>
         <rule header="宏不应该包含标记(token)粘贴，变量参数列表，也不包括递归宏调用" id="13" impl="PREPROC-13" quickfix="false" scope="line" severity="3">
            <file path="PREPROC\PREPROC-13.rule"/>
         </rule>
         <rule header="所有宏必须扩展到完整的句法单位" id="14" impl="PREPROC-14" quickfix="false" scope="line" severity="3">
            <file path="PREPROC\PREPROC-14.rule"/>
         </rule>
         <rule header="指针解引用操作不应该被隐藏在宏定义中" id="15" impl="PREPROC-15" quickfix="false" scope="line" severity="3">
            <file path="PREPROC\PREPROC-15.rule"/>
         </rule>
         <rule header="一个紧跟在 # 操作符的宏参数不应该在其后紧跟或在其前加上 ## 操作符" id="16" impl="PREPROC-16" quickfix="false" scope="line" severity="3">
            <file path="PREPROC\PREPROC-16.rule"/>
         </rule>
         <rule header="不应该包含标准输入/输出库 stdio.h" id="18" impl="PREPROC-18" quickfix="false" scope="line" severity="3">
            <file path="PREPROC\PREPROC-18.rule"/>
         </rule>
         <rule header="#if 或 #elif 预处理指令的控制表达式应评估为 0 或 1" id="19" impl="PREPROC-19" quickfix="false" scope="line" severity="3">
            <file path="PREPROC\PREPROC-19.rule"/>
         </rule>
         <rule header="将 #include 指令中的文件名匹配到文件系统上的文件名" id="20" impl="PREPROC-20" quickfix="false" scope="line" severity="3">
            <file path="PREPROC\PREPROC-20.rule"/>
         </rule>
         <rule header="不应使用 #error 指令" id="22" impl="PREPROC-22" quickfix="false" scope="line" severity="3">
            <file path="PREPROC\PREPROC-22.rule"/>
         </rule>
         <rule header="不应使用 #pragma 指令" id="23" impl="PREPROC-23" quickfix="false" scope="line" severity="3">
            <file path="PREPROC\PREPROC-23.rule"/>
         </rule>
         <rule header="除 #ifdef 和 #ifndef 预处理器指令和 defined() 操作符外，预处理指令中的所有宏标识符都应在使用前定义" id="24" impl="PREPROC-24" quickfix="false" scope="line" severity="3">
            <file path="PREPROC\PREPROC-24.rule"/>
         </rule>
         <rule header="不应使用 #undef" id="25" impl="PREPROC-25" quickfix="false" scope="line" severity="3">
            <file path="PREPROC\PREPROC-25.rule"/>
         </rule>
         <rule header="#ifndef、#ifdef、#if、#elif、#else 和 #endif 预处理器指令只能用于条件文件包含和包含保护" id="26" impl="PREPROC-26" quickfix="false" scope="line" severity="3">
            <file path="PREPROC\PREPROC-26.rule"/>
         </rule>
         <rule header="不要在 #undef 指令中使用'bool'、'false'或'true'标识符" id="27" impl="PREPROC-27" quickfix="false" scope="line" severity="3">
            <file path="PREPROC\PREPROC-27.rule"/>
         </rule>
         <rule header="不能重定义原始类型" id="03" impl="PREPROC-03" quickfix="false" scope="line" severity="4">
            <file path="PREPROC\PREPROC-03.rule"/>
         </rule>
         <rule header="不能只定义一部分语句" id="04" impl="PREPROC-04" quickfix="false" scope="line" severity="4">
            <file path="PREPROC\PREPROC-04.rule"/>
         </rule>
         <rule header="一个被用作 # 或者 ## 操作符的操作数的宏参数，并且它本身受制于进一步的宏替换，那么它应该只能被用作这些操作符的操作数" id="17" impl="PREPROC-17" quickfix="false" scope="line" severity="4">
            <file path="PREPROC\PREPROC-17.rule"/>
         </rule>
         <rule header="不正确的 'NULL' 定义" id="07" impl="PREPROC-07" quickfix="false" scope="line" severity="5">
            <file path="PREPROC\PREPROC-07.rule"/>
         </rule>
         <rule header="避免产生通用字符名称的占位符串联" id="21" impl="PREPROC-21" quickfix="false" scope="line" severity="5">
            <file path="PREPROC\PREPROC-21.rule"/>
         </rule>
      </category>
      <category description="代码格式" name="FORMAT">
         <rule header="将左边大括号 '{' 置于单独的行上" id="02" impl="FORMAT-02" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-02.rule"/>
         </rule>
         <rule header="将右闭大括号 '}' 置于单独的行上" id="03" impl="FORMAT-03" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-03.rule"/>
         </rule>
         <rule header="单行字符应该不超过 80 个" id="04" impl="FORMAT-04" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-04.rule"/>
         </rule>
         <rule header="宏的长度不能超过 10 行" id="05" impl="FORMAT-05" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-05.rule"/>
         </rule>
         <rule header="每行只允许一个语句" id="06" impl="FORMAT-06" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-06.rule"/>
         </rule>
         <rule header="在赋值运算符之前应该有且仅有一个 ASCII 空格字符" id="07" impl="FORMAT-07" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-07.rule"/>
         </rule>
         <rule header="在赋值运算符之后应该有且仅有一个 ASCII 空格字符" id="08" impl="FORMAT-08" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-08.rule"/>
         </rule>
         <rule header="在位运算符之前应该有且仅有一个 ASCII 空格字符" id="09" impl="FORMAT-09" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-09.rule"/>
         </rule>
         <rule header="在位运算符之后应该有且仅有一个 ASCII 空格字符" id="10" impl="FORMAT-10" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-10.rule"/>
         </rule>
         <rule header="在位运算符 '&amp;'前后应该有且仅有一个 ASCII 空格字符" id="11" impl="FORMAT-11" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-11.rule"/>
         </rule>
         <rule header="在条件语句的关键字和左括号之间应该有且仅有一个 ASCII 空格字符" id="12" impl="FORMAT-12" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-12.rule"/>
         </rule>
         <rule header="在条件语句的开括号之后最多只能有一个 ASCII 的空格字符" id="13" impl="FORMAT-13" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-13.rule"/>
         </rule>
         <rule header="在三元条件操作符之前只能有一个 ASCII 的空格字符" id="14" impl="FORMAT-14" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-14.rule"/>
         </rule>
         <rule header="在三元条件操作符之后只能有一个 ASCII 的空格字符" id="15" impl="FORMAT-15" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-15.rule"/>
         </rule>
         <rule header="在关系和相等运算符前后只能有一个 ASCII 的空格字符" id="16" impl="FORMAT-16" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-16.rule"/>
         </rule>
         <rule header="在 '.' 或 '-&gt;' 操作符之后不能有空白格" id="17" impl="FORMAT-17" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-17.rule"/>
         </rule>
         <rule header="在 '.' 或 '-&gt;' 操作符之前不能有空白格" id="18" impl="FORMAT-18" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-18.rule"/>
         </rule>
         <rule header="在所有逗号后应该有且仅有一个 ASCII 的空格字符" id="19" impl="FORMAT-19" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-19.rule"/>
         </rule>
         <rule header="在所有分号后应该有且仅有一个 ASCII 的空格字符" id="20" impl="FORMAT-20" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-20.rule"/>
         </rule>
         <rule header="在一元运算符 &quot;!&quot; 或 &quot;~&quot; 及其操作数之间不能有空格" id="21" impl="FORMAT-21" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-21.rule"/>
         </rule>
         <rule header="在自增/自减运算符 (++/--) 和其操作数之间不能有空格" id="22" impl="FORMAT-22" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-22.rule"/>
         </rule>
         <rule header="在 'return' 返回语句或 'sizeof' 运算符和以下左括号间不能有空格" id="23" impl="FORMAT-23" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-23.rule"/>
         </rule>
         <rule header="在打开 '(' 之后和关闭 ')' 括号之前不应有空格，这些括号包含 'return' 语句或 'sizeof' 运算符的操作数" id="24" impl="FORMAT-24" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-24.rule"/>
         </rule>
         <rule header="'sizeof' 运算符的操作数应括在括号中" id="25" impl="FORMAT-25" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-25.rule"/>
         </rule>
         <rule header="&quot;return&quot; 语句应该使用括号" id="25_b" impl="FORMAT-25_b" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-25_b.rule"/>
         </rule>
         <rule header="在逻辑运算符的前后应该有且仅有一个 ASCII 空格字符" id="26" impl="FORMAT-26" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-26.rule"/>
         </rule>
         <rule header="代码行以每一级四个空格缩进" id="27" impl="FORMAT-27" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-27.rule"/>
         </rule>
         <rule header="在函数的定义中，函数返回类型应该直接写在函数名称前面的单独一行上" id="28" impl="FORMAT-28" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-28.rule"/>
         </rule>
         <rule header="不允许在同一行声明多个变量" id="29" impl="FORMAT-29" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-29.rule"/>
         </rule>
         <rule header="在函数名后直接写左括号" id="30" impl="FORMAT-30" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-30.rule"/>
         </rule>
         <rule header="条件表达式中单独进行逻辑判断" id="31" impl="FORMAT-31" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-31.rule"/>
         </rule>
         <rule header="每个变量都要在单独的声明语句中被声明" id="33" impl="FORMAT-33" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-33.rule"/>
         </rule>
         <rule header="包含一个区域的括号 &quot;{}&quot; 应该放置在同一列" id="34" impl="FORMAT-34" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-34.rule"/>
         </rule>
         <rule header="在函数声明的时候，前括号和第一个形参应该于函数名写在同一行上" id="35" impl="FORMAT-35" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-35.rule"/>
         </rule>
         <rule header="同级语句行应该缩进到相同的位置" id="36" impl="FORMAT-36" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-36.rule"/>
         </rule>
         <rule header="控制语句块的第一行应该比控制语句关键字缩进更多" id="37" impl="FORMAT-37" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-37.rule"/>
         </rule>
         <rule header="当函数的形参超过两个的时候，前括号和第一个参数应该和函数名写在一行,其他参数应该再单独一行写一个" id="38" impl="FORMAT-38" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-38.rule"/>
         </rule>
         <rule header="用于包住一个代码模块的括号 (&quot;{}&quot;) 在同一行上除了注释以外不应该有其它代码" id="42" impl="FORMAT-42" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-42.rule"/>
         </rule>
         <rule header="大括号 (&quot;{}&quot;) 将把一个块放在同一列中" id="43" impl="FORMAT-43" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-43.rule"/>
         </rule>
         <rule header="用于包住一个代码模块的括号 (&quot;{}&quot;) 不允许在 &quot;{&quot; 之后或 &quot;}&quot; 之前有空行" id="44" impl="FORMAT-44" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-44.rule"/>
         </rule>
         <rule header="在一元运算符 &quot;&amp;&quot;, &quot;*&quot;, &quot;+&quot;, &quot;-&quot; 及其操作数之间不能有空格" id="45" impl="FORMAT-45" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-45.rule"/>
         </rule>
         <rule header="在宏定义中的自增/自减运算符 (++/--) 及其操作数之间不能有空格" id="46" impl="FORMAT-46" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-46.rule"/>
         </rule>
         <rule header="将CV限定词放在其适用类型的右侧" id="47_a" impl="FORMAT-47_a" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-47_a.rule"/>
         </rule>
         <rule header="CV 限定符应放置在类型为声明类型(typedef)或使用名称(using name)的右侧" id="47_b" impl="FORMAT-47_b" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-47_b.rule"/>
         </rule>
         <rule header="函数声明中的参数名不应该括在括号中" id="48" impl="FORMAT-48" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-48.rule"/>
         </rule>
         <rule header="变量声明中的局部变量名不应该用括号括起来" id="49" impl="FORMAT-49" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-49.rule"/>
         </rule>
         <rule header="解引用运算符 '*' 和地址运算符 '&amp;' 应直接与类型连接在一起" id="32" impl="FORMAT-32" quickfix="false" scope="line" severity="4">
            <file path="FORMAT\FORMAT-32.rule"/>
         </rule>
         <rule header="按字母顺序排序 #include 指令" id="39" impl="FORMAT-39" quickfix="false" scope="line" severity="4">
            <file path="FORMAT\FORMAT-39.rule"/>
         </rule>
         <rule header="禁止使用未用 ASCII 空格的制表符" id="01" impl="FORMAT-01" quickfix="false" scope="line" severity="5">
            <file path="FORMAT\FORMAT-01.rule"/>
         </rule>
         <rule header="空格在开始方括号 '[' 之后和结束方括号 ']' 之前的使用方式应该保持一致" id="40" impl="FORMAT-40" quickfix="false" scope="line" severity="5">
            <file path="FORMAT\FORMAT-40.rule"/>
         </rule>
         <rule header="在开始方括号 '[' 和前面的标识符之间不应该有空格" id="41" impl="FORMAT-41" quickfix="false" scope="line" severity="5">
            <file path="FORMAT\FORMAT-41.rule"/>
         </rule>
      </category>
      <category description="度量指标" name="METRICS">
         <rule header="函数内的代码块" id="03" impl="METRICS-03" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-03.rule"/>
         </rule>
         <rule header="函数中有过多函数调用" id="04" impl="METRICS-04" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-04.rule"/>
         </rule>
         <rule header="类的继承级别" id="05" impl="METRICS-05" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-05.rule"/>
         </rule>
         <rule header="每个函数的成员变量数不应该超过 15个" id="06" impl="METRICS-06" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-06.rule"/>
         </rule>
         <rule header="每个类的方法数" id="07" impl="METRICS-07" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-07.rule"/>
         </rule>
         <rule header="每个方法参数不应该超过10" id="08" impl="METRICS-08" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-08.rule"/>
         </rule>
         <rule header="每个类的私有成员变量数目" id="09" impl="METRICS-09" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-09.rule"/>
         </rule>
         <rule header="每个类的私有方法数" id="10" impl="METRICS-10" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-10.rule"/>
         </rule>
         <rule header="每个类的 protected 成员变量数" id="11" impl="METRICS-11" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-11.rule"/>
         </rule>
         <rule header="每个类的 protected 方法的数量" id="12" impl="METRICS-12" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-12.rule"/>
         </rule>
         <rule header="每个类的公共成员变量数目" id="13" impl="METRICS-13" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-13.rule"/>
         </rule>
         <rule header="每个类的公共方法数目" id="14" impl="METRICS-14" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-14.rule"/>
         </rule>
         <rule header="避免函数的参数数目超过5个" id="15" impl="METRICS-15" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-15.rule"/>
         </rule>
         <rule header="宏参数应该不超过 5个" id="16" impl="METRICS-16" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-16.rule"/>
         </rule>
         <rule header="将圈复杂度限制在 10 之内" id="18" impl="METRICS-18" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-18.rule"/>
         </rule>
         <rule header="注释行占模块行总数的百分比应该在 20 到 60 之间" id="19" impl="METRICS-19" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-19.rule"/>
         </rule>
         <rule header="避免太长的函数声明和代码段" id="20" impl="METRICS-20" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-20.rule"/>
         </rule>
         <rule header="避免太长的函数块" id="21" impl="METRICS-21" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-21.rule"/>
         </rule>
         <rule header="避免函数的行数超过75行" id="22" impl="METRICS-22" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-22.rule"/>
         </rule>
         <rule header="嵌套块深度不应高于 5" id="23" impl="METRICS-23" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-23.rule"/>
         </rule>
         <rule header="任何函数或方法应该不包含超过200行的逻辑代码行数 (L-SLOC)" id="25" impl="METRICS-25" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-25.rule"/>
         </rule>
         <rule header="源代码行的长度不得超过120个字符" id="26" impl="METRICS-26" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-26.rule"/>
         </rule>
         <rule header="不要使用多于 7 个参数的函数" id="27" impl="METRICS-27" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-27.rule"/>
         </rule>
         <rule header="限制圈复杂度在 20 之内" id="28" impl="METRICS-28" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-28.rule"/>
         </rule>
         <rule header="函数不应该超过 60 行代码" id="30" impl="METRICS-30" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-30.rule"/>
         </rule>
         <rule header="代码的断言密度应至少平均每个函数两个断言" id="31" impl="METRICS-31" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-31.rule"/>
         </rule>
         <rule header="所有超过 20 行的函数应该包含至少两个断言" id="32" impl="METRICS-32" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-32.rule"/>
         </rule>
         <rule header="不应从超过 5 个的不同函数中调用全局函数" id="36" impl="METRICS-36" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-36.rule"/>
         </rule>
         <rule header="函数不得调用超过 7 个不同的函数" id="37" impl="METRICS-37" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-37.rule"/>
         </rule>
         <rule header="函数中的语句数量应该介于 1-50 的范围之间" id="38" impl="METRICS-38" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-38.rule"/>
         </rule>
         <rule header="函数的 VOCF 度量指标值不应该高于 4" id="39" impl="METRICS-39" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-39.rule"/>
         </rule>
         <rule header="函数内的语句不应嵌套超过 4 个级别" id="40" impl="METRICS-40" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-40.rule"/>
         </rule>
         <rule header="函数前面和内部的注释模块的数量与函数内语句的数量之比应该 &gt; 0.2" id="41" impl="METRICS-41" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-41.rule"/>
         </rule>
         <rule header="报告函数的霍尔斯特德交付错误 (B) 值" id="43" impl="METRICS-43" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-43.rule"/>
         </rule>
         <rule header="函数中的执行路径数不应大于80" id="44" impl="METRICS-44" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-44.rule"/>
         </rule>
         <rule header="避免函数超过 50 行" id="01" impl="METRICS-01" quickfix="false" scope="line" severity="5">
            <file path="METRICS\METRICS-01.rule"/>
         </rule>
         <rule header="避免 switch 代码段包含过多 case" id="02" impl="METRICS-02" quickfix="false" scope="line" severity="5">
            <file path="METRICS\METRICS-02.rule"/>
         </rule>
         <rule header="避免 structs, unions, 或类有超过20个范围" id="17" impl="METRICS-17" quickfix="false" scope="line" severity="5">
            <file path="METRICS\METRICS-17.rule"/>
         </rule>
         <rule header="避免超过 500 行的源代码" id="24" impl="METRICS-24" quickfix="false" scope="line" severity="5">
            <file path="METRICS\METRICS-24.rule"/>
         </rule>
         <rule header="报告圈复杂度" id="29" impl="METRICS-29" quickfix="false" scope="line" severity="5">
            <file path="METRICS\METRICS-29.rule"/>
         </rule>
         <rule header="报告基本复杂度" id="33" impl="METRICS-33" quickfix="false" scope="line" severity="5">
            <file path="METRICS\METRICS-33.rule"/>
         </rule>
         <rule header="遵守基本复杂度为 4 的限制" id="34" impl="METRICS-34" quickfix="false" scope="line" severity="5">
            <file path="METRICS\METRICS-34.rule"/>
         </rule>
         <rule header="遵守基本复杂度为 10 的限制" id="35" impl="METRICS-35" quickfix="false" scope="line" severity="5">
            <file path="METRICS\METRICS-35.rule"/>
         </rule>
         <rule header="遵循基本复杂度为 1 的限制" id="42" impl="METRICS-42" quickfix="false" scope="line" severity="5">
            <file path="METRICS\METRICS-42.rule"/>
         </rule>
      </category>
      <category description="MISRA C 1998" name="MISRA">
         <rule header="只使用 ISO C 标准中定义的字符" id="005" impl="MISRA-005" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-005.rule"/>
         </rule>
         <rule header="字符类型值必须是严格定义和记录的 ISO 10646-1 标准的子集" id="006" impl="MISRA-006" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-006.rule"/>
         </rule>
         <rule header="不要使用宽字符串字面量" id="008" impl="MISRA-008" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-008.rule"/>
         </rule>
         <rule header="不应该使用 char, int, short, long, float 和 double 的基本类型, 而是应该用 typedef 来定义特定长度的等效类型" id="013" impl="MISRA-013" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-013.rule"/>
         </rule>
         <rule header="显式地声明 'char' 类型为有符号类型或者无符号类型" id="014" impl="MISRA-014" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-014.rule"/>
         </rule>
         <rule header="不得使用浮点型数向下转换表示" id="016" impl="MISRA-016" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-016.rule"/>
         </rule>
         <rule header="所有对象和函数必须先声明再使用" id="020" impl="MISRA-020" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-020.rule"/>
         </rule>
         <rule header="标识符在同一编译单元中不能同时具有内部和外部链接" id="024" impl="MISRA-024" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-024.rule"/>
         </rule>
         <rule header="外部对象不得声明在多个文件中" id="027" impl="MISRA-027" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-027.rule"/>
         </rule>
         <rule header="外部对象不应该在实现文件中声明" id="027_b" impl="MISRA-027_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-027_b.rule"/>
         </rule>
         <rule header="标签的使用应当与其声明一致" id="029" impl="MISRA-029" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-029.rule"/>
         </rule>
         <rule header="所有自动变量在使用之前都必须被赋值" id="030" impl="MISRA-030" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-030.rule"/>
         </rule>
         <rule header="一个移位操作符的右操作数应该位于 0 与左操作数底层类型的位宽减 1之间" id="038" impl="MISRA2004-12_8" originalId="MISRA2004-12_8" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_8.rule"/>
         </rule>
         <rule header="除了在 FOR 循环的控制表达式之外，不得使用逗号运算符" id="042" impl="MISRA-042" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-042.rule"/>
         </rule>
         <rule header="不应使用可能导致信息丢失的从较宽到较窄的整数类型的隐式转换" id="043" impl="MISRA-043" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-043.rule"/>
         </rule>
         <rule header="避免在同一个表达式中混合使用不同精度的算术运算" id="043_b" impl="MISRA-043_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-043_b.rule"/>
         </rule>
         <rule header="不应使用可能导致信息丢失的从整型到浮点型的隐式转换" id="043_c" impl="MISRA-043_c" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-043_c.rule"/>
         </rule>
         <rule header="不应使用可能会导致信息丢失的从整数常量到浮点类型的隐式转换" id="043_d" impl="MISRA-043_d" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-043_d.rule"/>
         </rule>
         <rule header="不允许冗余显式转换为同一类型" id="044" impl="OPT-29" originalId="OPT-29" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-29.rule"/>
         </rule>
         <rule header="不要使用 volatile 关键字" id="046_a" impl="MISRA-046_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-046_a.rule"/>
         </rule>
         <rule header="赋值语句不应该嵌套使用在赋值语句中" id="046_b" impl="MISRA-046_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-046_b.rule"/>
         </rule>
         <rule header="避免在将结果转换为更广泛的整数类型的表达式中可能出现的整数溢出" id="048_a" impl="MISRA-048_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-048_a.rule"/>
         </rule>
         <rule header="不要将两个整数的被除数强制类型转换为一个浮点类型" id="048_b" impl="MISRA-048_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-048_b.rule"/>
         </rule>
         <rule header="避免将表达式的结果赋给更大整数类型的变量，这可能出现整数溢出" id="048_c" impl="PB-65" originalId="PB-65" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-65.rule"/>
         </rule>
         <rule header="避免无意地丢弃整数除法的余数" id="048_d" impl="PB-15_b" originalId="PB-15_b" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-15_b.rule"/>
         </rule>
         <rule header="空语句只能单独一行出现" id="054" impl="MISRA-054" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-054.rule"/>
         </rule>
         <rule header="请勿使用 break 语句" id="058" impl="MISRA-058" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-058.rule"/>
         </rule>
         <rule header="不得使用浮点变量作为循环计数器" id="065" impl="MISRA-065" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-065.rule"/>
         </rule>
         <rule header="避免使用有可变数量参数的函数" id="069" impl="MISRA-069" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-069.rule"/>
         </rule>
         <rule header="函数应该有函数原型并且该原型应该对函数定义和调用可见" id="071_a" impl="MISRA-071_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-071_a.rule"/>
         </rule>
         <rule header="在函数调用时，函数总是有可见的原型" id="071_b" impl="MISRA-071_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-071_b.rule"/>
         </rule>
         <rule header="函数的参数要么不提供标识符要么提供所有标识符" id="073" impl="MISRA-073" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-073.rule"/>
         </rule>
         <rule header="非 void 函数的返回语句必须提供表达式" id="083" impl="MISRA-083" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-083.rule"/>
         </rule>
         <rule header="避免 void 函数中存在 return 语句表达式。" id="084" impl="MISRA-084" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-084.rule"/>
         </rule>
         <rule header="#include 指令后面应当添加 &lt;filename&gt; 或是 &quot;filename&quot;" id="089" impl="MISRA-089" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-089.rule"/>
         </rule>
         <rule header="必须把类函数形式的宏定义放进括号中" id="096" impl="MISRA-096" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-096.rule"/>
         </rule>
         <rule header="只能使用没有歧义性的预处理操作符格式" id="100" impl="MISRA-100" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-100.rule"/>
         </rule>
         <rule header="不应该使用指针算法" id="101" impl="MISRA-101" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-101.rule"/>
         </rule>
         <rule header="不要使用非常量指针指向函数" id="104" impl="MISRA-104" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-104.rule"/>
         </rule>
         <rule header="函数指针应该与其指向的所有函数的参数个数，参数类型和返回值类型相同" id="105" impl="MISRA-105" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-105.rule"/>
         </rule>
         <rule header="空指针不应取消引用" id="107_a" impl="MISRA-107_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-107_a.rule"/>
         </rule>
         <rule header="空指针不应取消引用" id="107_b" impl="MISRA-107_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-107_b.rule"/>
         </rule>
         <rule header="结构体和联合体中的所有成员必须完全指定" id="108" impl="MISRA-108" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-108.rule"/>
         </rule>
         <rule header="不能使用联合体访问大数据结构的子部分" id="110" impl="MISRA-110" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-110.rule"/>
         </rule>
         <rule header="结构体或联合体或类的所有成员变量应该被命名" id="113" impl="MISRA-113" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-113.rule"/>
         </rule>
         <rule header="不得重复使用标准库函数的名称" id="115" impl="MISRA-115" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-115.rule"/>
         </rule>
         <rule header="不要使用 setlocale 函数" id="121_a" impl="MISRA-121_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-121_a.rule"/>
         </rule>
         <rule header="不应包含 &lt;locale.h&gt; 头文件" id="121_b" impl="MISRA-121_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-121_b.rule"/>
         </rule>
         <rule header="应该在头文件中声明具有外部链接的对象或函数" id="023" impl="MISRA-023" quickfix="false" scope="line" severity="4">
            <file path="MISRA\MISRA-023.rule"/>
         </rule>
         <rule header="应当作出适当的运行时检查的规定" id="004_a" impl="MISRA-004_a" quickfix="false" scope="line" severity="5">
            <file path="MISRA\MISRA-004_a.rule"/>
         </rule>
         <rule header="应当作出适当的运行时检查的规定" id="004_b" impl="MISRA-004_b" quickfix="false" scope="line" severity="5">
            <file path="MISRA\MISRA-004_b.rule"/>
         </rule>
         <rule header="数字常量必须使用类型后缀" id="018_a" impl="MISRA-018_a" quickfix="false" scope="line" severity="5">
            <file path="MISRA\MISRA-018_a.rule"/>
         </rule>
         <rule header="数字常量必须使用类型后缀" id="018_b" impl="MISRA-018_b" quickfix="false" scope="line" severity="5">
            <file path="MISRA\MISRA-018_b.rule"/>
         </rule>
         <rule header="数字常量必须使用类型后缀" id="018_c" impl="MISRA-018_c" quickfix="false" scope="line" severity="5">
            <file path="MISRA\MISRA-018_c.rule"/>
         </rule>
         <rule header="数字常量必须使用类型后缀" id="018_d" impl="MISRA-018_d" quickfix="false" scope="line" severity="5">
            <file path="MISRA\MISRA-018_d.rule"/>
         </rule>
         <rule header="在函数范围内声明对象" id="022" impl="MISRA-022" quickfix="false" scope="line" severity="5">
            <file path="MISRA\MISRA-022.rule"/>
         </rule>
         <rule header="不应使用'register'存储类说明符" id="028" impl="MISRA-028" quickfix="false" scope="line" severity="5">
            <file path="MISRA\MISRA-028.rule"/>
         </rule>
         <rule header="文件整数除法" id="041" impl="MISRA-041" quickfix="false" scope="line" severity="5">
            <file path="MISRA\MISRA-041.rule"/>
         </rule>
         <rule header="对常量无符号整数表达式的求值不应该导致循环" id="051" impl="PB-73" originalId="PB-73" quickfix="false" scope="line" severity="5">
            <file path="PB\PB-73.rule"/>
         </rule>
         <rule header="避免使用标签" id="055" impl="MISRA-055" quickfix="false" scope="line" severity="5">
            <file path="MISRA\MISRA-055.rule"/>
         </rule>
      </category>
      <category description="物理文件组织" name="PFO">
         <rule header="在头文件中不能定义具有链接属性的实体" id="01" impl="PFO-01" quickfix="false" scope="line" severity="3">
            <file path="PFO\PFO-01.rule"/>
         </rule>
         <rule header="使用多个包含保护" id="02" impl="PFO-02" quickfix="false" scope="line" severity="3">
            <file path="PFO\PFO-02.rule"/>
         </rule>
         <rule header="一个包含文件中只能带有一个类定义" id="03" impl="PFO-03" quickfix="false" scope="line" severity="3">
            <file path="PFO\PFO-03.rule"/>
         </rule>
         <rule header="带有 '.c' 扩展名的文件不能包含其它带有 '.c' 扩展名的文件" id="05" impl="PFO-05" quickfix="false" scope="line" severity="3">
            <file path="PFO\PFO-05.rule"/>
         </rule>
         <rule header="禁止在带有 '.icc' 扩展名的文件中包含其它文件" id="06" impl="PFO-06" quickfix="false" scope="line" severity="3">
            <file path="PFO\PFO-06.rule"/>
         </rule>
         <rule header="使用基于头文件名的多重包含保护机制" id="07" impl="PFO-07" quickfix="false" scope="line" severity="3">
            <file path="PFO\PFO-07.rule"/>
         </rule>
         <rule header="使用某种机制以防止文件的多重包含，例如，包含保护或者使用 &quot;#pragma once&quot; 预处理指令" id="08" impl="PFO-08" quickfix="false" scope="line" severity="3">
            <file path="PFO\PFO-08.rule"/>
         </rule>
         <rule header="&quot;#pragma once&quot;预处理指令不能使用在源代码文件中" id="09" impl="PFO-09" quickfix="false" scope="line" severity="3">
            <file path="PFO\PFO-09.rule"/>
         </rule>
         <rule header="头文件中的定义不要超过类" id="10" impl="PFO-10" quickfix="false" scope="line" severity="3">
            <file path="PFO\PFO-10.rule"/>
         </rule>
         <rule header="每个实现文件都应该声明一个描述文件的局部常量字符串" id="04" impl="PFO-04" quickfix="false" scope="line" severity="5">
            <file path="PFO\PFO-04.rule"/>
         </rule>
      </category>
      <category description="STL 最佳实践" name="STL">
         <rule header="要使复制有效、正确且不会产生切片问题，应该创建指针容器而不是对象容器" id="02" impl="STL-02" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-02.rule"/>
         </rule>
         <rule header="调用 empty 而不要判断 size() 是否为 0" id="03" impl="STL-03" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-03.rule"/>
         </rule>
         <rule header="避免在显式的循环中递归调用插入操作" id="04" impl="STL-04" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-04.rule"/>
         </rule>
         <rule header="几乎所有的复制是通过调用成员函数而不是插入迭代器来确定目的范围" id="05" impl="STL-05" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-05.rule"/>
         </rule>
         <rule header="当用作函数参数时，应使用 istream_iterator 名字而不是匿名的 istream_iterator 对象" id="06" impl="STL-06" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-06.rule"/>
         </rule>
         <rule header="容器中如果有新创建的指针，切记删除容器之前先删除指针" id="07" impl="STL-07" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-07.rule"/>
         </rule>
         <rule header="禁止创建 auto_ptrs 的容器" id="08" impl="STL-08" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-08.rule"/>
         </rule>
         <rule header="避免对 list 和标准关联容器使用 remove 算法" id="09" impl="STL-09" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-09.rule"/>
         </rule>
         <rule header="对于动态分配的数组最好使用 vector 或 string" id="10" impl="STL-10" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-10.rule"/>
         </rule>
         <rule header="使用 reserve 来避免不必要的重复分配" id="12" impl="STL-12" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-12.rule"/>
         </rule>
         <rule header="每一个 vector 和 string 在被传递给 C 函数之前，应该对它们是否为空做一个检查" id="13" impl="STL-13" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-13.rule"/>
         </rule>
         <rule header="避免使用 vector&lt;bool&gt;" id="14" impl="STL-14" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-14.rule"/>
         </rule>
         <rule header="对存放指针的关联容器指定比较方式" id="15" impl="STL-15" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-15.rule"/>
         </rule>
         <rule header="禁止对关联容器使用判定相等数值为 true 的比较函数" id="16" impl="STL-16" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-16.rule"/>
         </rule>
         <rule header="禁止对关联容器使用判定相等数值为真的比较函数" id="17" impl="STL-17" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-17.rule"/>
         </rule>
         <rule header="使用迭代器而不是常量迭代器,reverse_iterator,或 const_reverse_iterator" id="18" impl="STL-18" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-18.rule"/>
         </rule>
         <rule header="使用 distance 和 advance 将容器的 const_iterators 转换为 iterators" id="19" impl="STL-19" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-19.rule"/>
         </rule>
         <rule header="确保目标范围足够大" id="22" impl="STL-22" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-22.rule"/>
         </rule>
         <rule header="通过擦除遵循类似删除的算法从容器中删除元素" id="23" impl="STL-23" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-23.rule"/>
         </rule>
         <rule header="避免对存放动态内存指针的容器使用 remove 或类似的算法（即remove_if和unique）" id="24" impl="STL-24" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-24.rule"/>
         </rule>
         <rule header="正确执行 copy_if 的前提是不应该在谓词前返回带有 not1 的 remove_copy_if" id="26" impl="STL-26" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-26.rule"/>
         </rule>
         <rule header="如果 accumulate() 用于包含浮点指针值的容器，必须使用浮点数值初始化" id="27" impl="STL-27" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-27.rule"/>
         </rule>
         <rule header="按传递值来设计 functor 类" id="28" impl="STL-28" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-28.rule"/>
         </rule>
         <rule header="使谓词常量成为纯函数" id="29" impl="STL-29" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-29.rule"/>
         </rule>
         <rule header="每一个 functor 类应该有且只有一个 operator()，并且其参数和返回值类型应该通过 unary_function 或 binary_function 来指定" id="30" impl="STL-30" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-30.rule"/>
         </rule>
         <rule header="将函数传递给 STL 构件时，必须使用 ptr_fun,mem_fun,或者 mem_fun_ref" id="31" impl="STL-31" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-31.rule"/>
         </rule>
         <rule header="确保 less&lt;T&gt; 与操作符 &lt; 语义一致" id="32" impl="STL-32" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-32.rule"/>
         </rule>
         <rule header="尽量采用算法调用而不是手写循环" id="33" impl="STL-33" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-33.rule"/>
         </rule>
         <rule header="最好采用成员函数而不是采用同名算法" id="34" impl="STL-34" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-34.rule"/>
         </rule>
         <rule header="不能简单的将某个非零的常量转换为真，将零转换为假" id="35" impl="STL-35" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-35.rule"/>
         </rule>
         <rule header="不要使用一个不是真实范围的迭代器范围" id="36" impl="STL-36" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-36.rule"/>
         </rule>
         <rule header="不得使用 C 样式数组" id="37" impl="STL-37" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-37.rule"/>
         </rule>
         <rule header="使用 != 代替 &lt; 来比较迭代器" id="38" impl="STL-38" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-38.rule"/>
         </rule>
         <rule header="将特征类（Traits）与重载关联使用" id="39" impl="STL-39" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-39.rule"/>
         </rule>
         <rule header="调用 swap 时，使用 using 声明 std::swap，然后调用 swap 不需要命名空间限定" id="40" impl="STL-40" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-40.rule"/>
         </rule>
         <rule header="不能声明非成员作为 std::swap 的重载" id="41" impl="STL-41" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-41.rule"/>
         </rule>
         <rule header="Swap 的成员版本应该禁止抛出异常" id="42" impl="STL-42" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-42.rule"/>
         </rule>
         <rule header="使用 vector&lt;char&gt; 而非 string" id="11" impl="STL-11" quickfix="false" scope="line" severity="4">
            <file path="STL\STL-11.rule"/>
         </rule>
         <rule header="出于删除目的时，应谨慎使用 reverse_iterator 的基迭代器" id="20" impl="STL-20" quickfix="false" scope="line" severity="4">
            <file path="STL\STL-20.rule"/>
         </rule>
         <rule header="逐字符输入时，使用 istreambuf 的迭代器" id="21" impl="STL-21" quickfix="false" scope="line" severity="4">
            <file path="STL\STL-21.rule"/>
         </rule>
         <rule header="如果你传递一个已排序的值域给某个算法，而同时该值域进行一个比较函数操作时，应确保这个比较函数传递的值域是跟用于排序的值域是相同的" id="25" impl="STL-25" quickfix="false" scope="line" severity="4">
            <file path="STL\STL-25.rule"/>
         </rule>
         <rule header="选择使用类的封装，而不是编写与容器无关的代码" id="01" impl="STL-01" quickfix="false" scope="line" severity="5">
            <file path="STL\STL-01.rule"/>
         </rule>
      </category>
      <category description="模板" name="TEMPL">
         <rule header="从模板中分离出参数无关的代码" id="01" impl="TEMPL-01" quickfix="false" scope="line" severity="3">
            <file path="TEMPL\TEMPL-01.rule"/>
         </rule>
         <rule header="需要类型转换时在模板内定义非成员函数" id="02" impl="TEMPL-02" quickfix="false" scope="line" severity="3">
            <file path="TEMPL\TEMPL-02.rule"/>
         </rule>
         <rule header="不要重载模板类中的函数" id="03" impl="TEMPL-03" quickfix="false" scope="line" severity="3">
            <file path="TEMPL\TEMPL-03.rule"/>
         </rule>
         <rule header="在全局模板函数中使用 'typename' 去标识嵌套依赖类型名" id="04" impl="TEMPL-04" quickfix="false" scope="line" severity="3">
            <file path="TEMPL\TEMPL-04.rule"/>
         </rule>
         <rule header="在模板类中使用 'typename' 去标识嵌套依赖类型名" id="05" impl="TEMPL-05" quickfix="false" scope="line" severity="3">
            <file path="TEMPL\TEMPL-05.rule"/>
         </rule>
         <rule header="在模板类中，不要改变默认的虚函数参数" id="06" impl="TEMPL-06" quickfix="false" scope="line" severity="3">
            <file path="TEMPL\TEMPL-06.rule"/>
         </rule>
         <rule header="当存在一个包含单个泛型参数的模板构造函数时，应声明拷贝构造函数" id="07" impl="TEMPL-07" quickfix="false" scope="line" severity="3">
            <file path="TEMPL\TEMPL-07.rule"/>
         </rule>
         <rule header="函数调用的可行函数集合应该要么不包括函数特化，要么只包括函数特化" id="08" impl="TEMPL-08" quickfix="false" scope="line" severity="3">
            <file path="TEMPL\TEMPL-08.rule"/>
         </rule>
         <rule header="重载函数模板不应显式特化" id="09" impl="TEMPL-09" quickfix="false" scope="line" severity="3">
            <file path="TEMPL\TEMPL-09.rule"/>
         </rule>
         <rule header="模板所有的部分和显式专门化都应在与其主模板声明相同的文件中声明" id="10" impl="TEMPL-10" quickfix="false" scope="line" severity="3">
            <file path="TEMPL\TEMPL-10.rule"/>
         </rule>
         <rule header="存在一个包含泛型参数的模板赋值运算符时，拷贝赋值运算符应该被声明" id="11" impl="TEMPL-11" quickfix="false" scope="line" severity="3">
            <file path="TEMPL\TEMPL-11.rule"/>
         </rule>
         <rule header="在含有依赖基础的类模板中，任何可能在这个依赖类中被发现的名称都应该引用使用限定标识（qualified-id）或 -&gt;" id="12" impl="TEMPL-12" quickfix="false" scope="line" severity="3">
            <file path="TEMPL\TEMPL-12.rule"/>
         </rule>
         <rule header="不要在关联的命名空间中声明非成员通用函数" id="13" impl="TEMPL-13" quickfix="false" scope="line" severity="3">
            <file path="TEMPL\TEMPL-13.rule"/>
         </rule>
         <rule header="函数应解析为先前在编译单元中声明的函数" id="14" impl="TEMPL-14" quickfix="false" scope="line" severity="3">
            <file path="TEMPL\TEMPL-14.rule"/>
         </rule>
         <rule header="声明 'extern' 一个显式实例化的模板" id="15" impl="TEMPL-15" quickfix="false" scope="line" severity="3">
            <file path="TEMPL\TEMPL-15.rule"/>
         </rule>
         <rule header="模板专门化应声明在与主模板或用户定义类型相同的文件中，为其声明专门化" id="16" impl="TEMPL-16" quickfix="false" scope="line" severity="3">
            <file path="TEMPL\TEMPL-16.rule"/>
         </rule>
         <rule header="如果返回类型前面带有 'typename' 关键字，使用尾随返回类型语法" id="17" impl="TEMPL-17" quickfix="false" scope="line" severity="3">
            <file path="TEMPL\TEMPL-17.rule"/>
         </rule>
         <rule header="非成员泛型操作符只能在不包含类(结构体)类型、枚举类型或联合类型声明的命名空间中声明" id="18" impl="TEMPL-18" quickfix="false" scope="line" severity="3">
            <file path="TEMPL\TEMPL-18.rule"/>
         </rule>
      </category>
   </builtin>
</rules>
