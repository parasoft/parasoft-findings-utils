#Auto-generated file.
#Thu May 25 15:12:25 CEST 2023
APSC_DV=DISA ASD STIG
APSC_DV-000160=APSC_DV-000160 The application must implement DoD-approved encryption to protect the confidentiality of remote access sessions.
APSC_DV-000160-a=Do not use weak encryption functions
APSC_DV-000170=APSC_DV-000170 The application must implement cryptographic mechanisms to protect the integrity of remote access sessions.
APSC_DV-000170-a=Do not use weak encryption functions
APSC_DV-000500=APSC_DV-000500 The application must prevent non-privileged users from executing privileged functions to include disabling, circumventing, or altering implemented security safeguards/countermeasures.
APSC_DV-000500-a=Observe correct revocation order while relinquishing privileges
APSC_DV-000650=APSC_DV-000650 The application must not write sensitive data into the application logs.
APSC_DV-000650-a=Do not print potentially sensitive information, resulting from an application error into exception messages
APSC_DV-001290=APSC_DV-001290 The application must protect audit information from unauthorized modification.
APSC_DV-001290-b=Untrusted data is used as a loop boundary
APSC_DV-001290-c=Avoid passing user input into methods as parameters
APSC_DV-001290-d=Avoid using unsecured shell functions that may be affected by shell metacharacters
APSC_DV-001860=APSC_DV-001860 The application must use mechanisms meeting the requirements of applicable federal laws, Executive Orders, directives, policies, regulations, standards, and guidance for authentication to a cryptographic module.
APSC_DV-001860-a=Do not use weak encryption functions
APSC_DV-001995=APSC_DV-001995 The application must not be vulnerable to race conditions.
APSC_DV-001995-f=Avoid using thread-unsafe functions
APSC_DV-001995-g=Usage of functions prone to race is not allowed
APSC_DV-001995-h=Avoid using the 'vfork()' function
APSC_DV-002010=APSC_DV-002010 The application must implement NSA-approved cryptography to protect classified information in accordance with applicable federal laws, Executive Orders, directives, policies, regulations, and standards.
APSC_DV-002010-a=Do not use weak encryption functions
APSC_DV-002290=APSC_DV-002290 The application must use the Federal Information Processing Standard (FIPS) 140-2-validated cryptographic modules and random number generator if the application implements encryption, key exchange, digital signature, and hash functionality.
APSC_DV-002290-a=Do not use the rand() function for generating pseudorandom numbers
APSC_DV-002290-c=The 'random_shuffle' identifier should not be used
APSC_DV-002290-d=The random number generator functions 'rand()' and 'srand()' should not be used
APSC_DV-002350=APSC_DV-002350 The application must use appropriate cryptography in order to protect stored DoD information when required by the information owner or DoD policy.
APSC_DV-002350-a=Do not use weak encryption functions
APSC_DV-002390=APSC_DV-002390 XML-based applications must mitigate DoS attacks by using XML filters, parser options, or gateways.
APSC_DV-002390-b=Do not process structured text data natively
APSC_DV-002390-c=Do not use scanf and fscanf functions without specifying variable size in format string
APSC_DV-002390-d=Do not use mbstowcs() function
APSC_DV-002400=APSC_DV-002400 The application must restrict the ability to launch Denial of Service (DoS) attacks against itself or other information systems.
APSC_DV-002400-b=The execution of a function registered with 'std\:\:atexit()' or 'std\:\:at_quick_exit()' should not exit via an exception
APSC_DV-002400-c=Avoid using the 'vfork()' function
APSC_DV-002400-d=Avoid using thread-unsafe functions
APSC_DV-002480=APSC_DV-002480 The application must not disclose unnecessary information to users.
APSC_DV-002480-a=Do not print potentially sensitive information, resulting from an application error into exception messages
APSC_DV-002520=APSC_DV-002520 The application must protect from canonical representation vulnerabilities.
APSC_DV-002520-d=Never use unfiltered data from an untrusted user as the format parameter
APSC_DV-002520-k=Untrusted data is used as a loop boundary
APSC_DV-002530=APSC_DV-002530 The application must validate all input.
APSC_DV-002530-d=Never use unfiltered data from an untrusted user as the format parameter
APSC_DV-002530-k=Untrusted data is used as a loop boundary
APSC_DV-002550=APSC_DV-002550 The application must not be vulnerable to XML-oriented attacks.
APSC_DV-002550-d=Never use unfiltered data from an untrusted user as the format parameter
APSC_DV-002550-k=Untrusted data is used as a loop boundary
APSC_DV-002560=APSC_DV-002560 The application must not be subject to input handling vulnerabilities.
APSC_DV-002560-d=Never use unfiltered data from an untrusted user as the format parameter
APSC_DV-002560-k=Untrusted data is used as a loop boundary
APSC_DV-002570=APSC_DV-002570 The application must generate error messages that provide information necessary for corrective actions without revealing information that could be exploited by adversaries.
APSC_DV-002570-b=Do not print potentially sensitive information, resulting from an application error into exception messages
APSC_DV-003110=APSC_DV-003110 The application must not contain embedded authentication data.
APSC_DV-003110-a=Do not hard code string literals
AUTOSAR=AUTOSAR C++14 Coding Guidelines
AUTOSAR-A0_1_2=AUTOSAR A0-1-2 The value returned by a function having a non-void return type that is not an overloaded operator shall be used
AUTOSAR-A0_1_2-a=The value returned by a function having a non-void return type that is not an overloaded operator shall always be used
AUTOSAR-A0_1_3=AUTOSAR A0-1-3 Every function defined in an anonymous namespace, or static function with internal linkage, or private member function shall be used
AUTOSAR-A0_1_3-a=Every defined function with internal linkage shall be used at least once
AUTOSAR-A0_1_4=AUTOSAR A0-1-4 There shall be no unused named parameters in non-virtual functions
AUTOSAR-A0_1_4-a=Eliminate unused parameters
AUTOSAR-A0_1_5=AUTOSAR A0-1-5 There shall be no unused named parameters in the set of parameters for a virtual function and all the functions that override it
AUTOSAR-A0_1_5-a=There shall be no unused named parameters in virtual functions
AUTOSAR-A0_4_2=AUTOSAR A0-4-2 Type long double shall not be used
AUTOSAR-A0_4_2-a=Type long double shall not be used
AUTOSAR-A10_1_1=AUTOSAR A10-1-1 Class shall not be derived from more than one base class which is not an interface class
AUTOSAR-A10_1_1-a=Be wary about using multiple inheritance of classes that are not abstract interfaces
AUTOSAR-A10_2_1=AUTOSAR A10-2-1 Non-virtual member functions shall not be redefined in derived classes
AUTOSAR-A10_2_1-a=Never redefine an inherited nonvirtual function
AUTOSAR-A10_2_1-b=Member functions declared in derived class should not hide functions declared in base classes
AUTOSAR-A10_3_1=AUTOSAR A10-3-1 Virtual function declaration shall contain exactly one of the three specifiers\:
AUTOSAR-A10_3_1-a=Only one of virtual, override or final should be specified in a member function declaration
AUTOSAR-A10_3_2=AUTOSAR A10-3-2 Each overriding virtual function shall be declared with the override or final specifier
AUTOSAR-A10_3_2-a=Each overriding virtual function shall be declared with the override or final specifier
AUTOSAR-A10_3_3=AUTOSAR A10-3-3 Virtual functions shall not be introduced in a final class
AUTOSAR-A10_3_3-a=Do not introduce virtual functions in a final class
AUTOSAR-A10_3_5=AUTOSAR A10-3-5 A user-defined assignment operator shall not be virtual
AUTOSAR-A10_3_5-a=A user-defined assignment operator shall not be virtual
AUTOSAR-A10_4_1=AUTOSAR A10-4-1 Hierarchies should be based on interface classes
AUTOSAR-A10_4_1-a=Hierarchies should be based on abstract classes
AUTOSAR-A11_0_1=AUTOSAR A11-0-1 A non-POD type should be defined as class
AUTOSAR-A11_0_1-a=A non-POD type should be defined as class
AUTOSAR-A11_0_2=AUTOSAR A11-0-2 A type defined as struct shall\: (1) provide only public data members, (2) not provide any special member functions or methods, (3) not be a base of another struct or class, (4) not inherit from another struct or class
AUTOSAR-A11_0_2-a=Structs should only contain public data members and should not be a base or inherit
AUTOSAR-A11_3_1=AUTOSAR A11-3-1 Friend declarations shall not be used
AUTOSAR-A11_3_1-a=Friend declarations shall not be used except declarations of comparison operators
AUTOSAR-A12_0_1=AUTOSAR A12-0-1 If a class declares a copy or move operation, or a destructor, either via "\=default", "\=delete", or via a user-provided declaration, then all others of these five special member functions shall be declared as well
AUTOSAR-A12_0_1-a=If a class declares a copy or move operation, or a destructor, either via '\=default', '\=delete', or via a user-provided declaration, then all others of these five special member functions shall be declared as well
AUTOSAR-A12_0_2=AUTOSAR A12-0-2 Bitwise operations and operations that assume data representation in memory shall not be performed on objects
AUTOSAR-A12_0_2-a=Do not compare objects of a class that may contain padding bits with C standard library functions
AUTOSAR-A12_1_1=AUTOSAR A12-1-1 Constructors shall explicitly initialize all virtual base classes, all direct non-virtual base classes and all non-static data members
AUTOSAR-A12_1_1-a=All constructors of a class should explicitly call a constructor for all of its immediate base classes and all virtual base classes
AUTOSAR-A12_1_1-b=All member variables should be initialized in constructor
AUTOSAR-A12_1_2=AUTOSAR A12-1-2 Both NSDMI and a non-static member initializer in a constructor shall not be used in the same type
AUTOSAR-A12_1_2-a=Both NSDMI and a non-static member initializer in a constructor shall not be used in the same type
AUTOSAR-A12_1_3=AUTOSAR A12-1-3 If all user-defined constructors of a class initialize data members with constant values that are the same across all constructors, then data members shall be initialized using NSDMI instead
AUTOSAR-A12_1_3-a=User-defined constructors that initialize data members with the same constant values across all constructors should initialize using NSDMI instead
AUTOSAR-A12_1_4=AUTOSAR A12-1-4 All constructors that are callable with a single argument of fundamental type shall be declared explicit
AUTOSAR-A12_1_4-a=All constructors that are callable with a single argument of fundamental type shall be declared explicit
AUTOSAR-A12_1_5=AUTOSAR A12-1-5 Common class initialization for non-constant members shall be done by a delegating constructor
AUTOSAR-A12_1_5-a=Use delegating constructors to reduce code duplication
AUTOSAR-A12_1_6=AUTOSAR A12-1-6 Derived classes that do not need further explicit initialization and require all the constructors from the base class shall use inheriting constructors
AUTOSAR-A12_1_6-a=Derived classes that do not need further explicit initialization and require all the constructors from the base class shall use inheriting constructors
AUTOSAR-A12_4_1=AUTOSAR A12-4-1 Destructor of a base class shall be public virtual, public override or protected non-virtual
AUTOSAR-A12_4_1-a=Make base class destructors public and virtual, or protected and nonvirtual
AUTOSAR-A12_4_2=AUTOSAR A12-4-2 If a public destructor of a class is non-virtual, then the class should be declared final
AUTOSAR-A12_4_2-a=If a public destructor of a class is non-virtual, then the class should be declared final
AUTOSAR-A12_6_1=AUTOSAR A12-6-1 All class data members that are initialized by the constructor shall be initialized using member initializers
AUTOSAR-A12_6_1-a=Prefer initialization to assignment in constructors
AUTOSAR-A12_7_1=AUTOSAR A12-7-1 If the behavior of a user-defined special member function is identical to implicitly defined special member function, then it shall be defined "\=default" or be left undefined
AUTOSAR-A12_7_1-a=Define special members as \=default when the behavior is equivalent to the compiler's behavior
AUTOSAR-A12_8_1=AUTOSAR A12-8-1 Move and copy constructors shall move and respectively copy base classes and data members of a class, without any side effects
AUTOSAR-A12_8_1-a=A copy constructor shall only initialize its base classes and the non-static members of the class of which it is a member
AUTOSAR-A12_8_2=AUTOSAR A12-8-2 User-defined copy and move assignment operators should use user-defined no-throw swap function
AUTOSAR-A12_8_2-a=User-defined copy and move assignment operators should use user-defined no-throw swap function
AUTOSAR-A12_8_4=AUTOSAR A12-8-4 Move constructor shall not initialize its class members and base classes using copy semantics
AUTOSAR-A12_8_4-a=Use std\:\:move() on rvalue references and std\:\:forward() on forwarding references
AUTOSAR-A12_8_5=AUTOSAR A12-8-5 A copy assignment and a move assignment operators shall handle self-assignment
AUTOSAR-A12_8_5-a=Check for assignment to self in operator\=
AUTOSAR-A12_8_6=AUTOSAR A12-8-6 Copy and move constructors and copy assignment and move assignment operators shall be declared protected or defined "\=delete" in base class
AUTOSAR-A12_8_6-a=Avoid public copy constructors and assignment operators in base classes
AUTOSAR-A12_8_7=AUTOSAR A12-8-7 Assignment operators should be declared with the ref-qualifier &
AUTOSAR-A12_8_7-a=Declare assignment operators with the ref-qualifier &
AUTOSAR-A13_1_2=AUTOSAR A13-1-2 User defined suffixes of the user defined literal operators shall start with underscore followed by one or more letters
AUTOSAR-A13_1_2-a=User defined suffixes of the user defined literal operators shall start with underscore followed by one or more letters
AUTOSAR-A13_1_3=AUTOSAR A13-1-3 User defined literals operators shall only perform conversion of passed parameters
AUTOSAR-A13_1_3-a=User defined literals operators shall only perform conversion of passed parameters
AUTOSAR-A13_2_1=AUTOSAR A13-2-1 An assignment operator shall return a reference to "this"
AUTOSAR-A13_2_1-a=Have assignment operator returns a reference to *this; make assignment operator's return type a non-const reference to it's class' type
AUTOSAR-A13_2_2=AUTOSAR A13-2-2 A binary arithmetic operator and a bitwise operator shall return a "prvalue"
AUTOSAR-A13_2_2-a=A binary arithmetic operator and a bitwise operator shall return a 'prvalue'
AUTOSAR-A13_2_3=AUTOSAR A13-2-3 A relational operator shall return a boolean value
AUTOSAR-A13_2_3-a=A relational operator shall return a boolean value
AUTOSAR-A13_3_1=AUTOSAR A13-3-1 A function that contains "forwarding reference" as its argument shall not be overloaded
AUTOSAR-A13_3_1-a=Avoid Overloading on Forwarding References
AUTOSAR-A13_5_1=AUTOSAR A13-5-1 If "operator[]" is to be overloaded with a non-const version, const version shall also be implemented
AUTOSAR-A13_5_1-a=When overloading the subscript operator (operator[]), implement both const and non-const versions
AUTOSAR-A13_5_2=AUTOSAR A13-5-2 All user-defined conversion operators shall be defined explicit
AUTOSAR-A13_5_2-a=User-conversion cast operators should be made explicit
AUTOSAR-A13_5_3=AUTOSAR A13-5-3 User-defined conversion operators should not be used
AUTOSAR-A13_5_3-a=Do not use user-defined conversion functions
AUTOSAR-A13_5_4=AUTOSAR A13-5-4 If two opposite operators are defined, one shall be defined in terms of the other
AUTOSAR-A13_5_4-b=If two opposite equality operators ('\=\=', '\!\=') are defined in a class, one shall be defined in terms of the other
AUTOSAR-A13_5_5=AUTOSAR A13-5-5 Comparison operators shall be non-member functions with identical parameter types and noexcept
AUTOSAR-A13_5_5-a=Comparison operators shall be non-member functions
AUTOSAR-A13_5_5-b=Comparison operators shall be non-member functions with identical parameter types and noexcept
AUTOSAR-A13_6_1=AUTOSAR A13-6-1 Digit sequences separators ' shall only be used as follows\: (1) for decimal, every 3 digits, (2) for hexadecimal, every 2 digits, (3) for binary, every 4 digits
AUTOSAR-A13_6_1-a=Digit sequences separators ' shall only be used consistently
AUTOSAR-A14_5_1=AUTOSAR A14-5-1 A template constructor shall not participate in overload resolution for a single argument of the enclosing class type
AUTOSAR-A14_5_1-a=A copy constructor shall be declared when there is a template constructor with a single parameter that is a generic parameter
AUTOSAR-A14_5_3=AUTOSAR A14-5-3 A non-member generic operator shall only be declared in a namespace that does not contain class (struct) type, enum type or union type declarations.
AUTOSAR-A14_5_3-a=A non-member generic operator shall only be declared in a namespace that does not contain class (struct) type, enum type or union type declarations
AUTOSAR-A14_7_2=AUTOSAR A14-7-2 Template specialization shall be declared in the same file (1) as the primary template (2) as a user-defined type, for which the specialization is declared
AUTOSAR-A14_7_2-a=Template specialization shall be declared in the same file as the primary template or a user-defined type, for which the specialization is declared
AUTOSAR-A14_8_2=AUTOSAR A14-8-2 Explicit specializations of function templates shall not be used
AUTOSAR-A14_8_2-a=Overloaded function templates shall not be explicitly specialized
AUTOSAR-A15_1_1=AUTOSAR A15-1-1 Only instances of types derived from std\:\:exception shall be thrown
AUTOSAR-A15_1_1-a=Only use instances of std\:\:exception for exceptions
AUTOSAR-A15_1_2=AUTOSAR A15-1-2 An exception object shall not be a pointer
AUTOSAR-A15_1_2-a=An exception object should not have pointer type
AUTOSAR-A15_1_5=AUTOSAR A15-1-5 Exceptions shall not be thrown across execution boundaries
AUTOSAR-A15_1_5-a=Do not throw an exception across execution boundaries
AUTOSAR-A15_2_1=AUTOSAR A15-2-1 Constructors that are not noexcept shall not be invoked before program startup
AUTOSAR-A15_2_1-a=Function called in global or namespace scope shall not throw unhandled exceptions
AUTOSAR-A15_2_1-b=Each exception explicitly thrown in the code shall have a handler of a compatible type in all call paths that could lead to that point
AUTOSAR-A15_3_2=AUTOSAR A15-3-2 If a function throws an exception, it shall be handled when meaningful actions can be taken, otherwise it shall be propagated
AUTOSAR-A15_3_2-a=Each exception explicitly thrown in the code shall have a handler of a compatible type in all call paths that could lead to that point
AUTOSAR-A15_3_3=AUTOSAR A15-3-3 Main function and a task main function shall catch at least\: base class exceptions from all third-party libraries used, std\:\:exception and all otherwise unhandled exceptions
AUTOSAR-A15_3_3-a=There should be at least one exception handler to catch all otherwise unhandled exceptions
AUTOSAR-A15_3_4=AUTOSAR A15-3-4 Catch-all (ellipsis and std\:\:exception) handlers shall be used only in (a) main, (b) task main functions, (c) in functions that are supposed to isolate independent components and (d) when calling third-party code that uses exceptions not according to AUTOSAR C++14 guidelines
AUTOSAR-A15_3_4-a=Avoid using catch-all exception handlers
AUTOSAR-A15_3_5=AUTOSAR A15-3-5 A class type exception shall be caught by reference or const reference
AUTOSAR-A15_3_5-a=A class type exception shall always be caught by reference
AUTOSAR-A15_4_1=AUTOSAR A15-4-1 Dynamic exception-specification shall not be used
AUTOSAR-A15_4_1-a=Do not use throw exception specifications
AUTOSAR-A15_4_4=AUTOSAR A15-4-4 A declaration of non-throwing function shall contain noexcept specification
AUTOSAR-A15_4_4-a=Declare functions 'noexcept' if they will not emit exceptions
AUTOSAR-A15_4_5=AUTOSAR A15-4-5 Checked exceptions that could be thrown from a function shall be specified together with the function declaration and they shall be identical in all function declarations and for all its overriders
AUTOSAR-A15_4_5-a=Checked exceptions that could be thrown from a function shall be specified in the comment directly before the function declaration
AUTOSAR-A15_5_1=AUTOSAR A15-5-1 All user-provided class destructors, deallocation functions, move constructors, move assignment operators and swap functions shall not exit with an exception. A noexcept exception specification shall be added to these functions as appropriate
AUTOSAR-A15_5_1-a=Never allow an exception to be thrown from a destructor, deallocation, and swap
AUTOSAR-A15_5_1-b=All user-provided move constructors and move assignment operators shall not exit with an exception
AUTOSAR-A15_5_2=AUTOSAR A15-5-2 Program shall not be abruptly terminated. In particular, an implicit or explicit invocation of std\:\:abort(), std\:\:quick_exit(), std\:\:_Exit(), std\:\:terminate() shall not be done
AUTOSAR-A15_5_2-a=The execution of a function registered with 'std\:\:atexit()' or 'std\:\:at_quick_exit()' should not exit via an exception
AUTOSAR-A15_5_2-b=The 'abort()' function from the 'stdlib.h' or 'cstdlib' library shall not be used
AUTOSAR-A15_5_2-c=The 'quick_exit()' and '_Exit()' functions from the 'stdlib.h' or 'cstdlib' library shall not be used
AUTOSAR-A15_5_3=AUTOSAR A15-5-3 The std\:\:terminate() function shall not be called implicitly
AUTOSAR-A15_5_3-a=The execution of a function registered with 'std\:\:atexit()' or 'std\:\:at_quick_exit()' should not exit via an exception
AUTOSAR-A15_5_3-b=Never allow an exception to be thrown from a destructor, deallocation, and swap
AUTOSAR-A15_5_3-c=Do not throw from within destructor
AUTOSAR-A15_5_3-d=There should be at least one exception handler to catch all otherwise unhandled exceptions
AUTOSAR-A15_5_3-e=An empty throw (throw;) shall only be used in the compound-statement of a catch handler
AUTOSAR-A15_5_3-f=Exceptions shall be raised only after start-up and before termination of the program
AUTOSAR-A15_5_3-g=Each exception explicitly thrown in the code shall have a handler of a compatible type in all call paths that could lead to that point
AUTOSAR-A15_5_3-h=Where a function's declaration includes an exception-specification, the function shall only be capable of throwing exceptions of the indicated type(s)
AUTOSAR-A15_5_3-i=Function called in global or namespace scope shall not throw unhandled exceptions
AUTOSAR-A16_0_1=AUTOSAR A16-0-1 The pre-processor shall only be used for unconditional and conditional file inclusion and include guards, and using the following directives\: (1) \#ifndef, (2) \#ifdef, (3) \#if, (4) \#if defined, (5) \#elif, (6) \#else, (7) \#define, (8) \#endif, (9) \#include
AUTOSAR-A16_0_1-a=The \#ifndef, \#ifdef, \#if, \#elif, \#else, and \#endif pre-processor directives shall only be used for conditional file inclusion and include guards
AUTOSAR-A16_0_1-b=\#error directive shall not be used
AUTOSAR-A16_0_1-c=The \#pragma directive shall not be used
AUTOSAR-A16_0_1-d=Avoid using macro definitions
AUTOSAR-A16_0_1-e=\#undef shall not be used
AUTOSAR-A16_2_1=AUTOSAR A16-2-1 The ', ", /*, //, \\ characters shall not occur in a header file name or in \#include directive
AUTOSAR-A16_2_1-a=The following character sequences shall not appear in header file names\: ', \\, /*, //, or "
AUTOSAR-A16_2_2=AUTOSAR A16-2-2 There shall be no unused include directives
AUTOSAR-A16_2_2-a=A file should directly include only the headers that contain declarations and definitions required to compile that file
AUTOSAR-A16_6_1=AUTOSAR A16-6-1 \#error directive shall not be used
AUTOSAR-A16_6_1-a=\#error directive shall not be used
AUTOSAR-A16_7_1=AUTOSAR A16-7-1 The \#pragma directive shall not be used
AUTOSAR-A16_7_1-a=The \#pragma directive shall not be used
AUTOSAR-A17_0_1=AUTOSAR A17-0-1 Reserved identifiers, macros and functions in the C++ standard library shall not be defined, redefined or undefined
AUTOSAR-A17_0_1-a=Do not \#define nor \#undef identifier 'defined'
AUTOSAR-A17_0_1-b=Reserved identifiers, macros and functions in the standard library, shall not be defined, redefined or undefined (C99 code)
AUTOSAR-A17_0_1-c=Reserved identifiers, macros and functions in the standard library, shall not be defined, redefined or undefined (C90 code)
AUTOSAR-A17_0_1-d=Do not redefine reserved words
AUTOSAR-A17_0_1-e=Do not \#define or \#undef identifiers with names which start with underscore
AUTOSAR-A17_1_1=AUTOSAR A17-1-1 Use of the C Standard Library shall be encapsulated and isolated
AUTOSAR-A17_1_1-a=The error indicator 'errno' shall not be used
AUTOSAR-A17_6_1=AUTOSAR A17-6-1 Non-standard entities shall not be added to standard namespaces
AUTOSAR-A17_6_1-a=Do not modify the standard namespaces 'std' and 'posix'
AUTOSAR-A18_0_1=AUTOSAR A18-0-1 The C library facilities shall only be accessed through C++ library headers
AUTOSAR-A18_0_1-a=The C library shall not be used
AUTOSAR-A18_0_2=AUTOSAR A18-0-2 The error state of a conversion from string to a numeric value shall be checked
AUTOSAR-A18_0_2-a=The library functions atof, atoi and atol from library stdlib.h shall not be used
AUTOSAR-A18_0_2-b=The library functions atof, atoi and atol from library stdlib.h shall not be used
AUTOSAR-A18_0_3=AUTOSAR A18-0-3 The library <clocale> (locale.h) and the setlocale function shall not be used
AUTOSAR-A18_0_3-a=Do not include <locale.h> header
AUTOSAR-A18_0_3-b=Do not use 'setlocale' function
AUTOSAR-A18_1_1=AUTOSAR A18-1-1 C-style arrays shall not be used
AUTOSAR-A18_1_1-a=C-style arrays shall not be used
AUTOSAR-A18_1_2=AUTOSAR A18-1-2 The std\:\:vector<bool> specialization shall not be used
AUTOSAR-A18_1_2-a=Avoid using vector<bool>
AUTOSAR-A18_1_3=AUTOSAR A18-1-3 The std\:\:auto_ptr type shall not be used
AUTOSAR-A18_1_3-a=Prefer to use std\:\:unique_ptr instead of std\:\:auto_ptr
AUTOSAR-A18_1_6=AUTOSAR A18-1-6 All std\:\:hash specializations for user-defined types shall have a noexcept function call operator
AUTOSAR-A18_1_6-a=All std\:\:hash specializations for user-defined types shall have a noexcept function call operator
AUTOSAR-A18_5_1=AUTOSAR A18-5-1 Functions malloc, calloc, realloc and free shall not be used
AUTOSAR-A18_5_1-a=Do not use calloc, malloc, realloc and free functions
AUTOSAR-A18_5_10=AUTOSAR A18-5-10 Placement new shall be used only with properly aligned pointers to sufficient storage capacity
AUTOSAR-A18_5_10-a=Do not pass a pointer that has insufficient storage capacity or that is not suitably aligned for the object being constructed to placement 'new'
AUTOSAR-A18_5_10-b=An overhead should be used when an array of objects is passed to the placement 'new' allocation function
AUTOSAR-A18_5_11=AUTOSAR A18-5-11 "operator new" and "operator delete" shall be defined together
AUTOSAR-A18_5_11-a=Write operator delete if you write operator new
AUTOSAR-A18_5_11-b=Write operator delete[] if you write operator new[]
AUTOSAR-A18_5_2=AUTOSAR A18-5-2 Non-placement new or delete expressions shall not be used
AUTOSAR-A18_5_2-a=Dynamic heap memory allocation shall not be used
AUTOSAR-A18_5_3=AUTOSAR A18-5-3 The form of the delete expression shall match the form of the new expression used to allocate the memory
AUTOSAR-A18_5_3-a=Never provide brackets ([]) for delete when deallocating non-arrays
AUTOSAR-A18_5_3-b=Always provide empty brackets ([]) for delete when deallocating arrays
AUTOSAR-A18_5_4=AUTOSAR A18-5-4 If a project has sized or unsized version of operator "delete" globally defined, then both sized and unsized versions shall be defined
AUTOSAR-A18_5_4-a=Define both sized and unsized versions of operator delete
AUTOSAR-A18_5_5=AUTOSAR A18-5-5 Memory management functions shall ensure the following\: (a) deterministic behavior resulting with the existence of worst-case execution time, (b) avoiding memory fragmentation, (c) avoid running out of memory, (d) avoiding mismatched allocations or deallocations, (e) no dependence on non-deterministic calls to kernel
AUTOSAR-A18_5_5-a=Use the same form in corresponding calls to new/malloc and delete/free
AUTOSAR-A18_5_5-b=Freed memory shouldn't be accessed under any circumstances
AUTOSAR-A18_5_8=AUTOSAR A18-5-8 Objects that do not outlive a function shall have automatic storage duration
AUTOSAR-A18_5_8-a=Use allocation by declaration rather than by new or malloc
AUTOSAR-A18_5_9=AUTOSAR A18-5-9 Custom implementations of dynamic memory allocation and deallocation functions shall meet the semantic requirements specified in the corresponding "Required behaviour" clause from the C++ Standard
AUTOSAR-A18_5_9-a=The user defined 'new' operator should throw the 'std\:\:bad_alloc' exception when the allocation fails
AUTOSAR-A18_9_1=AUTOSAR A18-9-1 The std\:\:bind shall not be used
AUTOSAR-A18_9_1-a=Prefer lambdas over std\:\:bind, std\:\:bind1st and std\:\:bind2nd
AUTOSAR-A18_9_2=AUTOSAR A18-9-2 Forwarding values to other functions shall be done via\: (1) std\:\:move if the value is an rvalue reference, (2) std\:\:forward if the value is forwarding reference
AUTOSAR-A18_9_2-a=The 'std\:\:forward' function shall be used to forward universal references
AUTOSAR-A18_9_3=AUTOSAR A18-9-3 The std\:\:move shall not be used on objects declared const or const&
AUTOSAR-A18_9_3-a=Do not use std\:\:move on objects declared with the const or const & type
AUTOSAR-A1_1_1=AUTOSAR A1-1-1 All code shall conform to ISO/IEC 14882\:2014 - Programming Language C++ and shall not use deprecated features
AUTOSAR-A1_1_1-a=The 'register' storage class specifier shall not be used
AUTOSAR-A1_1_1-b=A copy assignment operator should be declared when a copy constructor is declared (and vice versa)
AUTOSAR-A1_1_1-c=Both copy constructor and copy assignment operator should be declared for classes with a nontrivial destructor
AUTOSAR-A1_1_1-d=The C library shall not be used
AUTOSAR-A1_1_1-e=Prefer lambdas over std\:\:bind, std\:\:bind1st and std\:\:bind2nd
AUTOSAR-A1_1_1-f=The 'binder1st' and 'binder2nd' identifiers should not be used
AUTOSAR-A1_1_1-g=Prefer to use std\:\:unique_ptr instead of std\:\:auto_ptr
AUTOSAR-A1_1_1-h=The 'random_shuffle' identifier should not be used
AUTOSAR-A1_1_1-i=Do not use the increment operator (++) on an operand of type 'bool'
AUTOSAR-A1_1_1-j=The 'set_unexpected' identifier should not be used
AUTOSAR-A1_1_1-k=Do not use throw exception specifications
AUTOSAR-A20_8_2=AUTOSAR A20-8-2 A std\:\:unique_ptr shall be used to represent exclusive ownership
AUTOSAR-A20_8_2-a=Use smart pointers when passing a pointer to an object in a thread
AUTOSAR-A20_8_3=AUTOSAR A20-8-3 A std\:\:shared_ptr shall be used to represent shared ownership
AUTOSAR-A20_8_3-a=Use smart pointers when passing a pointer to an object in a thread
AUTOSAR-A20_8_4=AUTOSAR A20-8-4 A std\:\:unique_ptr shall be used over std\:\:shared_ptr if ownership sharing is not required
AUTOSAR-A20_8_4-a=Consider using 'std\:\:unique_ptr' instead of 'std\:\:shared_ptr' for local objects
AUTOSAR-A20_8_5=AUTOSAR A20-8-5 std\:\:make_unique shall be used to construct objects owned by std\:\:unique_ptr
AUTOSAR-A20_8_5-a='std\:\:make_unique' shall be used to construct objects owned by 'std\:\:unique_ptr'
AUTOSAR-A20_8_6=AUTOSAR A20-8-6 std\:\:make_shared shall be used to construct objects owned by std\:\:shared_ptr
AUTOSAR-A20_8_6-a=Prefer 'std\:\:make_shared' to the direct use of new
AUTOSAR-A23_0_1=AUTOSAR A23-0-1 An iterator shall not be implicitly converted to const_iterator
AUTOSAR-A23_0_1-a=Use const container calls when the result is immediately converted to a const iterator
AUTOSAR-A25_1_1=AUTOSAR A25-1-1 Non-static data members or captured values of predicate function objects that are state related to this object's identity shall not be copied
AUTOSAR-A25_1_1-a=Make predicates const pure functions
AUTOSAR-A25_4_1=AUTOSAR A25-4-1 Ordering predicates used with associative containers and STL sorting and related algorithms shall adhere to a strict weak ordering relation
AUTOSAR-A25_4_1-a=For associative containers never use comparison function returning true for equal values
AUTOSAR-A26_5_1=AUTOSAR A26-5-1 Pseudorandom numbers shall not be generated using std\:\:rand()
AUTOSAR-A26_5_1-a=Do not use the rand() function for generating pseudorandom numbers
AUTOSAR-A27_0_1=AUTOSAR A27-0-1 Inputs from independent components shall be validated
AUTOSAR-A27_0_1-a=Avoid calling functions printf/wprintf with only one argument other than string constant
AUTOSAR-A27_0_2=AUTOSAR A27-0-2 A C-style string shall guarantee sufficient space for data and the null terminator
AUTOSAR-A27_0_2-c=Do not use the 'char' buffer to store input from 'std\:\:cin'
AUTOSAR-A27_0_4=AUTOSAR A27-0-4 C-style strings shall not be used
AUTOSAR-A27_0_4-a=Don't use unsafe C functions that do write to range-unchecked buffers
AUTOSAR-A27_0_4-b=Avoid using unsafe string functions that do not check bounds
AUTOSAR-A27_0_4-c=Do not use the 'char' buffer to store input from 'std\:\:cin'
AUTOSAR-A27_0_4-d=C-style strings shall not be used
AUTOSAR-A2_10_1=AUTOSAR A2-10-1 An identifier declared in an inner scope shall not hide an identifier declared in an outer scope
AUTOSAR-A2_10_1-a=Identifier declared in a local or function prototype scope shall not hide an identifier declared in a global or namespace scope
AUTOSAR-A2_10_1-b=Identifiers declared in an inner local scope should not hide identifiers declared in an outer local scope
AUTOSAR-A2_10_1-c=Identifiers declared in a local scope should not hide identifiers declared in a class scope
AUTOSAR-A2_10_1-d=Identifiers declared in a class scope should not hide identifiers declared in a global or namespace scope
AUTOSAR-A2_10_1-e=Identifiers declared in an inner class scope should not hide identifiers declared in outer class scope
AUTOSAR-A2_10_6=AUTOSAR A2-10-6 A class or enumeration name shall not be hidden by a variable, function or enumerator declaration in the same scope
AUTOSAR-A2_10_6-a=If an identifier refers to a type, it shall not also refer to an object or a function in the same scope
AUTOSAR-A2_10_6-b=If an identifier refers to a type, it shall not also refer to an object or a function in the same scope
AUTOSAR-A2_10_6-c=If an identifier refers to a type, it shall not also refer to an object or a function in the same scope
AUTOSAR-A2_11_1=AUTOSAR A2-11-1 Volatile keyword shall not be used
AUTOSAR-A2_11_1-a=Do not use the volatile keyword
AUTOSAR-A2_13_1=AUTOSAR A2-13-1 Only those escape sequences that are defined in ISO/IEC 14882\:2014 shall be used
AUTOSAR-A2_13_1-a=Only those escape sequences that are defined in ISO/IEC 14882\:2014 shall be used
AUTOSAR-A2_13_2=AUTOSAR A2-13-2 String literals with different encoding prefixes shall not be concatenated
AUTOSAR-A2_13_2-a=String literals with different encoding prefixes shall not be concatenated
AUTOSAR-A2_13_3=AUTOSAR A2-13-3 Type wchar_t shall not be used
AUTOSAR-A2_13_3-a=Type wchar_t shall not be used
AUTOSAR-A2_13_4=AUTOSAR A2-13-4 String literals shall not be assigned to non-constant pointers
AUTOSAR-A2_13_4-a=A string literal shall not be modified
AUTOSAR-A2_13_5=AUTOSAR A2-13-5 Hexadecimal constants should be upper case
AUTOSAR-A2_13_5-a=Hexadecimal constants will be represented using all uppercase letters
AUTOSAR-A2_13_6=AUTOSAR A2-13-6 Universal character names shall be used only inside character or string literals
AUTOSAR-A2_13_6-a=Universal character names shall be used only inside character or string literals
AUTOSAR-A2_3_1=AUTOSAR A2-3-1 Only those characters specified in the C++ Language Standard basic source character set shall be used in the source code
AUTOSAR-A2_3_1-a=Only use characters defined in the ISO C standard
AUTOSAR-A2_5_1=AUTOSAR A2-5-1 Trigraphs shall not be used
AUTOSAR-A2_5_1-a=Trigraphs shall not be used
AUTOSAR-A2_5_1-b=Trigraphs shall not be used
AUTOSAR-A2_5_2=AUTOSAR A2-5-2 Digraphs shall not be used
AUTOSAR-A2_5_2-a=Do not use the following digraphs\: <%, %>, <\:, \:>, %\:, %\:%\:
AUTOSAR-A2_7_1=AUTOSAR A2-7-1 The character \\ shall not occur as a last character of a C++ comment
AUTOSAR-A2_7_1-a=Line-splicing shall not be used in // comments
AUTOSAR-A2_7_2=AUTOSAR A2-7-2 Sections of code shall not be "commented out"
AUTOSAR-A2_7_2-a=Sections of code should not be "commented out"
AUTOSAR-A2_7_3=AUTOSAR A2-7-3 All declarations of "user-defined" types, static and non-static data members, functions and methods shall be preceded by documentation using "///" comments and "@tag" tags
AUTOSAR-A2_7_3-a=All declarations of types, data members, and functions should be preceded by a comment annotated with the '@brief' tag
AUTOSAR-A2_7_3-b=Function parameters and return type should be documented in a comment that precedes the function declaration
AUTOSAR-A2_8_1=AUTOSAR A2-8-1 A header file name shall be identical to a type name declared in it if it declares a type
AUTOSAR-A2_8_1-a=An include file for a class should have a file name of the form <class name> + extension
AUTOSAR-A3_1_1=AUTOSAR A3-1-1 It shall be possible to include any header file in multiple translation units without violating the One Definition Rule
AUTOSAR-A3_1_1-a=Don't define entities with linkage in a header file
AUTOSAR-A3_1_2=AUTOSAR A3-1-2 Header files, that are defined locally in the project, shall have a file name extension of one of\: ".h", ".hpp" or ".hxx"
AUTOSAR-A3_1_2-a=Header files should have a file extension of\: ".h", ".hpp" or ".hxx"
AUTOSAR-A3_1_3=AUTOSAR A3-1-3 Implementation files, that are defined locally in the project, should have a file name extension of ".cpp"
AUTOSAR-A3_1_3-a=Implementation files in C++ will always have a file name extension of ".cpp"
AUTOSAR-A3_1_4=AUTOSAR A3-1-4 When an array with external linkage is declared, its size shall be stated explicitly
AUTOSAR-A3_1_4-a=When an array is declared with external linkage, its size shall be stated explicitly or defined implicitly by initialisation
AUTOSAR-A3_1_5=AUTOSAR A3-1-5 A function definition shall only be placed in a class definition if (1) the function is intended to be inlined (2) it is a member function template (3) it is a member function of a class template
AUTOSAR-A3_1_5-a=A function definition should not be placed in a class specification unless the function is intended to be inlined
AUTOSAR-A3_1_6=AUTOSAR A3-1-6 Trivial accessor and mutator functions should be inlined
AUTOSAR-A3_1_6-a=Trivial accessor and mutator functions should be inlined
AUTOSAR-A3_3_1=AUTOSAR A3-3-1 Objects or functions with external linkage (including members of named namespaces) shall be declared in a header file
AUTOSAR-A3_3_1-a=Objects or functions with external linkage shall be declared in a header file
AUTOSAR-A3_3_1-b=Don't define entities with linkage in a header file
AUTOSAR-A3_3_2=AUTOSAR A3-3-2 Static and thread-local objects shall be constant-initialized
AUTOSAR-A3_3_2-a=Static and thread-local objects shall be constant-initialized
AUTOSAR-A3_8_1=AUTOSAR A3-8-1 An object shall not be accessed outside of its lifetime
AUTOSAR-A3_8_1-b=The address of an object with automatic storage shall not be returned from a function
AUTOSAR-A3_8_1-c=The address of an object with automatic storage shall not be assigned to another object that may persist after the first object has ceased to exist
AUTOSAR-A3_9_1=AUTOSAR A3-9-1 Fixed width integer types from <cstdint>, indicating the size and signedness, shall be used in place of the basic numerical types
AUTOSAR-A3_9_1-b=Fixed width integer types from <cstdint>, indicating the size and signedness, shall be used in place of the basic numerical types
AUTOSAR-A3_9_1-c=A typedef should be used in place of the plain char type
AUTOSAR-A4_10_1=AUTOSAR A4-10-1 Only nullptr literal shall be used as the null-pointer-constant
AUTOSAR-A4_10_1-a=NULL shall not be used as an integer value
AUTOSAR-A4_10_1-b=Prefer 'nullptr' over 'NULL' or '0'(zero)
AUTOSAR-A4_5_1=AUTOSAR A4-5-1 Expressions with type enum or enum class shall not be used as operands to built-in and overloaded operators other than the subscript operator [ ], the assignment operator \=, the equality operators \=\= and \!\=, the unary & operator, and the relational operators <, <\=, >, >\=
AUTOSAR-A4_5_1-a=Expressions with type enum shall not be used as operands to built-in operators other than  [ ],  \=, \=\=, \!\=, <, <\=, >, >\=, and the unary & operator
AUTOSAR-A4_7_1=AUTOSAR A4-7-1 An integer expression shall not lead to data loss
AUTOSAR-A4_7_1-a=Avoid implicit conversions from signed to unsigned type
AUTOSAR-A4_7_1-b=Implicit conversions from integral constant to floating type which may result in a loss of information shall not be used
AUTOSAR-A4_7_1-c=Avoid conversions of constant values to a narrower type
AUTOSAR-A4_7_1-d=Implicit conversions from wider to narrower integral type which may result in a loss of information shall not be used
AUTOSAR-A4_7_1-e=Avoid implicit conversions from wider to narrower floating type
AUTOSAR-A4_7_1-f=Avoid implicit conversions from floating to integral type
AUTOSAR-A4_7_1-g=Implicit conversions from integral to floating type which may result in a loss of information shall not be used
AUTOSAR-A5_0_1=AUTOSAR A5-0-1 The value of an expression shall be the same under any order of evaluation that the standard permits
AUTOSAR-A5_0_1-a=Don't write code that depends on the order of evaluation of function calls
AUTOSAR-A5_0_1-b=Do not use more than one volatile between two adjacent sequence points
AUTOSAR-A5_0_1-c=Between sequence points an object shall have its stored value modified at most once by the evaluation of an expression
AUTOSAR-A5_0_1-d=Don't write code that depends on the order of evaluation of expression that involves a function call
AUTOSAR-A5_0_1-e=Don't write code that depends on the order of evaluation of function designator and function arguments
AUTOSAR-A5_0_1-f=Don't write code that depends on the order of evaluation of function arguments
AUTOSAR-A5_0_1-g=The value of an expression shall be the same under any order of evaluation that the standard permits
AUTOSAR-A5_0_2=AUTOSAR A5-0-2 The condition of an if-statement and the condition of an iteration statement shall have type bool
AUTOSAR-A5_0_2-a=The condition of an if-statement and the condition of an iteration-statement shall have type bool
AUTOSAR-A5_0_3=AUTOSAR A5-0-3 The declaration of objects shall contain no more than two levels of pointer indirection
AUTOSAR-A5_0_3-a=The declaration of objects should contain no more than 2 levels of pointer indirection
AUTOSAR-A5_0_4=AUTOSAR A5-0-4 Pointer arithmetic shall not be used with pointers to non-final classes
AUTOSAR-A5_0_4-a=Don't treat arrays polymorphically
AUTOSAR-A5_0_4-b=A pointer to an array of derived class objects should not be converted to a base class pointer
AUTOSAR-A5_10_1=AUTOSAR A5-10-1 A pointer to member virtual function shall only be tested for equality with null-pointer-constant
AUTOSAR-A5_10_1-a=A pointer to member virtual function shall only be tested for equality with null-pointer-constant
AUTOSAR-A5_16_1=AUTOSAR A5-16-1 The ternary conditional operator shall not be used as a sub-expression
AUTOSAR-A5_16_1-a=The conditional operator should not be used as a sub-expression
AUTOSAR-A5_1_1=AUTOSAR A5-1-1 Literal values shall not be used apart from type initialization, otherwise symbolic names shall be used instead
AUTOSAR-A5_1_1-a=Avoid magic numbers
AUTOSAR-A5_1_2=AUTOSAR A5-1-2 Variables shall not be implicitly captured in a lambda expression
AUTOSAR-A5_1_2-a=Avoid default capture modes
AUTOSAR-A5_1_3=AUTOSAR A5-1-3 Parameter list (possibly empty) shall be included in every lambda expression
AUTOSAR-A5_1_3-a=Include a parameter list in every lambda expression
AUTOSAR-A5_1_4=AUTOSAR A5-1-4 A lambda expression object shall not outlive any of its reference-captured objects
AUTOSAR-A5_1_4-a=Never return lambdas that capture local objects by reference
AUTOSAR-A5_1_4-b=Never capture local objects from an outer lambda by reference
AUTOSAR-A5_1_4-c=The lambda that captures local objects by reference should not be assigned to the variable with a greater lifetime
AUTOSAR-A5_1_6=AUTOSAR A5-1-6 Return type of a non-void return type lambda expression should be explicitly specified
AUTOSAR-A5_1_6-a=Return type of a non-void return type lambda expression should be explicitly specified
AUTOSAR-A5_1_7=AUTOSAR A5-1-7 A lambda shall not be an operand to decltype or typeid
AUTOSAR-A5_1_7-a=A lambda shall not be an operand to typeid
AUTOSAR-A5_1_8=AUTOSAR A5-1-8 Lambda expressions should not be defined inside another lambda expression
AUTOSAR-A5_1_8-a=Lambda expressions should not be defined inside another lambda expression
AUTOSAR-A5_2_1=AUTOSAR A5-2-1 dynamic_cast should not be used
AUTOSAR-A5_2_1-a=Avoid dynamic_casts
AUTOSAR-A5_2_2=AUTOSAR A5-2-2 Traditional C-style casts shall not be used
AUTOSAR-A5_2_2-a=C-style casts should not be used
AUTOSAR-A5_2_3=AUTOSAR A5-2-3 A cast shall not remove any const or volatile qualification from the type of a pointer or reference
AUTOSAR-A5_2_3-a=A cast shall not remove any 'const' or 'volatile' qualification from the type of a pointer or reference
AUTOSAR-A5_2_4=AUTOSAR A5-2-4 reinterpret_cast shall not be used
AUTOSAR-A5_2_4-a=Avoid using reinterpret_cast
AUTOSAR-A5_2_6=AUTOSAR A5-2-6 The operands of a logical && or || shall be parenthesized if the operands contain binary operators
AUTOSAR-A5_2_6-a=The operands of a logical && or || shall be parenthesized if the operands contain binary operators
AUTOSAR-A5_3_1=AUTOSAR A5-3-1 Evaluation of the operand to the typeid operator shall not contain side effects
AUTOSAR-A5_3_1-a=The operand of the 'typeid' operator shall not contain any expression that has side effects
AUTOSAR-A5_3_1-b=The operand of the 'typeid' operator shall not contain a function call that causes side effects
AUTOSAR-A5_3_3=AUTOSAR A5-3-3 Pointers to incomplete class types shall not be deleted
AUTOSAR-A5_3_3-a=Do not delete objects with incomplete class at the point of deletion
AUTOSAR-A5_5_1=AUTOSAR A5-5-1 A pointer to member shall not access non-existent class members
AUTOSAR-A5_5_1-a=A cast shall not convert a pointer to a function to any other pointer type, including a pointer to function type
AUTOSAR-A6_2_1=AUTOSAR A6-2-1 Move and copy assignment operators shall either move or respectively copy base classes and data members of a class, without any side effects
AUTOSAR-A6_2_1-a=Copy assignment operators should not have side effects that could affect copying the object
AUTOSAR-A6_2_1-b=Move assignment operators should not have side effects that could affect moving the object
AUTOSAR-A6_2_2=AUTOSAR A6-2-2 Expression statements shall not be explicit calls to constructors of temporary objects only
AUTOSAR-A6_2_2-a=Expression statements shall not be explicit calls to constructors of temporary objects only
AUTOSAR-A6_4_1=AUTOSAR A6-4-1 A switch statement shall have at least two case-clauses, distinct from the default label
AUTOSAR-A6_4_1-a=Every switch statement will have at least two cases and a potential default
AUTOSAR-A6_5_1=AUTOSAR A6-5-1 A for-loop that loops through all elements of the container and does not use its loop-counter shall not be used
AUTOSAR-A6_5_1-a=A for-loop that loops through all elements of the container and does not use its loop-counter shall not be used
AUTOSAR-A6_5_2=AUTOSAR A6-5-2 A for loop shall contain a single loop-counter which shall not have floating-point type
AUTOSAR-A6_5_2-a=A for loop shall contain a single loop-counter which shall not have floating type
AUTOSAR-A6_5_3=AUTOSAR A6-5-3 Do statements should not be used
AUTOSAR-A6_5_3-a='Do' statements should not be used except in a function-like macro
AUTOSAR-A6_5_4=AUTOSAR A6-5-4 For-init-statement and expression should not perform actions other than loop-counter initialization and modification
AUTOSAR-A6_5_4-a=The initialization expression in a for loop will perform no actions other than to initialize the value of a single for loop parameter
AUTOSAR-A6_5_4-b=The increment expression in a for loop will perform no action other than to change a single loop parameter to the next value for the loop
AUTOSAR-A6_6_1=AUTOSAR A6-6-1 The goto statement shall not be used
AUTOSAR-A6_6_1-a=The goto statement shall not be used
AUTOSAR-A7_1_1=AUTOSAR A7-1-1 Constexpr or const specifiers shall be used for immutable data declaration
AUTOSAR-A7_1_1-a=Declare local variable as const whenever possible
AUTOSAR-A7_1_1-b=Declare parameters as const whenever possible
AUTOSAR-A7_1_2=AUTOSAR A7-1-2 The constexpr specifier shall be used for values that can be determined at compile time
AUTOSAR-A7_1_2-a=Use constexpr to declare const variables whenever possible
AUTOSAR-A7_1_2-b=Use constexpr to declare functions whenever possible
AUTOSAR-A7_1_3=AUTOSAR A7-1-3 CV-qualifiers shall be placed on the right hand side of the type that is a typedef or a using name
AUTOSAR-A7_1_3-a=CV-qualifiers shall be placed on the right hand side of the type that is a typedef or a using name
AUTOSAR-A7_1_4=AUTOSAR A7-1-4 The register keyword shall not be used
AUTOSAR-A7_1_4-a=The 'register' storage class specifier shall not be used
AUTOSAR-A7_1_5=AUTOSAR A7-1-5 The auto specifier shall not be used apart from following cases\: (1) to declare that a variable has the same type as return type of a function call, (2) to declare that a variable has the same type as initializer of non-fundamental type, (3) to declare parameters of a generic lambda expression, (4) to declare a function template using trailing return type syntax
AUTOSAR-A7_1_5-a=Do not overuse 'auto' specifier
AUTOSAR-A7_1_6=AUTOSAR A7-1-6 The typedef specifier shall not be used
AUTOSAR-A7_1_6-a=Prefer alias declarations to typedefs
AUTOSAR-A7_1_7=AUTOSAR A7-1-7 Each expression statement and identifier declaration shall be placed on a separate line
AUTOSAR-A7_1_7-a=Only one statement shall be allowed per line
AUTOSAR-A7_1_7-b=Multiple variable declarations shall not be allowed on the same line
AUTOSAR-A7_1_7-c=Each variable should be declared in a separate declaration statement
AUTOSAR-A7_1_8=AUTOSAR A7-1-8 A non-type specifier shall be placed before a type specifier in a declaration
AUTOSAR-A7_1_8-a=Do not place type specifiers before non-type specifiers in a declaration
AUTOSAR-A7_1_9=AUTOSAR A7-1-9 A class, structure, or enumeration shall not be declared in the definition of its type
AUTOSAR-A7_1_9-a=A class, structure, or enumeration will not be declared in the definition of its type
AUTOSAR-A7_2_1=AUTOSAR A7-2-1 An expression with enum underlying type shall only have values corresponding to the enumerators of the enumeration
AUTOSAR-A7_2_1-a=An expression with enum underlying type shall only have values corresponding to the enumerators of the enumeration
AUTOSAR-A7_2_2=AUTOSAR A7-2-2 Enumeration underlying base type shall be explicitly defined
AUTOSAR-A7_2_2-a=Use an explicit enumeration base and ensure that it is large enough to store all enumerators
AUTOSAR-A7_2_3=AUTOSAR A7-2-3 Enumerations shall be declared as scoped enum classes
AUTOSAR-A7_2_3-a=Prefer Scoped Enums to Unscoped Enums
AUTOSAR-A7_2_4=AUTOSAR A7-2-4 In an enumeration, either (1) none, (2) the first or (3) all enumerators shall be initialized
AUTOSAR-A7_2_4-a=In an enumerator list, the "\=" construct shall not be used to explicitly initialise members other than the first, unless all items are explicitly initialised
AUTOSAR-A7_2_5=AUTOSAR A7-2-5 Enumerations should be used to represent sets of related named constants
AUTOSAR-A7_2_5-a=Enumeration types shall be used instead of integer types (and constants) as case labels
AUTOSAR-A7_3_1=AUTOSAR A7-3-1 All overloads of a function shall be visible from where it is called
AUTOSAR-A7_3_1-a=Member functions declared in derived class should not hide functions declared in base classes
AUTOSAR-A7_4_1=AUTOSAR A7-4-1 The asm declaration shall not be used
AUTOSAR-A7_4_1-a=Do not use the asm declaration
AUTOSAR-A7_5_1=AUTOSAR A7-5-1 A function shall not return a reference or a pointer to a parameter that is passed by reference to const
AUTOSAR-A7_5_1-a=A function shall not return a pointer or a reference to a parameter that is passed by const reference
AUTOSAR-A7_5_2=AUTOSAR A7-5-2 Functions shall not call themselves, either directly or indirectly
AUTOSAR-A7_5_2-a=Functions shall not call themselves, either directly or indirectly
AUTOSAR-A8_2_1=AUTOSAR A8-2-1 When declaring function templates, the trailing return type syntax shall be used if the return type depends on the type of parameters
AUTOSAR-A8_2_1-a=Use a trailing return type syntax if the return type is preceded by the 'typename' keyword
AUTOSAR-A8_4_1=AUTOSAR A8-4-1 Functions shall not be defined using the ellipsis notation
AUTOSAR-A8_4_1-a=Do not use functions with variable numbers of arguments
AUTOSAR-A8_4_11=AUTOSAR A8-4-11 A smart pointer shall only be used as a parameter type if it expresses lifetime semantics
AUTOSAR-A8_4_11-a=A smart pointer shall only be used as a parameter type if it expresses lifetime semantics
AUTOSAR-A8_4_12=AUTOSAR A8-4-12 A std\:\:unique_ptr shall be passed to a function as\: (1) a copy to express the function assumes ownership (2) an lvalue reference to express that the function replaces the managed object
AUTOSAR-A8_4_12-a=Do not pass std\:\:unique_ptr by const reference
AUTOSAR-A8_4_12-b=A smart pointer shall only be used as a parameter type if it expresses lifetime semantics
AUTOSAR-A8_4_12-c=A parameter should only be declared as a non-const lvalue reference to 'std\:\:shared_ptr' or 'std\:\:unique_ptr' if the function replaces the managed object
AUTOSAR-A8_4_12-d=Do not declare the type of a parameter as an rvalue reference to 'std\:\:shared_ptr' or 'std\:\:unique_ptr'
AUTOSAR-A8_4_13=AUTOSAR A8-4-13 A std\:\:shared_ptr shall be passed to a function as\: (1) a copy to express the function shares ownership (2) an lvalue reference to express that the function replaces the managed object (3) a const lvalue reference to express that the function retains a reference count
AUTOSAR-A8_4_13-a=A smart pointer shall only be used as a parameter type if it expresses lifetime semantics
AUTOSAR-A8_4_13-b=A parameter should only be declared as a non-const lvalue reference to 'std\:\:shared_ptr' or 'std\:\:unique_ptr' if the function replaces the managed object
AUTOSAR-A8_4_13-c=Do not declare the type of a parameter as an rvalue reference to 'std\:\:shared_ptr' or 'std\:\:unique_ptr'
AUTOSAR-A8_4_2=AUTOSAR A8-4-2 All exit paths from a function with non-void return type shall have an explicit return statement with an expression
AUTOSAR-A8_4_2-a=All exit paths from a function, except main(), with non-void return type shall have an explicit return statement with an expression
AUTOSAR-A8_4_3=AUTOSAR A8-4-3 Common ways of passing parameters should be used
AUTOSAR-A8_4_3-a=A parameter of a type that is not 'cheap to copy' should be passed by reference
AUTOSAR-A8_4_3-b=Declare reference parameters as const references whenever possible
AUTOSAR-A8_4_4=AUTOSAR A8-4-4 Multiple output values from a function should be returned as a struct or tuple
AUTOSAR-A8_4_4-a=Multiple output values from a function should be returned as a struct or tuple
AUTOSAR-A8_4_5=AUTOSAR A8-4-5 "consume" parameters declared as X && shall always be moved from
AUTOSAR-A8_4_5-a=Use std\:\:move() on rvalue references and std\:\:forward() on forwarding references
AUTOSAR-A8_4_6=AUTOSAR A8-4-6 "forward" parameters declared as T && shall always be forwarded
AUTOSAR-A8_4_6-a=Use std\:\:move() on rvalue references and std\:\:forward() on forwarding references
AUTOSAR-A8_4_7=AUTOSAR A8-4-7 "in" parameters for "cheap to copy" types shall be passed by value
AUTOSAR-A8_4_7-a=A parameter of const reference to a 'cheap to copy' type should be passed by value
AUTOSAR-A8_4_8=AUTOSAR A8-4-8 Output parameters shall not be used
AUTOSAR-A8_4_8-a=Output parameters shall not be used
AUTOSAR-A8_4_9=AUTOSAR A8-4-9 "in-out" parameters declared as T & shall be modified
AUTOSAR-A8_4_9-a=Declare reference parameters as const references whenever possible
AUTOSAR-A8_5_1=AUTOSAR A8-5-1 In an initialization list, the order of initialization shall be following\: (1) virtual base classes in depth and left to right order of the inheritance graph, (2) direct base classes in left to right order of inheritance list, (3) non-static data members in the order they were declared in the class definition
AUTOSAR-A8_5_1-a=List members in an initialization list in the order in which they are declared
AUTOSAR-A8_5_2=AUTOSAR A8-5-2 Braced-initialization {}, without equals sign, shall be used for variable initialization
AUTOSAR-A8_5_2-a=Braced-initialization {}, without equals sign, shall be used for variable initialization
AUTOSAR-A8_5_3=AUTOSAR A8-5-3 A variable of type auto shall not be initialized using {} or \={} braced-initialization
AUTOSAR-A8_5_3-a=A variable of type auto shall not be initialized using '{}' or '\={}' braced-initialization
AUTOSAR-A8_5_4=AUTOSAR A8-5-4 If a class has a user-declared constructor that takes a parameter of type std\:\:initializer_list, then it shall be the only constructor apart from special member function constructors
AUTOSAR-A8_5_4-a=Avoid overloading constructors with std\:\:initializer_list
AUTOSAR-A9_3_1=AUTOSAR A9-3-1 Member functions shall not return non-const "raw" pointers or references to private or protected data owned by the class
AUTOSAR-A9_3_1-a=Public member functions shall not return non-const handles to private/protected class-data
AUTOSAR-A9_3_1-b=Protected member function shall not return non-const handles to private class-data
AUTOSAR-A9_5_1=AUTOSAR A9-5-1 Unions shall not be used
AUTOSAR-A9_5_1-a=Unions shall not be used
AUTOSAR-A9_5_1-b=Unions shall not be used
AUTOSAR-A9_6_1=AUTOSAR A9-6-1 Data types used for interfacing with hardware or conforming to communication protocols shall be trivial, standard-layout and only contain members of types with defined sizes
AUTOSAR-A9_6_1-a=Bit fields shall only be defined to be of type unsigned int or signed int
AUTOSAR-A9_6_2=AUTOSAR A9-6-2 Bit-fields shall be used only when interfacing to hardware or conforming to communication protocols
AUTOSAR-A9_6_2-a=Do not declare member variables as bit-fields
AUTOSAR-M0_1_1=AUTOSAR M0-1-1 A project shall not contain unreachable code
AUTOSAR-M0_1_1-a=There shall be no unreachable code in "if/else/while/for" block
AUTOSAR-M0_1_1-b=There shall be no unreachable code after 'return', 'break', 'continue', and 'goto' statements
AUTOSAR-M0_1_1-c=There shall be no unreachable code in "else" block
AUTOSAR-M0_1_1-d=There shall be no unreachable code after "if" or "switch" statement inside while/for/do...while loop
AUTOSAR-M0_1_1-e=There shall be no unreachable code after 'if' or 'switch' statement
AUTOSAR-M0_1_1-f=There shall be no unreachable code in 'for' loop
AUTOSAR-M0_1_1-g=There shall be no unreachable code in switch statement
AUTOSAR-M0_1_10=AUTOSAR M0-1-10 Every defined function should be called at least once
AUTOSAR-M0_1_10-b=Every defined function with internal linkage shall be used at least once
AUTOSAR-M0_1_2=AUTOSAR M0-1-2 A project shall not contain infeasible paths
AUTOSAR-M0_1_2-a=Boolean operations whose results are invariant shall not be permitted
AUTOSAR-M0_1_2-aa=Boolean operations whose results are invariant shall not be permitted
AUTOSAR-M0_1_2-ab=Boolean operations whose results are invariant shall not be permitted
AUTOSAR-M0_1_2-b=Boolean operations whose results are invariant shall not be permitted
AUTOSAR-M0_1_2-c=Boolean operations whose results are invariant shall not be permitted
AUTOSAR-M0_1_2-d=Boolean operations whose results are invariant shall not be permitted
AUTOSAR-M0_1_2-e=Boolean operations whose results are invariant shall not be permitted
AUTOSAR-M0_1_2-f=Boolean operations whose results are invariant shall not be permitted
AUTOSAR-M0_1_2-g=Boolean operations whose results are invariant shall not be permitted
AUTOSAR-M0_1_2-h=Boolean operations whose results are invariant shall not be permitted
AUTOSAR-M0_1_2-i=Boolean operations whose results are invariant shall not be permitted
AUTOSAR-M0_1_2-j=Boolean operations whose results are invariant shall not be permitted
AUTOSAR-M0_1_2-k=Boolean operations whose results are invariant shall not be permitted
AUTOSAR-M0_1_2-l=Boolean operations whose results are invariant shall not be permitted
AUTOSAR-M0_1_2-m=Boolean operations whose results are invariant shall not be permitted
AUTOSAR-M0_1_2-n=Boolean operations whose results are invariant shall not be permitted
AUTOSAR-M0_1_2-o=Boolean operations whose results are invariant shall not be permitted
AUTOSAR-M0_1_2-p=Boolean operations whose results are invariant shall not be permitted
AUTOSAR-M0_1_2-q=Boolean operations whose results are invariant shall not be permitted
AUTOSAR-M0_1_2-r=Boolean operations whose results are invariant shall not be permitted
AUTOSAR-M0_1_2-s=Boolean operations whose results are invariant shall not be permitted
AUTOSAR-M0_1_2-t=Boolean operations whose results are invariant shall not be permitted
AUTOSAR-M0_1_2-u=Boolean operations whose results are invariant shall not be permitted
AUTOSAR-M0_1_2-v=Boolean operations whose results are invariant shall not be permitted
AUTOSAR-M0_1_2-w=Boolean operations whose results are invariant shall not be permitted
AUTOSAR-M0_1_2-x=Boolean operations whose results are invariant shall not be permitted
AUTOSAR-M0_1_2-y=Boolean operations whose results are invariant shall not be permitted
AUTOSAR-M0_1_2-z=Boolean operations whose results are invariant shall not be permitted
AUTOSAR-M0_1_3=AUTOSAR M0-1-3 A project shall not contain unused variables
AUTOSAR-M0_1_3-a=Avoid unused local variables
AUTOSAR-M0_1_3-b=Avoid unnecessary local variables
AUTOSAR-M0_1_3-c=Avoid unused private member variables
AUTOSAR-M0_1_3-e=A project should not contain unused variables with internal linkage
AUTOSAR-M0_1_8=AUTOSAR M0-1-8 All functions with void return type shall have external side effect(s)
AUTOSAR-M0_1_8-a=All non-empty functions with void return type shall have external side effect(s)
AUTOSAR-M0_1_8-b=Functions with void return type shall not be empty
AUTOSAR-M0_1_9=AUTOSAR M0-1-9 There shall be no dead code
AUTOSAR-M0_1_9-a=All non-null statements shall either have at least one side-effect however executed or cause control flow to change
AUTOSAR-M0_2_1=AUTOSAR M0-2-1 An object shall not be assigned to an overlapping object
AUTOSAR-M0_2_1-a=An object shall not be assigned to an overlapping object
AUTOSAR-M0_2_1-b=An object shall not be assigned to an overlapping object
AUTOSAR-M0_3_2=AUTOSAR M0-3-2 If a function generates error information, then that error information shall be tested
AUTOSAR-M0_3_2-a=If a function returns error information, then that error information shall be tested
AUTOSAR-M0_4_2=AUTOSAR M0-4-2 Use of floating-point arithmetic shall be documented
AUTOSAR-M0_4_2-a=Use of floating-point arithmetic shall be documented
AUTOSAR-M10_1_1=AUTOSAR M10-1-1 Classes should not be derived from virtual bases
AUTOSAR-M10_1_1-a=Classes should not be derived from virtual bases
AUTOSAR-M10_1_3=AUTOSAR M10-1-3 An accessible base class shall not be both virtual and non-virtual in the same hierarchy
AUTOSAR-M10_1_3-a=A base class shall not be both virtual and non-virtual in the same hierarchy
AUTOSAR-M10_2_1=AUTOSAR M10-2-1 All accessible entity names within a multiple inheritance hierarchy should be unique
AUTOSAR-M10_2_1-a=All accessible entity names within a multiple inheritance hierarchy should be unique
AUTOSAR-M10_3_3=AUTOSAR M10-3-3 A virtual function shall only be overridden by a pure virtual function if it is itself declared as pure virtual
AUTOSAR-M10_3_3-a=A virtual function shall only be overridden by a pure virtual function if it is itself declared as pure virtual
AUTOSAR-M11_0_1=AUTOSAR M11-0-1 Member data in non-POD class types shall be private
AUTOSAR-M11_0_1-a=Member data in non-POD types shall be private
AUTOSAR-M14_5_3=AUTOSAR M14-5-3 A copy assignment operator shall be declared when there is a template assignment operator with a parameter that is a generic parameter
AUTOSAR-M14_5_3-a=A copy assignment operator shall be declared when there is a template assignment operator with a parameter that is a generic parameter
AUTOSAR-M14_6_1=AUTOSAR M14-6-1 In a class template with a dependent base, any name that may be found in that dependent base shall be referred to using a qualified-id or this->
AUTOSAR-M14_6_1-a=In a class template with a dependent base, any name that may be found in that dependent base shall be referred to using a qualified-id or this->
AUTOSAR-M15_0_3=AUTOSAR M15-0-3 Control shall not be transferred into a try or catch block using a goto or a switch statement
AUTOSAR-M15_0_3-a=Control shall not be transferred into a try or catch block using a goto or a switch statement
AUTOSAR-M15_1_1=AUTOSAR M15-1-1 The assignment-expression of a throw statement shall not itself cause an exception to be thrown
AUTOSAR-M15_1_1-a=The assignment-expression of a throw statement shall not itself cause an exception to be thrown
AUTOSAR-M15_1_2=AUTOSAR M15-1-2 NULL shall not be thrown explicitly
AUTOSAR-M15_1_2-a=NULL shall not be thrown explicitly
AUTOSAR-M15_1_3=AUTOSAR M15-1-3 An empty throw (throw;) shall only be used in the compound statement of a catch handler
AUTOSAR-M15_1_3-a=An empty throw (throw;) shall only be used in the compound-statement of a catch handler
AUTOSAR-M15_3_1=AUTOSAR M15-3-1 Exceptions shall be raised only after start-up and before termination
AUTOSAR-M15_3_1-a=Exceptions shall be raised only after start-up and before termination of the program
AUTOSAR-M15_3_3=AUTOSAR M15-3-3 Handlers of a function-try-block implementation of a class constructor or destructor shall not reference non-static members from this class or its bases
AUTOSAR-M15_3_3-a=Handlers of a function-try-block implementation of a class constructor or destructor shall not reference nonstatic members from this class or its bases
AUTOSAR-M15_3_4=AUTOSAR M15-3-4 Each exception explicitly thrown in the code shall have a handler of a compatible type in all call paths that could lead to that point
AUTOSAR-M15_3_4-a=Function called in global or namespace scope shall not throw unhandled exceptions
AUTOSAR-M15_3_4-b=Each exception explicitly thrown in the code shall have a handler of a compatible type in all call paths that could lead to that point
AUTOSAR-M15_3_6=AUTOSAR M15-3-6 Where multiple handlers are provided in a single try-catch statement or function-try-block for a derived class and some or all of its bases, the handlers shall be ordered most-derived to base class
AUTOSAR-M15_3_6-a=Where multiple handlers are provided in a single try-catch statement or function-try-block for a derived class and some or all of its bases, the handlers shall be ordered most-derived to base class
AUTOSAR-M15_3_7=AUTOSAR M15-3-7 Where multiple handlers are provided in a single try-catch statement or function-try-block, any ellipsis (catch-all) handler shall occur last
AUTOSAR-M15_3_7-a=Where multiple handlers are provided in a single 'try-catch' statement or 'function-try-block', any ellipsis (catch-all) handler shall occur last
AUTOSAR-M16_0_1=AUTOSAR M16-0-1 \#include directives in a file shall only be preceded by other pre-processor directives or comments
AUTOSAR-M16_0_1-a=\#include statements in a file should only be preceded by other preprocessor directives or comments
AUTOSAR-M16_0_2=AUTOSAR M16-0-2 Macros shall only be \#define'd or \#undef'd in the global namespace
AUTOSAR-M16_0_2-a=Macros shall not be \#define'd or \#undef'd within a block
AUTOSAR-M16_0_5=AUTOSAR M16-0-5 Arguments to a function-like macro shall not contain tokens that look like pre-processing directives
AUTOSAR-M16_0_5-a=Arguments to a function-like macro shall not contain tokens that look like preprocessing directives
AUTOSAR-M16_0_6=AUTOSAR M16-0-6 In the definition of a function-like macro, each instance of a parameter shall be enclosed in parentheses, unless it is used as the operand of \# or \#\#
AUTOSAR-M16_0_6-a=In the definition of a function-like macro each instance of a parameter shall be enclosed in parentheses unless it is used as the operand of \# or \#\#
AUTOSAR-M16_0_7=AUTOSAR M16-0-7 Undefined macro identifiers shall not be used in \#if or \#elif pre-processor directives, except as operands to the defined operator
AUTOSAR-M16_0_7-a=Do not use in preprocessor directives \#if and \#elif macros not defined in translation unit
AUTOSAR-M16_0_8=AUTOSAR M16-0-8 If the \# token appears as the first token on a line, then it shall be immediately followed by a pre-processing token
AUTOSAR-M16_0_8-a=Preprocessing directives shall be syntactically meaningful even when excluded by the preprocessor
AUTOSAR-M16_1_1=AUTOSAR M16-1-1 The defined pre-processor operator shall only be used in one of the two standard forms
AUTOSAR-M16_1_1-a=The defined preprocessor operator shall only be used in one of the two standard forms
AUTOSAR-M16_1_2=AUTOSAR M16-1-2 All \#else, \#elif and \#endif pre-processor directives shall reside in the same file as the \#if or \#ifdef directive to which they are related
AUTOSAR-M16_1_2-a=All \#else, \#elif and \#endif preprocessor directives shall reside in the same file as the \#if or \#ifdef directive to which they are related
AUTOSAR-M16_2_3=AUTOSAR M16-2-3 Include guards shall be provided
AUTOSAR-M16_2_3-a=Use multiple include guards
AUTOSAR-M16_3_1=AUTOSAR M16-3-1 There shall be at most one occurrence of the \# or \#\# operators in a single macro definition
AUTOSAR-M16_3_1-a=There shall be at most one occurrence of the \# or \#\# preprocessor operators in a single macro definition
AUTOSAR-M16_3_2=AUTOSAR M16-3-2 The \# and \#\# operators should not be used
AUTOSAR-M16_3_2-a=The \# and \#\# preprocessor operators should not be used
AUTOSAR-M17_0_2=AUTOSAR M17-0-2 The names of standard library macros and objects shall not be reused
AUTOSAR-M17_0_2-a=The names of standard library macros and objects shall not be reused
AUTOSAR-M17_0_3=AUTOSAR M17-0-3 The names of standard library functions shall not be overridden
AUTOSAR-M17_0_3-a=The names of standard library functions shall not be overridden
AUTOSAR-M17_0_5=AUTOSAR M17-0-5 The setjmp macro and the longjmp function shall not be used
AUTOSAR-M17_0_5-a=The facilities provided by <setjmp.h> should not be used
AUTOSAR-M17_0_5-b=The standard header files <setjmp.h> or <csetjmp> shall not be used
AUTOSAR-M18_0_3=AUTOSAR M18-0-3 The library functions abort, exit, getenv and system from library <cstdlib> shall not be used
AUTOSAR-M18_0_3-a=The 'abort()' function from the 'stdlib.h' or 'cstdlib' library shall not be used
AUTOSAR-M18_0_3-b=The 'exit()' function from the 'stdlib.h' or 'cstdlib' library shall not be used
AUTOSAR-M18_0_3-c=The 'system()' function from the 'stdlib.h' or 'cstdlib' library shall not be used
AUTOSAR-M18_0_3-d=The 'getenv()' function from the 'stdlib.h' or 'cstdlib' library shall not be used
AUTOSAR-M18_0_4=AUTOSAR M18-0-4 The time handling functions of library <ctime> shall not be used
AUTOSAR-M18_0_4-a=The standard header files <time.h> or <ctime> shall not be used
AUTOSAR-M18_0_4-b=The time handling functions and macros of the library <time.h> shall not be used
AUTOSAR-M18_0_4-c=The types defined in the library <time.h> shall not be used
AUTOSAR-M18_0_5=AUTOSAR M18-0-5 The unbounded functions of library <cstring> shall not be used
AUTOSAR-M18_0_5-a=The unbounded functions of library <cstring> shall not be used
AUTOSAR-M18_2_1=AUTOSAR M18-2-1 The macro offsetof shall not be used
AUTOSAR-M18_2_1-a=The macro offsetof, in library stddef.h, shall not be used
AUTOSAR-M18_7_1=AUTOSAR M18-7-1 The signal handling facilities of <csignal> shall not be used
AUTOSAR-M18_7_1-a=The signal handling facilities of <signal.h> shall not be used
AUTOSAR-M18_7_1-b=The standard header files <signal.h> or <csignal> shall not be used
AUTOSAR-M19_3_1=AUTOSAR M19-3-1 The error indicator errno shall not be used
AUTOSAR-M19_3_1-a=The error indicator 'errno' shall not be used
AUTOSAR-M27_0_1=AUTOSAR M27-0-1 The stream input/output library <cstdio> shall not be used
AUTOSAR-M27_0_1-a=The input/output library stdio.h shall not be used
AUTOSAR-M2_10_1=AUTOSAR M2-10-1 Different identifiers shall be typographically unambiguous
AUTOSAR-M2_10_1-a=Different identifiers shall be typographically unambiguous
AUTOSAR-M2_13_2=AUTOSAR M2-13-2 Octal constants (other than zero) and octal escape sequences (other than "\\0" ) shall not be used
AUTOSAR-M2_13_2-a=Octal constants (other than zero) shall not be used
AUTOSAR-M2_13_2-b=Octal escape sequences shall not be used
AUTOSAR-M2_13_3=AUTOSAR M2-13-3 A "U" suffix shall be applied to all octal or hexadecimal integer literals of unsigned type
AUTOSAR-M2_13_3-a=A "U" suffix shall be applied to all octal or hexadecimal integer literals of unsigned type
AUTOSAR-M2_13_4=AUTOSAR M2-13-4 Literal suffixes shall be upper case
AUTOSAR-M2_13_4-a=Literal suffixes shall use uppercase rather than lowercase letters
AUTOSAR-M2_7_1=AUTOSAR M2-7-1 The character sequence /* shall not be used within a C-style comment
AUTOSAR-M2_7_1-a=The character sequence /* shall not be used within a C-style comment
AUTOSAR-M3_1_2=AUTOSAR M3-1-2 Functions shall not be declared at block scope
AUTOSAR-M3_1_2-a=Always declare functions at file scope
AUTOSAR-M3_3_2=AUTOSAR M3-3-2 If a function has internal linkage then all re-declarations shall include the static storage class specifier
AUTOSAR-M3_3_2-a=If a function has internal linkage then all re-declarations shall include the 'static' storage class specifier
AUTOSAR-M3_4_1=AUTOSAR M3-4-1 An identifier declared to be an object or type shall be defined in a block that minimizes its visibility
AUTOSAR-M3_4_1-a=Declare variables as locally as possible
AUTOSAR-M3_4_1-b=Objects shall be defined at block scope if they are only accessed from within a single function
AUTOSAR-M3_9_1=AUTOSAR M3-9-1 The types used for an object, a function return type, or a function parameter shall be token-for-token identical in all declarations and re-declarations
AUTOSAR-M3_9_1-a=The types used for an object, a function return type, or a function parameter shall be token-for-token identical in all declarations and re-declarations
AUTOSAR-M3_9_3=AUTOSAR M3-9-3 The underlying bit representations of floating-point values shall not be used
AUTOSAR-M3_9_3-a=The underlying bit representations of floating-point values shall not be used
AUTOSAR-M4_10_1=AUTOSAR M4-10-1 NULL shall not be used as an integer value
AUTOSAR-M4_10_1-a=NULL shall not be used as an integer value
AUTOSAR-M4_10_2=AUTOSAR M4-10-2 Literal zero (0) shall not be used as the null-pointer-constant
AUTOSAR-M4_10_2-a=Literal zero (0) shall not be used as the null-pointer-constant
AUTOSAR-M4_5_1=AUTOSAR M4-5-1 Expressions with type bool shall not be used as operands to built-in operators other than the assignment operator \=, the logical operators &&, ||, \!, the equality operators \=\= and \!\=, the unary & operator, and the conditional operator
AUTOSAR-M4_5_1-a=Expressions that are effectively Boolean should not be used as operands to operators other than (&&, ||, \!, \=, \=\=, \!\=, ?\:)
AUTOSAR-M4_5_3=AUTOSAR M4-5-3 Expressions with type (plain) char and wchar_t shall not be used as operands to built-in operators other than the assignment operator \=, the equality operators \=\= and \!\=, and the unary & operator
AUTOSAR-M4_5_3-a=Expressions with type (plain) char and wchar_t shall not be used as operands to built-in operators other than  \=,  \=\=, \!\= and the unary & operator
AUTOSAR-M5_0_10=AUTOSAR M5-0-10 If the bitwise operators ~ and << are applied to an operand with an underlying type of unsigned char or unsigned short, the result shall be immediately cast to the underlying type of the operand
AUTOSAR-M5_0_10-a=If the bitwise operators ~ and << are applied to an operand of underlying type unsigned char or unsigned short, the result shall be immediately cast to the underlying type of the operand
AUTOSAR-M5_0_11=AUTOSAR M5-0-11 The plain char type shall only be used for the storage and use of character values
AUTOSAR-M5_0_11-a=The plain char type shall be used only for the storage and use of character values
AUTOSAR-M5_0_12=AUTOSAR M5-0-12 Signed char and unsigned char type shall only be used for the storage and use of numeric values
AUTOSAR-M5_0_12-a=signed and unsigned char type shall be used only for the storage and use of numeric values
AUTOSAR-M5_0_14=AUTOSAR M5-0-14 The first operand of a conditional-operator shall have type bool
AUTOSAR-M5_0_14-a=The first operand of a conditional-operator shall have type bool
AUTOSAR-M5_0_15=AUTOSAR M5-0-15 Array indexing shall be the only form of pointer arithmetic
AUTOSAR-M5_0_15-a=Array indexing shall be the only allowed form of pointer arithmetic
AUTOSAR-M5_0_2=AUTOSAR M5-0-2 Limited dependence should be placed on C++ operator precedence rules in expressions
AUTOSAR-M5_0_2-a=Use parenthesis for the right-hand operand of an assignment operator when it contains an assignment expression
AUTOSAR-M5_0_2-b=Limited dependence should be placed on C's operator precedence rules in expressions
AUTOSAR-M5_0_2-c=No parentheses are required for the operand of a unary operator
AUTOSAR-M5_0_2-d=Limited dependence should be placed on C's operator precedence rules in expressions
AUTOSAR-M5_0_2-e=Use parentheses unless all operators in the expression are the same
AUTOSAR-M5_0_2-f=Limited dependence should be placed on C's operator precedence rules in expressions
AUTOSAR-M5_0_20=AUTOSAR M5-0-20 Non-constant operands to a binary bitwise operator shall have the same underlying type
AUTOSAR-M5_0_20-a=Non-constant operands to a binary bitwise operator shall have the same underlying type
AUTOSAR-M5_0_21=AUTOSAR M5-0-21 Bitwise operators shall only be applied to operands of unsigned underlying type
AUTOSAR-M5_0_21-a=Bitwise operators shall only be applied to operands of unsigned underlying type
AUTOSAR-M5_0_3=AUTOSAR M5-0-3 A cvalue expression shall not be implicitly converted to a different underlying type
AUTOSAR-M5_0_3-a=Avoid implicit conversions of complex expressions
AUTOSAR-M5_0_3-b=Avoid implicit conversions of complex expressions
AUTOSAR-M5_0_3-c=Avoid implicit conversions of complex expressions
AUTOSAR-M5_0_4=AUTOSAR M5-0-4 An implicit integral conversion shall not change the signedness of the underlying type
AUTOSAR-M5_0_4-a=Avoid implicit conversions between signed and unsigned integer types
AUTOSAR-M5_0_5=AUTOSAR M5-0-5 There shall be no implicit floating-integral conversions
AUTOSAR-M5_0_5-a=There shall be no implicit conversions from integral to floating type
AUTOSAR-M5_0_5-b=Avoid implicit conversions from floating to integral type
AUTOSAR-M5_0_6=AUTOSAR M5-0-6 An implicit integral or floating-point conversion shall not reduce the size of the underlying type
AUTOSAR-M5_0_6-a=Avoid implicit integral conversions from a wider to a narrower type
AUTOSAR-M5_0_6-b=Avoid implicit conversions from wider to narrower floating type
AUTOSAR-M5_0_6-c=Avoid implicit conversions of floating point numbers from wider to narrower floating type
AUTOSAR-M5_0_7=AUTOSAR M5-0-7 There shall be no explicit floating-integral conversions of a cvalue expression
AUTOSAR-M5_0_7-a=The value of a complex expression of floating type should not be cast to an integer type
AUTOSAR-M5_0_7-b=The value of a complex expression of integer type shall only be cast to a type  of the same signedness that is no wider than the underlying type of the expression
AUTOSAR-M5_0_8=AUTOSAR M5-0-8 An explicit integral or floating-point conversion shall not increase the size of the underlying type of a cvalue expression
AUTOSAR-M5_0_8-a=The value of a complex expression of integer type shall only be cast to a type  of the same signedness that is no wider than the underlying type of the expression
AUTOSAR-M5_0_8-b=The value of a complex expression of floating type should not be cast to a wider floating type
AUTOSAR-M5_0_9=AUTOSAR M5-0-9 An explicit integral conversion shall not change the signedness of the underlying type of a cvalue expression
AUTOSAR-M5_0_9-a=The value of a complex expression of integer type shall only be cast to a type  of the same signedness that is no wider than the underlying type of the expression
AUTOSAR-M5_14_1=AUTOSAR M5-14-1 The right hand operand of a logical &&, || operators shall not contain side effects
AUTOSAR-M5_14_1-a=The right-hand operand of a logical && or || operator shall not contain side effects
AUTOSAR-M5_17_1=AUTOSAR M5-17-1 The semantic equivalence between a binary operator and its assignment operator form shall be preserved
AUTOSAR-M5_17_1-a=The overloaded binary operator should be implemented in terms of its corresponding compound assignment operator
AUTOSAR-M5_18_1=AUTOSAR M5-18-1 The comma operator shall not be used
AUTOSAR-M5_18_1-a=The comma operator shall not be used
AUTOSAR-M5_19_1=AUTOSAR M5-19-1 Evaluation of constant unsigned integer expressions shall not lead to wrap-around
AUTOSAR-M5_19_1-a=Integer overflow or underflow in constant expression in '<<' operator
AUTOSAR-M5_19_1-b=Integer overflow or underflow in constant expression in '+', '-', '*' operator
AUTOSAR-M5_2_10=AUTOSAR M5-2-10 The increment (++) and decrement (--) operators shall not be mixed with other operators in an expression
AUTOSAR-M5_2_10-a=The increment (++) and decrement (--) operators should not be mixed with arithmetic operators in an expression
AUTOSAR-M5_2_11=AUTOSAR M5-2-11 The comma operator, && operator and the || operator shall not be overloaded
AUTOSAR-M5_2_11-a=Avoid overloading comma operator ","
AUTOSAR-M5_2_11-b=Avoid overloading logical operators AND, OR (&&, ||)
AUTOSAR-M5_2_12=AUTOSAR M5-2-12 An identifier with array type passed as a function argument shall not decay to a pointer
AUTOSAR-M5_2_12-a=An identifier with array type passed as a function argument shall not decay to a pointer
AUTOSAR-M5_2_2=AUTOSAR M5-2-2 A pointer to a virtual base class shall only be cast to a pointer to a derived class by means of dynamic_cast
AUTOSAR-M5_2_2-a=A pointer to a virtual base class shall only be cast to a pointer to a derived class by means of dynamic_cast
AUTOSAR-M5_2_3=AUTOSAR M5-2-3 Casts from a base class to a derived class should not be performed on polymorphic types
AUTOSAR-M5_2_3-a=Casts from a base class to a derived class should not be performed on polymorphic types
AUTOSAR-M5_2_6=AUTOSAR M5-2-6 A cast shall not convert a pointer to a function to any other pointer type, including a pointer to function type
AUTOSAR-M5_2_6-a=A cast shall not convert a pointer to a function to any other pointer type, including a pointer to function type
AUTOSAR-M5_2_8=AUTOSAR M5-2-8 An object with integer type or pointer to void type shall not be converted to an object with pointer type
AUTOSAR-M5_2_8-a=An object with integer type or pointer to void type shall not be converted to an object with pointer type
AUTOSAR-M5_2_9=AUTOSAR M5-2-9 A cast shall not convert a pointer type to an integral type
AUTOSAR-M5_2_9-a=A cast should not convert a pointer type to an integral type
AUTOSAR-M5_3_1=AUTOSAR M5-3-1 Each operand of the \! operator, the logical && or the logical || operators shall have type bool
AUTOSAR-M5_3_1-a=Each operand of the \! operator, the logical && or the logical || operators shall have type bool
AUTOSAR-M5_3_2=AUTOSAR M5-3-2 The unary minus operator shall not be applied to an expression whose underlying type is unsigned
AUTOSAR-M5_3_2-a=The unary minus operator shall not be applied to an expression whose underlying type is unsigned
AUTOSAR-M5_3_3=AUTOSAR M5-3-3 The unary & operator shall not be overloaded
AUTOSAR-M5_3_3-a=The unary & operator shall not be overloaded
AUTOSAR-M5_3_4=AUTOSAR M5-3-4 Evaluation of the operand to the sizeof operator shall not contain side effects
AUTOSAR-M5_3_4-a=The operand of the sizeof operator shall not contain any expression which has side effects
AUTOSAR-M5_3_4-b=Object designated by a volatile lvalue should not be accessed in the operand of the sizeof operator
AUTOSAR-M5_3_4-c=The function call that causes the side effect shall not be the operand of the sizeof operator
AUTOSAR-M5_8_1=AUTOSAR M5-8-1 The right hand operand of a shift operator shall lie between zero and one less than the width in bits of the underlying type of the left hand operand
AUTOSAR-M5_8_1-a=The right-hand operand of a shift operator shall lie between zero and one less than the width in bits of the underlying type of the left-hand operand
AUTOSAR-M6_2_1=AUTOSAR M6-2-1 Assignment operators shall not be used in sub-expressions
AUTOSAR-M6_2_1-a=Assignment operators shall not be used in expressions that yield a Boolean value
AUTOSAR-M6_2_2=AUTOSAR M6-2-2 Floating-point expressions shall not be directly or indirectly tested for equality or inequality
AUTOSAR-M6_2_2-a=Floating-point expressions shall not be tested for equality or inequality
AUTOSAR-M6_2_3=AUTOSAR M6-2-3 Before preprocessing, a null statement shall only occur on a line by itself; it may be followed by a comment, provided that the first character following the null statement is a white-space character
AUTOSAR-M6_2_3-a=A null statement shall occur on a line by itself or be followed by a comment
AUTOSAR-M6_3_1=AUTOSAR M6-3-1 The statement forming the body of a switch, while, do ... while or for statement shall be a compound statement
AUTOSAR-M6_3_1-a=The statement forming the body of a 'switch', 'while', 'do...while' or 'for' statement shall be a compound statement
AUTOSAR-M6_4_1=AUTOSAR M6-4-1 An if ( condition ) construct shall be followed by a compound statement. The else keyword shall be followed by either a compound statement, or another if statement
AUTOSAR-M6_4_1-a='if' and 'else' should be followed by a compound statement
AUTOSAR-M6_4_2=AUTOSAR M6-4-2 All if ... else if constructs shall be terminated with an else clause
AUTOSAR-M6_4_2-a=All 'if...else-if' constructs shall be terminated with an 'else' clause
AUTOSAR-M6_4_3=AUTOSAR M6-4-3 A switch statement shall be a well-formed switch statement
AUTOSAR-M6_4_3-a=An unconditional throw or break statement shall terminate every non-empty switch-clause
AUTOSAR-M6_4_3-b=The final clause of a switch statement shall be the default-clause unless all enumeration values are tested
AUTOSAR-M6_4_3-c=A switch label shall only be used when the most closely-enclosing compound statement is the body of a switch statement
AUTOSAR-M6_4_3-d=Every switch statement shall have at least one case clause
AUTOSAR-M6_4_3-e=A switch expression shall not represent a value that is effectively Boolean
AUTOSAR-M6_4_4=AUTOSAR M6-4-4 A switch-label shall only be used when the most closely-enclosing compound statement is the body of a switch statement
AUTOSAR-M6_4_4-a=A switch label shall only be used when the most closely-enclosing compound statement is the body of a switch statement
AUTOSAR-M6_4_5=AUTOSAR M6-4-5 An unconditional throw or break statement shall terminate every non-empty switch-clause
AUTOSAR-M6_4_5-a=An unconditional throw or break statement shall terminate every non-empty switch-clause
AUTOSAR-M6_4_6=AUTOSAR M6-4-6 The final clause of a switch statement shall be the default-clause
AUTOSAR-M6_4_6-a=The final clause of a switch statement shall be the default-clause unless all enumeration values are tested
AUTOSAR-M6_4_7=AUTOSAR M6-4-7 The condition of a switch statement shall not have bool type
AUTOSAR-M6_4_7-a=A switch expression shall not represent a value that is effectively Boolean
AUTOSAR-M6_5_2=AUTOSAR M6-5-2 If loop-counter is not modified by -- or ++, then, within condition, the loop-counter shall only be used as an operand to <\=, <, > or >\=
AUTOSAR-M6_5_2-a=If loop-counter is not modified by -- or ++, then, within condition, the loop-counter shall only be used as an operand to <\=, <, > or >\=
AUTOSAR-M6_5_3=AUTOSAR M6-5-3 The loop-counter shall not be modified within condition or statement
AUTOSAR-M6_5_3-a=Do not modify for loop counter within a body of the loop
AUTOSAR-M6_5_4=AUTOSAR M6-5-4 The loop-counter shall be modified by one of\: --, ++, -\= n, or +\= n; where n remains constant for the duration of the loop
AUTOSAR-M6_5_4-a=The loop-counter shall be modified by one of\: --, ++, -\=n, or +\=n; where n remains constant for the duration of the loop
AUTOSAR-M6_5_5=AUTOSAR M6-5-5 A loop-control-variable other than the loop-counter shall not be modified within condition or expression
AUTOSAR-M6_5_5-a=A loop-control-variable other than the loop-counter shall not be modified within condition or expression
AUTOSAR-M6_5_6=AUTOSAR M6-5-6 A loop-control-variable other than the loop-counter which is modified in statement shall have type bool
AUTOSAR-M6_5_6-a=A loop-control-variable other than the loop-counter which is modified in statement shall have type bool
AUTOSAR-M6_6_1=AUTOSAR M6-6-1 Any label referenced by a goto statement shall be declared in the same block, or in a block enclosing the goto statement
AUTOSAR-M6_6_1-a=Any label referenced by a goto statement shall be declared in the same block, or in a block enclosing the goto statement
AUTOSAR-M6_6_2=AUTOSAR M6-6-2 The goto statement shall jump to a label declared later in the same function body
AUTOSAR-M6_6_2-a=The goto statement shall jump to a label declared later in the same function body
AUTOSAR-M6_6_3=AUTOSAR M6-6-3 The continue statement shall only be used within a well-formed for loop
AUTOSAR-M6_6_3-a=The continue statement shall only be used within a well formed for loop
AUTOSAR-M7_1_2=AUTOSAR M7-1-2 A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the corresponding object is not modified
AUTOSAR-M7_1_2-a=Declare a type of parameter as typedef to pointer to const if the pointer is not used to modify the addressed object
AUTOSAR-M7_1_2-b=A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify the addressed object
AUTOSAR-M7_1_2-c=Declare reference parameters as const references whenever possible
AUTOSAR-M7_3_1=AUTOSAR M7-3-1 The global namespace shall only contain main, namespace declarations and extern "C" declarations
AUTOSAR-M7_3_1-a=The global namespace shall only contain main() and namespace declarations
AUTOSAR-M7_3_2=AUTOSAR M7-3-2 The identifier main shall not be used for a function other than the global function main
AUTOSAR-M7_3_2-a=The identifier main shall not be used for a function other than the global function main
AUTOSAR-M7_3_3=AUTOSAR M7-3-3 There shall be no unnamed namespaces in header files
AUTOSAR-M7_3_3-a=There shall be no unnamed namespaces in header files
AUTOSAR-M7_3_4=AUTOSAR M7-3-4 Using-directives shall not be used
AUTOSAR-M7_3_4-a=using-directives shall not be used
AUTOSAR-M7_3_6=AUTOSAR M7-3-6 Using-directives and using-declarations (excluding class scope or function scope using-declarations) shall not be used in header files
AUTOSAR-M7_3_6-a=using-directives and using-declarations (excluding class scope or function scope using-declarations) shall not be used in header files
AUTOSAR-M7_4_1=AUTOSAR M7-4-1 All usage of assembler shall be documented
AUTOSAR-M7_4_1-a=All usage of assembler shall be documented
AUTOSAR-M7_4_2=AUTOSAR M7-4-2 Assembler instructions shall only be introduced using the asm declaration
AUTOSAR-M7_4_2-a=Assembler instructions shall only be introduced using the asm declaration
AUTOSAR-M7_4_3=AUTOSAR M7-4-3 Assembly language shall be encapsulated and isolated
AUTOSAR-M7_4_3-a=Assembly language shall be encapsulated and isolated in C/C++ functions
AUTOSAR-M7_5_1=AUTOSAR M7-5-1 A function shall not return a reference or a pointer to an automatic variable (including parameters), defined within the function
AUTOSAR-M7_5_1-a=The address of an object with automatic storage shall not be returned from a function
AUTOSAR-M7_5_2=AUTOSAR M7-5-2 The address of an object with automatic storage shall not be assigned to another object that may persist after the first object has ceased to exist
AUTOSAR-M7_5_2-a=The address of an object with automatic storage shall not be assigned to another object that may persist after the first object has ceased to exist
AUTOSAR-M8_0_1=AUTOSAR M8-0-1 An init-declarator-list or a member-declarator-list shall consist of a single init-declarator or member-declarator respectively
AUTOSAR-M8_0_1-a=Each variable should be declared in a separate declaration statement
AUTOSAR-M8_3_1=AUTOSAR M8-3-1 Parameters in an overriding virtual function shall either use the same default arguments as the function they override, or else shall not specify any default arguments
AUTOSAR-M8_3_1-a=Do not redefine an inherited virtual function with a different default parameter value
AUTOSAR-M8_4_2=AUTOSAR M8-4-2 The identifiers used for the parameters in a re-declaration of a function shall be identical to those in the declaration
AUTOSAR-M8_4_2-a=The identifiers used in the declaration and definition of a function shall be identical
AUTOSAR-M8_4_4=AUTOSAR M8-4-4 A function identifier shall either be used to call the function or it shall be preceded by &
AUTOSAR-M8_4_4-a=A function identifier shall only be used with either a preceding '&', or with a parenthesised parameter list, which may be empty
AUTOSAR-M8_5_2=AUTOSAR M8-5-2 Braces shall be used to indicate and match the structure in the non-zero initialization of arrays and structures
AUTOSAR-M8_5_2-a=The initializer for an aggregate or union shall be enclosed in braces
AUTOSAR-M8_5_2-b=Arrays shall not be partially initialized
AUTOSAR-M8_5_2-c=The non-zero initialization of structures requires an explicit initializer for each element
AUTOSAR-M9_3_1=AUTOSAR M9-3-1 Const member functions shall not return non-const pointers or references to class-data
AUTOSAR-M9_3_1-a=Const member functions shall not return non-const pointers or references to class-data
AUTOSAR-M9_3_3=AUTOSAR M9-3-3 If a member function can be made static then it shall be made static, otherwise if it can be made const then it shall be made const
AUTOSAR-M9_3_3-a=If a member function can be made static then it shall be made static, otherwise if it can be made const then it shall be made const
AUTOSAR-M9_6_4=AUTOSAR M9-6-4 Named bit-fields with signed integer type shall have a length of more than one bit
AUTOSAR-M9_6_4-a=Named bit-fields with signed integer type shall have a length of more than one bit
CERT_C=SEI CERT C
CERT_C-API00=CERT-API00_C (REC) Functions should validate their parameters
CERT_C-API00-a=The validity of parameters must be checked inside each function
CERT_C-API01=CERT-API01_C (REC) Avoid laying out strings in memory directly before sensitive data
CERT_C-API01-b=Avoid using unsafe string functions which may cause buffer overflows
CERT_C-API02=CERT-API02_C (REC) Functions that read or write to or from an array should take an argument to specify the source or target size
CERT_C-API02-a=Avoid using unsafe string functions which may cause buffer overflows
CERT_C-API02-b=Don't use unsafe C functions that do write to range-unchecked buffers
CERT_C-ARR01=CERT-ARR01_C (REC) Do not apply the sizeof operator to a pointer when taking the size of an array
CERT_C-ARR01-a=Do not call 'sizeof' on a pointer type
CERT_C-ARR02=CERT-ARR02_C (REC) Explicitly specify array bounds, even if implicitly defined by an initializer
CERT_C-ARR02-a=Explicitly specify array bounds in array declarations with initializers
CERT_C-ARR37=CERT-ARR37_C (RULE) Do not add or subtract an integer to a pointer to a non-array object
CERT_C-ARR37-a=Pointer arithmetic shall not be applied to pointers that address variables of non-array type
CERT_C-ARR39=CERT-ARR39_C (RULE) Do not add or subtract a scaled integer to a pointer
CERT_C-ARR39-b=Pointer arithmetic should not be used
CERT_C-ARR39-c=Do not add or subtract a scaled integer to a pointer
CERT_C-CON02=CERT-CON02_C (REC) Do not use volatile as a synchronization primitive
CERT_C-CON02-a=Do not use the volatile keyword
CERT_C-CON33=CERT-CON33_C (RULE) Avoid race conditions when using library functions
CERT_C-CON33-a=Avoid using thread-unsafe functions
CERT_C-CON36=CERT-CON36_C (RULE) Wrap functions that can spuriously wake up in a loop
CERT_C-CON36-a=Wrap functions that can spuriously wake up in a loop
CERT_C-CON37=CERT-CON37_C (RULE) Do not call signal() in a multithreaded program
CERT_C-CON37-a=The signal handling facilities of <signal.h> shall not be used
CERT_C-CON38=CERT-CON38_C (RULE) Preserve thread safety and liveness when using condition variables
CERT_C-CON38-a=Use the 'cnd_signal()' function with a unique condition variable
CERT_C-CON40=CERT-CON40_C (RULE) Do not refer to an atomic variable twice in an expression
CERT_C-CON40-a=Do not refer to an atomic variable twice in an expression
CERT_C-CON41=CERT-CON41_C (RULE) Wrap functions that can fail spuriously in a loop
CERT_C-CON41-a=Wrap functions that can fail spuriously in a loop
CERT_C-DCL00=CERT-DCL00_C (REC) Const-qualify immutable objects
CERT_C-DCL00-a=Declare local variable as const whenever possible
CERT_C-DCL00-b=Declare parameters as const whenever possible
CERT_C-DCL01=CERT-DCL01_C (REC) Do not reuse variable names in subscopes
CERT_C-DCL01-a=Identifier declared in a local or function prototype scope shall not hide an identifier declared in a global or namespace scope
CERT_C-DCL01-b=Identifiers declared in an inner local scope should not hide identifiers declared in an outer local scope
CERT_C-DCL02=CERT-DCL02_C (REC) Use visually distinct identifiers
CERT_C-DCL02-a=Use visually distinct identifiers
CERT_C-DCL04=CERT-DCL04_C (REC) Do not declare more than one variable per declaration
CERT_C-DCL04-a=Each variable should be declared in a separate declaration statement
CERT_C-DCL05=CERT-DCL05_C (REC) Use typedefs of non-pointer types only
CERT_C-DCL05-a=Declare a type of parameter as typedef to pointer to const if the pointer is not used to modify the addressed object
CERT_C-DCL06=CERT-DCL06_C (REC) Use meaningful symbolic constants to represent literal values
CERT_C-DCL06-a=Use meaningful symbolic constants to represent literal values
CERT_C-DCL10=CERT-DCL10_C (REC) Maintain the contract between the writer and caller of variadic functions
CERT_C-DCL10-a=The number of format specifiers in the format string and the number of corresponding arguments in the invocation of a string formatting function should be equal
CERT_C-DCL11=CERT-DCL11_C (REC) Understand the type issues associated with variadic functions
CERT_C-DCL11-a=There should be no mismatch between the '%s' and '%c' format specifiers in the format string and their corresponding arguments in the invocation of a string formatting function
CERT_C-DCL11-b=There should be no mismatch between the '%f' format specifier in the format string and its corresponding argument in the invocation of a string formatting function
CERT_C-DCL11-c=There should be no mismatch between the '%i' and '%d' format specifiers in the string and their corresponding arguments in the invocation of a string formatting function
CERT_C-DCL11-d=There should be no mismatch between the '%u' format specifier in the format string and its corresponding argument in the invocation of a string formatting function
CERT_C-DCL11-e=There should be no mismatch between the '%p' format specifier in the format string and its corresponding argument in the invocation of a string formatting function
CERT_C-DCL11-f=The number of format specifiers in the format string and the number of corresponding arguments in the invocation of a string formatting function should be equal
CERT_C-DCL12=CERT-DCL12_C (REC) Implement abstract data types using opaque types
CERT_C-DCL12-a=If a pointer to a structure or union is never dereferenced within a translation unit, then the implementation of the object should be hidden
CERT_C-DCL13=CERT-DCL13_C (REC) Declare function parameters that are pointers to values not changed by the function as const
CERT_C-DCL13-a=A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify the addressed object
CERT_C-DCL15=CERT-DCL15_C (REC) Declare file-scope objects or functions that do not need external linkage as static
CERT_C-DCL15-a=Objects or functions with external linkage shall be declared in a header file
CERT_C-DCL16=CERT-DCL16_C (REC) Use "L," not "l," to indicate a long value
CERT_C-DCL16-a=Use capital 'L' instead of lowercase 'l' to indicate long
CERT_C-DCL18=CERT-DCL18_C (REC) Do not begin integer constants with 0 when specifying a decimal value
CERT_C-DCL18-a=Octal and hexadecimal escape sequences shall be terminated
CERT_C-DCL18-b=Octal constants (other than zero) shall not be used
CERT_C-DCL19=CERT-DCL19_C (REC) Minimize the scope of variables and functions
CERT_C-DCL19-a=Declare variables as locally as possible
CERT_C-DCL20=CERT-DCL20_C (REC) Explicitly specify void when a function accepts no arguments
CERT_C-DCL20-a=The number of arguments passed to a function shall match the number of parameters
CERT_C-DCL30=CERT-DCL30_C (RULE) Declare objects with appropriate storage durations
CERT_C-DCL30-a=The address of an object with automatic storage shall not be returned from a function
CERT_C-DCL30-b=The address of an object with automatic storage shall not be assigned to another object that may persist after the first object has ceased to exist
CERT_C-DCL31=CERT-DCL31_C (RULE) Declare identifiers before using them
CERT_C-DCL31-a=All functions shall be declared before use
CERT_C-DCL36=CERT-DCL36_C (RULE) Do not declare an identifier with conflicting linkage classifications
CERT_C-DCL36-a=Identifiers shall not simultaneously have both internal and external linkage in the same translation unit
CERT_C-DCL37=CERT-DCL37_C (RULE) Do not declare or define a reserved identifier
CERT_C-DCL37-a=Do not \#define or \#undef identifiers with names which start with underscore
CERT_C-DCL38=CERT-DCL38_C (RULE) Use the correct syntax when declaring a flexible array member
CERT_C-DCL38-a=The final member of a structure should not be an array of size '0' or '1'
CERT_C-DCL39=CERT-DCL39_C (RULE) Avoid information leakage when passing a structure across a trust boundary
CERT_C-DCL39-a=A pointer to a structure should not be passed to a function that can copy data to the user space
CERT_C-DCL40=CERT-DCL40_C (RULE) Do not create incompatible declarations of the same function or object
CERT_C-DCL40-b=If objects or functions are declared more than once their types shall be compatible
CERT_C-DCL41=CERT-DCL41_C (RULE) Do not declare variables inside a switch statement before the first case label
CERT_C-DCL41-a=A switch statement shall only contain switch labels and switch clauses, and no other code
CERT_C-ENV01=CERT-ENV01_C (REC) Do not make assumptions about the size of an environment variable
CERT_C-ENV01-a=Don't use unsafe C functions that do write to range-unchecked buffers
CERT_C-ENV01-b=Avoid using unsafe string functions which may cause buffer overflows
CERT_C-ENV02=CERT-ENV02_C (REC) Beware of multiple environment variables with the same effective name
CERT_C-ENV02-a=Usage of system properties (environment variables) should be restricted
CERT_C-ENV30=CERT-ENV30_C (RULE) Do not modify the object referenced by the return value of certain functions
CERT_C-ENV30-a=The pointers returned by the Standard Library functions 'localeconv', 'getenv', 'setlocale' or, 'strerror' shall only be used as if they have pointer to const-qualified type
CERT_C-ENV33=CERT-ENV33_C (RULE) Do not call system()
CERT_C-ENV33-a=Do not call the 'system()' function from the 'stdlib.h' or 'cstdlib' library with an argument other than '0' (null pointer)
CERT_C-ERR01=CERT-ERR01_C (REC) Use ferror() rather than errno to check for FILE stream errors
CERT_C-ERR01-a=The error indicator 'errno' shall not be used
CERT_C-ERR02=CERT-ERR02_C (REC) Avoid in-band error indicators
CERT_C-ERR02-a=The Standard Library input/output functions shall not be used
CERT_C-ERR04=CERT-ERR04_C (REC) Choose an appropriate termination strategy
CERT_C-ERR04-a=The 'abort()' function from the 'stdlib.h' or 'cstdlib' library shall not be used
CERT_C-ERR04-b=The 'exit()' function from the 'stdlib.h' or 'cstdlib' library shall not be used
CERT_C-ERR04-c=The 'quick_exit()' and '_Exit()' functions from the 'stdlib.h' or 'cstdlib' library shall not be used
CERT_C-ERR05=CERT-ERR05_C (REC) Application-independent code should provide error detection without dictating error handling
CERT_C-ERR05-a=The 'abort()' function from the 'stdlib.h' or 'cstdlib' library shall not be used
CERT_C-ERR05-b=The 'exit()' function from the 'stdlib.h' or 'cstdlib' library shall not be used
CERT_C-ERR05-c=The 'quick_exit()' and '_Exit()' functions from the 'stdlib.h' or 'cstdlib' library shall not be used
CERT_C-ERR06=CERT-ERR06_C (REC) Understand the termination behavior of assert() and abort()
CERT_C-ERR06-a=Do not use assertions
CERT_C-ERR07=CERT-ERR07_C (REC) Prefer functions that support error checking over equivalent functions that don't
CERT_C-ERR07-a=The library functions atof, atoi and atol from library stdlib.h shall not be used
CERT_C-ERR07-b=The Standard Library input/output functions shall not be used
CERT_C-ERR30=CERT-ERR30_C (RULE) Set errno to zero before calling a library function known to set errno, and check errno only after the function returns a value indicating failure
CERT_C-ERR30-b=Provide error handling for file opening errors right next to the call to fopen
CERT_C-ERR33=CERT-ERR33_C (RULE) Detect and handle standard library errors
CERT_C-ERR33-a=The value returned by a standard library function that may return an error should be used
CERT_C-ERR33-b=The standard library functions for which return values need not be checked should be cast to 'void'
CERT_C-ERR34=CERT-ERR34_C (RULE) Detect errors when converting a string to a number
CERT_C-ERR34-a=The library functions atof, atoi and atol from library stdlib.h shall not be used
CERT_C-EXP00=CERT-EXP00_C (REC) Use parentheses for precedence of operation
CERT_C-EXP00-a=Use parenthesis to clarify expression order if operators with precedence lower than arithmetic are used
CERT_C-EXP02=CERT-EXP02_C (REC) Be aware of the short-circuit behavior of the logical AND and OR operators
CERT_C-EXP02-a=The right-hand operand of a logical && or || operator shall not contain side effects
CERT_C-EXP05=CERT-EXP05_C (REC) Do not cast away a const qualification
CERT_C-EXP05-a=A cast shall not remove any 'const' or 'volatile' qualification from the type of a pointer or reference
CERT_C-EXP08=CERT-EXP08_C (REC) Ensure pointer arithmetic is used correctly
CERT_C-EXP08-a=Pointer arithmetic should not be used
CERT_C-EXP10=CERT-EXP10_C (REC) Do not depend on the order of evaluation of subexpressions or the order in which side effects take place
CERT_C-EXP10-a=The value of an expression shall be the same under any order of evaluation that the standard permits
CERT_C-EXP10-b=Don't write code that depends on the order of evaluation of function arguments
CERT_C-EXP10-c=Don't write code that depends on the order of evaluation of function designator and function arguments
CERT_C-EXP10-d=Don't write code that depends on the order of evaluation of expression that involves a function call
CERT_C-EXP12=CERT-EXP12_C (REC) Do not ignore values returned by functions
CERT_C-EXP12-a=The value returned by a function having non-void return type shall be used
CERT_C-EXP12-b=The value returned by a function having non-void return type shall be used
CERT_C-EXP14=CERT-EXP14_C (REC) Beware of integer promotion when performing bitwise operations on integer types smaller than int
CERT_C-EXP14-a=Avoid mixing arithmetic of different precisions in the same expression
CERT_C-EXP15=CERT-EXP15_C (REC) Do not place a semicolon on the same line as an if, for, or while statement
CERT_C-EXP15-a=Suspicious use of semicolon
CERT_C-EXP16=CERT-EXP16_C (REC) Do not compare function pointers to constant values
CERT_C-EXP16-a=Function address should not be compared to zero
CERT_C-EXP19=CERT-EXP19_C (REC) Use braces for the body of an if, for, or while statement
CERT_C-EXP19-a=The statement forming the body of a 'switch', 'while', 'do...while' or 'for' statement shall be a compound statement
CERT_C-EXP20=CERT-EXP20_C (REC) Perform explicit tests to determine success, true and false, and equality
CERT_C-EXP20-a=Avoid comparing values with TRUE macro/enum constant using equality operators ("\=\=", "\!\=")
CERT_C-EXP20-b=Tests of a value against zero should be made explicit, unless the operand is effectively Boolean
CERT_C-EXP30=CERT-EXP30_C (RULE) Do not depend on the order of evaluation for side effects
CERT_C-EXP30-a=The value of an expression shall be the same under any order of evaluation that the standard permits
CERT_C-EXP30-b=Don't write code that depends on the order of evaluation of function arguments
CERT_C-EXP30-c=Don't write code that depends on the order of evaluation of function designator and function arguments
CERT_C-EXP30-d=Don't write code that depends on the order of evaluation of expression that involves a function call
CERT_C-EXP32=CERT-EXP32_C (RULE) Do not access a volatile object through a nonvolatile reference
CERT_C-EXP32-a=A cast shall not remove any 'const' or 'volatile' qualification from the type of a pointer or reference
CERT_C-EXP35=CERT-EXP35_C (RULE) Do not modify objects with temporary lifetime
CERT_C-EXP35-a=Do not modify objects with temporary lifetime
CERT_C-EXP36=CERT-EXP36_C (RULE) Do not cast pointers into more strictly aligned pointer types
CERT_C-EXP36-a=Do not cast pointers into more strictly aligned pointer types
CERT_C-EXP37=CERT-EXP37_C (RULE) Call functions with the correct number and type of arguments
CERT_C-EXP37-a=Conversions shall not be performed between non compatible pointer to a function types
CERT_C-EXP37-b=Specify the access permission bits if a file is created using the 'open' or 'openat' system call
CERT_C-EXP37-d=Functions shall always have visible prototype at the function call
CERT_C-EXP39=CERT-EXP39_C (RULE) Do not access a variable through a pointer of an incompatible type
CERT_C-EXP39-a=There shall be no implicit conversions from integral to floating type
CERT_C-EXP39-b=A cast should not be performed between a pointer to object type and a different pointer to object type
CERT_C-EXP40=CERT-EXP40_C (RULE) Do not modify constant objects
CERT_C-EXP40-a=A cast shall not remove any 'const' or 'volatile' qualification from the type of a pointer or reference
CERT_C-EXP42=CERT-EXP42_C (RULE) Do not compare padding data
CERT_C-EXP42-a=Don't memcpy or memcmp non-PODs
CERT_C-EXP43=CERT-EXP43_C (RULE) Avoid undefined behavior when using restrict-qualified pointers
CERT_C-EXP43-a=The restrict type qualifier shall not be used
CERT_C-EXP44=CERT-EXP44_C (RULE) Do not rely on side effects in operands to sizeof, _Alignof, or _Generic
CERT_C-EXP44-a=Object designated by a volatile lvalue should not be accessed in the operand of the sizeof operator
CERT_C-EXP44-b=The function call that causes the side effect shall not be the operand of the sizeof operator
CERT_C-EXP45=CERT-EXP45_C (RULE) Do not perform assignments in selection statements
CERT_C-EXP45-b=Assignment operators shall not be used in conditions without brackets
CERT_C-EXP45-d=Assignment operators shall not be used in expressions that yield a Boolean value
CERT_C-EXP46=CERT-EXP46_C (RULE) Do not use a bitwise operator with a Boolean-like operand
CERT_C-EXP46-b=Expressions that are effectively Boolean should not be used as operands to operators other than (&&, ||, \!, \=, \=\=, \!\=, ?\:)
CERT_C-EXP47=CERT-EXP47_C (RULE) Do not call va_arg with an argument of the incorrect type
CERT_C-EXP47-a=Do not call va_arg with an argument of the incorrect type
CERT_C-FIO01=CERT-FIO01_C (REC) Be careful using functions that use file names for identification
CERT_C-FIO01-a=Don't use chmod(), chown(), chgrp()
CERT_C-FIO01-b=Usage of functions prone to race is not allowed
CERT_C-FIO21=CERT-FIO21_C (REC) Do not create temporary files in shared directories
CERT_C-FIO21-a=Usage of functions prone to race is not allowed
CERT_C-FIO30=CERT-FIO30_C (RULE) Exclude user input from format strings
CERT_C-FIO30-a=Avoid calling functions printf/wprintf with only one argument other than string constant
CERT_C-FIO30-b=Avoid using functions fprintf/fwprintf with only two parameters, when second parameter is a variable
CERT_C-FIO30-c=Never use unfiltered data from an untrusted user as the format parameter
CERT_C-FIO38=CERT-FIO38_C (RULE) Do not copy a FILE object
CERT_C-FIO38-a=A pointer to a FILE object shall not be dereferenced
CERT_C-FIO41=CERT-FIO41_C (RULE) Do not call getc(), putc(), getwc(), or putwc() with a stream argument that has side effects
CERT_C-FIO41-a=Do not call 'getc()', 'putc()', 'getwc()', or 'putwc()' with a stream argument containing assignments, increment or decrement operators
CERT_C-FIO41-b=Do not call 'getc()', 'putc()', 'getwc()', or 'putwc()' with a stream argument containing function calls or function-like macro calls
CERT_C-FIO47=CERT-FIO47_C (RULE) Use valid format strings
CERT_C-FIO47-a=There should be no mismatch between the '%s' and '%c' format specifiers in the format string and their corresponding arguments in the invocation of a string formatting function
CERT_C-FIO47-b=There should be no mismatch between the '%f' format specifier in the format string and its corresponding argument in the invocation of a string formatting function
CERT_C-FIO47-c=There should be no mismatch between the '%i' and '%d' format specifiers in the string and their corresponding arguments in the invocation of a string formatting function
CERT_C-FIO47-d=There should be no mismatch between the '%u' format specifier in the format string and its corresponding argument in the invocation of a string formatting function
CERT_C-FIO47-e=There should be no mismatch between the '%p' format specifier in the format string and its corresponding argument in the invocation of a string formatting function
CERT_C-FIO47-f=The number of format specifiers in the format string and the number of corresponding arguments in the invocation of a string formatting function should be equal
CERT_C-FLP00=CERT-FLP00_C (REC) Understand the limitations of floating-point numbers
CERT_C-FLP00-a=Floating-point expressions shall not be tested for equality or inequality
CERT_C-FLP02=CERT-FLP02_C (REC) Avoid using floating-point numbers when precise computation is needed
CERT_C-FLP02-a=Floating-point expressions shall not be tested for equality or inequality
CERT_C-FLP03=CERT-FLP03_C (REC) Detect and handle floating-point errors
CERT_C-FLP03-b=Avoid implicit conversions from wider to narrower floating type
CERT_C-FLP03-c=Avoid implicit conversions from narrower to wider floating type
CERT_C-FLP03-d=Avoid implicit conversions of floating point numbers from wider to narrower floating type
CERT_C-FLP06=CERT-FLP06_C (REC) Convert integers to floating point for floating-point operations
CERT_C-FLP06-a=Implicit conversions from integral to floating type which may result in a loss of information shall not be used
CERT_C-FLP06-b=Implicit conversions from integral constant to floating type which may result in a loss of information shall not be used
CERT_C-FLP30=CERT-FLP30_C (RULE) Do not use floating-point variables as loop counters
CERT_C-FLP30-a=Do not use floating point variables as loop counters
CERT_C-FLP34=CERT-FLP34_C (RULE) Ensure that floating-point conversions are within range of the new type
CERT_C-FLP34-a=Avoid implicit conversions from wider to narrower floating type
CERT_C-FLP34-b=Avoid implicit conversions of floating point numbers from wider to narrower floating type
CERT_C-FLP36=CERT-FLP36_C (RULE) Preserve precision when converting integral values to floating-point type
CERT_C-FLP36-a=Implicit conversions from integral to floating type which may result in a loss of information shall not be used
CERT_C-FLP36-b=Implicit conversions from integral constant to floating type which may result in a loss of information shall not be used
CERT_C-FLP37=CERT-FLP37_C (RULE) Do not use object representations to compare floating-point values
CERT_C-FLP37-c=Do not use object representations to compare floating-point values
CERT_C-INT02=CERT-INT02_C (REC) Understand integer conversion rules
CERT_C-INT02-a=Implicit conversions from wider to narrower integral type which may result in a loss of information shall not be used
CERT_C-INT02-b=Avoid mixing arithmetic of different precisions in the same expression
CERT_C-INT05=CERT-INT05_C (REC) Do not use input functions to convert character data if they cannot handle all possible inputs
CERT_C-INT05-a=Avoid using unsafe string functions that do not check bounds
CERT_C-INT07=CERT-INT07_C (REC) Use only explicitly signed or unsigned char type for numeric values
CERT_C-INT07-a=The plain char type shall be used only for the storage and use of character values
CERT_C-INT07-b=signed and unsigned char type shall be used only for the storage and use of numeric values
CERT_C-INT09=CERT-INT09_C (REC) Ensure enumeration constants map to unique values
CERT_C-INT09-a=In an enumerator list, the "\=" construct shall not be used to explicitly initialise members other than the first, unless all items are explicitly initialised
CERT_C-INT10=CERT-INT10_C (REC) Do not assume a positive remainder when using the % operator
CERT_C-INT10-a=The operands of the remainder operator '%' should be of unsigned integer types
CERT_C-INT12=CERT-INT12_C (REC) Do not make assumptions about the type of a plain int bit-field when used in an expression
CERT_C-INT12-a=Bit fields shall only be defined to be of type unsigned int or signed int
CERT_C-INT13=CERT-INT13_C (REC) Use bitwise operators only on unsigned operands
CERT_C-INT13-a=Bitwise operators shall only be applied to operands of unsigned underlying type
CERT_C-INT15=CERT-INT15_C (REC) Use intmax_t or uintmax_t for formatted IO on programmer-defined integer types
CERT_C-INT15-a=Use intmax_t or uintmax_t for formatted IO on programmer-defined integer types
CERT_C-INT16=CERT-INT16_C (REC) Do not make assumptions about representation of signed integers
CERT_C-INT16-a=Bitwise operators shall only be applied to operands of unsigned underlying type
CERT_C-INT18=CERT-INT18_C (REC) Evaluate integer expressions in a larger size before comparing or assigning to that size
CERT_C-INT18-a=Avoid possible integer overflow in expressions in which the result is assigned to a variable of a wider integer type
CERT_C-INT18-b=Avoid possible integer overflow in expressions in which the result is compared to an expression of a wider integer type
CERT_C-INT18-c=Avoid possible integer overflow in expressions in which the result is cast to a wider integer type
CERT_C-INT30=CERT-INT30_C (RULE) Ensure that unsigned integer operations do not wrap
CERT_C-INT30-b=Integer overflow or underflow in constant expression in '+', '-', '*' operator
CERT_C-INT30-c=Integer overflow or underflow in constant expression in '<<' operator
CERT_C-INT31=CERT-INT31_C (RULE) Ensure that integer conversions do not result in lost or misinterpreted data
CERT_C-INT31-a=An expression of essentially Boolean type should always be used where an operand is interpreted as a Boolean value
CERT_C-INT31-b=An operand of essentially Boolean type should not be used where an operand is interpreted as a numeric value
CERT_C-INT31-c=An operand of essentially character type should not be used where an operand is interpreted as a numeric value
CERT_C-INT31-d=An operand of essentially enum type should not be used in an arithmetic operation
CERT_C-INT31-e=Shift and bitwise operations should not be performed on operands of essentially signed or enum type
CERT_C-INT31-f=An operand of essentially signed or enum type should not be used as the right hand operand to the bitwise shifting operator
CERT_C-INT31-g=An operand of essentially unsigned type should not be used as the operand to the unary minus operator
CERT_C-INT31-h=The value of an expression shall not be assigned to an object with a narrower essential type
CERT_C-INT31-i=The value of an expression shall not be assigned to an object of a different essential type category
CERT_C-INT31-j=Both operands of an operator in which the usual arithmetic conversions are performed shall have the same essential type category
CERT_C-INT31-k=The second and third operands of the ternary operator shall have the same essential type category
CERT_C-INT31-l=The value of a composite expression shall not be assigned to an object with wider essential type
CERT_C-INT31-m=If a composite expression is used as one operand of an operator in which the usual arithmetic conversions are performed then the other operand shall not have wider essential type
CERT_C-INT31-n=If a composite expression is used as one (second or third) operand of a conditional operator then the other operand shall not have wider essential type
CERT_C-INT32=CERT-INT32_C (RULE) Ensure that operations on signed integers do not result in overflow
CERT_C-INT32-b=Integer overflow or underflow in constant expression in '+', '-', '*' operator
CERT_C-INT32-c=Integer overflow or underflow in constant expression in '<<' operator
CERT_C-INT35=CERT-INT35_C (RULE) Use correct integer precisions
CERT_C-INT35-a=Use correct integer precisions when checking the right hand operand of the shift operator
CERT_C-INT36=CERT-INT36_C (RULE) Converting a pointer to integer or integer to pointer
CERT_C-INT36-b=A conversion should not be performed between a pointer to object type and an integer type other than 'uintptr_t' or 'intptr_t'
CERT_C-MEM00=CERT-MEM00_C (REC) Allocate and free memory in the same module, at the same level of abstraction
CERT_C-MEM00-a=Do not allocate memory and expect that someone else will deallocate it later
CERT_C-MEM00-b=Do not allocate memory and expect that someone else will deallocate it later
CERT_C-MEM00-c=Do not allocate memory and expect that someone else will deallocate it later
CERT_C-MEM01=CERT-MEM01_C (REC) Store a new value in pointers immediately after free()
CERT_C-MEM01-b=Always assign a new value to an expression that points to deallocated memory
CERT_C-MEM01-c=Always assign a new value to global or member variable that points to deallocated memory
CERT_C-MEM01-d=Always assign a new value to parameter or local variable that points to deallocated memory
CERT_C-MEM02=CERT-MEM02_C (REC) Immediately cast the result of a memory allocation function call into a pointer to the allocated type
CERT_C-MEM02-a=The result of the memory allocation function should be cast immediately
CERT_C-MEM02-b=The result of the memory allocation function should be cast immediately into a pointer to the allocated type
CERT_C-MEM04=CERT-MEM04_C (REC) Beware of zero-length allocations
CERT_C-MEM04-a=The validity of values passed to library functions shall be checked
CERT_C-MEM07=CERT-MEM07_C (REC) Ensure that the arguments to calloc(), when multiplied, do not wrap
CERT_C-MEM07-a=The validity of values passed to library functions shall be checked
CERT_C-MEM33=CERT-MEM33_C (RULE) Allocate and copy structures containing a flexible array member dynamically
CERT_C-MEM33-a=Allocate structures containing a flexible array member dynamically
CERT_C-MEM33-b=Do not copy instances of structures containing a flexible array member
CERT_C-MEM35=CERT-MEM35_C (RULE) Allocate sufficient memory for an object
CERT_C-MEM35-a=Do not use sizeof operator on pointer type to specify the size of the memory to be allocated via 'malloc', 'calloc' or 'realloc' function
CERT_C-MSC01=CERT-MSC01_C (REC) Strive for logical completeness
CERT_C-MSC01-a=All 'if...else-if' constructs shall be terminated with an 'else' clause
CERT_C-MSC01-b=The final clause of a switch statement shall be the default clause
CERT_C-MSC04=CERT-MSC04_C (REC) Use comments consistently and in a readable fashion
CERT_C-MSC04-a=The character sequence /* shall not be used within a C-style comment
CERT_C-MSC04-b=The character sequence // shall not be used within a C-style comment
CERT_C-MSC04-c=The character sequence /* shall not be used within a C++-style comment
CERT_C-MSC04-d=Line-splicing shall not be used in // comments
CERT_C-MSC07=CERT-MSC07_C (REC) Detect and remove dead code
CERT_C-MSC07-a=There shall be no unreachable code in "else" block
CERT_C-MSC07-b=There shall be no unreachable code after 'return', 'break', 'continue', and 'goto' statements
CERT_C-MSC07-c=There shall be no unreachable code in "if/else/while/for" block
CERT_C-MSC07-d=There shall be no unreachable code in switch statement
CERT_C-MSC07-e=There shall be no unreachable code in 'for' loop
CERT_C-MSC07-f=There shall be no unreachable code after 'if' or 'switch' statement
CERT_C-MSC07-g=There shall be no unreachable code after "if" or "switch" statement inside while/for/do...while loop
CERT_C-MSC09=CERT-MSC09_C (REC) Character encoding\: Use subset of ASCII for safety
CERT_C-MSC09-a=Only use characters defined in the ISO C standard
CERT_C-MSC11=CERT-MSC11_C (REC) Incorporate diagnostic tests using assertions
CERT_C-MSC11-a=Assert liberally to document internal assumptions and invariants
CERT_C-MSC12=CERT-MSC12_C (REC) Detect and remove code that has no effect or is never executed
CERT_C-MSC12-a=There shall be no unreachable code in "else" block
CERT_C-MSC12-b=There shall be no unreachable code after 'return', 'break', 'continue', and 'goto' statements
CERT_C-MSC12-c=There shall be no unreachable code in "if/else/while/for" block
CERT_C-MSC12-d=There shall be no unreachable code in switch statement
CERT_C-MSC12-e=There shall be no unreachable code in 'for' loop
CERT_C-MSC12-f=There shall be no unreachable code after 'if' or 'switch' statement
CERT_C-MSC12-g=There shall be no unreachable code after "if" or "switch" statement inside while/for/do...while loop
CERT_C-MSC12-k=All non-null statements shall either have at least one side-effect however executed or cause control flow to change
CERT_C-MSC13=CERT-MSC13_C (REC) Detect and remove unused values
CERT_C-MSC13-a=Avoid unnecessary local variables
CERT_C-MSC14=CERT-MSC14_C (REC) Do not introduce unnecessary platform dependencies
CERT_C-MSC14-a=Evaluation of constant unsigned integer expressions should not lead to wrap-around
CERT_C-MSC15=CERT-MSC15_C (REC) Do not depend on undefined behavior
CERT_C-MSC15-a=Evaluation of constant unsigned integer expressions should not lead to wrap-around
CERT_C-MSC17=CERT-MSC17_C (REC) Finish every set of statements associated with a case label with a break statement
CERT_C-MSC17-a=Missing break statement between cases in a switch statement
CERT_C-MSC22=CERT-MSC22_C (REC) Use the setjmp(), longjmp() facility securely
CERT_C-MSC22-a=The facilities provided by <setjmp.h> should not be used
CERT_C-MSC24=CERT-MSC24_C (REC) Do not use deprecated or obsolescent functions
CERT_C-MSC24-a=The library functions atof, atoi and atol from library stdlib.h shall not be used
CERT_C-MSC24-b=The 'getenv()' function from the 'stdlib.h' or 'cstdlib' library shall not be used
CERT_C-MSC24-c=Avoid using unsafe string functions which may cause buffer overflows
CERT_C-MSC24-d=Don't use unsafe C functions that do write to range-unchecked buffers
CERT_C-MSC30=CERT-MSC30_C (RULE) Do not use the rand() function for generating pseudorandom numbers
CERT_C-MSC30-a=Do not use the rand() function for generating pseudorandom numbers
CERT_C-MSC33=CERT-MSC33_C (RULE) Do not pass invalid data to the asctime() function
CERT_C-MSC33-a=The 'asctime()' and 'asctime_r()' functions should not be used
CERT_C-MSC37=CERT-MSC37_C (RULE) Ensure that control never reaches the end of a non-void function
CERT_C-MSC37-a=All exit paths from a function, except main(), with non-void return type shall have an explicit return statement with an expression
CERT_C-MSC38=CERT-MSC38_C (RULE) Do not treat a predefined identifier as an object if it might only be implemented as a macro
CERT_C-MSC38-a=A function-like macro shall not be invoked without all of its arguments
CERT_C-MSC40=CERT-MSC40_C (RULE) Do not violate constraints
CERT_C-MSC40-a=An inline definition of a function with external linkage shall not contain definitions and uses of static objects
CERT_C-MSC41=CERT-MSC41_C (RULE) Never hard code sensitive information
CERT_C-MSC41-a=Do not hard code string literals
CERT_C-POS30=CERT-POS30_C (RULE) Use the readlink() function properly
CERT_C-POS30-b=The values returned by functions 'read' and 'readlink' shall be used
CERT_C-POS30-c=Use of possibly not null-terminated string with functions expecting null-terminated string
CERT_C-POS33=CERT-POS33_C (RULE) Do not use vfork()
CERT_C-POS33-a=Avoid using the 'vfork()' function
CERT_C-POS34=CERT-POS34_C (RULE) Do not call putenv() with a pointer to an automatic variable as the argument
CERT_C-POS34-a=Usage of system properties (environment variables) should be restricted
CERT_C-POS36=CERT-POS36_C (RULE) Observe correct revocation order while relinquishing privileges
CERT_C-POS36-a=Observe correct revocation order while relinquishing privileges
CERT_C-POS37=CERT-POS37_C (RULE) Ensure that privilege relinquishment is successful
CERT_C-POS37-a=Ensure that privilege relinquishment is successful
CERT_C-POS44=CERT-POS44_C (RULE) Do not use signals to terminate threads
CERT_C-POS44-a=The 'pthread_kill', 'pthread_sigqueue' and 'tgkill' functions should not be used to send signals to threads
CERT_C-POS47=CERT-POS47_C (RULE) Do not use threads that can be canceled asynchronously
CERT_C-POS47-a=The function 'pthread_setcanceltype()' should not be called with 'PTHREAD_CANCEL_ASYNCHRONOUS' argument
CERT_C-POS54=CERT-POS54_C (RULE) Detect and handle POSIX library errors
CERT_C-POS54-a=The value returned by a POSIX library function that may return an error should be used
CERT_C-PRE00=CERT-PRE00_C (REC) Prefer inline or static functions to function-like macros
CERT_C-PRE00-a=A function should be used in preference to a function-like macro
CERT_C-PRE01=CERT-PRE01_C (REC) Use parentheses within macros around parameter names
CERT_C-PRE01-a=In the definition of a function-like macro each instance of a parameter shall be enclosed in parentheses unless it is used as the operand of \# or \#\#
CERT_C-PRE02=CERT-PRE02_C (REC) Macro replacement lists should be parenthesized
CERT_C-PRE02-a=Enclose in parentheses whole definition of a function-like macro
CERT_C-PRE06=CERT-PRE06_C (REC) Enclose header files in an include guard
CERT_C-PRE06-a=Use multiple include guards
CERT_C-PRE07=CERT-PRE07_C (REC) Avoid using repeated question marks
CERT_C-PRE07-a=Trigraphs shall not be used
CERT_C-PRE30=CERT-PRE30_C (RULE) Do not create a universal character name through concatenation
CERT_C-PRE30-a=Avoid token concatenation that may produce universal character names
CERT_C-PRE31=CERT-PRE31_C (RULE) Avoid side effects in arguments to unsafe macros
CERT_C-PRE31-b=Assertions should not contain assignments, increment, or decrement operators
CERT_C-PRE31-c=Assertions should not contain function calls nor function-like macro calls
CERT_C-PRE31-d=Avoid side effects in arguments to unsafe macros
CERT_C-PRE32=CERT-PRE32_C (RULE) Do not use preprocessor directives in invocations of function-like macros
CERT_C-PRE32-a=Arguments to a function-like macro shall not contain tokens that look like preprocessing directives
CERT_C-SIG00=CERT-SIG00_C (REC) Mask signals handled by noninterruptible signal handlers
CERT_C-SIG00-a=The signal handling facilities of <signal.h> shall not be used
CERT_C-SIG01=CERT-SIG01_C (REC) Understand implementation-specific details regarding signal handler persistence
CERT_C-SIG01-a=The signal handling facilities of <signal.h> shall not be used
CERT_C-SIG02=CERT-SIG02_C (REC) Avoid using signals to implement normal functionality
CERT_C-SIG02-a=The signal handling facilities of <signal.h> shall not be used
CERT_C-STR00=CERT-STR00_C (REC) Represent characters using an appropriate type
CERT_C-STR00-a=The plain char type shall be used only for the storage and use of character values
CERT_C-STR04=CERT-STR04_C (REC) Use plain char for characters in the basic character set
CERT_C-STR04-a=The plain char type shall be used only for the storage and use of character values
CERT_C-STR05=CERT-STR05_C (REC) Use pointers to const when referring to string literals
CERT_C-STR05-a=A string literal shall not be modified
CERT_C-STR07=CERT-STR07_C (REC) Use the bounds-checking interfaces for string manipulation
CERT_C-STR07-a=Avoid using unsafe string functions that do not check bounds
CERT_C-STR09=CERT-STR09_C (REC) Don't assume numeric values for expressions with type plain character
CERT_C-STR09-a=Expressions with type (plain) char and wchar_t shall not be used as operands to built-in operators other than  \=,  \=\=, \!\= and the unary & operator
CERT_C-STR10=CERT-STR10_C (REC) Do not concatenate different type of string literals
CERT_C-STR10-a=Narrow and wide string literals shall not be concatenated
CERT_C-STR11=CERT-STR11_C (REC) Do not specify the bound of a character array initialized with a string literal
CERT_C-STR11-a=Do not specify the bound of a character array initialized with a string literal
CERT_C-STR30=CERT-STR30_C (RULE) Do not attempt to modify string literals
CERT_C-STR30-a=A string literal shall not be modified
CERT_C-STR31=CERT-STR31_C (RULE) Guarantee that storage for strings has sufficient space for character data and the null terminator
CERT_C-STR31-e=Avoid using unsafe string functions which may cause buffer overflows
CERT_C-STR34=CERT-STR34_C (RULE) Cast characters to unsigned char before converting to larger integer sizes
CERT_C-STR34-b=Cast characters to unsigned char before assignment to larger integer sizes
CERT_C-STR34-c=An expressions of the 'signed char' type should not be used as an array index
CERT_C-STR34-d=Cast characters to unsigned char before converting to larger integer sizes
CERT_C-STR38=CERT-STR38_C (RULE) Do not confuse narrow and wide character strings and functions
CERT_C-STR38-a=Do not confuse narrow and wide character strings and functions
CERT_C-WIN00=CERT-WIN00_C (REC) Be specific when dynamically loading libraries
CERT_C-WIN00-a=Use care to ensure that LoadLibrary() will load the correct library
CERT_CPP=SEI CERT C++
CERT_CPP-CON51=CERT-CON51_CPP (RULE) Ensure actively held locks are released on exceptional conditions
CERT_CPP-CON51-a=Do not call lock() directly on a mutex
CERT_CPP-CON54=CERT-CON54_CPP (RULE) Wrap functions that can spuriously wake up in a loop
CERT_CPP-CON54-a=Wrap functions that can spuriously wake up in a loop
CERT_CPP-CON55=CERT-CON55_CPP (RULE) Preserve thread safety and liveness when using condition variables
CERT_CPP-CON55-a=Do not use the 'notify_one()' function when multiple threads are waiting on the same condition variable
CERT_CPP-CTR53=CERT-CTR53_CPP (RULE) Use valid iterator ranges
CERT_CPP-CTR53-a=Do not use an iterator range that isn't really a range
CERT_CPP-CTR55=CERT-CTR55_CPP (RULE) Do not use an additive operator on an iterator if the result would overflow
CERT_CPP-CTR55-a=Do not add or subtract a constant with a value greater than one from an iterator
CERT_CPP-CTR56=CERT-CTR56_CPP (RULE) Do not use pointer arithmetic on polymorphic objects
CERT_CPP-CTR56-a=Don't treat arrays polymorphically
CERT_CPP-CTR56-b=A pointer to an array of derived class objects should not be converted to a base class pointer
CERT_CPP-CTR57=CERT-CTR57_CPP (RULE) Provide a valid ordering predicate
CERT_CPP-CTR57-a=For associative containers never use comparison function returning true for equal values
CERT_CPP-CTR58=CERT-CTR58_CPP (RULE) Predicate function objects should not be mutable
CERT_CPP-CTR58-a=Make predicates const pure functions
CERT_CPP-DCL50=CERT-DCL50_CPP (RULE) Do not define a C-style variadic function
CERT_CPP-DCL50-a=Functions shall not be defined with a variable number of arguments
CERT_CPP-DCL51=CERT-DCL51_CPP (RULE) Do not declare or define a reserved identifier
CERT_CPP-DCL51-a=Do not \#define or \#undef identifiers with names which start with underscore
CERT_CPP-DCL51-b=Do not redefine reserved words
CERT_CPP-DCL51-c=Do not \#define nor \#undef identifier 'defined'
CERT_CPP-DCL51-d=The names of standard library macros, objects and functions shall not be reused
CERT_CPP-DCL51-e=The names of standard library macros, objects and functions shall not be reused (C90)
CERT_CPP-DCL51-f=The names of standard library macros, objects and functions shall not be reused (C99)
CERT_CPP-DCL52=CERT-DCL52_CPP (RULE) Never qualify a reference type with const or volatile
CERT_CPP-DCL52-a=Never qualify a reference type with 'const' or 'volatile'
CERT_CPP-DCL53=CERT-DCL53_CPP (RULE) Do not write syntactically ambiguous declarations
CERT_CPP-DCL53-a=Parameter names in function declarations should not be enclosed in parentheses
CERT_CPP-DCL53-b=Local variable names in variable declarations should not be enclosed in parentheses
CERT_CPP-DCL53-c=Avoid function declarations that are syntactically ambiguous
CERT_CPP-DCL54=CERT-DCL54_CPP (RULE) Overload allocation and deallocation functions as a pair in the same scope
CERT_CPP-DCL54-a=Always provide new and delete together
CERT_CPP-DCL55=CERT-DCL55_CPP (RULE) Avoid information leakage when passing a class object across a trust boundary
CERT_CPP-DCL55-a=A pointer to a structure should not be passed to a function that can copy data to the user space
CERT_CPP-DCL56=CERT-DCL56_CPP (RULE) Avoid cycles during initialization of static objects
CERT_CPP-DCL56-a=Avoid initialization order problems across translation units by replacing non-local static objects with local static objects
CERT_CPP-DCL57=CERT-DCL57_CPP (RULE) Do not let exceptions escape from destructors or deallocation functions
CERT_CPP-DCL57-a=Never allow an exception to be thrown from a destructor, deallocation, and swap
CERT_CPP-DCL58=CERT-DCL58_CPP (RULE) Do not modify the standard namespaces
CERT_CPP-DCL58-a=Do not modify the standard namespaces 'std' and 'posix'
CERT_CPP-DCL59=CERT-DCL59_CPP (RULE) Do not define an unnamed namespace in a header file
CERT_CPP-DCL59-a=There shall be no unnamed namespaces in header files
CERT_CPP-ERR50=CERT-ERR50_CPP (RULE) Do not abruptly terminate the program
CERT_CPP-ERR50-a=The execution of a function registered with 'std\:\:atexit()' or 'std\:\:at_quick_exit()' should not exit via an exception
CERT_CPP-ERR50-b=Never allow an exception to be thrown from a destructor, deallocation, and swap
CERT_CPP-ERR50-c=Do not throw from within destructor
CERT_CPP-ERR50-d=There should be at least one exception handler to catch all otherwise unhandled exceptions
CERT_CPP-ERR50-e=An empty throw (throw;) shall only be used in the compound-statement of a catch handler
CERT_CPP-ERR50-f=Exceptions shall be raised only after start-up and before termination of the program
CERT_CPP-ERR50-g=Each exception explicitly thrown in the code shall have a handler of a compatible type in all call paths that could lead to that point
CERT_CPP-ERR50-h=Where a function's declaration includes an exception-specification, the function shall only be capable of throwing exceptions of the indicated type(s)
CERT_CPP-ERR50-i=Function called in global or namespace scope shall not throw unhandled exceptions
CERT_CPP-ERR50-l=The 'abort()' function from the 'stdlib.h' or 'cstdlib' library shall not be used
CERT_CPP-ERR50-n=The 'quick_exit()' and '_Exit()' functions from the 'stdlib.h' or 'cstdlib' library shall not be used
CERT_CPP-ERR51=CERT-ERR51_CPP (RULE) Handle all exceptions
CERT_CPP-ERR51-b=Each exception explicitly thrown in the code shall have a handler of a compatible type in all call paths that could lead to that point
CERT_CPP-ERR52=CERT-ERR52_CPP (RULE) Do not use setjmp() or longjmp()
CERT_CPP-ERR52-a=The facilities provided by <setjmp.h> should not be used
CERT_CPP-ERR52-b=The standard header files <setjmp.h> or <csetjmp> shall not be used
CERT_CPP-ERR53=CERT-ERR53_CPP (RULE) Do not reference base classes or class data members in a constructor or destructor function-try-block handler
CERT_CPP-ERR53-a=Handlers of a function-try-block implementation of a class constructor or destructor shall not reference nonstatic members from this class or its bases
CERT_CPP-ERR54=CERT-ERR54_CPP (RULE) Catch handlers should order their parameter types from most derived to least derived
CERT_CPP-ERR54-a=Where multiple handlers are provided in a single try-catch statement or function-try-block for a derived class and some or all of its bases, the handlers shall be ordered most-derived to base class
CERT_CPP-ERR55=CERT-ERR55_CPP (RULE) Honor exception specifications
CERT_CPP-ERR55-a=Where a function's declaration includes an exception-specification, the function shall only be capable of throwing exceptions of the indicated type(s)
CERT_CPP-ERR56=CERT-ERR56_CPP (RULE) Guarantee exception safety
CERT_CPP-ERR56-b=Do not leave 'catch' blocks empty
CERT_CPP-ERR58=CERT-ERR58_CPP (RULE) Handle all exceptions thrown before main() begins executing
CERT_CPP-ERR58-a=Exceptions shall be raised only after start-up and before termination of the program
CERT_CPP-ERR59=CERT-ERR59_CPP (RULE) Do not throw an exception across execution boundaries
CERT_CPP-ERR59-a=Do not throw an exception across execution boundaries
CERT_CPP-ERR60=CERT-ERR60_CPP (RULE) Exception objects must be nothrow copy constructible
CERT_CPP-ERR60-a=Exception objects must be nothrow copy constructible
CERT_CPP-ERR60-b=An explicitly declared copy constructor for a class that inherits from 'std\:\:exception' should have a non-throwing exception specification
CERT_CPP-ERR61=CERT-ERR61_CPP (RULE) Catch exceptions by lvalue reference
CERT_CPP-ERR61-a=A class type exception shall always be caught by reference
CERT_CPP-ERR61-b=Throw by value, catch by reference
CERT_CPP-ERR62=CERT-ERR62_CPP (RULE) Detect errors when converting a string to a number
CERT_CPP-ERR62-a=The library functions atof, atoi and atol from library stdlib.h shall not be used
CERT_CPP-EXP50=CERT-EXP50_CPP (RULE) Do not depend on the order of evaluation for side effects
CERT_CPP-EXP50-a=The value of an expression shall be the same under any order of evaluation that the standard permits
CERT_CPP-EXP50-b=Don't write code that depends on the order of evaluation of function arguments
CERT_CPP-EXP50-c=Don't write code that depends on the order of evaluation of function designator and function arguments
CERT_CPP-EXP50-d=Don't write code that depends on the order of evaluation of expression that involves a function call
CERT_CPP-EXP50-e=Between sequence points an object shall have its stored value modified at most once by the evaluation of an expression
CERT_CPP-EXP50-f=Don't write code that depends on the order of evaluation of function calls
CERT_CPP-EXP52=CERT-EXP52_CPP (RULE) Do not rely on side effects in unevaluated operands
CERT_CPP-EXP52-a=The operand of the sizeof operator shall not contain any expression which has side effects
CERT_CPP-EXP52-b=Object designated by a volatile lvalue should not be accessed in the operand of the sizeof operator
CERT_CPP-EXP52-c=The function call that causes the side effect shall not be the operand of the sizeof operator
CERT_CPP-EXP52-d=The operand of the 'typeid' operator shall not contain any expression that has side effects
CERT_CPP-EXP52-e=The operand of the 'typeid' operator shall not contain a function call that causes side effects
CERT_CPP-EXP54=CERT-EXP54_CPP (RULE) Do not access an object outside of its lifetime
CERT_CPP-EXP54-b=The address of an object with automatic storage shall not be returned from a function
CERT_CPP-EXP54-c=The address of an object with automatic storage shall not be assigned to another object that may persist after the first object has ceased to exist
CERT_CPP-EXP55=CERT-EXP55_CPP (RULE) Do not access a cv-qualified object through a cv-unqualified type
CERT_CPP-EXP55-a=A cast shall not remove any 'const' or 'volatile' qualification from the type of a pointer or reference
CERT_CPP-EXP56=CERT-EXP56_CPP (RULE) Do not call a function with a mismatched language linkage
CERT_CPP-EXP56-a=Do not call a function with a mismatched language linkage
CERT_CPP-EXP57=CERT-EXP57_CPP (RULE) Do not cast or delete pointers to incomplete classes
CERT_CPP-EXP57-a=Do not delete objects with incomplete class at the point of deletion
CERT_CPP-EXP57-b=Conversions shall not be performed between a pointer to an incomplete type and any other type
CERT_CPP-EXP59=CERT-EXP59_CPP (RULE) Use offsetof() on valid types and members
CERT_CPP-EXP59-a=Use offsetof() on valid types and members
CERT_CPP-EXP60=CERT-EXP60_CPP (RULE) Do not pass a nonstandard-layout type object across execution boundaries
CERT_CPP-EXP60-a=Do not pass a nonstandard-layout type object across execution boundaries
CERT_CPP-EXP61=CERT-EXP61_CPP (RULE) A lambda object must not outlive any of its reference captured objects
CERT_CPP-EXP61-a=Never return lambdas that capture local objects by reference
CERT_CPP-EXP61-b=Never capture local objects from an outer lambda by reference
CERT_CPP-EXP61-c=The lambda that captures local objects by reference should not be assigned to the variable with a greater lifetime
CERT_CPP-EXP62=CERT-EXP62_CPP (RULE) Do not access the bits of an object representation that are not part of the object's value representation
CERT_CPP-EXP62-a=Do not compare objects of a class that may contain padding bits with C standard library functions
CERT_CPP-INT50=CERT-INT50_CPP (RULE) Do not cast to an out-of-range enumeration value
CERT_CPP-INT50-a=An expression with enum underlying type shall only have values corresponding to the enumerators of the enumeration
CERT_CPP-MEM51=CERT-MEM51_CPP (RULE) Properly deallocate dynamically allocated resources
CERT_CPP-MEM51-a=Use the same form in corresponding calls to new/malloc and delete/free
CERT_CPP-MEM51-b=Always provide empty brackets ([]) for delete when deallocating arrays
CERT_CPP-MEM51-c=Both copy constructor and copy assignment operator should be declared for classes with a nontrivial destructor
CERT_CPP-MEM52=CERT-MEM52_CPP (RULE) Detect and handle memory allocation errors
CERT_CPP-MEM52-a=Check the return value of new
CERT_CPP-MEM52-b=Do not allocate resources in function argument list because the order of evaluation of a function's parameters is undefined
CERT_CPP-MEM53=CERT-MEM53_CPP (RULE) Explicitly construct and destruct objects when manually managing object lifetime
CERT_CPP-MEM53-a=Do not invoke malloc/realloc for objects having constructors
CERT_CPP-MEM54=CERT-MEM54_CPP (RULE) Provide placement new with properly aligned pointers to sufficient storage capacity
CERT_CPP-MEM54-a=Do not pass a pointer that has insufficient storage capacity or that is not suitably aligned for the object being constructed to placement 'new'
CERT_CPP-MEM54-b=An overhead should be used when an array of objects is passed to the placement 'new' allocation function
CERT_CPP-MEM55=CERT-MEM55_CPP (RULE) Honor replacement dynamic storage management requirements
CERT_CPP-MEM55-a=The user defined 'new' operator should throw the 'std\:\:bad_alloc' exception when the allocation fails
CERT_CPP-MEM57=CERT-MEM57_CPP (RULE) Avoid using default operator new for over-aligned types
CERT_CPP-MEM57-a=Avoid using the default operator 'new' for over-aligned types
CERT_CPP-MSC50=CERT-MSC50_CPP (RULE) Do not use std\:\:rand() for generating pseudorandom numbers
CERT_CPP-MSC50-a=Do not use the rand() function for generating pseudorandom numbers
CERT_CPP-MSC52=CERT-MSC52_CPP (RULE) Value-returning functions must return a value from all exit paths
CERT_CPP-MSC52-a=All exit paths from a function, except main(), with non-void return type shall have an explicit return statement with an expression
CERT_CPP-OOP50=CERT-OOP50_CPP (RULE) Do not invoke virtual functions from constructors or destructors
CERT_CPP-OOP50-a=Avoid calling virtual functions from constructors
CERT_CPP-OOP50-b=Avoid calling virtual functions from destructors
CERT_CPP-OOP51=CERT-OOP51_CPP (RULE) Do not slice derived objects
CERT_CPP-OOP51-a=Avoid slicing function arguments / return value
CERT_CPP-OOP52=CERT-OOP52_CPP (RULE) Do not delete a polymorphic object without a virtual destructor
CERT_CPP-OOP52-a=Define a virtual destructor in classes used as base classes which have virtual functions
CERT_CPP-OOP53=CERT-OOP53_CPP (RULE) Write constructor member initializers in the canonical order
CERT_CPP-OOP53-a=List members in an initialization list in the order in which they are declared
CERT_CPP-OOP54=CERT-OOP54_CPP (RULE) Gracefully handle self-copy assignment
CERT_CPP-OOP54-a=Check for assignment to self in operator\=
CERT_CPP-OOP55=CERT-OOP55_CPP (RULE) Do not use pointer-to-member operators to access nonexistent members
CERT_CPP-OOP55-a=A cast shall not convert a pointer to a function to any other pointer type, including a pointer to function type
CERT_CPP-OOP57=CERT-OOP57_CPP (RULE) Prefer special member functions and overloaded operators to C Standard Library functions
CERT_CPP-OOP57-a=Do not initialize objects with a non-trivial class type using C standard library functions
CERT_CPP-OOP57-b=Do not compare objects of nonstandard-layout class type with C standard library functions
CERT_CPP-OOP58=CERT-OOP58_CPP (RULE) Copy operations must not mutate the source object
CERT_CPP-OOP58-a=Copy operations must not mutate the source object
CERT_CPP-STR50=CERT-STR50_CPP (RULE) Guarantee that storage for strings has sufficient space for character data and the null terminator
CERT_CPP-STR50-g=Do not use the 'char' buffer to store input from 'std\:\:cin'
CODSTA=Coding Conventions
CODSTA-01=Array elements shall be accessed by the array operator [ ]
CODSTA-02=Do not declare member variables as bit-fields
CODSTA-02_b=A member of a union shall not be declared as a bit-field
CODSTA-03=Do not define constants via \#define
CODSTA-04=Do not declare local variables with the 'static' keyword
CODSTA-05=Pointers to pointers should be avoided whenever possible
CODSTA-06=Avoid using the '?\:' operator
CODSTA-07=If a function has no parameters, use ( ) instead of ( void )
CODSTA-08=Do not use break in for loops
CODSTA-09=Do not cast pointers to functions to pointers to primitive types
CODSTA-10=Storage type modifiers shall be associated with the type, not the variable or the function
CODSTA-100=Signed and unsigned values shall not be mixed in arithmetic operations
CODSTA-101=Signed and unsigned values shall not be mixed in second and third operand of conditional operator
CODSTA-102=A single operation with side-effect shall only be used in the proper context
CODSTA-103=A call of function with side-effect shall only be used in the proper context
CODSTA-104=The operands of a logical && or || shall be parenthesized if the operands contain binary operators
CODSTA-105=The second or third operand of a ternary operator '?\:' shall not contain side effects
CODSTA-107=The library functions bsearch and qsort of <stdlib.h> shall not be used
CODSTA-108=The standard header file <tgmath.h> shall not be used
CODSTA-108_b=The facilities that are specified as being provided by <tgmath.h> should not be used
CODSTA-108_c=All arguments to any type-generic macros declared in <tgmath.h> shall have appropriate essential type
CODSTA-108_d=All arguments to any multi-argument type-generic macros declared in <tgmath.h> shall have the same standard type
CODSTA-109=The features provided by <fenv.h> should not be used
CODSTA-109_b=The standard header file <fenv.h> shall not be used
CODSTA-11=Assert liberally to document internal assumptions and invariants
CODSTA-110=The Standard Library input/output functions shall not be used
CODSTA-111=The union keyword should not be used
CODSTA-112=Variable-length arrays should not be used
CODSTA-112_b=Pointers to variably-modified array types should not be used
CODSTA-113=Flexible array members shall not be declared
CODSTA-114=Assembly language shall be encapsulated and isolated in C/C++ functions
CODSTA-115=If a pointer to a structure or union is never dereferenced within a translation unit, then the implementation of the object should be hidden
CODSTA-116=A 'default' label, if it exists, shall appear as either the first or the last switch label of a switch statement
CODSTA-117=Octal and hexadecimal escape sequences shall be terminated
CODSTA-118=A declaration shall be visible when an object or function with external linkage is defined
CODSTA-119=A 'default' label shall have a statement or a comment before terminating 'break'
CODSTA-12=Avoid using shift operations instead of arithmetic operations
CODSTA-120=An inline function shall be declared with the static storage class
CODSTA-121=The restrict type qualifier shall not be used
CODSTA-122_a=The value returned by a function having non-void return type shall be used
CODSTA-122_b=The value returned by a function having non-void return type shall be used
CODSTA-123=A full expression containing an increment (++) or decrement (--) operator should have no other potential side effects
CODSTA-124_a=Conversions shall not be performed between a pointer to a function and any other type than pointer to function
CODSTA-124_b=Conversions shall not be performed between non compatible pointer to a function types
CODSTA-125=Conversions shall not be performed between a pointer to an incomplete type and any other type
CODSTA-126=A cast shall not be performed between a pointer to object type and a pointer to a different object type
CODSTA-127=A conversion should not be performed between a pointer to object and an integer type
CODSTA-127_b=A conversion should not be performed between a pointer to object type and an integer type other than 'uintptr_t' or 'intptr_t'
CODSTA-128=A conversion should not be performed from pointer to void into pointer to object
CODSTA-129_a=A cast shall not be performed between pointer to void and an arithmetic type
CODSTA-129_b=An implicit conversion shall not be performed between pointer to void and an arithmetic type
CODSTA-13=>, >\=, <, <\= shall not be applied to pointer types except where they point to the same array
CODSTA-130=A cast shall not be performed between pointer to object and a non-integer arithmetic type
CODSTA-131=Use NULL instead of literal zero (0) as the null-pointer-constant
CODSTA-132=A function parameter should not be modified
CODSTA-133_a=A macro shall not be defined with the same name as a keyword in C90
CODSTA-133_b=A macro shall not be defined with the same name as a keyword in C99
CODSTA-134=The function argument corresponding to a parameter declared to have an array type shall have an appropriate number of elements
CODSTA-135=Type casting from any type to or from pointers shall not be used
CODSTA-136_a=The identifiers va_list, va_arg, va_start, va_end, va_copy should not be used
CODSTA-136_b=The identifiers va_list, va_arg, va_start, va_end should not be used
CODSTA-136_c=The standard header file <stdarg.h> or <cstdarg> shall not be used
CODSTA-137=The function call shall not be the operand of the sizeof operator
CODSTA-138=The result of a built-in assignment operator should not be used
CODSTA-13_b=Pointer subtraction shall only be applied to pointers that address elements of the same array
CODSTA-14=Never convert consts to non-consts
CODSTA-141_a=Initializer lists shall not contain persistent side effects
CODSTA-142=Global functions shall not declare parameters with array type
CODSTA-142_b=Functions which are called with array argument shall not be declared with pointer parameter
CODSTA-143=Suspicious use of 'strcpy' without checking size of source buffer
CODSTA-144=The values returned by functions 'read' and 'readlink' shall be used
CODSTA-145=Use of possibly not null-terminated string with functions expecting null-terminated string
CODSTA-146=A value returned from a stdio character-oriented I/O function should not be implicitly converted to a type smaller than 'int'
CODSTA-147=Pointer should not be compared with NULL using relational operators <, >, >\=, <\=
CODSTA-148=Do not use string literals as operands of equality or relational operators
CODSTA-149=Missing break statement between cases in a switch statement
CODSTA-15=Do not declare the size of an array when the array is passed into a function as a parameter
CODSTA-150=Assertions should not contain assignments, increment, or decrement operators
CODSTA-150_b=Assertions should not contain function calls nor function-like macro calls
CODSTA-150_c=Avoid side effects in arguments to unsafe macros
CODSTA-151=Do not use enumerations in boolean condition
CODSTA-152=The value of a composite expression shall not be cast to a different essential type category or a wider essential type
CODSTA-154=An external object or function shall not have more than one non-defining declaration in translation unit
CODSTA-155=Use typedefs from stdint.h instead of declaring your own in C99 code
CODSTA-156_a=If a composite expression is used as one operand of an operator in which the usual arithmetic conversions are performed then the other operand shall not have wider essential type
CODSTA-156_b=If a composite expression is used as one (second or third) operand of a conditional operator then the other operand shall not have wider essential type
CODSTA-157=The value of a composite expression shall not be assigned to an object with wider essential type
CODSTA-158=Function types shall have named parameters
CODSTA-159=Function types shall be in prototype form
CODSTA-16=Do not declare the size of an array when the array is initialized
CODSTA-160=The declaration of an array parameter shall not contain the 'static' keyword between the [ ]
CODSTA-161_a=An expression of essentially Boolean type should always be used where an operand is interpreted as a Boolean value
CODSTA-161_b=An operand of essentially Boolean type should not be used where an operand is interpreted as a numeric value
CODSTA-161_c=An operand of essentially character type should not be used where an operand is interpreted as a numeric value
CODSTA-161_d=An operand of essentially enum type should not be used in an arithmetic operation
CODSTA-161_e=Shift and bitwise operations should not be performed on operands of essentially signed or enum type
CODSTA-161_f=An operand of essentially signed or enum type should not be used as the right hand operand to the bitwise shifting operator
CODSTA-161_g=An operand of essentially unsigned type should not be used as the operand to the unary minus operator
CODSTA-162=Expressions of essentially character type shall not be used inappropriately in addition and subtraction operations
CODSTA-163_a=The value of an expression shall not be assigned to an object with a narrower essential type
CODSTA-163_b=The value of an expression shall not be assigned to an object of a different essential type category
CODSTA-164_a=Both operands of an operator in which the usual arithmetic conversions are performed shall have the same essential type category
CODSTA-164_b=The second and third operands of the ternary operator shall have the same essential type category
CODSTA-165_a=The cast operation to essentially enumeration type is not allowed
CODSTA-165_b=Do not cast from or to essentially Boolean type
CODSTA-165_c=Do not use casts between essentially character types and essentially floating types
CODSTA-166_a=A pointer to a FILE object shall not be dereferenced
CODSTA-166_b=A pointer to a FILE object shall not be dereferenced by a library function
CODSTA-167_a=A loop counter in a 'for' loop shall not have essentially floating type
CODSTA-167_b=A loop counter in 'while' and 'do-while' loops shall not have essentially floating type
CODSTA-168=There shall only be one loop counter in a 'for' loop, which shall not be modified in the 'for' loop body
CODSTA-169_a=The first clause of a 'for' loop shall be well-formed
CODSTA-169_b=The second clause of a 'for' loop shall be well-formed
CODSTA-169_c=The third clause of a 'for' statement shall be well-formed
CODSTA-17=Do not use NULL identifier; use 0 instead
CODSTA-170_c90=The names of macros that exist prior to preprocessing should be distinct from the identifiers that exist after preprocessing (c90)
CODSTA-170_c99=The names of macros that exist prior to preprocessing should be distinct from the identifiers that exist after preprocessing (c99)
CODSTA-171_c90=The name of a macro should be distinct from the names of its parameters(c90)
CODSTA-171_c99=The name of a macro should be distinct from the names of its parameters(c99)
CODSTA-172_c90=The name of a macro should be distinct from the names of other macros that are currently defined(c90)
CODSTA-172_c99=The name of a macro should be distinct from the names of other macros that are currently defined(c99)
CODSTA-174_a_c90=A program should not exceed the translation limits imposed by The Standard (c90)
CODSTA-174_a_c99=A program should not exceed the translation limits imposed by The Standard (c99)
CODSTA-174_b_c90=A program should not exceed the translation limits imposed by The Standard (c90)
CODSTA-174_b_c99=A program should not exceed the translation limits imposed by The Standard (c99)
CODSTA-175_a=A function should not contain unused type declarations
CODSTA-175_b=A source file should not contain unused type declarations
CODSTA-176_a=A function should not contain unused local tag declarations
CODSTA-176_b=A source file should not contain unused tag declarations
CODSTA-177=A source file should not contain unused macro definitions
CODSTA-178=External identifiers shall be distinct
CODSTA-179_a_c90=Identifiers declared in the file scope and in the same name space shall be distinct (c90)
CODSTA-179_a_c99=Identifiers declared in the file scope and in the same name space shall be distinct (c99)
CODSTA-179_b_c90=Identifiers declared in the same block scope and name space shall be distinct (c90)
CODSTA-179_b_c99=Identifiers declared in the same block scope and name space shall be distinct (c99)
CODSTA-18=Prefer 'while' statements over 'do' statements
CODSTA-181=The +, -, +\= and -\= operators should not be applied to an expression of pointer type
CODSTA-182=The 'sizeof' operator shall not have an operand which is a function parameter declared as "array of type"
CODSTA-183=The pointer arguments to the Standard Library functions 'memcmp', 'memmove' and 'memcmp' shall be pointers to qualified or unqualified versions of compatible types
CODSTA-184=The pointer arguments to the Standard Library function 'memcmp' shall point to either a pointer type, an essentially signed type, an essentially unsigned type, an essentially Boolean type or an essentially enum type
CODSTA-185_a=The pointers returned by the Standard Library functions 'localeconv', 'getenv', 'setlocale' or, 'strerror' shall only be used as if they have pointer to const-qualified type
CODSTA-185_b=Strings pointed by members of the structure 'lconv' should not be modified
CODSTA-186=Where designated initializers are used to initialize an array object the size of the array shall be specified explicitly
CODSTA-187_a=Cast characters to unsigned char before assignment to larger integer sizes
CODSTA-187_b=An expressions of the 'signed char' type should not be used as an array index
CODSTA-187_c=Cast characters to unsigned char before converting to larger integer sizes
CODSTA-188=Do not confuse narrow and wide character strings and functions
CODSTA-189=Do not add or subtract a scaled integer to a pointer
CODSTA-18_b='Do' statements should not be used except in a function-like macro
CODSTA-19=Use the ctype.h facilities for character test
CODSTA-190=Do not use object representations to compare floating-point values
CODSTA-191=Wrap functions that can spuriously wake up in a loop
CODSTA-192=The final member of a structure should not be an array of size '0' or '1'
CODSTA-193=Allocate structures containing a flexible array member dynamically
CODSTA-194=Wrap functions that can fail spuriously in a loop
CODSTA-195=Do not refer to an atomic variable twice in an expression
CODSTA-196=Do not modify objects with temporary lifetime
CODSTA-197=Do not specify the bound of a character array initialized with a string literal
CODSTA-198=The value of a complex expression of floating type should not be cast to a wider floating type
CODSTA-198_b=The value of a complex expression of floating type should not be cast to an integer type
CODSTA-199=Do not use assertions
CODSTA-20=EOS should be used to terminate a string rather than NULL
CODSTA-200=Explicitly specify array bounds in array declarations with initializers
CODSTA-201=Do not process structured text data natively
CODSTA-202=An inline definition of a function with external linkage shall not contain definitions and uses of static objects
CODSTA-203=Do not hard code string literals
CODSTA-204=Functions declared as 'noreturn' shall have the 'void' return type
CODSTA-205=Do not cast an array to the pointer to a structure of a larger size than the size of the array
CODSTA-206=The '_Noreturn' function specifier should not be used
CODSTA-207=The <stdnoreturn.h> header file should not be used
CODSTA-208=The <stdalign.h> header file shall not be used
CODSTA-209=The facilities that are specified as being provided by <stdatomic.h> should not be used
CODSTA-209_b=Do not use the macro ATOMIC_VAR_INIT
CODSTA-21=When using enum, the values of each member should be explicitly declared
CODSTA-210=The '_Thread_local' storage class specifier should not be used
CODSTA-211=The facilities that are specified as being provided by <threads.h> should not be used
CODSTA-212=The 'rsize_t' type should not be used
CODSTA-213=The '_Alignas' alignment specifier and the '_Alignof' operator should not be used
CODSTA-214=The '_Atomic' type specifier and the '_Atomic' type qualifier should not be used
CODSTA-215=The '__STDC_WANT_LIB_EXT1__' macro should not be defined to the value other than '0'
CODSTA-216=The '_Generic' operator should not be used
CODSTA-217=The 'errno_t' type should not be used
CODSTA-218=Do not use following macros\: RSIZE_MAX, L_tmpnam_s, TMP_MAX_S
CODSTA-219=Do not use the functions defined in Annex K of ISO/IEC 9899\:2011 standard
CODSTA-22=Local variable or parameter names and class member variable or parent class/struct member variable names shall differ by more than a single character
CODSTA-220=Arguments of integer-constant macros should be decimal, octal, or hexadecimal constants with appropriate values
CODSTA-220_b=The small integer variants of the minimum-width integer constant macros should not be used
CODSTA-221=Do not include any type qualifiers in the specification of a function type
CODSTA-222=Avoid implicit integral conversions from a wider to a narrower type
CODSTA-223=Fixed width integer types from <cstdint>, indicating the size and signedness, shall be used in place of the basic numerical types
CODSTA-223_b=A typedef should be used in place of the plain char type
CODSTA-224=The conditional operator should not be used as a sub-expression
CODSTA-225=Floating-point expressions shall not be explicitly (syntactically) tested for equality (\=\=) or inequality (\!\=)
CODSTA-226_a=The value returned by a standard library function that may return an error should be used
CODSTA-226_b=The standard library functions for which return values need not be checked should be cast to 'void'
CODSTA-227=The value returned by a POSIX library function that may return an error should be used
CODSTA-228_a=Do not call 'getc()', 'putc()', 'getwc()', or 'putwc()' with a stream argument containing assignments, increment or decrement operators
CODSTA-228_b=Do not call 'getc()', 'putc()', 'getwc()', or 'putwc()' with a stream argument containing function calls or function-like macro calls
CODSTA-229=The operands of the remainder operator '%' should be of unsigned integer types
CODSTA-23=All 'if' statements should have an 'else' clause
CODSTA-230=Do not cast pointers into more strictly aligned pointer types
CODSTA-231=The address of an object with thread storage duration shall not be assigned to an object with static storage duration
CODSTA-232=The increment (++) and decrement (--) operators should not be mixed with arithmetic operators in an expression
CODSTA-24=The macro FALSE should be defined as 0 (zero)
CODSTA-25=The enumeration constant named 'FALSE' should be explicitly initialized by 0 value
CODSTA-26=Avoid magic numbers
CODSTA-27=Avoid functions that modify global variables
CODSTA-28=Define fields for union declarations
CODSTA-29=Use meaningful symbolic constants to represent literal values
CODSTA-30=Avoid returning handles to function parameters
CODSTA-31=Avoid explicit type conversions (casts)
CODSTA-32=Do not write logical expressions of the type if(test) or if(\!test)  when test is a pointer
CODSTA-33=Do not use operator ++ or -- in the conditional expression of if, while, or switch
CODSTA-34=Use a typedef to simplify program syntax when declaring function pointers
CODSTA-35=Always provide a default branch for switch statements
CODSTA-36=Pass built-in-types by value unless you are modifying them
CODSTA-37=Prefer const objects or enums to \#defines for simple constants
CODSTA-38=Do not use a \#define that prevents the compiler from checking types
CODSTA-39=Avoid internal or external name conflict with a C++ reserved word
CODSTA-40='void' should be used when a function is passed or returns no values
CODSTA-41=Avoid switch statements with only one case
CODSTA-42=The macro TRUE should be defined as 1
CODSTA-43=The enumeration constant named 'TRUE' should be explicitly initialized by 1 value
CODSTA-44=Local variables should not use the same names as member variables
CODSTA-45=Parameters should not use the same names as member variables
CODSTA-46=Use positive logic rather than negative logic whenever practical
CODSTA-47=All structures should be typedef'd
CODSTA-48=Do not use the following digraphs\: <%, %>, <\:, \:>, %\:, %\:%\:
CODSTA-49=Null initialize or increment expressions in for loops will not be used; a while loop will be used instead
CODSTA-50=Hexadecimal constants will be represented using all uppercase letters
CODSTA-51=Literal suffixes shall use uppercase rather than lowercase letters
CODSTA-52=The initialization expression in a for loop will perform no actions other than to initialize the value of a single for loop parameter
CODSTA-53=The increment expression in a for loop will perform no action other than to change a single loop parameter to the next value for the loop
CODSTA-54=Every switch statement will have at least two cases and a potential default
CODSTA-55=Enumeration types shall be used instead of integer types (and constants) as case labels
CODSTA-56=All 'case' and 'default' labels of 'switch' statement should have an explicit 'break' or a 'return' statement, or 'fall through' comment
CODSTA-57=Suspicious use of semicolon
CODSTA-58=Cast to void is not allowed
CODSTA-59=Hardcoded array declarations and 'malloc' calls should not be used
CODSTA-60=Avoid comparing values with TRUE macro/enum constant using equality operators ("\=\=", "\!\=")
CODSTA-61=The final clause of a switch statement shall be the default-clause unless all enumeration values are tested
CODSTA-62=A cast shall not convert a pointer to a function to any other pointer type, including a pointer to function type
CODSTA-63=Bitwise operators shall only be applied to operands of unsigned underlying type
CODSTA-64=An unconditional throw or break statement shall terminate every non-empty switch-clause
CODSTA-65=An object with integer type or pointer to void type shall not be converted to an object with pointer type
CODSTA-66=Non-constant operands to a binary bitwise operator shall have the same underlying type
CODSTA-67=The types used for an object, a function return type, or a function parameter shall be token-for-token identical in all declarations and re-declarations
CODSTA-68=A "U" suffix shall be applied to all octal or hexadecimal integer literals of unsigned type
CODSTA-69=Expressions with type (plain) char and wchar_t shall not be used as operands to built-in operators other than  \=,  \=\=, \!\= and the unary & operator
CODSTA-70=Expressions with type enum shall not be used as operands to built-in operators other than  [ ],  \=, \=\=, \!\=, <, <\=, >, >\=, and the unary & operator
CODSTA-71=Named bit-fields with signed integer type shall have a length of more than one bit
CODSTA-73=Assembler instructions shall only be introduced using the asm declaration
CODSTA-74=Bit-fields shall not have enum type
CODSTA-75=Bit-fields shall be either bool type or an explicitly unsigned or signed integral type
CODSTA-76=The identifier main shall not be used for a function other than the global function main
CODSTA-77=The goto statement shall jump to a label declared later in the same function body
CODSTA-78=Any label referenced by a goto statement shall be declared in the same block, or in a block enclosing the goto statement
CODSTA-79=For any iteration statement there shall be no more than one break or goto statement used for loop termination
CODSTA-80=The continue statement shall only be used within a well formed for loop
CODSTA-81=If a function has internal linkage then all re-declarations shall include the 'static' storage class specifier
CODSTA-82=Avoid infinite loops
CODSTA-82_b=Do not use empty infinite loops
CODSTA-83=All loops must have a fixed upper or lower bound
CODSTA-85=Avoid exit points within infinite loops
CODSTA-86=The validity of parameters must be checked inside each function
CODSTA-87=Use no more than one level of dereferencing
CODSTA-88=Function pointers are not permitted
CODSTA-89=The declaration should not contain more than one level of pointer indirection
CODSTA-90=Each operand of a logical '&&' or '||' shall be a postfix-expression
CODSTA-91=A function shall have at most one exit point
CODSTA-92=The names of standard library macros and objects shall not be reused
CODSTA-92_a=Reserved identifiers, macros and functions in the standard library, shall not be defined, redefined or undefined (C90 code)
CODSTA-92_b=Reserved identifiers, macros and functions in the standard library, shall not be defined, redefined or undefined (C99 code)
CODSTA-93=The names of standard library functions shall not be overridden
CODSTA-94=Do not declare pointer or array type
CODSTA-95=Do not declare pointer type
CODSTA-96=Bit-fields shall have explicitly unsigned integral or enumeration types only
CODSTA-97=Use parenthesis to clarify expression order if operators with precedence lower than arithmetic are used
CODSTA-98=All 'if...else if' constructs will contain either a final else clause or a comment indicating why a final else clause is not necessary
CODSTA-99=Signed and unsigned values shall not be mixed in comparison operations
CODSTA-CPP=Coding Conventions for C++
CODSTA-CPP-01=Prefer iostream.h to stdio.h
CODSTA-CPP-02=Have assignment operator returns a reference to *this; make assignment operator's return type a non-const reference to it's class' type
CODSTA-CPP-03=Bitwise operators, comparison operators, logical operators, comma operator should be const
CODSTA-CPP-04=Constructors allowing for conversion should be made explicit
CODSTA-CPP-05=Do not use user-defined conversion functions
CODSTA-CPP-06=Avoid returning handles to class data from member functions
CODSTA-CPP-07=Postfix increment and decrement should be implemented in terms of their prefix counterparts
CODSTA-CPP-08=Avoid overloading logical operators AND, OR (&&, ||)
CODSTA-CPP-09=Avoid using reinterpret_cast
CODSTA-CPP-10=Do not define structs that contain member functions
CODSTA-CPP-100=Do not compare objects of a class that may contain padding bits with C standard library functions
CODSTA-CPP-101=A relational operator shall return a boolean value
CODSTA-CPP-102=A binary arithmetic operator and a bitwise operator shall return a 'prvalue'
CODSTA-CPP-103=Output parameters shall not be used
CODSTA-CPP-104=The operand of the 'typeid' operator shall not contain any expression that has side effects
CODSTA-CPP-104_b=The operand of the 'typeid' operator shall not contain a function call that causes side effects
CODSTA-CPP-105=Define special members as \=default when the behavior is equivalent to the compiler's behavior
CODSTA-CPP-106=Use delegating constructors to reduce code duplication
CODSTA-CPP-107=Comparison operators shall be non-member functions
CODSTA-CPP-107_b=Comparison operators shall be non-member functions with identical parameter types and noexcept
CODSTA-CPP-108=A parameter of const reference to a 'cheap to copy' type should be passed by value
CODSTA-CPP-108_b=Pass small objects with a trivial copy constructor by value
CODSTA-CPP-109=A parameter of a type that is not 'cheap to copy' should be passed by reference
CODSTA-CPP-11=C-style casts should not be used
CODSTA-CPP-12=Put classes that are used as base classes and classes that are used as member variables into separate include files
CODSTA-CPP-13=Put classes that are used as function return type into separate include files
CODSTA-CPP-14=Put classes that are used as argument types in function prototypes into separate include files
CODSTA-CPP-15=Put functions that are used in the body of inline member function into separate include file
CODSTA-CPP-16=When two operators are opposites (such as \=\= and \!\=), it is appropriate to define both
CODSTA-CPP-17=Do not use the 'struct' keyword to declare a variable in C++
CODSTA-CPP-18=Encapsulate global variables and constants, enumerated types, and typedefs in a class
CODSTA-CPP-19=Declare at least one constructor to prevent the compiler from doing so
CODSTA-CPP-20=If you'd like to support mixed-mode operations make operators a non-member functions
CODSTA-CPP-21=Assignment operator must return const reference
CODSTA-CPP-22=Prefer non-member non-friend functions to member functions
CODSTA-CPP-23=Whenever a global function  is  referenced, use the \:\: operator
CODSTA-CPP-24=Avoid making any assignment operator virtual. Do not return const T& from assignment operator
CODSTA-CPP-25=Consider making virtual functions nonpublic, and public functions nonvirtual
CODSTA-CPP-26=Keep types and functions in separate namespaces unless they're specifically intended to work together
CODSTA-CPP-27=Keep a type and its nonmember function interface in the same namespace
CODSTA-CPP-28=When binary arithmetic operators are defined  ( + , - , * , / , ^ , % , | , & ), assignment versions should be provided too
CODSTA-CPP-29=Prefer the canonical forms of arithmetic and assignment operators
CODSTA-CPP-30=Prefer non-member operators than member ones to support mixed-mode arithmetic
CODSTA-CPP-31=Do not use the keyword 'explicit' for a constructor
CODSTA-CPP-32=A function definition should not be placed in a class specification unless the function is intended to be inlined
CODSTA-CPP-33=Member functions shall not be defined within the template class definition
CODSTA-CPP-34=Avoid using static_cast on pointers
CODSTA-CPP-35=Avoid dynamic_casts
CODSTA-CPP-36=The global namespace shall only contain main() and namespace declarations
CODSTA-CPP-37=Do not define class/struct/union inside function implementation
CODSTA-CPP-38=Conversion operator, operator->, operator(), operator[] should be const
CODSTA-CPP-39=Don't write namespace usings in a header file or before an \#include
CODSTA-CPP-40=Limiting the number of objects of a class
CODSTA-CPP-41=Do not use the 'enum' keyword to declare a variable in C++
CODSTA-CPP-42=Do not declare member variables with the 'mutable' keyword
CODSTA-CPP-43=Declare reference parameters as const references whenever possible
CODSTA-CPP-44=Have the non-const version call the const version of member function instead of duplicating the const version definition
CODSTA-CPP-45=In the private section of a class items shall be declared in the following order\: Constructors, Destructor, Member Functions, Member Operator Function, Enumerations and others
CODSTA-CPP-46=Order of scopes in class\: public before all others
CODSTA-CPP-47=Order of scopes in classes\: protected before private
CODSTA-CPP-48=In the protected section of a class items shall be declared in the following order\: Constructors, Destructor, Member Functions, Member Operator Function, Enumerations and others
CODSTA-CPP-49=In the public section of a class items shall be declared in the following order\: Constructors, Destructor, Member Functions, Member Operator Function, Enumerations and others
CODSTA-CPP-50=Do not use static keyword except inside functions and classes
CODSTA-CPP-51=Do not define inline functions in source files
CODSTA-CPP-52=Consider using the natural relationship between the assignment version of an operator and the stand-alone version
CODSTA-CPP-53=Declare local variable as const whenever possible
CODSTA-CPP-53_b=Declare parameters as const whenever possible
CODSTA-CPP-54=Member functions shall be declared const whenever possible
CODSTA-CPP-55=Arrays shall not be used in interfaces
CODSTA-CPP-55_b=Private and protected methods shall not declare parameters with array type
CODSTA-CPP-56=A class, structure, or enumeration will not be declared in the definition of its type
CODSTA-CPP-57=Namespaces will not be nested more than two levels deep
CODSTA-CPP-58=The value returned by a function having a non-void return type that is not an overloaded operator shall always be used
CODSTA-CPP-59=The C library shall not be used
CODSTA-CPP-60=Only those escape sequences that are defined in ISO/IEC 14882\:2003 shall be used
CODSTA-CPP-60_b=Only those escape sequences that are defined in ISO/IEC 14882\:2014 shall be used
CODSTA-CPP-62=NULL shall not be used as an integer value
CODSTA-CPP-63=Literal zero (0) shall not be used as the null-pointer-constant
CODSTA-CPP-64=The condition of an if-statement and the condition of an iteration-statement shall have type bool
CODSTA-CPP-65=The first operand of a conditional-operator shall have type bool
CODSTA-CPP-66=C-style casts (other than void casts) and functional notation casts (other than explicit constructor calls) shall not be used
CODSTA-CPP-67=Each operand of the \! operator, the logical && or the logical || operators shall have type bool
CODSTA-CPP-68=The unary & operator shall not be overloaded
CODSTA-CPP-69=A for loop shall contain a single loop-counter which shall not have floating type
CODSTA-CPP-70=If loop-counter is not modified by -- or ++, then, within condition, the loop-counter shall only be used as an operand to <\=, <, > or >\=
CODSTA-CPP-71=The loop-counter shall be modified by one of\: --, ++, -\=n, or +\=n; where n remains constant for the duration of the loop
CODSTA-CPP-72=A loop-control-variable other than the loop-counter shall not be modified within condition or expression
CODSTA-CPP-73=A loop-control-variable other than the loop-counter which is modified in statement shall have type bool
CODSTA-CPP-74=There shall be no unnamed namespaces in header files
CODSTA-CPP-75=using-directives shall not be used
CODSTA-CPP-76=Multiple declarations for an identifier in the same namespace shall not straddle a using-declaration for that identifier
CODSTA-CPP-77=Const member functions shall not return non-const pointers or references to class-data
CODSTA-CPP-78=If a member function can be made static then it shall be made static, otherwise if it can be made const then it shall be made const
CODSTA-CPP-79=Neither operand of an equality operator (\=\= or \!\=) shall be a pointer to a virtual member function
CODSTA-CPP-80=Avoid overloading comma operator ","
CODSTA-CPP-81=Classes which have only getters/setters (accessors/mutators) are not allowed
CODSTA-CPP-82=Avoid unencapsulated global variables (including variables declared in namespaces and public static members)
CODSTA-CPP-83=Identifiers declared in a local scope should not hide identifiers declared in a class scope
CODSTA-CPP-84=Identifiers declared in a class scope should not hide identifiers declared in a global or namespace scope
CODSTA-CPP-85=Identifiers declared in an inner class scope should not hide identifiers declared in outer class scope
CODSTA-CPP-86=If two opposite equality operators ('\=\=', '\!\=') are defined in a class, one shall be defined in terms of the other
CODSTA-CPP-87_a=If an identifier refers to a type, it shall not also refer to an object or a function in the same scope
CODSTA-CPP-87_b=If an identifier refers to a type, it shall not also refer to an object or a function in the same scope
CODSTA-CPP-87_c=If an identifier refers to a type, it shall not also refer to an object or a function in the same scope
CODSTA-CPP-88=The name of typedef should not be the same as the name of its basic type
CODSTA-CPP-89=Do not assign enumerations to bool
CODSTA-CPP-90=using-directives and using-declarations (excluding class scope or function scope using-declarations) shall not be used in header files
CODSTA-CPP-91=The overloaded binary operator should be implemented in terms of its corresponding compound assignment operator
CODSTA-CPP-92=All accessible entity names within a multiple inheritance hierarchy should be unique
CODSTA-CPP-93=Do not initialize objects with a non-trivial class type using C standard library functions
CODSTA-CPP-94=Do not compare objects of nonstandard-layout class type with C standard library functions
CODSTA-CPP-95=Do not modify the standard namespaces 'std' and 'posix'
CODSTA-CPP-96=Do not call a function with a mismatched language linkage
CODSTA-CPP-97=Never qualify a reference type with 'const' or 'volatile'
CODSTA-CPP-98=Copy operations must not mutate the source object
CODSTA-CPP-99=Use offsetof() on valid types and members
CODSTA-MC=Coding Conventions for Modern C
CODSTA-MC-01=The 'alignof' operator should not be used with an array type as its operand
CODSTA-MC-02=A declaration of an object should contain at most one explicit alignment specifier
CODSTA-MC-03=The zero-alignment specifier should not be used in an object declaration
CODSTA-MC-04=Explicit alignment specifiers in all declarations of an object with internal linkage shall be the same
CODSTA-MC-05=Every generic selection shall contain a default association
CODSTA-MC-06=The default association shall be placed first or last in the association list
CODSTA-MC-07=A generic selection shall indicate at least one non-default association
CODSTA-MC-08=A generic selection should only be expanded from a macro
CODSTA-MC-09=A generic association shall list an appropriate type
CODSTA-MC-10=A generic selection used in a macro definition should have a macro parameter in the controlling expression
CODSTA-MC-11=A generic selection should not depend on implicit pointer type conversion
CODSTA-MC-12=The controlling expression of a generic selection shall have an essential type that matches its standard type
CODSTA-MC-13=A generic selection that is not expanded from a macro shall not contain potential side effects in the controlling expression
CODSTA-MC-14=Enumerated types should not be mixed with integer types in generic selections
CODSTA-MC-15=A generic selection that is expanded from a macro shall evaluate its argument only once
CODSTA-MC-16=The '_Atomic' qualifier should not be used with the 'void' type
CODSTA-MC-17=Members of atomic objects of structure and union types should not be directly accessed
CODSTA-MC-18=A cast shall not remove any '_Atomic' qualification from the type of a pointer
CODSTA-MC-19=The value of an expression with atomic type should be independent from thread interleaving
CODSTA-MC-20=Only 'memory_order_seq_cst' should be used as an explicit memory order argument
CODSTA-MC-21=The second argument passed to the 'mtx_init()' function call should be either 'mtx_plain', 'mtx_timed', 'mtx_plain | mtx_recursive', or 'mtx_timed | mtx_recursive'
CODSTA-MC-22=Thread objects, thread synchronization objects, and thread-specific storage pointers shall only be accessed by the appropriate Standard Library functions
CODSTA-MCPP=Coding Conventions for Modern C++
CODSTA-MCPP-01=User-conversion cast operators should be made explicit
CODSTA-MCPP-02=Prefer alias declarations to typedefs
CODSTA-MCPP-03=Prefer Scoped Enums to Unscoped Enums
CODSTA-MCPP-04=Prefer 'nullptr' over 'NULL' or '0'(zero)
CODSTA-MCPP-05=Each overriding virtual function shall be declared with the override or final specifier
CODSTA-MCPP-06_a=Declare copy constructor and copy assignment operators with the 'delete' specifier to prevent copying of class
CODSTA-MCPP-06_b=Declare copy constructor and copy assignment operators with the 'delete' specifier instead of using a base class with private methods to prevent copying of class
CODSTA-MCPP-07=Prefer lambdas over std\:\:bind, std\:\:bind1st and std\:\:bind2nd
CODSTA-MCPP-07_b=The 'binder1st' and 'binder2nd' identifiers should not be used
CODSTA-MCPP-08_a=Prefer 'auto' to explicit type names in variable declarations
CODSTA-MCPP-08_b=Prefer 'auto' to explicit type names for function return types
CODSTA-MCPP-09=Declare functions 'noexcept' if they will not emit exceptions
CODSTA-MCPP-10_a=Prefer const iterators to iterators
CODSTA-MCPP-10_b=Prefer to use cbegin(), crbegin, cend(), crend() functions
CODSTA-MCPP-11_a_cpp11=Use constexpr to declare const variables whenever possible
CODSTA-MCPP-11_b_cpp11=Use constexpr to declare functions whenever possible
CODSTA-MCPP-13=Use std\:\:move() on rvalue references and std\:\:forward() on forwarding references
CODSTA-MCPP-13_b=The 'std\:\:forward' function shall be used to forward universal references
CODSTA-MCPP-14=Avoid Overloading on Forwarding References
CODSTA-MCPP-15_a=Avoid default capture modes
CODSTA-MCPP-15_b=Use the 'this' pointer explicitly in lambdas with a default by-reference capture
CODSTA-MCPP-16_a=Prefer smart pointer members over raw pointer members
CODSTA-MCPP-16_b=Prefer smart pointers over raw pointers for arrays or STL containers
CODSTA-MCPP-16_c=Prefer 'std\:\:make_shared' to the direct use of new
CODSTA-MCPP-16_d=Prefer to use std\:\:unique_ptr instead of std\:\:auto_ptr
CODSTA-MCPP-16_e='std\:\:make_unique' shall be used to construct objects owned by 'std\:\:unique_ptr'
CODSTA-MCPP-17=Never return lambdas that capture local objects by reference
CODSTA-MCPP-17_b=Never capture local objects from an outer lambda by reference
CODSTA-MCPP-17_c=The lambda that captures local objects by reference should not be assigned to the variable with a greater lifetime
CODSTA-MCPP-18_a=Avoid unnecessary default capture modes in lambda expressions
CODSTA-MCPP-18_b=Avoid unnecessary lambda captures
CODSTA-MCPP-19=Declare assignment operators with the ref-qualifier &
CODSTA-MCPP-20=Prefer smart pointers over raw local pointers
CODSTA-MCPP-21=Do not call lock() directly on a mutex
CODSTA-MCPP-22=Use explicit ref-qualifiers on auto declarations in range-based 'for' loops
CODSTA-MCPP-23=If a public destructor of a class is non-virtual, then the class should be declared final
CODSTA-MCPP-24=Only one of virtual, override or final should be specified in a member function declaration
CODSTA-MCPP-25=Digit sequences separators ' shall only be used consistently
CODSTA-MCPP-26=A pointer to member virtual function shall only be tested for equality with null-pointer-constant
CODSTA-MCPP-27=All std\:\:hash specializations for user-defined types shall have a noexcept function call operator
CODSTA-MCPP-28=A lambda shall not be an operand to typeid
CODSTA-MCPP-29=Use smart pointers when passing a pointer to an object in a thread
CODSTA-MCPP-30=Consider using 'std\:\:unique_ptr' instead of 'std\:\:shared_ptr' for local objects
CODSTA-MCPP-31=Define both sized and unsized versions of operator delete
CODSTA-MCPP-32=Static and thread-local objects shall be constant-initialized
CODSTA-MCPP-33=User defined literals operators shall only perform conversion of passed parameters
CODSTA-MCPP-34=A smart pointer shall only be used as a parameter type if it expresses lifetime semantics
CODSTA-MCPP-35=A parameter should only be declared as a non-const lvalue reference to 'std\:\:shared_ptr' or 'std\:\:unique_ptr' if the function replaces the managed object
CODSTA-MCPP-36=Do not declare the type of a parameter as an rvalue reference to 'std\:\:shared_ptr' or 'std\:\:unique_ptr'
CODSTA-MCPP-37=Derived classes that do not need further explicit initialization and require all the constructors from the base class shall use inheriting constructors
CODSTA-MCPP-38=Braced-initialization {}, without equals sign, shall be used for variable initialization
CODSTA-MCPP-39=A variable of type auto shall not be initialized using '{}' or '\={}' braced-initialization
CODSTA-MCPP-40=Do not overuse 'auto' specifier
CODSTA-MCPP-41=The 'random_shuffle' identifier should not be used
CODSTA-MCPP-42=Do not use the increment operator (++) on an operand of type 'bool'
CODSTA-MCPP-43=The 'set_unexpected' identifier should not be used
CODSTA-MCPP-44=Lambda expressions should not be defined inside another lambda expression
CODSTA-MCPP-45=Return type of a non-void return type lambda expression should be explicitly specified
CODSTA-MCPP-46=Include a parameter list in every lambda expression
CODSTA-MCPP-47=Avoid overloading constructors with std\:\:initializer_list
CODSTA-MCPP-48=Multiple output values from a function should be returned as a struct or tuple
CODSTA-MCPP-49=User-defined copy and move assignment operators should use user-defined no-throw swap function
CODSTA-MCPP-50=A for-loop that loops through all elements of the container and does not use its loop-counter shall not be used
CODSTA-MCPP-51=Use const container calls when the result is immediately converted to a const iterator
CODSTA-MCPP-52=Do not introduce virtual functions in a final class
CODSTA-MCPP-53=Do not use std\:\:move on objects declared with the const or const & type
CODSTA-MCPP-54=Do not create an rvalue reference of std\:\:array
CODSTA-MCPP-55=Use std\:\:call_once rather than the Double-Checked Locking pattern
CODSTA-MCPP-56=If a class declares a copy or move operation, or a destructor, either via '\=default', '\=delete', or via a user-provided declaration, then all others of these five special member functions shall be declared as well
COMMENT=Comments
COMMENT-01=Prefer C++ style comment
COMMENT-02=Provide copyright information
COMMENT-03=Every source file will be documented with an introductory comment that provides information on the file
COMMENT-04=Document functions in comments that precede function definitions
COMMENT-04_b=Document functions in comments that precede function declarations
COMMENT-05=Each variable declaration should be commented
COMMENT-06=Each typedef should be commented
COMMENT-07=Each enumeration value should be commented
COMMENT-08=Each structure member variable should be commented
COMMENT-09=All usage of assembler shall be documented
COMMENT-10=Use of floating-point arithmetic shall be documented
COMMENT-11=The character sequence // shall not be used within a C-style comment
COMMENT-12=The character sequence /* shall not be used within a C++-style comment
COMMENT-13=Line-splicing shall not be used in // comments
COMMENT-14=All declarations of types, data members, and functions should be preceded by a comment annotated with the '@brief' tag
COMMENT-14_b=Function parameters and return type should be documented in a comment that precedes the function declaration
CWE=Common Weakness Enumeration
CWE-119=CWE-119 Improper Restriction of Operations within the Bounds of a Memory Buffer
CWE-119-j=Suspicious use of 'strcpy' without checking size of source buffer
CWE-190=CWE-190 Integer Overflow or Wraparound
CWE-190-b=Avoid possible integer overflow in expressions in which the result is cast to a wider integer type
CWE-190-c=Avoid possible integer overflow in expressions in which the result is assigned to a variable of a wider integer type
CWE-190-d=Avoid possible integer overflow in expressions in which the result is compared to an expression of a wider integer type
CWE-190-e=Integer overflow or underflow in constant expression in '+', '-', '*' operator
CWE-190-f=Integer overflow or underflow in constant expression in '<<' operator
CWE-190-g=Evaluation of constant unsigned integer expressions should not lead to wrap-around
CWE-20=CWE-20 Improper Input Validation
CWE-20-j=Untrusted data is used as a loop boundary
CWE-200=CWE-200 Information Exposure
CWE-200-a=Do not print potentially sensitive information, resulting from an application error into exception messages
CWE-269=CWE-269 Improper Privilege Management
CWE-269-a=Observe correct revocation order while relinquishing privileges
CWE-269-b=Ensure that privilege relinquishment is successful
CWE-287=CWE-287 Improper Authentication
CWE-287-a=Do not use weak encryption functions
CWE-326=CWE-326 Inadequate Encryption Strength
CWE-326-a=Do not use weak encryption functions
CWE-362=CWE-362 Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')
CWE-362-a=Usage of functions prone to race is not allowed
CWE-416=CWE-416 Use After Free
CWE-416-c=Freed memory shouldn't be accessed under any circumstances
CWE-426=CWE-426 Untrusted Search Path
CWE-426-a=Use care to ensure that LoadLibrary() will load the correct library
CWE-427=CWE-427\: Uncontrolled Search Path Element
CWE-427-a=Use care to ensure that LoadLibrary() will load the correct library
CWE-617=CWE-617 Reachable Assertion
CWE-617-a=Do not use assertions
CWE-704=CWE-704 Incorrect Type Conversion or Cast
CWE-704-a=Conversions shall not be performed between a pointer to a function and any other type than pointer to function
CWE-704-b=Conversions shall not be performed between non compatible pointer to a function types
CWE-704-c=Conversions shall not be performed between a pointer to an incomplete type and any other type
CWE-704-d=A cast shall not be performed between a pointer to object type and a pointer to a different object type
CWE-704-e=A conversion should not be performed between a pointer to object type and an integer type other than 'uintptr_t' or 'intptr_t'
CWE-704-f=A conversion should not be performed from pointer to void into pointer to object
CWE-704-g=A cast shall not be performed between pointer to void and an arithmetic type
CWE-704-h=An implicit conversion shall not be performed between pointer to void and an arithmetic type
CWE-704-i=A cast shall not be performed between pointer to object and a non-integer arithmetic type
CWE-704-j=Implicit conversions from wider to narrower integral type which may result in a loss of information shall not be used
CWE-704-k=Implicit conversions from integral to floating type which may result in a loss of information shall not be used
CWE-704-l=Implicit conversions from integral constant to floating type which may result in a loss of information shall not be used
CWE-732=CWE-732 Incorrect Permission Assignment for Critical Resource
CWE-732-a=Call 'umask' before calling 'mkstemp'
CWE-732-b=Specify the access permission bits if a file is created using the 'open' or 'openat' system call
CWE-772=CWE-772 Missing Release of Resource after Effective Lifetime
CWE-772-b=Define a virtual destructor in classes used as base classes which have virtual functions
CWE-798=CWE-798 Use of Hard-coded Credentials
CWE-798-a=Do not hard code string literals
CWE-835=CWE-835 Loop with Unreachable Exit Condition ('Infinite Loop')
CWE-835-a=Avoid infinite loops
CWE-843=CWE-843\: Access of Resource Using Incompatible Type ('Type Confusion')
CWE-843-a=A cast should not be performed between a pointer to object type and a different pointer to object type
CWE-863=CWE-863 Incorrect Authorization
CWE-863-a=Do not use 'cuserid' function
EXCEPT=Exceptions
EXCEPT-01=Never allow an exception to be thrown from a destructor, deallocation, and swap
EXCEPT-02=Throw by value, catch by reference
EXCEPT-03=Do not throw from within destructor
EXCEPT-04=All exceptions should be rethrown or logged with standard logger
EXCEPT-05=C++ exceptions shall not be used (i.e. throw, catch and try shall not be used.)
EXCEPT-06=There should be at least one exception handler to catch all otherwise unhandled exceptions
EXCEPT-07=An empty throw (throw;) shall only be used in the compound-statement of a catch handler
EXCEPT-08=Exceptions shall be raised only after start-up and before termination of the program
EXCEPT-09=An exception object should not have pointer type
EXCEPT-10=Control shall not be transferred into a try or catch block using a goto or a switch statement
EXCEPT-11=The assignment-expression of a throw statement shall not itself cause an exception to be thrown
EXCEPT-12=NULL shall not be thrown explicitly
EXCEPT-13=Each exception explicitly thrown in the code shall have a handler of a compatible type in all call paths that could lead to that point
EXCEPT-14=Where a function's declaration includes an exception-specification, the function shall only be capable of throwing exceptions of the indicated type(s)
EXCEPT-15=A class type exception shall always be caught by reference
EXCEPT-16=Handlers of a function-try-block implementation of a class constructor or destructor shall not reference nonstatic members from this class or its bases
EXCEPT-17=Where multiple handlers are provided in a single try-catch statement or function-try-block for a derived class and some or all of its bases, the handlers shall be ordered most-derived to base class
EXCEPT-18=Function called in global or namespace scope shall not throw unhandled exceptions
EXCEPT-19=Exception objects must be nothrow copy constructible
EXCEPT-20=An explicitly declared copy constructor for a class that inherits from 'std\:\:exception' should have a non-throwing exception specification
EXCEPT-21=All user-provided move constructors and move assignment operators shall not exit with an exception
EXCEPT-22=Checked exceptions that could be thrown from a function shall be specified in the comment directly before the function declaration
EXCEPT-23=Do not use throw exception specifications
EXCEPT-24=Where multiple handlers are provided in a single 'try-catch' statement or 'function-try-block', any ellipsis (catch-all) handler shall occur last
EXCEPT-25=Do not leave 'catch' blocks empty
EXCEPT-26=Avoid using catch-all exception handlers
FORMAT=Formatting
FORMAT-01=Tabs that do not use ASCII spaces shall not be used
FORMAT-02=Place an opening brace '{' on its own line
FORMAT-03=Place a closing brace '}' on its own line
FORMAT-04=Physical lines should be less than eighty characters
FORMAT-05=The length of a macro should not exceed 10 lines
FORMAT-06=Only one statement shall be allowed per line
FORMAT-07=There shall be a single ASCII space character preceding assignment operators
FORMAT-08=There shall be a single ASCII space character following assignment operators
FORMAT-09=There shall be a single ASCII space character preceding bitwise operators
FORMAT-10=There shall be a single ASCII space character following bitwise operators
FORMAT-11=There shall be a single ASCII space character preceding and following bitwise operator '&'
FORMAT-12=There shall be a single ASCII space character between a conditional statement keyword and its opening parenthesis
FORMAT-13=There shall be a maximum of 1 ASCII space character following the opening parenthesis in conditional statements
FORMAT-14=There shall be a single ASCII space character preceding ternary conditional operator
FORMAT-15=There shall be a single ASCII space character following ternary conditional operator
FORMAT-16=There shall be a single ASCII space character preceding and following relational and equality operators
FORMAT-17=There shall be no white space following '.' or '->' operator
FORMAT-18=There shall be no white space preceding '.' or '->' operator
FORMAT-19=There shall be a single ASCII space character following all commas
FORMAT-20=There shall be a single ASCII space character following all semicolons
FORMAT-21=There should be no space between a unary operator "\!" or "~" and its operand
FORMAT-22=There should be no space between a increment/decrement operator (++/--) and its operand
FORMAT-23=There shall be no white spaces between the 'return' statement or the 'sizeof' operator and the following opening parenthesis
FORMAT-24=There shall be no spaces after the opening '(' and before closing ')' parenthesis that enclose the operand of the 'return' statement or the 'sizeof' operator
FORMAT-25=The operand of the 'sizeof' operator should be enclosed in parentheses
FORMAT-25_b=Parenthesis shall be used with the "return" statement
FORMAT-26=There shall be a single ASCII space character preceding and following logical operators
FORMAT-27=Line should be indented by a multiple of four spaces
FORMAT-28=In a function definition, the return type of the function should be written on a separate line directly above the function name
FORMAT-29=Multiple variable declarations shall not be allowed on the same line
FORMAT-30=Place left parenthesis directly after function name
FORMAT-31=Separate logical tests in conditional expressions
FORMAT-32=The dereference operator '*' and the address-of operator '&' should be directly connected with the type
FORMAT-33=Each variable should be declared in a separate declaration statement
FORMAT-34=Braces "{}" which enclose a block should be placed in the same column
FORMAT-35=When declaring functions, the leading parenthesis and the first argument are to be written on the same line as the function name
FORMAT-36=Sibling statement lines should be indented to the same level
FORMAT-37=First line in control statement body should be indented more than control statement keyword
FORMAT-38=When declaring functions with more than 2 parameters, the leading parenthesis and the first argument are to be written on the same line as the function name, each additional argument will be written on a separate line
FORMAT-39=Sort \#include directives in alphabetical order
FORMAT-40=White spaces after the opening square bracket '[' and before its closing square bracket ']' shall be used in consistent way
FORMAT-41=There shall be no space between '[' opening square bracket and preceding token
FORMAT-42=Braces ("{}") which enclose a block will have nothing else on the line except comments
FORMAT-43=Braces ("{}") which enclose a block will be placed in the same column
FORMAT-44=Braces ("{}") which enclose a block will not have an empty line after "{" nor before "}"
FORMAT-45=There should be no space between a unary operator "&", "*", "+", "-" and its operand
FORMAT-46=There should be no space between an increment/decrement operator (++/--) and its operand in macro definition
FORMAT-47_a=Place CV-qualifiers on the right hand side of the type they apply to
FORMAT-47_b=CV-qualifiers shall be placed on the right hand side of the type that is a typedef or a using name
FORMAT-48=Parameter names in function declarations should not be enclosed in parentheses
FORMAT-49=Local variable names in variable declarations should not be enclosed in parentheses
HICPP=High Integrity C++
HICPP-10_1_1=HIC++ 10.1.1 Ensure that access to base class subobjects does not require explicit disambiguation
HICPP-10_1_1-a=For multiple inheritance use virtual common base class
HICPP-10_2_1=HIC++ 10.2.1 Use the override special identifier when overriding a virtual function
HICPP-10_2_1-a=Each overriding virtual function shall be declared with the override or final specifier
HICPP-10_3_1=HIC++ 10.3.1 Ensure that a derived class has at most one base class which is not an interface class
HICPP-10_3_1-a=Ensure that a derived class has at most one base class which is not an interface class
HICPP-11_1_1=HIC++ 11.1.1 Declare all data members private
HICPP-11_1_1-a=Avoid "public" data members
HICPP-11_1_1-b=Avoid 'protected' data members
HICPP-11_2_1=HIC++ 11.2.1 Do not use friend declarations
HICPP-11_2_1-a=Avoid using the friend mechanism
HICPP-12_1_1=HIC++ 12.1.1 Do not declare implicit user defined conversions
HICPP-12_1_1-a=Constructors allowing for conversion should be made explicit
HICPP-12_1_1-b=User-conversion cast operators should be made explicit
HICPP-12_2_1=HIC++ 12.2.1 Declare virtual, private or protected the destructor of a type used as a base class
HICPP-12_2_1-a=Make destructors virtual in base classes
HICPP-12_3_1=HIC++ 12.3.1 Correctly declare overloads for operator new and delete
HICPP-12_3_1-a=Write operator delete if you write operator new
HICPP-12_3_1-b=Write operator delete[] if you write operator new[]
HICPP-12_4_2=HIC++ 12.4.2 Ensure that a constructor initializes explicitly all base classes and non-static data members
HICPP-12_4_2-a=All member variables should be initialized in constructor
HICPP-12_4_3=HIC++ 12.4.3 Do not specify both an NSDMI and a member initializer in a constructor for the same non static member
HICPP-12_4_3-a=Do not specify both an NSDMI and a member initializer in a constructor for the same non-static member
HICPP-12_4_4=HIC++ 12.4.4 Write members in an initialization list in the order in which they are declared
HICPP-12_4_4-a=List members in an initialization list in the order in which they are declared
HICPP-12_4_5=HIC++ 12.4.5 Use delegating constructors to reduce code duplication
HICPP-12_4_5-a=Use delegating constructors to reduce code duplication
HICPP-12_5_1=HIC++ 12.5.1 Define explicitly \=default or \=delete implicit special member functions of concrete classes
HICPP-12_5_1-a=Explicitly define \=default or \=delete special member functions of concrete classes implicitly provided by the compiler
HICPP-12_5_2=HIC++ 12.5.2 Define special members \=default if the behavior is equivalent
HICPP-12_5_2-a=Define special members as \=default when the behavior is equivalent to the compiler's behavior
HICPP-12_5_3=HIC++ 12.5.3 Ensure that a user defined move/copy constructor only moves/copies base and member objects
HICPP-12_5_3-a=A copy constructor shall only initialize its base classes and the non-static members of the class of which it is a member
HICPP-12_5_4=HIC++ 12.5.4 Declare noexcept the move constructor and move assignment operator
HICPP-12_5_4-a=All user-provided move constructors and move assignment operators shall not exit with an exception
HICPP-12_5_6=HIC++ 12.5.6 Use an atomic, non-throwing swap operation to implement the copy and move assignment operators
HICPP-12_5_6-a=User-defined copy and move assignment operators should use user-defined no-throw swap function
HICPP-12_5_7=HIC++ 12.5.7 Declare assignment operators with the ref-qualifier &
HICPP-12_5_7-a=Declare assignment operators with the ref-qualifier &
HICPP-12_5_8=HIC++ 12.5.8 Make the copy assignment operator of an abstract class protected or define it \=delete
HICPP-12_5_8-a=The copy assignment operator shall be declared protected or private in an abstract class
HICPP-13_1_1=HIC++ 13.1.1 Ensure that all overloads of a function are visible from where it is called
HICPP-13_1_1-a=Member functions declared in derived class should not hide functions declared in base classes
HICPP-13_1_2=HIC++ 13.1.2 If a member of a set of callable functions includes a universal reference parameter, ensure that one appears in the same position for all other members
HICPP-13_1_2-a=Avoid Overloading on Forwarding References
HICPP-13_2_1=HIC++ 13.2.1 Do not overload operators with special semantics
HICPP-13_2_1-a=Avoid overloading logical operators AND, OR (&&, ||)
HICPP-13_2_1-b=Avoid overloading comma operator ","
HICPP-13_2_2=HIC++ 13.2.2 Ensure that the return type of an overloaded binary operator matches the built-in counterparts
HICPP-13_2_2-a=A relational operator shall return a boolean value
HICPP-13_2_2-b=A binary arithmetic operator and a bitwise operator shall return a 'prvalue'
HICPP-13_2_3=HIC++ 13.2.3 Declare binary arithmetic and bitwise operators as non-members
HICPP-13_2_3-a=Declare binary arithmetic and bitwise operators as non-members
HICPP-13_2_4=HIC++ 13.2.4 When overloading the subscript operator (operator[]) implement both const and non-const versions
HICPP-13_2_4-a=When overloading the subscript operator (operator[]), implement both const and non-const versions
HICPP-13_2_5=HIC++ 13.2.5 Implement a minimal set of operators and use them to implement all other related operators
HICPP-13_2_5-a=The overloaded binary operator should be implemented in terms of its corresponding compound assignment operator
HICPP-14_1_1=HIC++ 14.1.1 Use variadic templates rather than an ellipsis
HICPP-14_1_1-a=Do not use functions with variable numbers of arguments
HICPP-14_2_1=HIC++ 14.2.1 Declare template specializations in the same file as the primary template they specialize.
HICPP-14_2_1-a=All partial and explicit specializations for a template shall be declared in the same file as the declaration of their primary template
HICPP-14_2_2=HIC++ 14.2.2 Do not explicitly specialize a function template that is overloaded with other templates
HICPP-14_2_2-a=Overloaded function templates shall not be explicitly specialized
HICPP-14_2_3=HIC++ 14.2.3 Declare extern an explicitly instantiated template
HICPP-14_2_3-a=Declare 'extern' an explicitly instantiated template
HICPP-15_1_1=HIC++ 15.1.1 Only use instances of std\:\:exception for exceptions
HICPP-15_1_1-a=Only use instances of std\:\:exception for exceptions
HICPP-15_2_1=HIC++ 15.2.1 Do not throw an exception from a destructor
HICPP-15_2_1-a=Do not throw from within destructor
HICPP-15_3_1=HIC++ 15.3.1 Do not access non-static members from a catch handler of constructor/destructor function try block
HICPP-15_3_1-a=Handlers of a function-try-block implementation of a class constructor or destructor shall not reference nonstatic members from this class or its bases
HICPP-15_3_2=HIC++ 15.3.2 Ensure that a program does not result in a call to std\:\:terminate
HICPP-15_3_2-b=There should be at least one exception handler to catch all otherwise unhandled exceptions
HICPP-16_1_1=HIC++ 16.1.1 Use the preprocessor only for implementing include guards, and including header files with include guards
HICPP-16_1_1-a=Avoid using macro definitions
HICPP-16_1_1-b=The \#ifndef pre-processor directive will only be used to prevent multiple inclusions of the same header file
HICPP-16_1_1-c=The \#ifdef, \#else, \#elif preprocessor directives should not be used
HICPP-16_1_1-d=Use multiple include guards
HICPP-16_1_1-e=The \#endif pre-processor directives will only be used to prevent multiple inclusions of the same header file
HICPP-16_1_1-f=The \#if pre-processor directive will only be used to prevent multiple inclusions of the same header file
HICPP-16_1_1-g=\#error directive shall not be used
HICPP-16_1_1-h=The \#pragma directive shall not be used
HICPP-16_1_1-i=\#undef shall not be used
HICPP-16_1_2=HIC++ 16.1.2 Do not include a path specifier in filenames supplied in \#include directives
HICPP-16_1_2-a=Do not allow absolute or relative path names in \#include statements
HICPP-16_1_2-b=The \\ character should not occur in a header file name
HICPP-16_1_3=HIC++ 16.1.3 Match the filename in a \#include directive to the one on the filesystem
HICPP-16_1_3-a=Match the filename in a \#include directive to the one on the filesystem
HICPP-16_1_4=HIC++ 16.1.4 Use <> brackets for system and standard library headers. Use quotes for all other headers
HICPP-16_1_4-a=Use <> brackets for system and standard library headers. Use quotes for all other headers
HICPP-17_1_1=HIC++ 17.1.1 Do not use std\:\:vector<bool>
HICPP-17_1_1-a=Avoid using vector<bool>
HICPP-17_2_1=HIC++ 17.2.1 Wrap use of the C Standard Library
HICPP-17_2_1-a=Wrap use of the C Standard Library
HICPP-17_2_1-b=The error indicator 'errno' shall not be used
HICPP-17_3_1=HIC++ 17.3.1 Do not use std\:\:move on objects declared with const or const & type
HICPP-17_3_1-a=Do not use std\:\:move on objects declared with the const or const & type
HICPP-17_3_2=HIC++ 17.3.2 Use std\:\:forward to forward universal references
HICPP-17_3_2-a=The 'std\:\:forward' function shall be used to forward universal references
HICPP-17_3_4=HIC++ 17.3.4 Do not create smart pointers of array type
HICPP-17_3_4-a=Do not create smart pointers of array type
HICPP-17_3_5=HIC++ 17.3.5 Do not create an rvalue reference of std\:\:array
HICPP-17_3_5-a=Do not create an rvalue reference of std\:\:array
HICPP-17_4_1=HIC++ 17.4.1 Use const container calls when result is immediately converted to a const iterator
HICPP-17_4_1-a=Use const container calls when the result is immediately converted to a const iterator
HICPP-17_4_2=HIC++ 17.4.2 Use API calls that construct objects in place
HICPP-17_4_2-a=Prefer 'std\:\:make_shared' to the direct use of new
HICPP-17_5_1=HIC++ 17.5.1 Do not ignore the result of std\:\:remove, std\:\:remove if or std\:\:unique
HICPP-17_5_1-a=Follow remove-like algorithms by erase to remove elements from a container
HICPP-18_1_1=HIC++ 18.1.1 Do not use platform specific multi-threading facilities
HICPP-18_1_1-a=Do not use platform-specific multi-threading facilities
HICPP-18_2_1=HIC++ 18.2.1 Use high integrity\:\:thread in place of std\:\:thread
HICPP-18_2_1-a=Use high_integrity\:\:thread in place of std\:\:thread
HICPP-18_2_3=HIC++ 18.2.3 Do not share volatile data between threads
HICPP-18_2_3-a=Do not share volatile data between threads
HICPP-18_2_4=HIC++ 18.2.4 Use std\:\:call_once rather than the Double-Checked Locking pattern
HICPP-18_2_4-a=Use std\:\:call_once rather than the Double-Checked Locking pattern
HICPP-18_3_3=HIC++ 18.3.3 Do not use std\:\:recursive mutex
HICPP-18_3_3-a=Do not use std\:\:recursive_mutex
HICPP-18_3_4=HIC++ 18.3.4 Only use std\:\:unique lock when std\:\:lock guard cannot be used
HICPP-18_3_4-a=Only use std\:\:unique lock when std\:\:lock guard cannot be used
HICPP-18_3_5=HIC++ 18.3.5 Do not access the members of std\:\:mutex directly
HICPP-18_3_5-a=Do not access the members of std\:\:mutex directly
HICPP-18_3_6=HIC++ 18.3.6 Do not use relaxed atomics
HICPP-18_3_6-a=Do not use relaxed atomics
HICPP-18_4_1=HIC++ 18.4.1 Do not use std\:\:condition variable any on a std\:\:mutex
HICPP-18_4_1-a=Do not use std\:\:condition_variable_any on a std\:\:mutex
HICPP-1_2_1=HIC++ 1.2.1 Ensure that all statements are reachable
HICPP-1_2_1-a=There shall be no unreachable code in "else" block
HICPP-1_2_1-b=There shall be no unreachable code after 'return', 'break', 'continue', and 'goto' statements
HICPP-1_2_1-c=There shall be no unreachable code in "if/else/while/for" block
HICPP-1_2_1-d=There shall be no unreachable code in switch statement
HICPP-1_2_1-e=There shall be no unreachable code in 'for' loop
HICPP-1_2_1-f=There shall be no unreachable code after 'if' or 'switch' statement
HICPP-1_2_1-g=There shall be no unreachable code after "if" or "switch" statement inside while/for/do...while loop
HICPP-1_2_2=HIC++ 1.2.2 Ensure that no expression or sub-expression is redundant
HICPP-1_2_2-a=All non-null statements shall either have at least one side-effect however executed or cause control flow to change
HICPP-1_3_1=HIC++ 1.3.1 Do not use the increment operator (++) on a variable of type bool
HICPP-1_3_1-a=Do not use the increment operator (++) on an operand of type 'bool'
HICPP-1_3_2=HIC++ 1.3.2 Do not use the register keyword
HICPP-1_3_2-a=The 'register' storage class specifier shall not be used
HICPP-1_3_3=HIC++ 1.3.3 Do not use the C Standard Library .h headers
HICPP-1_3_3-a=The C library shall not be used
HICPP-1_3_4=HIC++ 1.3.4 Do not use deprecated STL library features
HICPP-1_3_4-a=Do not use deprecated STL library features
HICPP-1_3_5=HIC++ 1.3.5 Do not use throw exception specifications
HICPP-1_3_5-a=Do not use throw exception specifications
HICPP-2_1_1=HIC++ 2.1.1 Do not use tab characters in source files
HICPP-2_1_1-a=Tabs that do not use ASCII spaces shall not be used
HICPP-2_2_1=HIC++ 2.2.1 Do not use digraphs or trigraphs
HICPP-2_2_1-a=Do not use the following digraphs\: <%, %>, <\:, \:>, %\:, %\:%\:
HICPP-2_2_1-b=Trigraphs shall not be used
HICPP-2_3_1=HIC++ 2.3.1 Do not use the C comment delimiters /* ... */
HICPP-2_3_1-a=Prefer C++ style comment
HICPP-2_3_2=HIC++ 2.3.2 Do not comment out code
HICPP-2_3_2-a=Do not use comments to remove sections of code
HICPP-2_4_1=HIC++ 2.4.1 Ensure that each identifier is distinct from any other visible identifier
HICPP-2_4_1-a=Different identifiers shall be typographically unambiguous
HICPP-2_5_1=HIC++ 2.5.1 Do not concatenate strings with different encoding prefixes
HICPP-2_5_1-a=String literals with different encoding prefixes shall not be concatenated
HICPP-2_5_2=HIC++ 2.5.2 Do not use octal constants (other than zero)
HICPP-2_5_2-a=Octal constants (other than zero) shall not be used
HICPP-2_5_3=HIC++ 2.5.3 Use nullptr for the null pointer constant
HICPP-2_5_3-a=Prefer 'nullptr' over 'NULL' or '0'(zero)
HICPP-3_1_1=HIC++ 3.1.1 Do not hide declarations
HICPP-3_1_1-a=Identifier declared in a local or function prototype scope shall not hide an identifier declared in a global or namespace scope
HICPP-3_1_1-b=Identifiers declared in an inner local scope should not hide identifiers declared in an outer local scope
HICPP-3_1_1-c=Identifiers declared in a local scope should not hide identifiers declared in a class scope
HICPP-3_1_1-d=Identifiers declared in a class scope should not hide identifiers declared in a global or namespace scope
HICPP-3_1_1-e=Identifiers declared in an inner class scope should not hide identifiers declared in outer class scope
HICPP-3_2_1=HIC++ 3.2.1 Do not declare functions at block scope
HICPP-3_2_1-a=Always declare functions at file scope
HICPP-3_3_1=HIC++ 3.3.1 Do not use variables with static storage duration
HICPP-3_3_1-a=Do not use variables with static storage duration
HICPP-3_4_1=HIC++ 3.4.1 Do not return a reference or a pointer to an automatic variable defined within the function
HICPP-3_4_1-a=The address of an object with automatic storage shall not be returned from a function
HICPP-3_4_2=HIC++ 3.4.2 Do not assign the address of a variable to a pointer with a greater lifetime
HICPP-3_4_2-a=The address of an object with automatic storage shall not be assigned to another object that may persist after the first object has ceased to exist
HICPP-3_4_3=HIC++ 3.4.3 Use RAII for resources
HICPP-3_4_3-a=Prefer smart pointers over raw local pointers
HICPP-3_4_3-b=Do not call lock() directly on a mutex
HICPP-3_4_3-c=Use RAII to prevent resource leaks
HICPP-3_5_1=HIC++ 3.5.1 Do not make any assumptions about the internal representation of a value or object
HICPP-3_5_1-a=Unions shall not be used
HICPP-3_5_1-b=typedefs should be used in place of the basic types
HICPP-4_1_1=HIC++ 4.1.1 Ensure that a function argument does not undergo an array-to-pointer conversion
HICPP-4_1_1-a=An identifier with array type passed as a function argument shall not decay to a pointer
HICPP-4_1_1-b=Do not pass an expression with array type to a function with a pointer or array type parameter
HICPP-4_2_1=HIC++ 4.2.1 Ensure that the U suffix is applied to a literal used in a context requiring an unsigned integral expression
HICPP-4_2_1-a=Apply the U suffix to literals used in a context that requires an unsigned integral expression
HICPP-4_2_2=HIC++ 4.2.2 Ensure that data loss does not demonstrably occur in an integral expression
HICPP-4_2_2-a=The right-hand operand of a shift operator shall lie between zero and one less than the width in bits of the underlying type of the left-hand operand
HICPP-4_2_2-b=Avoid explicit type conversions (casts)
HICPP-4_2_2-c=Integer overflow or underflow in constant expression in '+', '-', '*' operator
HICPP-4_2_2-d=Integer overflow or underflow in constant expression in '<<' operator
HICPP-4_3_1=HIC++ 4.3.1 Do not convert an expression of wider floating point type to a narrower floating point type
HICPP-4_3_1-a=Avoid implicit conversions from wider to narrower floating type
HICPP-4_3_1-b=Avoid implicit conversions of floating point numbers from wider to narrower floating type
HICPP-4_4_1=HIC++ 4.4.1 Do not convert floating values to integral types except through use of standard library functions
HICPP-4_4_1-a=Avoid implicit conversions from floating to integral type
HICPP-5_1_1=HIC++ 5.1.1 Use symbolic names instead of literal values in code
HICPP-5_1_1-a=Avoid magic numbers
HICPP-5_1_2=HIC++ 5.1.2 Do not rely on the sequence of evaluation within an expression
HICPP-5_1_2-a=The value of an expression shall be the same under any order of evaluation that the standard permits
HICPP-5_1_2-b=Don't write code that depends on the order of evaluation of function arguments
HICPP-5_1_2-c=Don't write code that depends on the order of evaluation of function designator and function arguments
HICPP-5_1_2-d=Don't write code that depends on the order of evaluation of expression that involves a function call
HICPP-5_1_2-e=Between sequence points an object shall have its stored value modified at most once by the evaluation of an expression
HICPP-5_1_2-f=Do not use more than one volatile between two adjacent sequence points
HICPP-5_1_2-g=Don't write code that depends on the order of evaluation of function calls
HICPP-5_1_2-h=The increment (++) and decrement (--) operators should not be mixed with other operators in an expression
HICPP-5_1_2-i=The comma operator shall not be used
HICPP-5_1_2-j=The result of a built-in assignment operator should not be used
HICPP-5_1_3=HIC++ 5.1.3 Use parentheses in expressions to specify the intent of the expression
HICPP-5_1_3-a=Use parentheses unless all operators in the expression are the same
HICPP-5_1_3-b=The operands of a logical && or || shall be primary-expressions
HICPP-5_1_4=HIC++ 5.1.4 Do not capture variables implicitly in a lambda
HICPP-5_1_4-a=Do not capture variables implicitly in a lambda
HICPP-5_1_5=HIC++ 5.1.5 Include a (possibly empty) parameter list in every lambda expression
HICPP-5_1_5-a=Include a parameter list in every lambda expression
HICPP-5_1_6=HIC++ 5.1.6 Do not code side effects into the right-hand operands of\: &&, ||, sizeof, typeid or a function passed to condition variable\:\:wait
HICPP-5_1_6-a=The operand of the sizeof operator shall not contain any expression which has side effects
HICPP-5_1_6-b=Object designated by a volatile lvalue should not be accessed in the operand of the sizeof operator
HICPP-5_1_6-c=The function call that causes the side effect shall not be the operand of the sizeof operator
HICPP-5_1_6-d=The right-hand operand of a logical && or || operator shall not contain side effects
HICPP-5_1_6-e=The operand of the 'typeid' operator shall not contain any expression that has side effects
HICPP-5_1_6-f=The operand of the 'typeid' operator shall not contain a function call that causes side effects
HICPP-5_2_2=HIC++ 5.2.2 Ensure that functions do not call themselves, either directly or indirectly
HICPP-5_2_2-a=Functions shall not call themselves, either directly or indirectly
HICPP-5_3_1=HIC++ 5.3.1 Do not apply unary minus to operands of unsigned type
HICPP-5_3_1-a=The unary minus operator shall not be applied to an expression whose underlying type is unsigned
HICPP-5_3_2=HIC++ 5.3.2 Allocate memory using new and release it using delete
HICPP-5_3_2-a=Do not use calloc, malloc, realloc and free functions
HICPP-5_3_3=HIC++ 5.3.3 Ensure that the form of delete matches the form of new used to allocate the memory
HICPP-5_3_3-a=Never provide brackets ([]) for delete when deallocating non-arrays
HICPP-5_3_3-b=Always provide empty brackets ([]) for delete when deallocating arrays
HICPP-5_4_1=HIC++ 5.4.1 Only use casting forms\: static cast (excl. void*), dynamic cast or explicit constructor call
HICPP-5_4_1-a=C-style casts should not be used
HICPP-5_4_1-b=Avoid using reinterpret_cast
HICPP-5_4_1-c=A cast shall not remove any 'const' or 'volatile' qualification from the type of a pointer or reference
HICPP-5_4_2=HIC++ 5.4.2 Do not cast an expression to an enumeration type
HICPP-5_4_2-a=Do not cast an expression to an enumeration type
HICPP-5_4_3=HIC++ 5.4.3 Do not convert from a base class to a derived class
HICPP-5_4_3-a=Down casting (casting from base to derived class) shall not be allowed
HICPP-5_6_1=HIC++ 5.6.1 Do not use bitwise operators with signed operands
HICPP-5_6_1-a=Bitwise operators shall only be applied to operands of unsigned underlying type
HICPP-5_7_1=HIC++ 5.7.1 Do not write code that expects floating point calculations to yield exact results
HICPP-5_7_1-a=Floating-point expressions shall not be tested for equality or inequality
HICPP-5_7_2=HIC++ 5.7.2 Ensure that a pointer to member that is a virtual function is only compared (\=\=) with nullptr
HICPP-5_7_2-a=A pointer to member virtual function shall only be tested for equality with null-pointer-constant
HICPP-5_8_1=HIC++ 5.8.1 Do not use the conditional operator (?\:) as a sub-expression
HICPP-5_8_1-a=The conditional operator should not be used as a sub-expression
HICPP-6_1_1=HIC++ 6.1.1 Enclose the body of a selection or an iteration statement in a compound statement
HICPP-6_1_1-a=The statement forming the body of a 'switch', 'while', 'do...while' or 'for' statement shall be a compound statement
HICPP-6_1_1-b='if' and 'else' should be followed by a compound statement
HICPP-6_1_2=HIC++ 6.1.2 Explicitly cover all paths through multi-way selection statements
HICPP-6_1_2-a=All 'if...else-if' constructs shall be terminated with an 'else' clause
HICPP-6_1_2-b=The final clause of a switch statement shall be the default clause
HICPP-6_1_3=HIC++ 6.1.3 Ensure that a non-empty case statement block does not fall through to the next label
HICPP-6_1_3-a=An unconditional throw or break statement shall terminate every non-empty switch-clause
HICPP-6_1_4=HIC++ 6.1.4 Ensure that a switch statement has at least two case labels, distinct from the default label
HICPP-6_1_4-a=Every switch statement will have at least two cases and a potential default
HICPP-6_1_4-b=A switch expression shall not represent a value that is effectively Boolean
HICPP-6_2_1=HIC++ 6.2.1 Implement a loop that only uses element values as a range-based loop
HICPP-6_2_1-a=A for-loop that loops through all elements of the container and does not use its loop-counter shall not be used
HICPP-6_2_2=HIC++ 6.2.2 Ensure that a loop has a single loop counter, an optional control variable, and is not degenerate
HICPP-6_2_2-a=There shall only be one loop counter in a 'for' loop, which shall not be modified in the 'for' loop body
HICPP-6_2_3=HIC++ 6.2.3 Do not alter a control or counter variable more than once in a loop
HICPP-6_2_3-a=Do not modify for loop counter within a body of the loop
HICPP-6_2_4=HIC++ 6.2.4 Only modify a for loop counter in the for expression
HICPP-6_2_4-a=The third clause of a 'for' statement shall be well-formed
HICPP-6_3_1=HIC++ 6.3.1 Ensure that the label(s) for a jump statement or a switch condition appear later, in the same or an enclosing block
HICPP-6_3_1-a=A switch label shall only be used when the most closely-enclosing compound statement is the body of a switch statement
HICPP-6_3_1-b=The goto statement shall jump to a label declared later in the same function body
HICPP-6_3_1-c=Any label referenced by a goto statement shall be declared in the same block, or in a block enclosing the goto statement
HICPP-6_3_2=HIC++ 6.3.2 Ensure that execution of a function with a non-void return type ends in a return statement with a value
HICPP-6_3_2-a=All exit paths from a function, except main(), with non-void return type shall have an explicit return statement with an expression
HICPP-6_4_1=HIC++ 6.4.1 Postpone variable definitions as long as possible
HICPP-6_4_1-a=Declare variables as locally as possible
HICPP-6_4_1-b=Postpone variable definitions as long as possible
HICPP-7_1_1=HIC++ 7.1.1 Declare each identifier on a separate line in a separate declaration
HICPP-7_1_1-a=Multiple variable declarations shall not be allowed on the same line
HICPP-7_1_1-b=Each variable should be declared in a separate declaration statement
HICPP-7_1_10=HIC++ 7.1.10 Use static assert for assertions involving compile time constants
HICPP-7_1_10-a=Use static_assert for assertions involving compile time constants
HICPP-7_1_2=HIC++ 7.1.2 Use const whenever possible
HICPP-7_1_2-a=Declare local variable as const whenever possible
HICPP-7_1_2-b=Declare parameters as const whenever possible
HICPP-7_1_3=HIC++ 7.1.3 Do not place type specifiers before non-type specifiers in a declaration
HICPP-7_1_3-a=Do not place type specifiers before non-type specifiers in a declaration
HICPP-7_1_4=HIC++ 7.1.4 Place CV-qualifiers on the right hand side of the type they apply to
HICPP-7_1_4-a=Place CV-qualifiers on the right hand side of the type they apply to
HICPP-7_1_5=HIC++ 7.1.5 Do not inline large functions
HICPP-7_1_5-a=Do not inline large functions
HICPP-7_1_6=HIC++ 7.1.6 Use class types or typedefs to abstract scalar quantities and standard integer types
HICPP-7_1_6-a=The plain char type shall be used only for the storage and use of character values
HICPP-7_1_6-b=Use class types or typedefs to abstract scalar quantities and standard integer types
HICPP-7_1_6-c=Use class types or typedefs to abstract scalar quantities and standard integer types
HICPP-7_1_7=HIC++ 7.1.7 Use a trailing return type in preference to type disambiguation using typename
HICPP-7_1_7-a=Use a trailing return type syntax if the return type is preceded by the 'typename' keyword
HICPP-7_1_8=HIC++ 7.1.8 Use auto id \= expr when declaring a variable to have the same type as its initializer function call
HICPP-7_1_8-a=Use auto id \= expr when declaring a variable that is the same type as the initializer function call
HICPP-7_1_9=HIC++ 7.1.9 Do not explicitly specify the return type of a lambda
HICPP-7_1_9-a=Do not explicitly specify the return type of a lambda
HICPP-7_2_1=HIC++ 7.2.1 Use an explicit enumeration base and ensure that it is large enough to store all enumerators
HICPP-7_2_1-a=Use an explicit enumeration base and ensure that it is large enough to store all enumerators
HICPP-7_2_2=HIC++ 7.2.2 Initialize none, the first only or all enumerators in an enumeration
HICPP-7_2_2-a=Initialize all, only the first, or none of the enumerators in an enumeration
HICPP-7_3_1=HIC++ 7.3.1 Do not use using directives
HICPP-7_3_1-a=using-directives shall not be used
HICPP-7_4_1=HIC++ 7.4.1 Ensure that any objects, functions or types to be used from a single translation unit are defined in an unnamed namespace in the main source file
HICPP-7_4_1-a=Do not use static keyword except inside functions and classes
HICPP-7_5_1=HIC++ 7.5.1 Do not use the asm declaration
HICPP-7_5_1-a=Do not use the asm declaration
HICPP-8_1_1=HIC++ 8.1.1 Do not use multiple levels of pointer indirection
HICPP-8_1_1-a=The declaration should not contain more than one level of pointer indirection
HICPP-8_2_1=HIC++ 8.2.1 Make parameter names absent or identical in all declarations
HICPP-8_2_1-a=The identifiers used in the declaration and definition of a function shall be identical
HICPP-8_2_2=HIC++ 8.2.2 Do not declare functions with an excessive number of parameters
HICPP-8_2_2-a=Avoid functions with more than 5 parameters
HICPP-8_2_3=HIC++ 8.2.3 Pass small objects with a trivial copy constructor by value
HICPP-8_2_3-a=Pass small objects with a trivial copy constructor by value
HICPP-8_2_4=HIC++ 8.2.4 Do not pass std\:\:unique ptr by const reference
HICPP-8_2_4-a=Do not pass std\:\:unique_ptr by const reference
HICPP-8_3_1=HIC++ 8.3.1 Do not write functions with an excessive McCabe Cyclomatic Complexity
HICPP-8_3_1-a=Follow the Cyclomatic Complexity limit of 10
HICPP-8_3_3=HIC++ 8.3.3 Do not use default arguments
HICPP-8_3_3-a=Do not use default arguments
HICPP-8_3_4=HIC++ 8.3.4 Define \=delete functions with parameters of type rvalue reference to const
HICPP-8_3_4-a=Define rvalue reference functions that have a const parameter as \=delete
HICPP-8_4_1=HIC++ 8.4.1 Do not access an invalid object or an object with indeterminate value
HICPP-8_4_1-c=All automatic variables shall have been assigned a value before being used
HICPP-8_4_2=HIC++ 8.4.2 Ensure that a braced aggregate initializer matches the layout of the aggregate object
HICPP-8_4_2-a=The initializer for an aggregate or union shall be enclosed in braces
HICPP-9_1_1=HIC++ 9.1.1 Declare static any member function that does not require this. Alternatively, declare const any member function that does not modify the externally visible state of the object
HICPP-9_1_1-a=If a member function can be made static then it shall be made static, otherwise if it can be made const then it shall be made const
HICPP-9_1_2=HIC++ 9.1.2 Make default arguments the same or absent when overriding a virtual function
HICPP-9_1_2-a=Do not redefine an inherited virtual function with a different default parameter value
HICPP-9_1_3=HIC++ 9.1.3 Do not return non-const handles to class data from const member functions
HICPP-9_1_3-a=Const member functions shall not return non-const pointers or references to class-data
HICPP-9_1_4=HIC++ 9.1.4 Do not write member functions which return non-const handles to data less accessible than the member function
HICPP-9_1_4-a=Public member functions shall not return non-const handles to private/protected class-data
HICPP-9_1_5=HIC++ 9.1.5 Do not introduce virtual functions in a final class
HICPP-9_1_5-a=Do not introduce virtual functions in a final class
HICPP-9_2_1=HIC++ 9.2.1 Declare bit-fields with an explicitly unsigned integral or enumeration type
HICPP-9_2_1-a=Bit-fields shall have explicitly unsigned integral or enumeration types only
INIT=Initialization
INIT-01=Objects with external linkage should not be initialized in a header file
INIT-02=Do not initialize unsigned integer variables with signed constants
INIT-03=Initialize all variables
INIT-04=Initialize all pointer variables
INIT-05=Do not initialize a reference to an object whose address can be changed
INIT-06=All member variables should be initialized in constructor
INIT-07=Make class members' initialization explicit by providing user-defined constructor
INIT-08=User-defined constructor must be provided to ensure the proper initialization of dynamically allocated class objects
INIT-09=Initialize static class members
INIT-10=List members in an initialization list in the order in which they are declared
INIT-11=An assignment operator shall assign all data members
INIT-12=Avoid initialization order problems across translation units by replacing non-local static objects with local static objects
INIT-13=Do not assume that members are initialized in any special order in constructors
INIT-13_a=Do not use uninitialized nonstatic member variables in base class constructors
INIT-13_b=Do not use uninitialized nonstatic member variables of nonvirtual base classes in virtual base class constructors
INIT-13_c=Do not use possibly uninitialized nonstatic member variables of base classes in base class constructors
INIT-14=Prefer initialization to assignment in constructors
INIT-15=Consider adding constructor to initialize 'struct' member variables
INIT-16=The initializer for an aggregate or union shall be enclosed in braces
INIT-17=The data members initialized with the same constant values across all constructors should be initialized using NSDMI
INIT-17_b=User-defined constructors that initialize data members with the same constant values across all constructors should initialize using NSDMI instead
INIT-18=Both NSDMI and a non-static member initializer in a constructor shall not be used in the same type
JSF=Joint Strike Fighter
JSF-001=Any one function (or method) will contain no more than 200 logical source lines of code (L-SLOCs)
JSF-003=All functions shall have a cyclomatic complexity number of 20 or less
JSF-003_b=Follow the Essential Complexity limit of 1
JSF-009=Only those characters specified in the C++ basic source character set will be used
JSF-010=Values of character types will be restricted to a defined and documented subset of ISO 10646-1
JSF-011=Trigraphs will not be used
JSF-012=The following digraphs will not be used <%, %>, <\:, \:>, %\:, %\:%\:
JSF-013=Wide string literals (for example L"abc") will not be used
JSF-014=Capital 'L' shall be used instead of lowercase 'l' to indicate long
JSF-015=Ensure that array indices are within the bounds of the array
JSF-017=The error indicator 'errno' shall not be used
JSF-018=The macro 'offsetof', in library <stddef.h>, shall not be used
JSF-019='setlocale' function shall not be used
JSF-019_b=<locale.h> shall not be used
JSF-020=The 'setjmp' macro and the 'longjmp' function shall not be used
JSF-020_b=The standard header file <setjmp.h> shall not be used
JSF-021=The standard header file <signal.h> shall not be used
JSF-021_b=The signal handling facilities of <signal.h> shall not be used
JSF-022=The input/output library <stdio.h> shall not be used
JSF-023=The library functions atof, atoi and atol from library <stdlib.h> shall not be used
JSF-024=The library function 'abort' of <stdlib.h> shall not be used
JSF-024_b=The library function 'exit' of <stdlib.h> shall not be used
JSF-024_c=The library function 'getenv' of <stdlib.h> shall not be used
JSF-024_d=The library function 'system' of <stdlib.h> shall not be used
JSF-025=The time handling functions of library <time.h> shall not be used
JSF-026=The \#ifdef, \#else, \#elif preprocessor directives should not be used
JSF-026_b=The \#if preprocessor directive should not be used
JSF-026_c=\#error directive shall not be used
JSF-026_d=The \#pragma directive shall not be used
JSF-026_e=\#undef shall not be used
JSF-027=\#ifndef, \#define and \#endif will be used to prevent multiple inclusions of the same header file
JSF-028=The \#ifndef pre-processor directive will only be used to prevent multiple inclusions of the same header file
JSF-028_b=The \#endif pre-processor directives will only be used to prevent multiple inclusions of the same header file
JSF-029=The \#define pre-processor directive shall not be used to create inline macros
JSF-030=The \#define pre-processor directive shall not be used to define constant values
JSF-031=The \#define pre-processor directive will only be used as part of the technique to prevent multiple inclusions of the same header file
JSF-032=The \#include pre-processor directive will only be used to include header (*.h) files
JSF-033=The \#include directive shall use the <filename.h> notation to include header files
JSF-035=A header file will contain a mechanism that prevents multiple inclusions of itself
JSF-037=A file should directly include only headers containing declarations and definitions needed to a compilation
JSF-039_a=Header files (*.h) will not contain non-const variable definitions or function definitions
JSF-041=Source lines will be kept to a length of 120 characters or less
JSF-042=Each expression-statement will be on a separate line
JSF-043=Tabs should be avoided
JSF-044=All indentations will be consistent
JSF-046_a=User-specified C++ external identifiers should differ in the first 64 characters
JSF-046_b=User-specified C++ internal identifiers should differ from external identifiers in the first 64 characters
JSF-046_c=User-specified C++ internal identifiers declared in the same scope should differ in the first 64 characters
JSF-047=Identifiers will not begin with the underscore character "_"
JSF-048=Identifiers will not differ by mixture of case, the underscore character, interchange of the similarly looking letters and numbers
JSF-050=Begin class, struct, union, enum, and typedef names with an uppercase letter
JSF-051=All letters contained in function and variable names will be composed entirely of lowercase letters
JSF-052=Identifiers for constant and enumerator values shall be lowercase
JSF-053=Header files will always have a file name extension of ".h"
JSF-053.1=The following character sequences shall not appear in header file names\: ', \\, /*, //, or " 
JSF-054=Implementation files will always have a file name extension of ".cpp"
JSF-057_a=The public section of a class will be declared before the protected section and before the private section
JSF-057_b=The protected section of a class will be declared before the private section
JSF-058=When declaring functions with more than 2 parameters, the leading parenthesis and the first argument are to be written on the same line as the function name, each additional argument will be written on a separate line
JSF-059_a=The statements forming the body of a 'while', 'do...while', 'switch' or 'for' statement shall always be enclosed in braces
JSF-059_b=The statements forming the body of an 'if', 'else if' or 'else' statement shall always be enclosed in braces
JSF-060_a=Braces ("{}") which enclose a block will have nothing else on the line except comments
JSF-060_b=Braces ("{}") which enclose a block will be placed in the same column
JSF-060_c=Braces ("{}") which enclose a block will not have an empty line after "{" nor before "}"
JSF-061=Braces ("{}") which enclose a block will have nothing else on the line except comments
JSF-062=The dereference operator '*' and the address-of operator '&' will be directly connected with the type-specifier
JSF-063_a=There will be no white space following '.' or '->' operator
JSF-063_b=There will be no white space preceding '.' or '->' operator
JSF-063_c=There will be no space between a unary operator '\!' or '~' and its operand
JSF-063_d=There will be no space between a increment/decrement operator (++/--) and its operand
JSF-063_e=There will be no space between a unary operator '&', '*', '+', '-' and its operand
JSF-063_f=There should be no space between an increment/decrement operator (++/--) and its operand in macro definition
JSF-067_a=Public data should only be used in structs, not in classes
JSF-067_b=Protected data should only be used in structs, not in classes
JSF-068=Declare both private copy constructor and copy assignment operator at the same time
JSF-069=A member function that does not affect the state of an object will be declared const
JSF-070=Avoid using the friend mechanism
JSF-070.1=Freed memory shall not be accessed under any circumstances
JSF-070.1_b=Destructor shall not be called manually
JSF-071=Public and protected methods shall not be invoked by class constructor
JSF-071.1=A class's virtual functions shall not be invoked from any of its constructors
JSF-071.1_b=A class's virtual functions shall not be invoked from its destructor
JSF-071_b=All member variables shall be initialized in constructor
JSF-071_c=A class's virtual functions shall not be invoked from any of its constructors
JSF-071_d=Uninitialized nonstatic member variables shall not be used in base class constructors
JSF-071_e=Uninitialized nonstatic member variables of nonvirtual base classes shall not be used in virtual base class constructors
JSF-071_f=Possibly uninitialized nonstatic member variables of base classes shall not be used in base class constructors
JSF-074=Initialization of nonstatic class members will be performed through the member initialization list rather than through assignment in the body of a constructor
JSF-075=Members of the initialization list shall be listed in the order in which they are declared in the class
JSF-076=A copy constructor and a copy assignment operator shall be declared for classes that contain pointers to data items or nontrivial destructors
JSF-077=A copy constructor shall copy all data members and bases
JSF-077.1=The definition of a constructor shall not contain default arguments that produce a signature identical to that of the implicitly-declared copy constructor
JSF-078=All base classes with a virtual function shall define a virtual destructor
JSF-079=Call fclose() on pointer member in destructor if the pointer was used to open a file
JSF-079_b=Call delete on pointer members in destructors
JSF-081=The assignment operator shall handle self-assignment correctly
JSF-082=An assignment operator shall return a reference to *this
JSF-083_a=An assignment operator shall assign all data members
JSF-083_b=An assignment operator shall assign all data bases
JSF-085=When two operators are opposites (such as \=\= and \!\=), both will be defined
JSF-085_a=When one of opposite operators (\=\= and \!\=) is defined, the other should be defined too and one will be defined in terms of the other
JSF-087=Hierarchies should be based on abstract classes
JSF-088=Multiple inheritance shall be limited to at most 1 protected implementation
JSF-088.1=A stateful virtual base shall be explicitly declared in each derived class that accesses it
JSF-088_b=Multiple inheritance shall not use any public implementations
JSF-089=A base class shall not be both virtual and non-virtual in the same hierarchy
JSF-094=An inherited nonvirtual function shall not be redefined in a derived class
JSF-094_b=Member functions declared in derived class shall not hide functions declared in base classes
JSF-095=An inherited default parameter shall never be redefined
JSF-096=Arrays shall not be treated polymorphically
JSF-097=Arrays shall not be used in interfaces
JSF-097.1=Neither operand of an equality operator (\=\= or \!\=) shall be a pointer to a virtual member function
JSF-097_b=Arrays shall not be used in private or protected methods
JSF-097_c=Arrays shall not be used in global functions
JSF-097_d=Arrays shall not be passed to functions as array/pointer parameters
JSF-097_e=Functions which are called with array argument shall not be declared with pointer parameter
JSF-098=Every nonlocal name, except main(), should be placed in some namespace
JSF-099=Namespaces will not be nested more than two levels deep
JSF-100=Don't write namespace usings in a header file or before an \#include
JSF-104=All partial and explicit specializations for a template should be declared in the same file as the declaration of their primary template
JSF-105=In a class template with a dependent base, any name that may be found in that dependent base should be referred to using a qualifier
JSF-107=Functions shall always be declared at file scope
JSF-108=Functions with variable numbers of arguments shall not be used
JSF-109=A function definition should not be placed in a class specification
JSF-110=Functions with more than 7 arguments will not be used
JSF-111=A function shall not return a pointer or reference to a non-static local object
JSF-111_a=A function shall not return a pointer or a reference to a parameter that is passed by const reference
JSF-112=Dereferenced local pointer initialized by new in function scope should not be returned
JSF-113=Functions will have a single exit point
JSF-114=All exit points of value-returning functions shall be through return statements
JSF-115=If a function returns error information, then that error information will be tested
JSF-115_a=Value returned by a function having a non-void return type that is not an overloaded operator shall always be used
JSF-116=Built-in-types should be passed by value unless you are modifying them
JSF-117=Arguments should be passed by reference
JSF-117.1=An object should be passed as const reference if the function should not change the value of the object
JSF-117_a=Avoid slicing function arguments / return value
JSF-117_b=The class object should be passed by reference if the class has non-static pointers and has no declared copy constructor
JSF-118=A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify the addressed object
JSF-118_b=Declare a type of parameter as typedef to pointer to const if the pointer is not used to modify the addressed object
JSF-119=Functions shall not call themselves, either directly or indirectly
JSF-121=Only functions with 1 or 2 statements should be considered candidates for inline functions
JSF-122=Trivial accessor and mutator functions should be inlined
JSF-123=Classes which have only getters/setters (accessors/mutators) are not allowed
JSF-124=Trivial forwarding functions should be inlined
JSF-125_a=Pass and return by reference when possible
JSF-125_b=Consider using op\= instead of stand-alone op
JSF-126=Only valid C++ style comments (//) shall be used
JSF-127=Code that is not used (commented out) shall be deleted
JSF-132_a=Each variable declaration will be commented
JSF-132_b=Each typedef will be commented
JSF-132_c=Each enumeration value will be commented
JSF-132_d=Each structure member variable will be commented
JSF-133_a=Every source file will be documented with an introductory comment that provides information on the file
JSF-133_b=Every source file will contain copyright information
JSF-134=Document functions in comments that precede function definitions
JSF-134_b=Document functions in comments that precede function declarations
JSF-135_a=Identifier declared in a local or function prototype scope shall not hide an identifier declared in a global or namespace scope
JSF-135_b=Identifiers declared in an inner local scope shall not hide identifiers declared in an outer local scope
JSF-135_c=Identifiers declared in a local scope shall not hide identifiers declared in a class scope
JSF-135_d=Identifiers declared in a class scope shall not hide identifiers declared in a global or namespace scope
JSF-135_e=Identifiers declared in an inner class scope shall not hide identifiers declared in outer class scope
JSF-136_a=Objects should be defined at block scope if they are only accessed from within a single function
JSF-136_b=Declarations of local variables should be at the smallest feasible scope
JSF-137=All declarations at file scope should be static where possible
JSF-138_a=Identifiers shall not simultaneously have both internal and external linkage in the same translation unit
JSF-138_b=The static storage class specifier shall be used in definitions and declarations of objects and functions that have internal linkage
JSF-139=External objects will not be declared in more than one file
JSF-139_b=External objects will not be declared in implementation files
JSF-140=The register storage class specifier shall not be used
JSF-141=A class, structure, or enumeration will not be declared in the definition of its type
JSF-142_a=All automatic variables shall have been assigned a value before being used
JSF-142_b=All variables shall be initialized before use
JSF-143=Variables will not be introduced until they can be initialized with meaningful values
JSF-143_a=Avoid unused local variables
JSF-144=Braces shall be used to indicate and match the structure in the non-zero initialization of arrays and structures
JSF-145=In an enumerator list, the '\=' construct shall not be used to explicitly initialize members other than the first, unless all items are explicitly initialized
JSF-147=The underlying bit representations of floating point numbers shall not be used in any way by the programmer
JSF-148=Enumeration types shall be used instead of integer types (and constants) to select from a limited series of choices
JSF-149=Octal constants (other than zero) shall not be used
JSF-150=Hexadecimal constants will be represented using all uppercase letters
JSF-151=Numeric values in code will not be used; symbolic values will be used instead
JSF-151.1=A string literal shall not be modified
JSF-152=Multiple variable declarations shall not be allowed on the same line
JSF-153=Unions shall not be used
JSF-154=Bit-fields shall have explicitly unsigned integral or enumeration types only
JSF-156=All the members of a structure (or class) shall be named
JSF-157=The right hand operand of a && or || operator shall not contain side effects
JSF-158=The operands of a logical && or || shall be parenthesized if the operands contain binary operators
JSF-159=Operators ||, && shall not be overloaded
JSF-159_b=Operator unary & shall not be overloaded
JSF-160=An assignment expression shall be used only as the expression in an expression statement
JSF-162_a=Signed and unsigned values shall not be mixed in comparison operations
JSF-162_b=Signed and unsigned values shall not be mixed in second and third operand of conditional operator
JSF-162_c=Signed and unsigned values shall not be mixed in arithmetic operations
JSF-163=Unsigned arithmetic shall not be used
JSF-164.1=The left-hand operand of a right-shift operator shall not have a negative value
JSF-165=The unary minus operator shall not be applied to an unsigned expression
JSF-166=The sizeof operator will not be used on expressions that contain side effects
JSF-166_b=The sizeof operator will not be used on expressions that contain side effects
JSF-166_c=The sizeof operator will not be used on expressions that contain side effects
JSF-167=The implementation of integer division shall be documented
JSF-167_a=Don't assign the dividend of two integers to a floating-point type
JSF-168_b=The comma operator shall not be used
JSF-169=Pointers to pointers should be avoided
JSF-170=More than 2 levels of pointer indirection shall not be used
JSF-173=The address of an object with automatic storage shall not be assigned to an object which persists after the object has ceased to exist
JSF-174_a=The null pointer shall not be de-referenced
JSF-174_b=The null pointer shall not be de-referenced
JSF-175=NULL identifier shall not be used; use plain 0 instead
JSF-176=A typedef will be used to simplify program syntax when declaring function pointers
JSF-177=User-defined conversion functions should be avoided
JSF-177_b=Constructors allowing for conversion should be made explicit
JSF-178=Down casting (casting from base to derived class) shall not be allowed
JSF-179=A pointer to a virtual base class shall not be converted to a pointer to a derived class
JSF-180_a=Implicit conversions from wider to narrower integral type which may result in a loss of information shall not be used
JSF-180_b=Avoid implicit conversions from floating to integral type
JSF-180_c=Avoid implicit conversions from wider to narrower floating type
JSF-180_d=Avoid conversions of constant values to a narrower type
JSF-180_e=Avoid implicit conversions from signed to unsigned type
JSF-180_f=Implicit conversions from integral to floating type which may result in a loss of information shall not be used
JSF-180_g=Implicit conversions from integral constant to floating type which may result in a loss of information shall not be used
JSF-181_a=Redundant explicit casts will not be used
JSF-181_b=Avoid explicit cast from derived to a base class
JSF-182=Type casting from any type to or from pointers shall not be used
JSF-183=Every possible measure should be taken to avoid type casting
JSF-183_a=Avoid using static_cast on pointers
JSF-183_b=Avoid using reinterpret_cast
JSF-184_a=Floating point numbers shall not implicitly be converted to integers
JSF-185=C-style casts (other than void casts) and functional notation casts (other than explicit constructor calls) shall not be used
JSF-186_a=There shall be no unreachable code in 'else' block
JSF-186_b=There shall be no unreachable code after 'return', 'break', 'continue', and 'goto' statements
JSF-186_c=There shall be no unreachable code in 'if', 'else', 'while' and 'for' block
JSF-186_d=There shall be no unreachable code in 'switch' statement
JSF-186_e=There shall be no unreachable code in 'for' loop
JSF-186_f=There shall be no unreachable code after 'if' or 'switch' statement
JSF-186_g=There shall be no unreachable code after 'if' or 'switch' statement inside 'while', 'for' or 'do...while' loop
JSF-186_h=Every defined function with internal linkage shall be used
JSF-187=All non-null statements shall potentially have a side-effect
JSF-188=Labels will not be used, except in switch statements
JSF-189=The goto statement shall not be used
JSF-190=The continue statement shall not be used
JSF-191=The break statement shall not be used (except to terminate the cases of a switch statement)
JSF-191_a=For any iteration statement there shall be no more than one break or goto statement used for loop termination
JSF-192=All 'if...else if' constructs will contain either a final else clause or a comment indicating why a final else clause is not necessary
JSF-193=Every non-empty case clause in a switch statement shall be terminated with a break statement
JSF-194=All switch statements that do not intend to test for every enumeration value shall contain a final default clause
JSF-195=A switch expression will not represent a Boolean value
JSF-196=Every switch statement will have at least two cases and a potential default
JSF-197=Floating point variables shall not be used as loop counters
JSF-198=The initialization expression in a for loop will perform no actions other than to initialize the value of a single for loop parameter
JSF-199=The increment expression in a for loop will perform no action other than to change a single loop parameter to the next value for the loop
JSF-200=Null initialize or increment expressions in for loops will not be used; a while loop will be used instead
JSF-201=Numeric variables being used within a for loop for iteration counting shall not be modified in the body of the loop
JSF-202=Floating point variables shall not be tested for exact equality or inequality
JSF-203=Evaluation of expressions shall not lead to overflow/underflow
JSF-204.1_a=The value of an expression shall be the same under any order of evaluation that the standard permits
JSF-204.1_b=Don't write code that depends on the order of evaluation of function arguments
JSF-204.1_c=Don't write code that depends on the order of evaluation of function designator and function arguments
JSF-204.1_d=Don't write code that depends on the order of evaluation of expression that involves a function call
JSF-204.1_e=Between sequence points an object shall have its stored value modified at most once by the evaluation of an expression
JSF-204.1_f=Do not use more than one volatile in one expression
JSF-204.1_g=Don't write code that depends on the order of evaluation of function calls
JSF-204_a=A single operation with side-effect shall only be used in the proper context
JSF-204_b=A call of function with side-effect shall only be used in the proper context
JSF-204_d=The second or third operand of a ternary operator '?\:' shall not contain side effects
JSF-205=The volatile keyword shall not be used
JSF-206=Dynamic heap memory allocation shall not be used
JSF-207=Unencapsulated global data will be avoided
JSF-208=C++ exceptions shall not be used
JSF-209=Typedefs that indicate size and signedness shall be used in place of the basic types
JSF-209_b=Typedefs that indicate size and signedness shall be used in place of the basic types
JSF-210.1=Algorithms shall not make assumptions concerning the order of allocation of nonstatic data members separated by an access specifier
JSF-211=Algorithms shall not assume particular memory alignment
JSF-213_e=Use parenthesis to clarify expression order if operators with precedence lower than arithmetic are used
JSF-214=Assuming that non-local static objects, in separate translation units, are initialized in a special order shall not be done
JSF-215=Pointer arithmetic will not be used
METRICS=Metrics
METRICS-01=Avoid functions with over 50 lines
METRICS-02=Avoid switch statements with many cases
METRICS-03=Number of blocks of code in a function
METRICS-04=Number of function calls within function
METRICS-05=Class inheritance level
METRICS-06=Number of data member(s) per class should not exceed 15
METRICS-07=Number of methods per class
METRICS-08=Number of parameter(s) per method should not exceed 10
METRICS-09=Number of private data member(s) per class
METRICS-10=Number of private methods per class
METRICS-11=Number of protected data member(s) per class
METRICS-12=Number of protected methods per class
METRICS-13=Number of public data member(s) per class
METRICS-14=Number of public methods per class
METRICS-15=Avoid functions with more than 5 parameters
METRICS-16=Macros should not use more than 5 parameters
METRICS-17=Avoid structs, unions, or classes with more than 20 fields
METRICS-18=Follow the Cyclomatic Complexity limit of 10
METRICS-19=The percentage of comment lines versus the total number of module lines should be between 20 and 60
METRICS-20=Avoid too long functions (declarations and statements)
METRICS-21=Avoid too long functions (blocks)
METRICS-22=Avoid functions with over 75 lines of code
METRICS-23=Nested block depth should not be higher than 5
METRICS-24=Avoid source files that are longer than 500 lines
METRICS-25=Any one function (or method) will contain no more than 200 logical source lines of code (L-SLOCs)
METRICS-26=Source lines will be kept to a length of 120 characters or less
METRICS-27=Functions with more than 7 parameters will not be used
METRICS-28=Follow the Cyclomatic Complexity limit of 20
METRICS-29=Report Cyclomatic Complexity
METRICS-30=No function should be longer than 60 lines of code
METRICS-31=The assertion density of the code should average to a minimum of two assertions per function
METRICS-32=All functions with more than 20 lines should contain at least 2 assertions
METRICS-33=Report Essential Complexity
METRICS-34=Follow the Essential Complexity limit of 4
METRICS-35=Follow the Essential Complexity limit of 10
METRICS-36=A global function should not be called from more than 5 different functions
METRICS-37=A function should not call more than 7 different functions
METRICS-38=The number of statements within function should be in range 1 - 50
METRICS-39=The value of VOCF metric for a function should not be higher than 4
METRICS-40=Statements within function should not be nested deeper than 4 levels
METRICS-41=The number of blocks of comments before and inside function to the number of statements in function should be > 0.2
METRICS-42=Follow the Essential Complexity limit of 1
METRICS-43=Report the value of Halstead's delivered bugs (B) for a function
METRICS-44=The number of execution paths in a function should not be higher than 80
MISRA=MISRA C 1998
MISRA-004_a=Provisions should be made for appropriate run-time checking
MISRA-004_b=Provisions should be made for appropriate run-time checking
MISRA-005=Only use characters defined in the ISO C standard
MISRA-006=Values of character types shall be restricted to a defined and documented subset of ISO 10646-1
MISRA-008=Do not use wide string literals
MISRA-013=The basic types of char, int, short, long, float and double should not be used, but specific-length equivalents should be typedef'd
MISRA-014=Explicitly declare 'char' type as signed or unsigned
MISRA-016=The underlying bit representations of floating point numbers shall not be used
MISRA-018_a=Use type suffix for numeric constants
MISRA-018_b=Use type suffix for numeric constants
MISRA-018_c=Use type suffix for numeric constants
MISRA-018_d=Use type suffix for numeric constants
MISRA-020=All functions shall be declared before use
MISRA-022=Declare objects at function scope
MISRA-023=Objects or functions with external linkage shall be declared in a header file
MISRA-024=Identifiers shall not simultaneously have both internal and external linkage in the same translation unit
MISRA-027=External object should not be declared in more than one file
MISRA-027_b=External objects should not be declared in implementation files
MISRA-028=The 'register' storage class specifier shall not be used
MISRA-029=The use of a tag shall agree with its declaration
MISRA-030=All automatic variables shall have been assigned a value before being used
MISRA-038=The right-hand operand of a shift operator shall lie between zero and one less than the width in bits of the underlying type of the left-hand operand
MISRA-041=Document integer division
MISRA-042=The comma operator shall not be used, except in the control expression of a for loop
MISRA-043=Implicit conversions from wider to narrower integral type which may result in a loss of information shall not be used
MISRA-043_b=Avoid mixing arithmetic of different precisions in the same expression
MISRA-043_c=Implicit conversions from integral to floating type which may result in a loss of information shall not be used
MISRA-043_d=Implicit conversions from integral constant to floating type which may result in a loss of information shall not be used
MISRA-044=Redundant explicit cast to the same type is not allowed
MISRA-046_a=Do not use the volatile keyword
MISRA-046_b=Assignment statements should not be nested within other assignment statements
MISRA-048_a=Avoid possible integer overflow in expressions in which the result is cast to a wider integer type
MISRA-048_b=Don't cast the dividend of two integers to a floating-point type
MISRA-048_c=Avoid possible integer overflow in expressions in which the result is assigned to a variable of a wider integer type
MISRA-048_d=Avoid unintentionally discarding the remainder of integer division
MISRA-051=Evaluation of constant unsigned integer expressions should not lead to wrap-around
MISRA-054=A null statement shall only occur on a line by itself
MISRA-055=Do not use labels
MISRA-058=Do not use the break statement
MISRA-065=Do not use floating point variables as loop counters
MISRA-069=Do not use functions with variable numbers of arguments
MISRA-071_a=Functions shall have prototype declarations and the prototype shall be visible at both the function definition and call
MISRA-071_b=Functions shall always have visible prototype at the function call
MISRA-073=Provide none or all identifiers for function arguments
MISRA-083=Provide expression for return statement of non-void functions
MISRA-084=Avoid expressions in return statements of void functions
MISRA-089=The \#include directive shall be followed by either a <filename> or "filename" sequence
MISRA-096=Enclose in parentheses whole definition of a function-like macro
MISRA-100=Use only non-ambiguous forms of defined pre-processor operator
MISRA-101=Pointer arithmetic should not be used
MISRA-104=Do not use non-constant pointers to functions
MISRA-105=All the functions pointed to by a single pointer to function shall be identical in the number and type of parameters and the return type
MISRA-107_a=The NULL pointer shall not be dereferenced
MISRA-107_b=The NULL pointer shall not be dereferenced
MISRA-108=All members of structure or union should be fully specified
MISRA-110=Unions shall not be used to access the sub-parts of larger data structure
MISRA-113=All the members of a structure (or class/union) shall be named
MISRA-115=Standard library function names shall not be reused
MISRA-121_a=Do not use 'setlocale' function
MISRA-121_b=Do not include <locale.h> header
MISRA2004=MISRA C 2004
MISRA2004-10_1_a=Avoid implicit conversions between signed and unsigned integer types
MISRA2004-10_1_b=There shall be no implicit conversions from integral to floating type
MISRA2004-10_1_c=Avoid implicit conversions of complex expressions
MISRA2004-10_1_d=Avoid implicit conversions from wider to narrower types
MISRA2004-10_1_e=Avoid implicit conversions of function return expressions
MISRA2004-10_1_f=Avoid implicit conversions of complex expressions
MISRA2004-10_1_g=Avoid implicit conversions of function arguments
MISRA2004-10_1_i=Avoid implicit conversions of complex expressions
MISRA2004-10_2_a=Avoid implicit conversions from floating to integral type
MISRA2004-10_2_b=Avoid implicit conversions from wider to narrower floating type
MISRA2004-10_2_c=Avoid implicit conversions from narrower to wider floating type
MISRA2004-10_2_d=Avoid implicit conversions of floating point numbers from wider to narrower floating type
MISRA2004-10_3=The value of a complex expression of integer type shall only be cast to a type  of the same signedness that is no wider than the underlying type of the expression
MISRA2004-10_4=The value of a complex expression of floating type should not be cast to a wider floating type
MISRA2004-10_4_b=The value of a complex expression of floating type should not be cast to an integer type
MISRA2004-10_5=If the bitwise operators ~ and << are applied to an operand of underlying type unsigned char or unsigned short, the result shall be immediately cast to the underlying type of the operand
MISRA2004-10_6=A 'U' suffix shall be applied to all constants of unsigned type
MISRA2004-11_1=Conversions shall not be performed between a pointer to a function and any type other than an integral type
MISRA2004-11_2=Conversions shall not be performed between a pointer to object and any type other than an integral type, another pointer to object type or a pointer to void
MISRA2004-11_2_b=Conversions shall not be performed between a pointer to object and any type other than an integral type, another pointer to object type or a pointer to void
MISRA2004-11_2_c=Conversions shall not be performed between a pointer to object and any type other than an integral type, another pointer to object type or a pointer to void
MISRA2004-11_3_a=A cast should not convert a pointer type to an integral type
MISRA2004-11_3_b=A cast should not convert an integral type to a pointer type
MISRA2004-11_4=A cast should not be performed between a pointer to object type and a different pointer to object type
MISRA2004-11_5=A cast shall not remove any 'const' or 'volatile' qualification from the type of a pointer or reference
MISRA2004-12_10=The comma operator shall not be used
MISRA2004-12_12=The underlying bit representations of floating-point values shall not be used
MISRA2004-12_13=The increment (++) and decrement (--) operators should not be mixed with other operators in an expression
MISRA2004-12_1_a=Use parenthesis for the right-hand operand of an assignment operator when it contains an assignment expression
MISRA2004-12_1_b=Limited dependence should be placed on C's operator precedence rules in expressions
MISRA2004-12_1_c=No parentheses are required for the operand of a unary operator
MISRA2004-12_1_d=Limited dependence should be placed on C's operator precedence rules in expressions
MISRA2004-12_1_e=Use parentheses unless all operators in the expression are the same
MISRA2004-12_1_f=Limited dependence should be placed on C's operator precedence rules in expressions
MISRA2004-12_2_a=The value of an expression shall be the same under any order of evaluation that the standard permits
MISRA2004-12_2_b=Don't write code that depends on the order of evaluation of function arguments
MISRA2004-12_2_c=Don't write code that depends on the order of evaluation of function designator and function arguments
MISRA2004-12_2_d=Don't write code that depends on the order of evaluation of expression that involves a function call
MISRA2004-12_2_e=Between sequence points an object shall have its stored value modified at most once by the evaluation of an expression
MISRA2004-12_2_f=Do not use more than one volatile between two adjacent sequence points
MISRA2004-12_2_g=Don't write code that depends on the order of evaluation of function calls
MISRA2004-12_3=The operand of the sizeof operator shall not contain any expression which has side effects
MISRA2004-12_3_b=Object designated by a volatile lvalue should not be accessed in the operand of the sizeof operator
MISRA2004-12_3_c=The function call that causes the side effect shall not be the operand of the sizeof operator
MISRA2004-12_4_a=The right-hand operand of a logical && or || operator shall not contain side effects
MISRA2004-12_5=The operands of a logical && or || shall be primary-expressions
MISRA2004-12_6_a=The operands of logical operators (&&, || and \!) should be effectively Boolean
MISRA2004-12_6_b=Expressions that are effectively Boolean should not be used as operands to operators other than (&&, ||, \!, \=, \=\=, \!\=, ?\:)
MISRA2004-12_7=Bitwise operators shall not be applied to operands whose underlying type is signed
MISRA2004-12_8=The right-hand operand of a shift operator shall lie between zero and one less than the width in bits of the underlying type of the left-hand operand
MISRA2004-12_9=The unary minus operator shall not be applied to an expression whose underlying type is unsigned
MISRA2004-13_1=Assignment operators shall not be used in expressions that yield a Boolean value
MISRA2004-13_2=Tests of a value against zero should be made explicit, unless the operand is effectively Boolean
MISRA2004-13_3=Floating-point expressions shall not be tested for equality or inequality
MISRA2004-13_4=The controlling expression of a for statement shall not contain any objects of floating type
MISRA2004-13_5=The three expressions of a for statement shall be concerned only with loop control
MISRA2004-13_6=Do not modify for loop counter within a body of the loop
MISRA2004-13_7_a=Boolean operations whose results are invariant shall not be permitted
MISRA2004-13_7_aa=Boolean operations whose results are invariant shall not be permitted
MISRA2004-13_7_ab=Boolean operations whose results are invariant shall not be permitted
MISRA2004-13_7_ac=Boolean operations whose results are invariant shall not be permitted
MISRA2004-13_7_ad=Boolean operations whose results are invariant shall not be permitted
MISRA2004-13_7_ae=Boolean operations whose results are invariant shall not be permitted
MISRA2004-13_7_af=Boolean operations whose results are invariant shall not be permitted
MISRA2004-13_7_ag=Boolean operations whose results are invariant shall not be permitted
MISRA2004-13_7_ah=Boolean operations whose results are invariant shall not be permitted
MISRA2004-13_7_ai=Boolean operations whose results are invariant shall not be permitted
MISRA2004-13_7_aj=Boolean operations whose results are invariant shall not be permitted
MISRA2004-13_7_ak=Boolean operations whose results are invariant shall not be permitted
MISRA2004-13_7_b=Boolean operations whose results are invariant shall not be permitted
MISRA2004-13_7_c=Boolean operations whose results are invariant shall not be permitted
MISRA2004-13_7_d=Boolean operations whose results are invariant shall not be permitted
MISRA2004-13_7_j=Boolean operations whose results are invariant shall not be permitted
MISRA2004-13_7_k=Boolean operations whose results are invariant shall not be permitted
MISRA2004-13_7_l=Boolean operations whose results are invariant shall not be permitted
MISRA2004-13_7_m=Boolean operations whose results are invariant shall not be permitted
MISRA2004-13_7_n=Boolean operations whose results are invariant shall not be permitted
MISRA2004-13_7_s=Boolean operations whose results are invariant shall not be permitted
MISRA2004-13_7_t=Boolean operations whose results are invariant shall not be permitted
MISRA2004-13_7_u=Boolean operations whose results are invariant shall not be permitted
MISRA2004-13_7_v=Boolean operations whose results are invariant shall not be permitted
MISRA2004-13_7_w=Boolean operations whose results are invariant shall not be permitted
MISRA2004-13_7_x=Boolean operations whose results are invariant shall not be permitted
MISRA2004-13_7_y=Boolean operations whose results are invariant shall not be permitted
MISRA2004-13_7_z=Boolean operations whose results are invariant shall not be permitted
MISRA2004-14_10=All 'if...else-if' constructs shall be terminated with an 'else' clause
MISRA2004-14_1_a=There shall be no unreachable code in "else" block
MISRA2004-14_1_b=There shall be no unreachable code after 'return', 'break', 'continue', and 'goto' statements
MISRA2004-14_1_c=There shall be no unreachable code in "if/else/while/for" block
MISRA2004-14_1_d=There shall be no unreachable code in switch statement
MISRA2004-14_1_e=There shall be no unreachable code in 'for' loop
MISRA2004-14_1_f=There shall be no unreachable code after 'if' or 'switch' statement
MISRA2004-14_1_g=There shall be no unreachable code after "if" or "switch" statement inside while/for/do...while loop
MISRA2004-14_2=All non-null statements shall either have at least one side-effect however executed or cause control flow to change
MISRA2004-14_3=A null statement shall occur on a line by itself or be followed by a comment
MISRA2004-14_4=The goto statement shall not be used
MISRA2004-14_5=The continue statement shall not be used
MISRA2004-14_6=For any iteration statement there shall be at most one break statement used for loop termination
MISRA2004-14_7=A function shall have a single point of exit at the end of the function
MISRA2004-14_8=The statement forming the body of a 'switch', 'while', 'do...while' or 'for' statement shall be a compound statement
MISRA2004-14_9='if' and 'else' should be followed by a compound statement
MISRA2004-15_0_a=A break statement should be placed only at the end of switch clause
MISRA2004-15_0_b=A switch statement shall only contain switch labels and switch clauses, and no other code
MISRA2004-15_1=A switch label shall only be used when the most closely-enclosing compound statement is the body of a switch statement
MISRA2004-15_2=An unconditional break statement shall terminate every non-empty case clause
MISRA2004-15_2_b=An unconditional break statement shall terminate every non-empty default clause
MISRA2004-15_3=The final clause of a switch statement shall be the default clause
MISRA2004-15_4=A switch expression shall not represent a value that is effectively Boolean
MISRA2004-15_4_b=A switch expression shall not represent a value that is effectively Boolean
MISRA2004-15_5=Every switch statement shall have at least one case clause
MISRA2004-16_1=Functions shall not be defined with a variable number of arguments
MISRA2004-16_10=If a function returns error information, then that error information shall be tested
MISRA2004-16_2=Functions shall not call themselves, either directly or indirectly
MISRA2004-16_3=Identifiers shall be given for all of the parameters in a function prototype declaration
MISRA2004-16_4=The identifiers used in the declaration and definition of a function shall be identical
MISRA2004-16_5=Functions with no parameters shall be declared with parameter type void
MISRA2004-16_6=The number of arguments passed to a function shall match the number of parameters
MISRA2004-16_7=A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify the addressed object
MISRA2004-16_7_b=Declare a type of parameter as typedef to pointer to const if the pointer is not used to modify the addressed object
MISRA2004-16_8=All exit paths from a function with non-void return type shall have an explicit return statement with an expression
MISRA2004-16_8_b=All exit paths from a function, except main(), with non-void return type shall have an explicit return statement with an expression
MISRA2004-16_9=A function identifier shall only be used with either a preceding '&', or with a parenthesised parameter list, which may be empty
MISRA2004-17_1=Do not apply arithmetic to pointers that don't address an array or array element
MISRA2004-17_2=Pointer subtraction shall only be applied to pointers that address elements of the same array
MISRA2004-17_3=>, >\=, <, <\= shall not be applied to pointer types except where they point to the same array
MISRA2004-17_4=Array indexing shall be the only allowed form of pointer arithmetic
MISRA2004-17_5=The declaration of objects should contain no more than 2 levels of pointer indirection
MISRA2004-17_6_a=The address of an object with automatic storage shall not be returned from a function
MISRA2004-17_6_b=The address of an object with automatic storage shall not be assigned to another object that may persist after the first object has ceased to exist
MISRA2004-18_1=All structure and union types shall be complete at the end of a translation unit
MISRA2004-18_2=An object shall not be assigned to an overlapping object
MISRA2004-18_2_b=An object shall not be assigned to an overlapping object
MISRA2004-18_4=Unions shall not be used
MISRA2004-19_1=\#include statements in a file should only be preceded by other preprocessor directives or comments
MISRA2004-19_10=In the definition of a function-like macro each instance of a parameter shall be enclosed in parentheses unless it is used as the operand of \# or \#\#
MISRA2004-19_11_b=Do not use in preprocessor directives \#if and \#elif macros not defined in translation unit
MISRA2004-19_12=There shall be at most one occurrence of the \# or \#\# preprocessor operators in a single macro definition
MISRA2004-19_13=The \# and \#\# preprocessor operators should not be used
MISRA2004-19_14=The defined preprocessor operator shall only be used in one of the two standard forms
MISRA2004-19_15=Precautions shall be taken in order to prevent the contents of a header file being included twice
MISRA2004-19_16=Preprocessing directives shall be syntactically meaningful even when excluded by the preprocessor
MISRA2004-19_17=All \#else, \#elif and \#endif preprocessor directives shall reside in the same file as the \#if or \#ifdef directive to which they are related
MISRA2004-19_2=Non-standard characters should not occur in header file names in \#include directives
MISRA2004-19_3=The \#include directive shall be followed by either a <filename> or "filename" sequence
MISRA2004-19_4=Avoid keywords and basic types in macros
MISRA2004-19_5=Macros shall not be \#define'd or \#undef'd within a block
MISRA2004-19_6=\#undef shall not be used
MISRA2004-19_7=A function should be used in preference to a function-like macro
MISRA2004-19_8=A function-like macro shall not be invoked without all of its arguments
MISRA2004-19_9=Arguments to a function-like macro shall not contain tokens that look like preprocessing directives
MISRA2004-20_10=The library functions atof, atoi and atol from library stdlib.h shall not be used
MISRA2004-20_11=The 'abort()' function from the 'stdlib.h' or 'cstdlib' library shall not be used
MISRA2004-20_11_b=The 'exit()' function from the 'stdlib.h' or 'cstdlib' library shall not be used
MISRA2004-20_11_c=The 'getenv()' function from the 'stdlib.h' or 'cstdlib' library shall not be used
MISRA2004-20_11_d=The 'system()' function from the 'stdlib.h' or 'cstdlib' library shall not be used
MISRA2004-20_12=The standard header files <time.h> or <ctime> shall not be used
MISRA2004-20_12_b=The time handling functions and macros of the library <time.h> shall not be used
MISRA2004-20_12_c=The types defined in the library <time.h> shall not be used
MISRA2004-20_1_a=Do not \#define or \#undef identifiers with names which start with underscore
MISRA2004-20_1_b=Do not redefine reserved words
MISRA2004-20_1_c=Reserved identifiers, macros and functions in the standard library, shall not be defined, redefined or undefined (C90 code)
MISRA2004-20_1_e=Do not \#define nor \#undef identifier 'defined'
MISRA2004-20_2=The names of standard library macros, objects and functions shall not be reused
MISRA2004-20_2_a=The names of standard library macros, objects and functions shall not be reused (C90)
MISRA2004-20_2_b=The names of standard library macros, objects and functions shall not be reused (C99)
MISRA2004-20_3=The validity of values passed to library functions shall be checked
MISRA2004-20_4=Dynamic heap memory allocation shall not be used
MISRA2004-20_5=The error indicator 'errno' shall not be used
MISRA2004-20_6=The macro offsetof, in library stddef.h, shall not be used
MISRA2004-20_7=The facilities provided by <setjmp.h> should not be used
MISRA2004-20_7_b=The standard header files <setjmp.h> or <csetjmp> shall not be used
MISRA2004-20_8=The standard header files <signal.h> or <csignal> shall not be used
MISRA2004-20_8_b=The signal handling facilities of <signal.h> shall not be used
MISRA2004-20_9=The input/output library stdio.h shall not be used
MISRA2004-2_1=Assembly language shall be encapsulated and isolated
MISRA2004-2_2=Source code shall only use /* ... */ style comments
MISRA2004-2_3=The character sequence /* shall not be used within a C-style comment
MISRA2004-2_4=Sections of code should not be "commented out"
MISRA2004-3_4=All uses of the \#pragma directive shall be documented and explained
MISRA2004-3_5=Do not mix bit-fields and other data within the same structure
MISRA2004-4_1=Only those escape sequences that are defined in the ISO C standard shall be used
MISRA2004-4_2=Trigraphs shall not be used
MISRA2004-5_1_a=User-specified C external identifiers should differ in the first 31 characters
MISRA2004-5_1_b=User-specified C internal identifiers should differ from external identifiers in the first 31 characters
MISRA2004-5_1_c=User-specified C internal identifiers declared in the same scope should differ in the first 31 characters
MISRA2004-5_2_a=Identifier declared in a local or function prototype scope shall not hide an identifier declared in a global or namespace scope
MISRA2004-5_2_b=Identifiers declared in an inner local scope should not hide identifiers declared in an outer local scope
MISRA2004-5_3_a=Do not reuse typedef names
MISRA2004-5_3_b=Do not reuse typedef names as a typedef name
MISRA2004-5_4_a=A tag name shall not be reused for other purpose within the program
MISRA2004-5_4_b=A tag name shall not be reused to define a different tag
MISRA2004-5_4_c=The name of typedef should not be the same as the name of type that is typedef'd
MISRA2004-5_5_a=No object or function identifier with static storage duration should be reused
MISRA2004-5_5_b=No object or function identifier with static storage duration should be reused
MISRA2004-5_6=No identifier in one name space should have the same spelling as an identifier in another name space, with the exception of structure and union member names
MISRA2004-5_7=No identifier name should be reused
MISRA2004-6_1=The plain char type shall be used only for the storage and use of character values
MISRA2004-6_2=signed and unsigned char type shall be used only for the storage and use of numeric values
MISRA2004-6_3=typedefs to basic types should contain some digits in their name
MISRA2004-6_3_b=typedefs should be used in place of the basic types
MISRA2004-6_4=Bit fields shall only be defined to be of type unsigned int or signed int
MISRA2004-6_5=Named bit-fields with signed integer type shall have a length of more than one bit
MISRA2004-6_5_a=Unnamed bit-fields with signed integer type shall have a length of more than one bit
MISRA2004-7_1_a=Octal constants (other than zero) shall not be used
MISRA2004-7_1_b=Octal escape sequences shall not be used
MISRA2004-8_10=Objects or functions with external linkage shall be declared in a header file
MISRA2004-8_11=The static storage class specifier shall be used in definitions and declarations of objects and functions that have internal linkage
MISRA2004-8_12=When an array is declared with external linkage, its size shall be stated explicitly or defined implicitly by initialisation
MISRA2004-8_1_a=Functions shall have prototype declarations and the prototype shall be visible at both the function definition and call
MISRA2004-8_1_b=Functions shall always have visible prototype at the function call
MISRA2004-8_2_a=Whenever a function is declared or defined, its type shall be explicitly stated
MISRA2004-8_2_b=Whenever an object is declared or defined, its type shall be explicitly stated
MISRA2004-8_3_a=Use identical types in declaration and definition
MISRA2004-8_3_b=Use identical types in declaration and definition
MISRA2004-8_4=If objects or functions are declared more than once their types shall be compatible
MISRA2004-8_5=There shall be no definitions of objects or functions in a header file
MISRA2004-8_6=Always declare functions at file scope
MISRA2004-8_7=Objects shall be defined at block scope if they are only accessed from within a single function
MISRA2004-9_1=All automatic variables shall have been assigned a value before being used
MISRA2004-9_2=The initializer for an aggregate or union shall be enclosed in braces
MISRA2004-9_2_b=Arrays shall not be partially initialized
MISRA2004-9_2_c=The non-zero initialization of structures requires an explicit initializer for each element
MISRA2004-9_3=In an enumerator list, the "\=" construct shall not be used to explicitly initialise members other than the first, unless all items are explicitly initialised
MISRA2008=MISRA C++ 2008
MISRA2008-0_1_10=Every defined function with internal linkage shall be used
MISRA2008-0_1_11=There shall be no unused parameters (named or unnamed) in nonvirtual functions
MISRA2008-0_1_1_a=A project shall not contain unreachable code in 'else' block
MISRA2008-0_1_1_b=A project shall not contain unreachable code after 'return', 'break', 'continue', and 'goto' statements
MISRA2008-0_1_1_c=A project shall not contain unreachable code in 'if/else/while/for' block
MISRA2008-0_1_1_d=A project shall not contain unreachable code in switch statement
MISRA2008-0_1_1_e=A project shall not contain unreachable code in 'for' loop
MISRA2008-0_1_1_f=A project shall not contain unreachable code after 'if' or 'switch' statement outside 'for/while/catch' block
MISRA2008-0_1_1_g=A project shall not contain unreachable code after 'if' or 'switch' statement inside 'while/for/catch' block
MISRA2008-0_1_2_a=A project shall not contain infeasible paths
MISRA2008-0_1_2_b=A project shall not contain infeasible paths
MISRA2008-0_1_2_c=A project shall not contain infeasible paths
MISRA2008-0_1_2_d=A project shall not contain infeasible paths
MISRA2008-0_1_2_e=A project shall not contain infeasible paths
MISRA2008-0_1_2_f=A project shall not contain infeasible paths
MISRA2008-0_1_2_g=A project shall not contain infeasible paths
MISRA2008-0_1_2_h=A project shall not contain infeasible paths
MISRA2008-0_1_2_i=A project shall not contain infeasible paths
MISRA2008-0_1_2_j=A project shall not contain infeasible paths
MISRA2008-0_1_2_k=A project shall not contain infeasible paths
MISRA2008-0_1_2_l=A project shall not contain infeasible paths
MISRA2008-0_1_2_m=A project shall not contain infeasible paths
MISRA2008-0_1_2_n=A project shall not contain infeasible paths
MISRA2008-0_1_2_o=A project shall not contain infeasible paths
MISRA2008-0_1_2_p=A project shall not contain infeasible paths
MISRA2008-0_1_2_q=A project shall not contain infeasible paths
MISRA2008-0_1_2_r=A project shall not contain infeasible paths
MISRA2008-0_1_2_rz=A project shall not contain infeasible paths
MISRA2008-0_1_2_s=A project shall not contain infeasible paths
MISRA2008-0_1_2_sz=A project shall not contain infeasible paths
MISRA2008-0_1_2_t=A project shall not contain infeasible paths
MISRA2008-0_1_2_u=A project shall not contain infeasible paths
MISRA2008-0_1_2_v=A project shall not contain infeasible paths
MISRA2008-0_1_2_w=A project shall not contain infeasible paths
MISRA2008-0_1_2_x=A project shall not contain infeasible paths
MISRA2008-0_1_2_y=A project shall not contain infeasible paths
MISRA2008-0_1_2_z=A project shall not contain infeasible paths
MISRA2008-0_1_3_a=A project shall not contain unused variables
MISRA2008-0_1_3_b=A project shall not contain unused variables
MISRA2008-0_1_3_c=Eliminate unused private member variables
MISRA2008-0_1_3_e=A project should not contain unused variables with internal linkage
MISRA2008-0_1_7=The value returned by a function having a non-void return type that is not an overloaded operator shall always be used
MISRA2008-0_1_8=All functions with void return type shall have external side effect(s)
MISRA2008-0_1_8_b=All functions with void return type shall have external side effect(s)
MISRA2008-0_1_9=All non-null statements shall either have at least one side-effect however executed or cause control flow to change
MISRA2008-0_2_1_a=An object shall not be assigned to an overlapping object
MISRA2008-0_2_1_b=An object shall not be assigned to an overlapping object
MISRA2008-0_3_2=If a function generates error information, then that error information shall be tested
MISRA2008-0_4_2=Use of floating-point arithmetic shall be documented
MISRA2008-10_1_1=Classes should not be derived from virtual bases
MISRA2008-10_1_3=An accessible base class shall not be both virtual and non-virtual in the same hierarchy
MISRA2008-10_2_1=All accessible entity names within a multiple inheritance hierarchy should be unique
MISRA2008-10_3_1=There shall be no more than one definition of each virtual function on each path through the inheritance hierarchy
MISRA2008-10_3_2=Each overriding virtual function shall be declared with the virtual keyword
MISRA2008-10_3_3=A virtual function shall only be overridden by a pure virtual function if it is itself declared as pure virtual
MISRA2008-11_0_1=Member data in non-POD class types shall be private
MISRA2008-12_1_2=All constructors of a class should explicitly call a constructor for all of its immediate base classes and all virtual base classes
MISRA2008-12_1_3=All constructors that are callable with a single argument of fundamental type shall be declared explicit
MISRA2008-12_8_1=A copy constructor shall only initialize its base classes and the nonstatic members of the class of which it is a member
MISRA2008-12_8_2=The copy assignment operator shall be declared protected or private in an abstract class
MISRA2008-14_5_1=Do not declare non-member generic functions in associated namespaces
MISRA2008-14_5_2=A copy constructor shall be declared when there is a template constructor with a single parameter that is a generic parameter
MISRA2008-14_5_3=A copy assignment operator shall be declared when there is a template assignment operator with a parameter that is a generic parameter
MISRA2008-14_6_1=In a class template with a dependent base, any name that may be found in that dependent base shall be referred to using a qualified-id or this->
MISRA2008-14_6_2=The function shall resolve to a function declared previously in the translation unit
MISRA2008-14_7_3=All partial and explicit specializations for a template shall be declared in the same file as the declaration of their primary template
MISRA2008-14_8_1=Overloaded function templates shall not be explicitly specialized
MISRA2008-14_8_2=The viable function set for a function call should either contain no function specializations, or only contain function specializations
MISRA2008-15_0_2=An exception object should not have pointer type
MISRA2008-15_0_3=Control shall not be transferred into a try or catch block using a goto or a switch statement
MISRA2008-15_1_1=The assignment-expression of a throw statement shall not itself cause an exception to be thrown
MISRA2008-15_1_2=NULL shall not be thrown explicitly
MISRA2008-15_1_3=An empty throw (throw;) shall only be used in the compound statement of a catch handler
MISRA2008-15_3_1=Exceptions shall be raised only after start-up and before termination of the program
MISRA2008-15_3_2=There should be at least one exception handler to catch all otherwise unhandled exceptions
MISRA2008-15_3_3=Handlers of a function-try-block implementation of a class constructor or destructor shall not reference non-static members from this class or its bases
MISRA2008-15_3_4_a=Each exception explicitly thrown in the code shall have a handler of a compatible type in all call paths that could lead to that point
MISRA2008-15_3_4_b=Each exception explicitly thrown in the code shall have a handler of a compatible type in all call paths that could lead to that point
MISRA2008-15_3_5=A class type exception shall always be caught by reference
MISRA2008-15_3_6=Where multiple handlers are provided in a single try-catch statement or function-try-block for a derived class and some or all of its bases, the handlers shall be ordered most-derived to base class
MISRA2008-15_3_7=Where multiple handlers are provided in a single try-catch statement or function-try-block, any ellipsis (catch-all) handler shall occur last
MISRA2008-15_5_1=A class destructor shall not exit with an exception
MISRA2008-15_5_2=Where a function's declaration includes an exception-specification, the function shall only be capable of throwing exceptions of the indicated type(s)
MISRA2008-15_5_3=The execution of a function registered with 'std\:\:atexit()' or 'std\:\:at_quick_exit()' should not exit via an exception
MISRA2008-15_5_3_b=Never allow an exception to be thrown from a destructor, deallocation, and swap
MISRA2008-15_5_3_c=Do not throw from within destructor
MISRA2008-15_5_3_d=There should be at least one exception handler to catch all otherwise unhandled exceptions
MISRA2008-15_5_3_e=An empty throw (throw;) shall only be used in the compound-statement of a catch handler
MISRA2008-15_5_3_f=Exceptions shall be raised only after start-up and before termination of the program
MISRA2008-15_5_3_g=Each exception explicitly thrown in the code shall have a handler of a compatible type in all call paths that could lead to that point
MISRA2008-15_5_3_h=Where a function's declaration includes an exception-specification, the function shall only be capable of throwing exceptions of the indicated type(s)
MISRA2008-15_5_3_i=Function called in global or namespace scope shall not throw unhandled exceptions
MISRA2008-16_0_1=\#include directives in a file shall only be preceded by other preprocessor directives or comments
MISRA2008-16_0_2=Macros shall only be \#define'd or \#undef'd in the global namespace
MISRA2008-16_0_3=\#undef shall not be used
MISRA2008-16_0_4=Function-like macros shall not be defined
MISRA2008-16_0_5=Arguments to a function-like macro shall not contain tokens that look like preprocessing directives
MISRA2008-16_0_6=In the definition of a function-like macro, each instance of a parameter shall be enclosed in parentheses, unless it is used as the operand of \# or \#\#
MISRA2008-16_0_7_b=Do not use in preprocessor directives \#if and \#elif macros not defined in translation unit
MISRA2008-16_0_8=If the \# token appears as the first token on a line, then it shall be immediately followed by a preprocessing token
MISRA2008-16_1_1=The defined preprocessor operator shall only be used in one of the two standard forms
MISRA2008-16_1_2=All \#else, \#elif and \#endif preprocessor directives shall reside in the same file as the \#if or \#ifdef directive to which they are related
MISRA2008-16_2_1_a=Avoid using macro definitions
MISRA2008-16_2_1_b=The \#ifndef pre-processor directive will only be used to prevent multiple inclusions of the same header file
MISRA2008-16_2_1_c=The \#ifdef, \#else, \#elif preprocessor directives should not be used
MISRA2008-16_2_1_d=The \#endif pre-processor directives will only be used to prevent multiple inclusions of the same header file
MISRA2008-16_2_1_e=The \#if pre-processor directive will only be used to prevent multiple inclusions of the same header file
MISRA2008-16_2_1_f=\#error directive shall not be used
MISRA2008-16_2_1_g=The \#pragma directive shall not be used
MISRA2008-16_2_1_h=\#undef shall not be used
MISRA2008-16_2_2=C++ macros shall only be used for\: include guards, type qualifiers, or storage class specifiers
MISRA2008-16_2_3=Include guards shall be provided
MISRA2008-16_2_4=The ', ", /* or // characters shall not occur in a header file name
MISRA2008-16_2_5=The \\ character should not occur in a header file name
MISRA2008-16_2_6=The \#include directive shall be followed by either a <filename> or "filename" sequence
MISRA2008-16_3_1=There shall be at most one occurrence of the \# or \#\# operators in a single macro definition
MISRA2008-16_3_2=The \# and \#\# operators should not be used
MISRA2008-16_6_1=All uses of the \#pragma directive shall be documented
MISRA2008-17_0_1_a=Reserved identifiers, macros and functions in the standard library shall not be defined, redefined or undefined
MISRA2008-17_0_1_b=Reserved identifiers, macros and functions in the standard library shall not be defined, redefined or undefined
MISRA2008-17_0_1_c=Reserved identifiers, macros and functions in the standard library shall not be defined, redefined or undefined
MISRA2008-17_0_1_d=Reserved identifiers, macros and functions in the standard library shall not be defined, redefined or undefined
MISRA2008-17_0_1_e=Reserved identifiers, macros and functions in the standard library shall not be defined, redefined or undefined
MISRA2008-17_0_2=The names of standard library macros and objects shall not be reused
MISRA2008-17_0_3=The names of standard library functions shall not be overridden
MISRA2008-17_0_5=The setjmp macro and the longjmp function shall not be used
MISRA2008-17_0_5_b=The standard header file <setjmp.h> shall not be used
MISRA2008-18_0_1=The C library shall not be used
MISRA2008-18_0_2=The library functions atof, atoi and atol from library <cstdlib> shall not be used
MISRA2008-18_0_3=The library function 'abort' of <stdlib.h> shall not be used
MISRA2008-18_0_3_b=The library function 'exit' of <stdlib.h> shall not be used
MISRA2008-18_0_3_c=The library function 'getenv' of <stdlib.h> shall not be used
MISRA2008-18_0_3_d=The library function 'system' of <stdlib.h> shall not be used
MISRA2008-18_0_4=The standard header file <ctime> shall not be used
MISRA2008-18_0_4_b=The time handling functions and macros of library <ctime> shall not be used
MISRA2008-18_0_4_c=The types defined in the library <ctime> shall not be used
MISRA2008-18_0_5=The unbounded functions of library <cstring> shall not be used
MISRA2008-18_2_1=The macro offsetof shall not be used
MISRA2008-18_4_1=Dynamic heap memory allocation shall not be used
MISRA2008-18_7_1=The standard header file <csignal> shall not be used
MISRA2008-18_7_1_b=The signal handling facilities of <csignal> shall not be used
MISRA2008-19_3_1=The error indicator errno shall not be used
MISRA2008-27_0_1=The stream input/output library <cstdio> shall not be used
MISRA2008-2_10_1=Different identifiers shall be typographically unambiguous
MISRA2008-2_10_2_a=Identifiers declared in an inner scope shall not hide an identifier declared in an outer scope
MISRA2008-2_10_2_b=Identifiers declared in an inner scope shall not hide an identifier declared in an outer scope
MISRA2008-2_10_6_a=If an identifier refers to a type, it shall not also refer to an object or a function in the same scope
MISRA2008-2_10_6_b=If an identifier refers to a type, it shall not also refer to an object or a function in the same scope
MISRA2008-2_10_6_c=If an identifier refers to a type, it shall not also refer to an object or a function in the same scope
MISRA2008-2_13_1=Only those escape sequences that are defined in ISO/IEC 14882\:2003 shall be used
MISRA2008-2_13_2_a=Octal constants (other than zero) shall not be used
MISRA2008-2_13_2_b=Octal escape sequences (other than "\\0") shall not be used
MISRA2008-2_13_3=A "U" suffix shall be applied to all octal or hexadecimal integer literals of unsigned type
MISRA2008-2_13_4=Literal suffixes shall be upper case
MISRA2008-2_13_5=Narrow and wide string literals shall not be concatenated
MISRA2008-2_3_1=Trigraphs shall not be used
MISRA2008-2_5_1=Digraphs should not be used
MISRA2008-2_7_1=The character sequence /* shall not be used within a C-style comment
MISRA2008-2_7_2=Sections of code shall not be "commented out" using C-style comments
MISRA2008-2_7_3=Sections of code should not be "commented out" using C++ comments
MISRA2008-3_1_1=It shall be possible to include any header file in multiple translation units without violating the One Definition Rule
MISRA2008-3_1_2=Functions shall not be declared at block scope
MISRA2008-3_1_3=When an array is declared, its size shall either be stated explicitly or defined implicitly by initialization
MISRA2008-3_3_1=Objects or functions with external linkage shall be declared in a header file
MISRA2008-3_3_2=If a function has internal linkage then all re-declarations shall include the static storage class specifier
MISRA2008-3_4_1_a=An identifier declared to be an object or type shall be defined in a block that minimizes its visibility
MISRA2008-3_4_1_b=An identifier declared to be an object or type shall be defined in a block that minimizes its visibility
MISRA2008-3_9_1=The types used for an object, a function return type, or a function parameter shall be token-for-token identical in all declarations and re-declarations
MISRA2008-3_9_2=typedefs that indicate size and signedness should be used in place of the basic numerical types
MISRA2008-3_9_3=The underlying bit representations of floating-point values shall not be used
MISRA2008-4_10_1=NULL shall not be used as an integer value
MISRA2008-4_10_2=Literal zero (0) shall not be used as the null-pointer-constant
MISRA2008-4_5_1=Expressions with type bool shall not be used as operands to built-in operators other than the assignment operator \=, the logical operators &&, ||, \!, the equality operators \=\= and \!\=, the unary & operator, and the conditional operator
MISRA2008-4_5_2=Expressions with type enum shall not be used as operands to built-in operators other than [ ], \=, \=\=, \!\=, <, <\=, >, >\=, and the unary & operator
MISRA2008-4_5_3=Expressions with type (plain) char and wchar_t shall not be used as operands to built-in operators other than the assignment operator \=, the equality operators \=\= and \!\=, and the unary & operator
MISRA2008-5_0_10=If the bitwise operators ~ and << are applied to an operand with an underlying type of unsigned char or unsigned short, the result shall be immediately cast to the underlying type of the operand
MISRA2008-5_0_11=The plain char type shall only be used for the storage and use of character values
MISRA2008-5_0_12=signed char and unsigned char type shall only be used for the storage and use of numeric values
MISRA2008-5_0_13=The condition of an if-statement and the condition of an iteration-statement shall have type bool
MISRA2008-5_0_14=The first operand of a conditional-operator shall have type bool
MISRA2008-5_0_15=Array indexing shall be the only form of pointer arithmetic
MISRA2008-5_0_19=The declaration of objects shall contain no more than two levels of pointer indirection
MISRA2008-5_0_1_a=The value of an expression shall be the same under any order of evaluation that the standard permits
MISRA2008-5_0_1_b=The value of an expression shall be the same under any order of evaluation that the standard permits
MISRA2008-5_0_1_c=The value of an expression shall be the same under any order of evaluation that the standard permits
MISRA2008-5_0_1_d=The value of an expression shall be the same under any order of evaluation that the standard permits
MISRA2008-5_0_1_e=The value of an expression shall be the same under any order of evaluation that the standard permits
MISRA2008-5_0_1_f=The value of an expression shall be the same under any order of evaluation that the standard permits
MISRA2008-5_0_1_g=The value of an expression shall be the same under any order of evaluation that the standard permits
MISRA2008-5_0_20=Non-constant operands to a binary bitwise operator shall have the same underlying type
MISRA2008-5_0_21=Bitwise operators shall only be applied to operands of unsigned underlying type
MISRA2008-5_0_2_a=Limited dependence should be placed on C++ operator precedence rules in expressions
MISRA2008-5_0_2_b=Limited dependence should be placed on C++ operator precedence rules in expressions
MISRA2008-5_0_2_c=Limited dependence should be placed on C++ operator precedence rules in expressions
MISRA2008-5_0_2_d=Limited dependence should be placed on C++ operator precedence rules in expressions
MISRA2008-5_0_2_e=Limited dependence should be placed on C++ operator precedence rules in expressions
MISRA2008-5_0_2_f=Limited dependence should be placed on C++ operator precedence rules in expressions
MISRA2008-5_0_3_a=A cvalue expression shall not be implicitly converted to a different underlying type
MISRA2008-5_0_3_b=A cvalue expression shall not be implicitly converted to a different underlying type
MISRA2008-5_0_3_c=A cvalue expression shall not be implicitly converted to a different underlying type
MISRA2008-5_0_4_a=An implicit integral conversion shall not change the signedness of the underlying type
MISRA2008-5_0_5_a=There shall be no implicit floating-integral conversions
MISRA2008-5_0_5_b=There shall be no implicit floating-integral conversions
MISRA2008-5_0_6_a=An implicit integral or floating-point conversion shall not reduce the size of the underlying type
MISRA2008-5_0_6_b=An implicit integral or floating-point conversion shall not reduce the size of the underlying type
MISRA2008-5_0_6_c=An implicit integral or floating-point conversion shall not reduce the size of the underlying type
MISRA2008-5_0_7_a=There shall be no explicit floating-integral conversions of a cvalue expression
MISRA2008-5_0_7_b=There shall be no explicit floating-integral conversions of a cvalue expression
MISRA2008-5_0_8=An explicit integral or floating-point conversion shall not increase the size of the underlying type of a cvalue expression
MISRA2008-5_0_8_b=An explicit integral or floating-point conversion shall not increase the size of the underlying type of a cvalue expression
MISRA2008-5_0_9=An explicit integral conversion shall not change the signedness of the underlying type of a cvalue expression
MISRA2008-5_14_1=The right hand operand of a logical && or || operator shall not contain side effects
MISRA2008-5_17_1=The overloaded binary operator should be implemented in terms of its corresponding compound assignment operator
MISRA2008-5_18_1=The comma operator shall not be used
MISRA2008-5_19_1_a=Integer overflow or underflow in constant expression in '+', '-', '*' operator
MISRA2008-5_19_1_b=Integer overflow or underflow in constant expression in '<<' operator
MISRA2008-5_2_1=Each operand of a logical && or || shall be a postfix-expression
MISRA2008-5_2_10=The increment (++) and decrement (--) operators should not be mixed with arithmetic operators in an expression
MISRA2008-5_2_11=The && operator and the || operator shall not be overloaded
MISRA2008-5_2_11_b=The comma "," operator shall not be overloaded
MISRA2008-5_2_12=An identifier with array type passed as a function argument shall not decay to a pointer
MISRA2008-5_2_2=A pointer to a virtual base class shall only be cast to a pointer to a derived class by means of dynamic_cast
MISRA2008-5_2_3=Casts from a base class to a derived class should not be performed on polymorphic types
MISRA2008-5_2_4=C-style casts (other than void casts) and functional notation casts (other than explicit constructor calls) shall not be used
MISRA2008-5_2_5=A cast shall not remove any const or volatile qualification from the type of a pointer or reference
MISRA2008-5_2_6=A cast shall not convert a pointer to a function to any other pointer type, including a pointer to function type
MISRA2008-5_2_7=An object with pointer type shall not be converted to an unrelated pointer type, either directly or indirectly
MISRA2008-5_2_8=An object with integer type or pointer to void type shall not be converted to an object with pointer type
MISRA2008-5_2_9=A cast should not convert a pointer type to an integral type
MISRA2008-5_3_1=Each operand of the \! operator, the logical && or the logical || operators shall have type bool
MISRA2008-5_3_2=The unary minus operator shall not be applied to an expression whose underlying type is unsigned
MISRA2008-5_3_3=The unary & operator shall not be overloaded
MISRA2008-5_3_4=Evaluation of the operand to the sizeof operator shall not contain side effects
MISRA2008-5_3_4_b=Evaluation of the operand to the sizeof operator shall not contain side effects
MISRA2008-5_3_4_c=Evaluation of the operand to the sizeof operator shall not contain side effects
MISRA2008-5_8_1=The right hand operand of a shift operator shall lie between zero and one less than the width in bits of the underlying type of the left hand operand
MISRA2008-6_2_1=Assignment operators shall not be used in sub-expressions
MISRA2008-6_2_2=Floating-point expressions shall not be directly or indirectly tested for equality or inequality
MISRA2008-6_2_3=Before preprocessing, a null statement shall only occur on a line by itself; it may be followed by a comment, provided that the first character following the null statement is a white-space character
MISRA2008-6_3_1=The statement forming the body of a switch, while, do while or for statement shall be a compound statement
MISRA2008-6_4_1=An if ( condition ) construct shall be followed by a compound statement. The else keyword shall be followed by either a compound statement, or another if statement
MISRA2008-6_4_2=All if ... else if constructs shall be terminated with an else clause
MISRA2008-6_4_3_a=A switch statement shall be a well-formed switch statement
MISRA2008-6_4_3_b=A switch statement shall be a well-formed switch statement
MISRA2008-6_4_3_c=A switch statement shall be a well-formed switch statement
MISRA2008-6_4_3_d=A switch statement shall be a well-formed switch statement
MISRA2008-6_4_3_e=A switch statement shall be a well-formed switch statement
MISRA2008-6_4_4=A switch-label shall only be used when the most closely-enclosing compound statement is the body of a switch statement
MISRA2008-6_4_5=An unconditional throw or break statement shall terminate every non-empty switch-clause
MISRA2008-6_4_6=The final clause of a switch statement shall be the default-clause
MISRA2008-6_4_7=The condition of a switch statement shall not have bool type
MISRA2008-6_4_8=Every switch statement shall have at least one case-clause
MISRA2008-6_5_1=A for loop shall contain a single loop-counter which shall not have floating type
MISRA2008-6_5_2=If loop-counter is not modified by -- or ++, then, within condition, the loop-counter shall only be used as an operand to <\=, <, > or >\=
MISRA2008-6_5_3=The loop-counter shall not be modified within condition or statement
MISRA2008-6_5_4=The loop-counter shall be modified by one of\: --, ++, -\=n, or +\=n; where n remains constant for the duration of the loop
MISRA2008-6_5_5=A loop-control-variable other than the loop-counter shall not be modified within condition or expression
MISRA2008-6_5_6=A loop-control-variable other than the loop-counter which is modified in statement within a body of the loop shall have type bool
MISRA2008-6_6_1=Any label referenced by a goto statement shall be declared in the same block, or in a block enclosing the goto statement
MISRA2008-6_6_2=The goto statement shall jump to a label declared later in the same function body
MISRA2008-6_6_3=The continue statement shall only be used within a well-formed for loop
MISRA2008-6_6_4=For any iteration statement there shall be no more than one break or goto statement used for loop termination
MISRA2008-6_6_5=A function shall have a single point of exit at the end of the function
MISRA2008-7_1_1=Declare local variable as const whenever possible
MISRA2008-7_1_1_b=Declare parameters as const whenever possible
MISRA2008-7_1_2_a=A pointer parameter in a function shall be declared as pointer to const if the corresponding object is not modified
MISRA2008-7_1_2_b=A reference parameter in a function shall be declared as reference to const if the corresponding object is not modified
MISRA2008-7_1_2_c=Declare a type of parameter as typedef to pointer to const if the pointer is not used to modify the addressed object
MISRA2008-7_2_1=An expression with enum underlying type shall only have values corresponding to the enumerators of the enumeration
MISRA2008-7_3_1=The global namespace shall only contain main, namespace declarations and extern "C" declarations
MISRA2008-7_3_2=The identifier main shall not be used for a function other than the global function main
MISRA2008-7_3_3=There shall be no unnamed namespaces in header files
MISRA2008-7_3_4=using-directives shall not be used
MISRA2008-7_3_5=Multiple declarations for an identifier in the same namespace shall not straddle a using-declaration for that identifier
MISRA2008-7_3_6=using-directives and using-declarations (excluding class scope or function scope using-declarations) shall not be used in header files
MISRA2008-7_4_1=All usage of assembler shall be documented
MISRA2008-7_4_2=Assembler instructions shall only be introduced using the asm declaration
MISRA2008-7_4_3=Assembly language shall be encapsulated and isolated
MISRA2008-7_5_1=A function shall not return a reference or a pointer to an automatic variable (including parameters), defined within the function
MISRA2008-7_5_2_a=The address of an object with automatic storage shall not be assigned to another object that may persist after the first object has ceased to exist
MISRA2008-7_5_2_b=The address of an object with automatic storage shall not be assigned to another object that may persist after the first object has ceased to exist
MISRA2008-7_5_3=A function shall not return a reference or a pointer to a parameter that is passed by reference or const reference
MISRA2008-7_5_4=Functions should not call themselves, either directly or indirectly
MISRA2008-8_0_1=An init-declarator-list or a member-declarator-list shall consist of a single init-declarator or member-declarator respectively
MISRA2008-8_3_1=Parameters in an overriding virtual function shall either use the same default arguments as the function they override, or else shall not specify any default arguments
MISRA2008-8_4_1=Functions shall not be defined using the ellipsis notation
MISRA2008-8_4_2=The identifiers used for the parameters in a re-declaration of a function shall be identical to those in the declaration
MISRA2008-8_4_3=All exit paths from a function with non-void return type shall have an explicit return statement with an expression
MISRA2008-8_4_4=A function identifier shall either be used to call the function or it shall be preceded by '&'
MISRA2008-8_5_1=All variables shall have a defined value before they are used
MISRA2008-8_5_2=Braces shall be used to indicate and match the structure in the non-zero initialization of arrays and structures
MISRA2008-8_5_2_b=Arrays shall not be partially initialized
MISRA2008-8_5_2_c=Structures shall not be partially initialized
MISRA2008-8_5_3=In an enumerator list, the \= construct shall not be used to explicitly initialize members other than the first, unless all items are explicitly initialized
MISRA2008-9_3_1=const member functions shall not return non-const pointers or references to class-data
MISRA2008-9_3_2_a=Protected member functions shall not return non-const handles to class-data
MISRA2008-9_3_2_b=Public member functions shall not return non-const handles to class-data
MISRA2008-9_3_3=If a member function can be made static then it shall be made static, otherwise if it can be made const then it shall be made const
MISRA2008-9_5_1=Unions shall not be used
MISRA2008-9_6_2=Bit-fields shall be either bool type or an explicitly unsigned or signed integral type
MISRA2008-9_6_3=Bit-fields shall not have enum type
MISRA2008-9_6_4=Named bit-fields with signed integer type shall have a length of more than one bit
MISRA2012=MISRA C 2012 (Legacy)
MISRA2012-DIR=MISRA C 2012 Directives
MISRA2012-DIR-4_10=Precautions shall be taken in order to prevent the contents of a header file being included more than once
MISRA2012-DIR-4_12=Dynamic memory allocation shall not be used
MISRA2012-DIR-4_2=All usage of assembly language should be documented
MISRA2012-DIR-4_3=Assembly language shall be encapsulated and isolated
MISRA2012-DIR-4_4=Sections of code should not be "commented out"
MISRA2012-DIR-4_5=Identifiers in the same name space with overlapping visibility should be typographically unambiguous
MISRA2012-DIR-4_6_a=typedefs to basic types should contain some digits in their name
MISRA2012-DIR-4_6_b=typedefs should be used in place of the basic types
MISRA2012-DIR-4_6_c=Use typedefs from stdint.h instead of declaring your own in C99 code
MISRA2012-DIR-4_8=If a pointer to a structure or union is never dereferenced within a translation unit, then the implementation of the object should be hidden
MISRA2012-DIR-4_9=A function should be used in preference to a function-like macro where they are interchangeable
MISRA2012-RULE=MISRA C 2012 Rules
MISRA2012-RULE-10_1_a=An expression of essentially Boolean type should always be used where an operand is interpreted as a Boolean value
MISRA2012-RULE-10_1_b=An operand of essentially Boolean type should not be used where an operand is interpreted as a numeric value
MISRA2012-RULE-10_1_c=An operand of essentially character type should not be used where an operand is interpreted as a numeric value
MISRA2012-RULE-10_1_d=An operand of essentially enum type should not be used in an arithmetic operation
MISRA2012-RULE-10_1_e=Shift and bitwise operations should not be performed on operands of essentially signed or enum type
MISRA2012-RULE-10_1_f=An operand of essentially signed or enum type should not be used as right hand side operand to the bitwise shifting operator
MISRA2012-RULE-10_1_g=An operand of essentially unsigned type should not be used as the operand to the unary minus operator
MISRA2012-RULE-10_1_h=Floating-point expressions shall not be explicitly (syntactically) tested for equality (\=\=) or inequality (\!\=)
MISRA2012-RULE-10_2=Expressions of essentially character type shall not be used inappropriately in addition and subtraction operations
MISRA2012-RULE-10_3_a=The value of an expression shall not be assigned to an object with a narrower essential type
MISRA2012-RULE-10_3_b=The value of an expression shall not be assigned to an object of a different essential type category
MISRA2012-RULE-10_4_a=Both operands of an operator in which the usual arithmetic conversions are performed shall have the same essential type category
MISRA2012-RULE-10_4_b=The second and third operands of the ternary operator shall have the same essential type category
MISRA2012-RULE-10_5_a=The cast operation to essentially enumeration type is not allowed
MISRA2012-RULE-10_5_b=Do not cast from or to essentially Boolean type
MISRA2012-RULE-10_5_c=Do not use casts between essentially character types and essentially floating types
MISRA2012-RULE-10_6=The value of a composite expression shall not be assigned to an object with wider essential type
MISRA2012-RULE-10_7_a=If a composite expression is used as one operand of an operator in which the usual arithmetic conversions are performed then the other operand shall not have wider essential type
MISRA2012-RULE-10_7_b=If a composite expression is used as one (second or third) operand of a conditional operator then the other operand shall not have wider essential type
MISRA2012-RULE-10_8=The value of a composite expression shall not be cast to a different essential type category or a wider essential type
MISRA2012-RULE-11_10=The _Atomic qualifier shall not be applied to the incomplete type void
MISRA2012-RULE-11_1_a=Conversions shall not be performed between a pointer to a function and any other type
MISRA2012-RULE-11_1_b=Conversions shall not be performed between a pointer to a function and any other type
MISRA2012-RULE-11_2=Conversions shall not be performed between a pointer to an incomplete type and any other type
MISRA2012-RULE-11_3=A cast shall not be performed between a pointer to object type and a pointer to a different object type
MISRA2012-RULE-11_4=A conversion should not be performed between a pointer to object and an integer type
MISRA2012-RULE-11_5=A conversion should not be performed from pointer to void into pointer to object
MISRA2012-RULE-11_6=A cast shall not be performed between pointer to void and an arithmetic type
MISRA2012-RULE-11_7=A cast shall not be performed between pointer to object and a non-integer arithmetic type
MISRA2012-RULE-11_9_a=The macro NULL shall be the only permitted form of integer null pointer constant
MISRA2012-RULE-11_9_b=The macro NULL shall be the only permitted form of integer null pointer constant
MISRA2012-RULE-12_1_a=Use parentheses unless all operators in the expression are the same
MISRA2012-RULE-12_1_b=The operands of a logical && or || shall be primary-expressions
MISRA2012-RULE-12_1_c=Parenthesis shall be used with 'sizeof' statement
MISRA2012-RULE-12_3=The comma operator should not be used
MISRA2012-RULE-12_4_a=Integer overflow or underflow in constant expression in '+', '-', '*' operator
MISRA2012-RULE-12_4_b=Integer overflow or underflow in constant expression in '<<' operator
MISRA2012-RULE-12_5=The 'sizeof' operator shall not have an operand which is a function parameter declared as "array of type"
MISRA2012-RULE-12_6=Structure and union members of atomic objects shall not be directly accessed
MISRA2012-RULE-13_1_a=Initializer lists shall not contain persistent side effects
MISRA2012-RULE-13_2_a=The value of an expression shall be the same under any order of evaluation that the standard permits
MISRA2012-RULE-13_2_b=Don't write code that depends on the order of evaluation of function arguments
MISRA2012-RULE-13_2_c=Don't write code that depends on the order of evaluation of function designator and function arguments
MISRA2012-RULE-13_2_d=Don't write code that depends on the order of evaluation of expression that involves a function call
MISRA2012-RULE-13_2_e=Between sequence points an object shall have its stored value modified at most once by the evaluation of an expression
MISRA2012-RULE-13_2_f=Do not use more than one volatile in one expression
MISRA2012-RULE-13_2_g=Don't write code that depends on the order of evaluation of function calls
MISRA2012-RULE-13_2_h=The value of an expression with atomic type should be independent from thread interleaving
MISRA2012-RULE-13_3=A full expression containing an increment (++) or decrement (--) operator should have no other potential side effects other than that caused by the increment or decrement operator
MISRA2012-RULE-13_4=The result of an assignment operator should not be used
MISRA2012-RULE-13_5=The right hand operand of a logical && or || operator shall not contain persistent side effects
MISRA2012-RULE-13_6_a=The operand of the sizeof operator shall not contain any expression which has potential side effects
MISRA2012-RULE-13_6_b=The operand of the sizeof operator shall not contain any expression which has potential side effects
MISRA2012-RULE-13_6_c=The operand of the sizeof operator shall not contain any expression which has potential side effects
MISRA2012-RULE-14_1_a=A loop counter in a 'for' loop shall not have essentially floating type
MISRA2012-RULE-14_1_b=A loop counter in 'while' and 'do-while' loops shall not have essentially floating type
MISRA2012-RULE-14_2_a=There shall only be one loop counter in a 'for' loop, which shall not be modified in the 'for' loop body
MISRA2012-RULE-14_2_b=The first clause of a 'for' loop shall be well-formed
MISRA2012-RULE-14_2_c=The second clause of a 'for' loop shall be well-formed
MISRA2012-RULE-14_2_d=The third clause of a 'for' statement shall be well-formed
MISRA2012-RULE-14_4=The controlling expression of an if statement and the controlling expression of an iteration-statement shall have essentially Boolean type
MISRA2012-RULE-15_1=The goto statement should not be used
MISRA2012-RULE-15_2=The goto statement shall jump to a label declared later in the same function
MISRA2012-RULE-15_3=Any label referenced by a goto statement shall be declared in the same block, or in any block enclosing the goto statement
MISRA2012-RULE-15_4=There should be no more than one break or goto statement used to terminate any iteration statement
MISRA2012-RULE-15_5=A function should have a single point of exit at the end
MISRA2012-RULE-15_6_a=The body of an iteration-statement or a selection-statement shall be a compound-statement
MISRA2012-RULE-15_6_b=The body of an iteration-statement or a selection-statement shall be a compound-statement
MISRA2012-RULE-15_7=All 'if ... else if' constructs shall be terminated with an 'else' statement
MISRA2012-RULE-16_1_a=A switch statement shall only contain switch labels and switch clauses, and no other code
MISRA2012-RULE-16_1_b=A switch label shall only be used when the most closely-enclosing compound statement is the body of a switch statement
MISRA2012-RULE-16_1_c=An unconditional break statement shall terminate every non-empty case clause
MISRA2012-RULE-16_1_d=An unconditional break statement shall terminate every non-empty default clause
MISRA2012-RULE-16_1_e=Always provide a default branch for switch statements
MISRA2012-RULE-16_1_f=A 'default' label shall have a statement or a comment before terminating 'break'
MISRA2012-RULE-16_1_g=A 'default' label, if it exists, shall appear as either the first or the last switch label of a switch statement
MISRA2012-RULE-16_1_h=Every switch statement shall have at least two switch-clauses
MISRA2012-RULE-16_2=A switch label shall only be used when the most closely-enclosing compound statement is the body of a switch statement
MISRA2012-RULE-16_3_a=An unconditional break statement shall terminate every switch-clause
MISRA2012-RULE-16_3_b=An unconditional break statement shall terminate every switch-clause
MISRA2012-RULE-16_4_a=Every 'switch' statement shall have a 'default' label
MISRA2012-RULE-16_4_b=A 'default' label shall have a statement or a comment before terminating 'break'
MISRA2012-RULE-16_5=A default label shall appear as either the first or the last switch label of a switch statement
MISRA2012-RULE-16_6=Every switch statement shall have at least two switch-clauses
MISRA2012-RULE-16_7_a=A switch-expression shall not have essentially Boolean type
MISRA2012-RULE-16_7_b=A switch-expression shall not have essentially Boolean type
MISRA2012-RULE-17_10=A function declared with a _Noreturn function specifier shall have void return type
MISRA2012-RULE-17_12=A function identifier shall only be used with either a preceding &, or with a parenthesised parameter list
MISRA2012-RULE-17_13=A function type shall not be type qualified
MISRA2012-RULE-17_1_a=The features of <stdarg.h> shall not be used
MISRA2012-RULE-17_1_b=The features of <stdarg.h> shall not be used
MISRA2012-RULE-17_1_c=The standard header file <stdarg.h> shall not be used
MISRA2012-RULE-17_2=Functions shall not call themselves, either directly or indirectly
MISRA2012-RULE-17_3=A function shall not be declared implicitly
MISRA2012-RULE-17_4=All exit paths from a function with non-void return type shall have an explicit return statement with an expression
MISRA2012-RULE-17_4_b=All exit paths from a function, except main(), with non-void return type shall have an explicit return statement with an expression
MISRA2012-RULE-17_5=The function argument corresponding to a parameter declared to have an array type shall have an appropriate number of elements
MISRA2012-RULE-17_6=The declaration of an array parameter shall not contain the 'static' keyword between the [ ]
MISRA2012-RULE-17_7_a=The value returned by a function having non-void return type shall be used
MISRA2012-RULE-17_7_b=The value returned by a function having non-void return type shall be used
MISRA2012-RULE-17_8=A function parameter should not be modified
MISRA2012-RULE-18_10=Pointers to variably-modified array types should not be used
MISRA2012-RULE-18_4=The +, -, +\= and -\= operators should not be applied to an expression of pointer type
MISRA2012-RULE-18_5=Declarations should contain no more than two levels of pointer nesting
MISRA2012-RULE-18_6_a=The address of an object with automatic storage shall not be returned from a function
MISRA2012-RULE-18_6_b=The address of an object with automatic storage shall not be assigned to another object that may persist after the first object has ceased to exist
MISRA2012-RULE-18_6_c=The address of an object with thread storage duration shall not be assigned to an object with static storage duration
MISRA2012-RULE-18_7=Flexible array members shall not be declared
MISRA2012-RULE-18_8=Variable-length arrays should not be used
MISRA2012-RULE-18_9=An object shall not be used outside its lifetime
MISRA2012-RULE-19_1_a=An object shall not be assigned or copied to an overlapping object
MISRA2012-RULE-19_1_b=An object shall not be assigned or copied to an overlapping object
MISRA2012-RULE-19_2=The union keyword should not be used
MISRA2012-RULE-1_1_a_c90=A program should not exceed the translation limits imposed by The Standard (c90)
MISRA2012-RULE-1_1_a_c99=A program should not exceed the translation limits imposed by The Standard (c99)
MISRA2012-RULE-1_1_b_c90=A program should not exceed the translation limits imposed by The Standard (c90)
MISRA2012-RULE-1_1_b_c99=A program should not exceed the translation limits imposed by The Standard (c99)
MISRA2012-RULE-1_3_f=The value of an expression shall be the same under any order of evaluation that the standard permits
MISRA2012-RULE-1_3_g=Don't write code that depends on the order of evaluation of function arguments
MISRA2012-RULE-1_3_h=Don't write code that depends on the order of evaluation of function designator and function arguments
MISRA2012-RULE-1_3_i=Don't write code that depends on the order of evaluation of expression that involves a function call
MISRA2012-RULE-1_3_j=Between sequence points an object shall have its stored value modified at most once by the evaluation of an expression
MISRA2012-RULE-1_3_k=Do not use more than one volatile in one expression
MISRA2012-RULE-1_3_l=Don't write code that depends on the order of evaluation of function calls
MISRA2012-RULE-1_3_m=A function shall not return a pointer or reference to a non-static local object
MISRA2012-RULE-1_3_n=The address of an object with automatic storage shall not be assigned to an object which persists after the object has ceased to exist
MISRA2012-RULE-1_3_o=The left-hand operand of a right-shift operator shall not have a negative value
MISRA2012-RULE-1_4_j=The '__STDC_WANT_LIB_EXT1__' macro should not be defined to the value other than '0'
MISRA2012-RULE-1_4_k=The 'rsize_t' type should not be used
MISRA2012-RULE-1_4_l=The 'errno_t' type should not be used
MISRA2012-RULE-1_4_m=Do not use following macros\: RSIZE_MAX, L_tmpnam_s, TMP_MAX_S
MISRA2012-RULE-1_4_n=Do not use the functions defined in Annex K of ISO/IEC 9899\:2011 standard
MISRA2012-RULE-1_5=The static storage class specifier shall be used in definitions and declarations of objects and functions that have internal linkage
MISRA2012-RULE-1_5_b=Storage type modifiers shall be associated with the type, not the variable or the function
MISRA2012-RULE-1_5_c=Function types shall be in prototype form
MISRA2012-RULE-1_5_d=Do not use macro ATOMIC_VAR_INIT
MISRA2012-RULE-1_5_e=Do not use 'bool', 'false' or 'true' identifiers in the \#undef directive
MISRA2012-RULE-20_1=\#include directives should only be preceded by preprocessor directives or comments
MISRA2012-RULE-20_10=The \# and \#\# preprocessor operators should not be used
MISRA2012-RULE-20_11=A macro parameter immediately following a \# operator shall not immediately be followed by a \#\# operator
MISRA2012-RULE-20_12=A macro parameter used as an operand to the \# or \#\# operators, which is itself subject to further macro replacement, shall only be used as an operand to these operators
MISRA2012-RULE-20_13=A line whose first token is \# shall be a valid preprocessing directive
MISRA2012-RULE-20_14=All \#else, \#elif and \#endif preprocessor directives shall reside in the same file as the \#if, \#ifdef or \#ifndef directive to which they are related
MISRA2012-RULE-20_2_a=The ', & or \\ characters and the /* or // character sequences shall not occur in a header file name
MISRA2012-RULE-20_2_b=The ', & or \\ characters and the /* or // character sequences shall not occur in a header file name
MISRA2012-RULE-20_3=The \#include directive shall be followed by either a <filename> or "filename" sequence
MISRA2012-RULE-20_4_a=A macro shall not be defined with the same name as a keyword
MISRA2012-RULE-20_4_b=A macro shall not be defined with the same name as a keyword
MISRA2012-RULE-20_5=\#undef should not be used
MISRA2012-RULE-20_6=Tokens that look like a preprocessing directive shall not occur within a macro argument
MISRA2012-RULE-20_7=Expressions resulting from the expansion of macro parameters shall be enclosed in parentheses
MISRA2012-RULE-20_8=The controlling expression of a \#if or \#elif preprocessing directive shall evaluate to 0 or 1
MISRA2012-RULE-20_9_b=All identifiers used in the controlling expression of \#if or \#elif preprocessing directives shall be \#define'd before evaluation
MISRA2012-RULE-21_10=The standard header file <time.h> shall not be used
MISRA2012-RULE-21_10_b=The time handling functions and macros of library <time.h> shall not be used
MISRA2012-RULE-21_10_c=The types defined in the library <time.h> shall not be used
MISRA2012-RULE-21_11=The standard header file <tgmath.h> shall not be used
MISRA2012-RULE-21_12=The features provided by <fenv.h> should not be used
MISRA2012-RULE-21_12_b=The standard header file <fenv.h> shall not be used
MISRA2012-RULE-21_15=The pointer arguments to the Standard Library functions 'memcmp', 'memmove' and 'memcmp' shall be pointers to qualified or unqualified versions of compatible types
MISRA2012-RULE-21_16=The pointer arguments to the Standard Library function 'memcmp' shall point to either a pointer type, an essentially signed type, an essentially unsigned type, an essentially Boolean type or an essentially enum type
MISRA2012-RULE-21_19_a=The pointers returned by the Standard Library functions 'localeconv', 'getenv', 'setlocale' or, 'strerror' shall only be used as if they have pointer to const-qualified type
MISRA2012-RULE-21_19_b=Strings pointed by members of the structure 'lconv' should not be modified
MISRA2012-RULE-21_1_a=Do not \#define or \#undef identifiers with names which start with underscore
MISRA2012-RULE-21_1_b=\#define and \#undef shall not be used on a reserved identifier or reserved macro name (for C90 code)
MISRA2012-RULE-21_1_c=\#define and \#undef shall not be used on a reserved identifier or reserved macro name (for C99 code)
MISRA2012-RULE-21_1_d=Do not \#define nor \#undef identifier 'defined'
MISRA2012-RULE-21_21=The library function 'system' of <stdlib.h> shall not be used
MISRA2012-RULE-21_22=All arguments to any type-generic macros declared in <tgmath.h> shall have appropriate essential type
MISRA2012-RULE-21_23=All arguments to any multi-argument type-generic macros declared in <tgmath.h> shall have the same standard type
MISRA2012-RULE-21_24=The random number generator functions of  <stdlib.h> shall not be used
MISRA2012-RULE-21_25=Only 'memory_order_seq_cst' should be used as an explicit memory order argument
MISRA2012-RULE-21_2_a=An identifier with name which starts with underscore shall not be declared
MISRA2012-RULE-21_2_b=A reserved identifier or macro name shall not be declared (for C90 code)
MISRA2012-RULE-21_2_c=A reserved identifier or macro name shall not be declared (for C99 code)
MISRA2012-RULE-21_3=The memory allocation and deallocation functions of <stdlib.h> shall not be used
MISRA2012-RULE-21_4_a=The standard header file <setjmp.h> shall not be used
MISRA2012-RULE-21_4_b=The standard header file <setjmp.h> shall not be used
MISRA2012-RULE-21_5_a=The standard header file <signal.h> shall not be used
MISRA2012-RULE-21_5_b=The standard header file <signal.h> shall not be used
MISRA2012-RULE-21_6=The Standard Library input/output functions shall not be used
MISRA2012-RULE-21_7=The atof, atoi, atol and atoll functions of <stdlib.h> shall not be used
MISRA2012-RULE-21_8=The library function 'abort' of <stdlib.h> shall not be used
MISRA2012-RULE-21_8_b=The library function 'exit' of <stdlib.h> shall not be used
MISRA2012-RULE-21_8_c=The library functions 'quick_exit' and '_Exit' of <stdlib.h> shall not be used
MISRA2012-RULE-21_9=The library functions bsearch and qsort of <stdlib.h> shall not be used
MISRA2012-RULE-22_12=Thread objects, thread synchronization objects, and thread-specific storage pointers shall only be accessed by the appropriate Standard Library functions
MISRA2012-RULE-22_14_b=The second argument passed to the 'mtx_init()' function call should be either 'mtx_plain', 'mtx_timed', 'mtx_plain | mtx_recursive', or 'mtx_timed | mtx_recursive'
MISRA2012-RULE-22_5_a=A pointer to a FILE object shall not be dereferenced
MISRA2012-RULE-22_5_b=A pointer to a FILE object shall not be dereferenced by a library function
MISRA2012-RULE-23_1=A generic selection should only be expanded from a macro
MISRA2012-RULE-23_1_b=A generic selection used in a macro definition should have a macro parameter in the controlling expression
MISRA2012-RULE-23_2=A generic selection that is not expanded from a macro shall not contain potential side effects in the controlling expression
MISRA2012-RULE-23_3=A generic selection should contain at least one non-default association
MISRA2012-RULE-23_4=A generic association shall list an appropriate type
MISRA2012-RULE-23_5=A generic selection should not depend on implicit pointer type conversion
MISRA2012-RULE-23_6=The controlling expression of a generic selection shall have an essential type that matches its standard type
MISRA2012-RULE-23_6_b=Enumerated types should not be mixed with integer types in generic selections
MISRA2012-RULE-23_7=A generic selection that is expanded from a macro should evaluate its argument only once
MISRA2012-RULE-23_8=A default association shall appear as either the first or the last association of a generic selection
MISRA2012-RULE-2_1_a=There shall be no unreachable code in 'else' block
MISRA2012-RULE-2_1_b=There shall be no unreachable code after 'return', 'break', 'continue', and 'goto' statements
MISRA2012-RULE-2_1_c=There shall be no unreachable code in 'if', 'else', 'while', 'for' block
MISRA2012-RULE-2_1_d=There shall be no unreachable code in 'switch' statement
MISRA2012-RULE-2_1_e=There shall be no unreachable code in 'for' loop
MISRA2012-RULE-2_1_f=There shall be no unreachable code after 'if' or 'switch' statement
MISRA2012-RULE-2_1_g=There shall be no unreachable code after 'if' or 'switch' statement inside 'while'/'for'/'do...while' loop
MISRA2012-RULE-2_2_a=All non-null statements shall either have at least one side-effect however executed or cause control flow to change
MISRA2012-RULE-2_3_a=A function should not contain unused type declarations
MISRA2012-RULE-2_3_b=A source file should not contain unused type declarations
MISRA2012-RULE-2_4_a=A function should not contain unused local tag declarations
MISRA2012-RULE-2_4_b=A source file should not contain unused tag declarations
MISRA2012-RULE-2_5=A source file should not contain unused macro definitions
MISRA2012-RULE-2_6=A function should not contain unused label declarations
MISRA2012-RULE-2_7=There should be no unused parameters in functions
MISRA2012-RULE-2_8_b=A project should not contain unused variables with internal linkage
MISRA2012-RULE-2_8_c=Avoid unused local variables
MISRA2012-RULE-3_1_a=The character sequence /* shall not be used within a C-style comment
MISRA2012-RULE-3_1_b=The character sequence // shall not be used within a C-style comment
MISRA2012-RULE-3_1_c=The character sequence /* shall not be used within a C++-style comment
MISRA2012-RULE-3_2=Line-splicing shall not be used in // comments
MISRA2012-RULE-4_1=Octal and hexadecimal escape sequences shall be terminated
MISRA2012-RULE-4_2=Trigraphs should not be used
MISRA2012-RULE-5_1=External identifiers shall be distinct
MISRA2012-RULE-5_2_a_c90=Identifiers declared in the file scope and in the same name space shall be distinct (c90)
MISRA2012-RULE-5_2_a_c99=Identifiers declared in the file scope and in the same name space shall be distinct (c99)
MISRA2012-RULE-5_2_b_c90=Identifiers declared in the same block scope and name space shall be distinct (c90)
MISRA2012-RULE-5_2_b_c99=Identifiers declared in the same block scope and name space shall be distinct (c99)
MISRA2012-RULE-5_3_a=An identifier declared in an inner scope shall not hide an identifier declared in an outer scope
MISRA2012-RULE-5_3_b=An identifier declared in an inner scope shall not hide an identifier declared in an outer scope
MISRA2012-RULE-5_4_a_c90=The name of a macro should be distinct from the names of its parameters(c90)
MISRA2012-RULE-5_4_a_c99=The name of a macro should be distinct from the names of its parameters(c99)
MISRA2012-RULE-5_4_b_c90=The name of a macro should be distinct from the names of other macros that are currently defined(c90)
MISRA2012-RULE-5_4_b_c99=The name of a macro should be distinct from the names of other macros that are currently defined(c99)
MISRA2012-RULE-5_5_c90=Identifiers shall be distinct from macro names (c90)
MISRA2012-RULE-5_5_c99=Identifiers shall be distinct from macro names (c99)
MISRA2012-RULE-6_1=Bit-fields shall only be declared with an appropriate type
MISRA2012-RULE-6_2=Single-bit named bit fields shall not be of a signed type
MISRA2012-RULE-6_3=A bit field shall not be declared as a member of a union
MISRA2012-RULE-7_1=Octal constants shall not be used
MISRA2012-RULE-7_2=A 'u' or 'U' suffix shall be applied to all integer constants that are represented in an unsigned type
MISRA2012-RULE-7_3=The lowercase character 'l' shall not be used in a literal suffix
MISRA2012-RULE-7_4=A string literal shall not be assigned to an object unless the object's type is pointer to const-qualified char
MISRA2012-RULE-7_5=The argument of an integer-constant macro shall have an appropriate form
MISRA2012-RULE-7_6=The small integer variants of the minimum-width integer constant macros should not be used
MISRA2012-RULE-8_10=An inline function shall be declared with the static storage class
MISRA2012-RULE-8_11=When an array with external linkage is declared, its size should be explicitly specified
MISRA2012-RULE-8_12=Within an enumerator list, the value of an implicitly-specified enumeration constant shall be unique
MISRA2012-RULE-8_13_a=A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify the addressed object
MISRA2012-RULE-8_13_b=Declare a type of parameter as typedef to pointer to const if the pointer is not used to modify the addressed object
MISRA2012-RULE-8_14=The restrict type qualifier shall not be used
MISRA2012-RULE-8_15_b=All declarations of an object with internal linkage and an explicit alignment specification shall specify the same alignment
MISRA2012-RULE-8_16=The alignment specification of zero should not appear in an object declaration
MISRA2012-RULE-8_17=At most one explicit alignment specifier should appear in an object declaration
MISRA2012-RULE-8_1_a=Whenever a function is declared or defined, its type shall be explicitly stated
MISRA2012-RULE-8_1_b=Whenever an object is declared or defined, its type shall be explicitly stated
MISRA2012-RULE-8_2_a=Identifiers shall be given for all of the parameters in a function prototype declaration
MISRA2012-RULE-8_2_b=Function types shall have named parameters
MISRA2012-RULE-8_2_c=Function types shall be in prototype form
MISRA2012-RULE-8_3_a=If objects or functions are declared more than once their types shall be compatible
MISRA2012-RULE-8_3_b=The identifiers used in the declaration and definition of a function shall be identical
MISRA2012-RULE-8_4_a=A compatible declaration shall be visible when an object or function with external linkage is defined
MISRA2012-RULE-8_4_b=A compatible declaration shall be visible when an object or function with external linkage is defined
MISRA2012-RULE-8_5=An external object or function shall not have more than one non-defining declaration in translation unit
MISRA2012-RULE-8_8=The static storage class specifier shall be used in all declarations of objects and functions that have internal linkage
MISRA2012-RULE-8_9=An object should be defined at block scope if its identifier only appears in a single function
MISRA2012-RULE-9_2=The initializer for an aggregate or union shall be enclosed in braces
MISRA2012-RULE-9_3=Arrays shall not be partially initialized
MISRA2012-RULE-9_4=An element of an object shall not be initialized more than once
MISRA2012-RULE-9_5=Where designated initializers are used to initialize an array object the size of the array shall be specified explicitly
MISRA2012-RULE-9_6=An initializer using chained designators shall not contain initializers without designators
MISRAC2012=MISRA C 2023 (MISRA C 2012)
MISRAC2012-DIR_4_10=Dir 4.10 (Required) Precautions shall be taken in order to prevent the contents of a header file being included more than once
MISRAC2012-DIR_4_10-a=Use multiple include guards
MISRAC2012-DIR_4_12=Dir 4.12 (Required) Dynamic memory allocation shall not be used
MISRAC2012-DIR_4_12-a=Dynamic heap memory allocation shall not be used
MISRAC2012-DIR_4_2=Dir 4.2 (Advisory) All usage of assembly language should be documented
MISRAC2012-DIR_4_2-a=All usage of assembler shall be documented
MISRAC2012-DIR_4_3=Dir 4.3 (Required) Assembly language shall be encapsulated and isolated
MISRAC2012-DIR_4_3-a=Assembly language shall be encapsulated and isolated
MISRAC2012-DIR_4_4=Dir 4.4 (Advisory) Sections of code should not be "commented out"
MISRAC2012-DIR_4_4-a=Sections of code should not be "commented out"
MISRAC2012-DIR_4_5=Dir 4.5 (Advisory) Identifiers in the same name space with overlapping visibility should be typographically unambiguous
MISRAC2012-DIR_4_5-a=Identifiers in the same name space with overlapping visibility should be typographically unambiguous
MISRAC2012-DIR_4_6=Dir 4.6 (Advisory) typedefs that indicate size and signedness should be used in place of the basic numerical types
MISRAC2012-DIR_4_6-a=typedefs to basic types should contain some digits in their name
MISRAC2012-DIR_4_6-b=typedefs should be used in place of the basic types
MISRAC2012-DIR_4_6-c=Use typedefs from stdint.h instead of declaring your own in C99 code
MISRAC2012-DIR_4_8=Dir 4.8 (Advisory) If a pointer to a structure or union is never dereferenced within a translation unit, then the implementation of the object should be hidden
MISRAC2012-DIR_4_8-a=If a pointer to a structure or union is never dereferenced within a translation unit, then the implementation of the object should be hidden
MISRAC2012-DIR_4_9=Dir 4.9 (Advisory) A function should be used in preference to a function-like macro where they are interchangeable
MISRAC2012-DIR_4_9-a=A function should be used in preference to a function-like macro
MISRAC2012-RULE_10_1=Rule 10.1 (Required) Operands shall not be of an inappropriate essential type
MISRAC2012-RULE_10_1-a=An expression of essentially Boolean type should always be used where an operand is interpreted as a Boolean value
MISRAC2012-RULE_10_1-b=An operand of essentially Boolean type should not be used where an operand is interpreted as a numeric value
MISRAC2012-RULE_10_1-c=An operand of essentially character type should not be used where an operand is interpreted as a numeric value
MISRAC2012-RULE_10_1-d=An operand of essentially enum type should not be used in an arithmetic operation
MISRAC2012-RULE_10_1-e=Shift and bitwise operations should not be performed on operands of essentially signed or enum type
MISRAC2012-RULE_10_1-f=An operand of essentially signed or enum type should not be used as the right hand operand to the bitwise shifting operator
MISRAC2012-RULE_10_1-g=An operand of essentially unsigned type should not be used as the operand to the unary minus operator
MISRAC2012-RULE_10_1-h=Floating-point expressions shall not be explicitly (syntactically) tested for equality (\=\=) or inequality (\!\=)
MISRAC2012-RULE_10_2=Rule 10.2 (Required) Expressions of essentially character type shall not be used inappropriately in addition and subtraction operations
MISRAC2012-RULE_10_2-a=Expressions of essentially character type shall not be used inappropriately in addition and subtraction operations
MISRAC2012-RULE_10_3=Rule 10.3 (Required) The value of an expression shall not be assigned to an object with a narrower essential type or of a different essential type category
MISRAC2012-RULE_10_3-a=The value of an expression shall not be assigned to an object with a narrower essential type
MISRAC2012-RULE_10_3-b=The value of an expression shall not be assigned to an object of a different essential type category
MISRAC2012-RULE_10_4=Rule 10.4 (Required) Both operands of an operator in which the usual arithmetic conversions are performed shall have the same essential type category
MISRAC2012-RULE_10_4-a=Both operands of an operator in which the usual arithmetic conversions are performed shall have the same essential type category
MISRAC2012-RULE_10_4-b=The second and third operands of the ternary operator shall have the same essential type category
MISRAC2012-RULE_10_5=Rule 10.5 (Advisory) The value of an expression should not be cast to an inappropriate essential type
MISRAC2012-RULE_10_5-a=The cast operation to essentially enumeration type is not allowed
MISRAC2012-RULE_10_5-b=Do not cast from or to essentially Boolean type
MISRAC2012-RULE_10_5-c=Do not use casts between essentially character types and essentially floating types
MISRAC2012-RULE_10_6=Rule 10.6 (Required) The value of a composite expression shall not be assigned to an object with wider essential type
MISRAC2012-RULE_10_6-a=The value of a composite expression shall not be assigned to an object with wider essential type
MISRAC2012-RULE_10_7=Rule 10.7 (Required) If a composite expression is used as one operand of an operator in which the usual arithmetic conversions are performed then the other operand shall not have wider essential type
MISRAC2012-RULE_10_7-a=If a composite expression is used as one operand of an operator in which the usual arithmetic conversions are performed then the other operand shall not have wider essential type
MISRAC2012-RULE_10_7-b=If a composite expression is used as one (second or third) operand of a conditional operator then the other operand shall not have wider essential type
MISRAC2012-RULE_10_8=Rule 10.8 (Required) The value of a composite expression shall not be cast to a different essential type category or a wider essential type
MISRAC2012-RULE_10_8-a=The value of a composite expression shall not be cast to a different essential type category or a wider essential type
MISRAC2012-RULE_11_1=Rule 11.1 (Required) Conversions shall not be performed between a pointer to a function and any other type
MISRAC2012-RULE_11_1-a=Conversions shall not be performed between a pointer to a function and any other type than pointer to function
MISRAC2012-RULE_11_1-b=Conversions shall not be performed between non compatible pointer to a function types
MISRAC2012-RULE_11_10=Rule 11.10 (Required) The _Atomic qualifier shall not be applied to the incomplete type void
MISRAC2012-RULE_11_10-a=The '_Atomic' qualifier should not be used with the 'void' type
MISRAC2012-RULE_11_2=Rule 11.2 (Required) Conversions shall not be performed between a pointer to an incomplete type and any other type
MISRAC2012-RULE_11_2-a=Conversions shall not be performed between a pointer to an incomplete type and any other type
MISRAC2012-RULE_11_3=Rule 11.3 (Required) A conversion shall not be performed between a pointer to object type and a pointer to a different object type
MISRAC2012-RULE_11_3-a=A cast shall not be performed between a pointer to object type and a pointer to a different object type
MISRAC2012-RULE_11_4=Rule 11.4 (Advisory) A conversion should not be performed between a pointer to object and an integer type
MISRAC2012-RULE_11_4-a=A conversion should not be performed between a pointer to object and an integer type
MISRAC2012-RULE_11_5=Rule 11.5 (Advisory) A conversion should not be performed from pointer to void into pointer to object
MISRAC2012-RULE_11_5-a=A conversion should not be performed from pointer to void into pointer to object
MISRAC2012-RULE_11_6=Rule 11.6 (Required) A cast shall not be performed between pointer to void and an arithmetic type
MISRAC2012-RULE_11_6-a=A cast shall not be performed between pointer to void and an arithmetic type
MISRAC2012-RULE_11_7=Rule 11.7 (Required) A cast shall not be performed between pointer to object and a non-integer arithmetic type
MISRAC2012-RULE_11_7-a=A cast shall not be performed between pointer to object and a non-integer arithmetic type
MISRAC2012-RULE_11_9=Rule 11.9 (Required) The macro NULL shall be the only permitted form of integer null pointer constant
MISRAC2012-RULE_11_9-a=Literal zero (0) shall not be used as the null-pointer-constant
MISRAC2012-RULE_11_9-b=Use NULL instead of literal zero (0) as the null-pointer-constant
MISRAC2012-RULE_12_1=Rule 12.1 (Advisory) The precedence of operators within expressions should be made explicit
MISRAC2012-RULE_12_1-a=Use parentheses unless all operators in the expression are the same
MISRAC2012-RULE_12_1-b=The operands of a logical && or || shall be primary-expressions
MISRAC2012-RULE_12_1-c=The operand of the 'sizeof' operator should be enclosed in parentheses
MISRAC2012-RULE_12_3=Rule 12.3 (Advisory) The comma operator should not be used
MISRAC2012-RULE_12_3-a=The comma operator shall not be used
MISRAC2012-RULE_12_4=Rule 12.4 (Advisory) Evaluation of constant expressions should not lead to unsigned integer wrap-around
MISRAC2012-RULE_12_4-a=Integer overflow or underflow in constant expression in '+', '-', '*' operator
MISRAC2012-RULE_12_4-b=Integer overflow or underflow in constant expression in '<<' operator
MISRAC2012-RULE_12_5=Rule 12.5 (Mandatory) The sizeof operator shall not have an operand which is a function parameter declared as "array of type"
MISRAC2012-RULE_12_5-a=The 'sizeof' operator shall not have an operand which is a function parameter declared as "array of type"
MISRAC2012-RULE_12_6=Rule 12.6 (Required) Structure and union members of atomic objects shall not be directly accessed
MISRAC2012-RULE_12_6-a=Members of atomic objects of structure and union types should not be directly accessed
MISRAC2012-RULE_13_1=Rule 13.1 (Required) Initializer lists shall not contain persistent side effects
MISRAC2012-RULE_13_1-a=Initializer lists shall not contain persistent side effects
MISRAC2012-RULE_13_2=Rule 13.2 (Required) The value of an expression and its persistent side effects shall be the same under all permitted evaluation orders and shall be independent from thread interleaving
MISRAC2012-RULE_13_2-a=The value of an expression shall be the same under any order of evaluation that the standard permits
MISRAC2012-RULE_13_2-b=Don't write code that depends on the order of evaluation of function arguments
MISRAC2012-RULE_13_2-c=Don't write code that depends on the order of evaluation of function designator and function arguments
MISRAC2012-RULE_13_2-d=Don't write code that depends on the order of evaluation of expression that involves a function call
MISRAC2012-RULE_13_2-e=Between sequence points an object shall have its stored value modified at most once by the evaluation of an expression
MISRAC2012-RULE_13_2-f=Do not use more than one volatile between two adjacent sequence points
MISRAC2012-RULE_13_2-g=Don't write code that depends on the order of evaluation of function calls
MISRAC2012-RULE_13_2-h=The value of an expression with atomic type should be independent from thread interleaving
MISRAC2012-RULE_13_3=Rule 13.3 (Advisory) A full expression containing an increment (++) or decrement (--) operator should have no other potential side effects other than that caused by the increment or decrement operator
MISRAC2012-RULE_13_3-a=A full expression containing an increment (++) or decrement (--) operator should have no other potential side effects
MISRAC2012-RULE_13_4=Rule 13.4 (Advisory) The result of an assignment operator should not be used
MISRAC2012-RULE_13_4-a=The result of a built-in assignment operator should not be used
MISRAC2012-RULE_13_5=Rule 13.5 (Required) The right hand operand of a logical && or || operator shall not contain persistent side effects
MISRAC2012-RULE_13_5-a=The right-hand operand of a logical && or || operator shall not contain side effects
MISRAC2012-RULE_13_6=Rule 13.6 (Required) The operand of the sizeof operator shall not contain any expression which has potential side effects
MISRAC2012-RULE_13_6-a=The operand of the sizeof operator shall not contain any expression which has side effects
MISRAC2012-RULE_13_6-b=Object designated by a volatile lvalue should not be accessed in the operand of the sizeof operator
MISRAC2012-RULE_13_6-c=The function call shall not be the operand of the sizeof operator
MISRAC2012-RULE_14_1=Rule 14.1 (Required) A loop counter shall not have essentially floating type
MISRAC2012-RULE_14_1-a=A loop counter in a 'for' loop shall not have essentially floating type
MISRAC2012-RULE_14_1-b=A loop counter in 'while' and 'do-while' loops shall not have essentially floating type
MISRAC2012-RULE_14_2=Rule 14.2 (Required) A for loop shall be well-formed
MISRAC2012-RULE_14_2-a=There shall only be one loop counter in a 'for' loop, which shall not be modified in the 'for' loop body
MISRAC2012-RULE_14_2-b=The first clause of a 'for' loop shall be well-formed
MISRAC2012-RULE_14_2-c=The second clause of a 'for' loop shall be well-formed
MISRAC2012-RULE_14_2-d=The third clause of a 'for' statement shall be well-formed
MISRAC2012-RULE_14_4=Rule 14.4 (Required) The controlling expression of an if statement and the controlling expression of an iteration-statement shall have essentially Boolean type
MISRAC2012-RULE_14_4-a=Tests of a value against zero should be made explicit, unless the operand is effectively Boolean
MISRAC2012-RULE_15_1=Rule 15.1 (Advisory) The goto statement should not be used
MISRAC2012-RULE_15_1-a=The goto statement shall not be used
MISRAC2012-RULE_15_2=Rule 15.2 (Required) The goto statement shall jump to a label declared later in the same function
MISRAC2012-RULE_15_2-a=The goto statement shall jump to a label declared later in the same function body
MISRAC2012-RULE_15_3=Rule 15.3 (Required) Any label referenced by a goto statement shall be declared in the same block, or in any block enclosing the goto statement
MISRAC2012-RULE_15_3-a=Any label referenced by a goto statement shall be declared in the same block, or in a block enclosing the goto statement
MISRAC2012-RULE_15_4=Rule 15.4 (Advisory) There should be no more than one break or goto statement used to terminate any iteration statement
MISRAC2012-RULE_15_4-a=For any iteration statement there shall be no more than one break or goto statement used for loop termination
MISRAC2012-RULE_15_5=Rule 15.5 (Advisory) A function should have a single point of exit at the end
MISRAC2012-RULE_15_5-a=A function shall have a single point of exit at the end of the function
MISRAC2012-RULE_15_6=Rule 15.6 (Required) The body of an iteration-statement or a selection-statement shall be a compound-statement
MISRAC2012-RULE_15_6-a=The statement forming the body of a 'switch', 'while', 'do...while' or 'for' statement shall be a compound statement
MISRAC2012-RULE_15_6-b='if' and 'else' should be followed by a compound statement
MISRAC2012-RULE_15_7=Rule 15.7 (Required) All if ... else if constructs shall be terminated with an else statement
MISRAC2012-RULE_15_7-a=All 'if...else-if' constructs shall be terminated with an 'else' clause
MISRAC2012-RULE_16_1=Rule 16.1 (Required) All switch statements shall be well-formed
MISRAC2012-RULE_16_1-a=A switch statement shall only contain switch labels and switch clauses, and no other code
MISRAC2012-RULE_16_1-b=A switch label shall only be used when the most closely-enclosing compound statement is the body of a switch statement
MISRAC2012-RULE_16_1-c=An unconditional break statement shall terminate every non-empty case clause
MISRAC2012-RULE_16_1-d=An unconditional break statement shall terminate every non-empty default clause
MISRAC2012-RULE_16_1-e=Always provide a default branch for switch statements
MISRAC2012-RULE_16_1-f=A 'default' label shall have a statement or a comment before terminating 'break'
MISRAC2012-RULE_16_1-g=A 'default' label, if it exists, shall appear as either the first or the last switch label of a switch statement
MISRAC2012-RULE_16_1-h=Every switch statement shall have at least two switch-clauses
MISRAC2012-RULE_16_2=Rule 16.2 (Required) A switch label shall only be used when the most closely-enclosing compound statement is the body of a switch statement
MISRAC2012-RULE_16_2-a=A switch label shall only be used when the most closely-enclosing compound statement is the body of a switch statement
MISRAC2012-RULE_16_3=Rule 16.3 (Required) An unconditional break statement shall terminate every switch-clause
MISRAC2012-RULE_16_3-a=An unconditional break statement shall terminate every non-empty case clause
MISRAC2012-RULE_16_3-b=An unconditional break statement shall terminate every non-empty default clause
MISRAC2012-RULE_16_4=Rule 16.4 (Required) Every switch statement shall have a default label
MISRAC2012-RULE_16_4-a=Always provide a default branch for switch statements
MISRAC2012-RULE_16_4-b=A 'default' label shall have a statement or a comment before terminating 'break'
MISRAC2012-RULE_16_5=Rule 16.5 (Required) A default label shall appear as either the first or the last switch label of a switch statement
MISRAC2012-RULE_16_5-a=A 'default' label, if it exists, shall appear as either the first or the last switch label of a switch statement
MISRAC2012-RULE_16_6=Rule 16.6 (Required) Every switch statement shall have at least two switch-clauses
MISRAC2012-RULE_16_6-a=Every switch statement shall have at least two switch-clauses
MISRAC2012-RULE_16_7=Rule 16.7 (Required) A switch-expression shall not have essentially Boolean type
MISRAC2012-RULE_16_7-a=A switch expression shall not represent a value that is effectively Boolean
MISRAC2012-RULE_16_7-b=A switch expression shall not represent a value that is effectively Boolean
MISRAC2012-RULE_17_1=Rule 17.1 (Required) The features of <stdarg.h> shall not be used
MISRAC2012-RULE_17_1-a=The identifiers va_list, va_arg, va_start, va_end, va_copy should not be used
MISRAC2012-RULE_17_1-b=The identifiers va_list, va_arg, va_start, va_end should not be used
MISRAC2012-RULE_17_1-c=The standard header file <stdarg.h> or <cstdarg> shall not be used
MISRAC2012-RULE_17_10=Rule 17.10 (Required) A function declared with a _Noreturn function specifier shall have void return type
MISRAC2012-RULE_17_10-a=Functions declared as 'noreturn' shall have the 'void' return type
MISRAC2012-RULE_17_12=Rule 17.12 (Advisory) A function identifier should only be used with either a preceding &, or with a parenthesised parameter list
MISRAC2012-RULE_17_12-a=A function identifier shall only be used with either a preceding '&', or with a parenthesised parameter list, which may be empty
MISRAC2012-RULE_17_13=Rule 17.13 (Required) A function type shall not be type qualified
MISRAC2012-RULE_17_13-a=Do not include any type qualifiers in the specification of a function type
MISRAC2012-RULE_17_2=Rule 17.2 (Required) Functions shall not call themselves, either directly or indirectly
MISRAC2012-RULE_17_2-a=Functions shall not call themselves, either directly or indirectly
MISRAC2012-RULE_17_3=Rule 17.3 (Mandatory) A function shall not be declared implicitly
MISRAC2012-RULE_17_3-a=Functions shall always have visible prototype at the function call
MISRAC2012-RULE_17_4=Rule 17.4 (Mandatory) All exit paths from a function with non-void return type shall have an explicit return statement with an expression
MISRAC2012-RULE_17_4-a=All exit paths from a function with non-void return type shall have an explicit return statement with an expression
MISRAC2012-RULE_17_4-b=All exit paths from a function, except main(), with non-void return type shall have an explicit return statement with an expression
MISRAC2012-RULE_17_5=Rule 17.5 (Required) The function argument corresponding to a parameter declared to have an array type shall have an appropriate number of elements
MISRAC2012-RULE_17_5-a=The function argument corresponding to a parameter declared to have an array type shall have an appropriate number of elements
MISRAC2012-RULE_17_6=Rule 17.6 (Mandatory) The declaration of an array parameter shall not contain the static keyword between the [ ]
MISRAC2012-RULE_17_6-a=The declaration of an array parameter shall not contain the 'static' keyword between the [ ]
MISRAC2012-RULE_17_7=Rule 17.7 (Required) The value returned by a function having non-void return type shall be used
MISRAC2012-RULE_17_7-a=The value returned by a function having non-void return type shall be used
MISRAC2012-RULE_17_7-b=The value returned by a function having non-void return type shall be used
MISRAC2012-RULE_17_8=Rule 17.8 (Advisory) A function parameter should not be modified
MISRAC2012-RULE_17_8-a=A function parameter should not be modified
MISRAC2012-RULE_18_10=Rule 18.10 (Mandatory) Pointers to variably-modified array types shall not be used
MISRAC2012-RULE_18_10-a=Pointers to variably-modified array types should not be used
MISRAC2012-RULE_18_4=Rule 18.4 (Advisory) The +, -, +\= and -\= operators should not be applied to an expression of pointer type
MISRAC2012-RULE_18_4-a=The +, -, +\= and -\= operators should not be applied to an expression of pointer type
MISRAC2012-RULE_18_5=Rule 18.5 (Advisory) Declarations should contain no more than two levels of pointer nesting
MISRAC2012-RULE_18_5-a=The declaration of objects should contain no more than 2 levels of pointer indirection
MISRAC2012-RULE_18_6=Rule 18.6 (Required) The address of an object with automatic or thread-local storage shall not be copied to another object that persists after the first object has ceased to exist
MISRAC2012-RULE_18_6-a=The address of an object with automatic storage shall not be returned from a function
MISRAC2012-RULE_18_6-b=The address of an object with automatic storage shall not be assigned to another object that may persist after the first object has ceased to exist
MISRAC2012-RULE_18_6-c=The address of an object with thread storage duration shall not be assigned to an object with static storage duration
MISRAC2012-RULE_18_7=Rule 18.7 (Required) Flexible array members shall not be declared
MISRAC2012-RULE_18_7-a=Flexible array members shall not be declared
MISRAC2012-RULE_18_8=Rule 18.8 (Required) Variable-length arrays shall not be used
MISRAC2012-RULE_18_8-a=Variable-length arrays should not be used
MISRAC2012-RULE_18_9=Rule 18.9 (Required) An object with temporary lifetime shall not undergo array-to-pointer conversion
MISRAC2012-RULE_18_9-a=Do not modify objects with temporary lifetime
MISRAC2012-RULE_19_1=Rule 19.1 (Mandatory) An object shall not be assigned or copied to an overlapping object
MISRAC2012-RULE_19_1-a=An object shall not be assigned to an overlapping object
MISRAC2012-RULE_19_1-b=An object shall not be assigned to an overlapping object
MISRAC2012-RULE_19_2=Rule 19.2 (Advisory) The union keyword should not be used
MISRAC2012-RULE_19_2-a=The union keyword should not be used
MISRAC2012-RULE_1_1=Rule 1.1 (Required) The program shall contain no violations of the standard C syntax and constraints, and shall not exceed the implementation's translation limits
MISRAC2012-RULE_1_1-a=A program should not exceed the translation limits imposed by The Standard (c90)
MISRAC2012-RULE_1_1-b=A program should not exceed the translation limits imposed by The Standard (c99)
MISRAC2012-RULE_1_1-c=A program should not exceed the translation limits imposed by The Standard (c90)
MISRAC2012-RULE_1_1-d=A program should not exceed the translation limits imposed by The Standard (c99)
MISRAC2012-RULE_1_3=Rule 1.3 (Required) There shall be no occurrence of undefined or critical unspecified behaviour
MISRAC2012-RULE_1_3-f=The value of an expression shall be the same under any order of evaluation that the standard permits
MISRAC2012-RULE_1_3-g=Don't write code that depends on the order of evaluation of function arguments
MISRAC2012-RULE_1_3-h=Don't write code that depends on the order of evaluation of function designator and function arguments
MISRAC2012-RULE_1_3-i=Don't write code that depends on the order of evaluation of expression that involves a function call
MISRAC2012-RULE_1_3-j=Between sequence points an object shall have its stored value modified at most once by the evaluation of an expression
MISRAC2012-RULE_1_3-k=Do not use more than one volatile between two adjacent sequence points
MISRAC2012-RULE_1_3-l=Don't write code that depends on the order of evaluation of function calls
MISRAC2012-RULE_1_3-m=The address of an object with automatic storage shall not be returned from a function
MISRAC2012-RULE_1_3-n=The address of an object with automatic storage shall not be assigned to another object that may persist after the first object has ceased to exist
MISRAC2012-RULE_1_3-o=The left-hand operand of a right-shift operator shall not have a negative value
MISRAC2012-RULE_1_4=Rule 1.4 (Required) Emergent language features shall not be used
MISRAC2012-RULE_1_4-j=The '__STDC_WANT_LIB_EXT1__' macro should not be defined to the value other than '0'
MISRAC2012-RULE_1_4-k=The 'rsize_t' type should not be used
MISRAC2012-RULE_1_4-l=The 'errno_t' type should not be used
MISRAC2012-RULE_1_4-m=Do not use following macros\: RSIZE_MAX, L_tmpnam_s, TMP_MAX_S
MISRAC2012-RULE_1_4-n=Do not use the functions defined in Annex K of ISO/IEC 9899\:2011 standard
MISRAC2012-RULE_1_5=Rule 1.5 (Required) Obsolescent language features shall not be used
MISRAC2012-RULE_1_5-a=The static storage class specifier shall be used in definitions and declarations of objects and functions that have internal linkage
MISRAC2012-RULE_1_5-b=Storage type modifiers shall be associated with the type, not the variable or the function
MISRAC2012-RULE_1_5-c=Function types shall be in prototype form
MISRAC2012-RULE_1_5-d=Do not use the macro ATOMIC_VAR_INIT
MISRAC2012-RULE_1_5-e=Do not use the 'bool', 'false' or 'true' identifiers in the \#undef directive
MISRAC2012-RULE_20_1=Rule 20.1 (Advisory) \#include directives should only be preceded by preprocessor directives or comments
MISRAC2012-RULE_20_1-a=\#include statements in a file should only be preceded by other preprocessor directives or comments
MISRAC2012-RULE_20_10=Rule 20.10 (Advisory) The \# and \#\# preprocessor operators should not be used
MISRAC2012-RULE_20_10-a=The \# and \#\# preprocessor operators should not be used
MISRAC2012-RULE_20_11=Rule 20.11 (Required) A macro parameter immediately following a \# operator shall not immediately be followed by a \#\# operator
MISRAC2012-RULE_20_11-a=A macro parameter immediately following a \# operator shall not immediately be followed by or preceded by a \#\# operator
MISRAC2012-RULE_20_12=Rule 20.12 (Required) A macro parameter used as an operand to the \# or \#\# operators, which is itself subject to further macro replacement, shall only be used as an operand to these operators
MISRAC2012-RULE_20_12-a=A macro parameter used as an operand to the \# or \#\# operators, which is itself subject to further macro replacement, shall only be used as an operand to these operators
MISRAC2012-RULE_20_13=Rule 20.13 (Required) A line whose first token is \# shall be a valid preprocessing directive
MISRAC2012-RULE_20_13-a=Preprocessing directives shall be syntactically meaningful even when excluded by the preprocessor
MISRAC2012-RULE_20_14=Rule 20.14 (Required) All \#else, \#elif and \#endif preprocessor directives shall reside in the same file as the \#if, \#ifdef or \#ifndef directive to which they are related
MISRAC2012-RULE_20_14-a=All \#else, \#elif and \#endif preprocessor directives shall reside in the same file as the \#if or \#ifdef directive to which they are related
MISRAC2012-RULE_20_2=Rule 20.2 (Required) The ', " or \\ characters and the /* or // character sequences shall not occur in a header file name
MISRAC2012-RULE_20_2-a=The ', ", /* or // characters shall not occur in a header file name
MISRAC2012-RULE_20_2-b=The \\ character should not occur in a header file name
MISRAC2012-RULE_20_3=Rule 20.3 (Required) The \#include directive shall be followed by either a <filename> or "filename" sequence
MISRAC2012-RULE_20_3-a=The \#include directive shall be followed by either a <filename> or "filename" sequence
MISRAC2012-RULE_20_4=Rule 20.4 (Required) A macro shall not be defined with the same name as a keyword
MISRAC2012-RULE_20_4-a=A macro shall not be defined with the same name as a keyword in C90
MISRAC2012-RULE_20_4-b=A macro shall not be defined with the same name as a keyword in C99
MISRAC2012-RULE_20_5=Rule 20.5 (Advisory) \#undef should not be used
MISRAC2012-RULE_20_5-a=\#undef shall not be used
MISRAC2012-RULE_20_6=Rule 20.6 (Required) Tokens that look like a preprocessing directive shall not occur within a macro argument
MISRAC2012-RULE_20_6-a=Arguments to a function-like macro shall not contain tokens that look like preprocessing directives
MISRAC2012-RULE_20_7=Rule 20.7 (Required) Expressions resulting from the expansion of macro parameters shall be enclosed in parentheses
MISRAC2012-RULE_20_7-a=In the definition of a function-like macro each instance of a parameter shall be enclosed in parentheses unless it is used as the operand of \# or \#\#
MISRAC2012-RULE_20_8=Rule 20.8 (Required) The controlling expression of a \#if or \#elif preprocessing directive shall evaluate to 0 or 1
MISRAC2012-RULE_20_8-a=The controlling expression of a \#if or \#elif preprocessing directive shall evaluate to 0 or 1
MISRAC2012-RULE_20_9=Rule 20.9 (Required) All identifiers used in the controlling expression of \#if or \#elif preprocessing directives shall be \#define'd before evaluation
MISRAC2012-RULE_20_9-b=Do not use in preprocessor directives \#if and \#elif macros not defined in translation unit
MISRAC2012-RULE_21_1=Rule 21.1 (Required) \#define and \#undef shall not be used on a reserved identifier or reserved macro name
MISRAC2012-RULE_21_1-a=Do not \#define or \#undef identifiers with names which start with underscore
MISRAC2012-RULE_21_1-b=Reserved identifiers, macros and functions in the standard library, shall not be defined, redefined or undefined (C90 code)
MISRAC2012-RULE_21_1-c=Reserved identifiers, macros and functions in the standard library, shall not be defined, redefined or undefined (C99 code)
MISRAC2012-RULE_21_1-d=Do not \#define nor \#undef identifier 'defined'
MISRAC2012-RULE_21_10=Rule 21.10 (Required) The Standard Library time and date functions shall not be used
MISRAC2012-RULE_21_10-a=The standard header files <time.h> or <ctime> shall not be used
MISRAC2012-RULE_21_10-b=The time handling functions and macros of the library <time.h> shall not be used
MISRAC2012-RULE_21_10-c=The types defined in the library <time.h> shall not be used
MISRAC2012-RULE_21_11=Rule 21.11 (Required) The standard header file <tgmath.h> shall not be used
MISRAC2012-RULE_21_11-a=The standard header file <tgmath.h> shall not be used
MISRAC2012-RULE_21_12=Rule 21.12 (Required) The standard header file <fenv.h> shall not be used
MISRAC2012-RULE_21_12-a=The features provided by <fenv.h> should not be used
MISRAC2012-RULE_21_12-b=The standard header file <fenv.h> shall not be used
MISRAC2012-RULE_21_15=Rule 21.15 (Required) The pointer arguments to the Standard Library functions memcpy, memmove and memcmp shall be pointers to qualified or unqualified versions of compatible types
MISRAC2012-RULE_21_15-a=The pointer arguments to the Standard Library functions 'memcmp', 'memmove' and 'memcmp' shall be pointers to qualified or unqualified versions of compatible types
MISRAC2012-RULE_21_16=Rule 21.16 (Required) The pointer arguments to the Standard Library function memcmp shall point to either a pointer type, an essentially signed type, an essentially unsigned type, an essentially Boolean type or an essentially enum type
MISRAC2012-RULE_21_16-a=The pointer arguments to the Standard Library function 'memcmp' shall point to either a pointer type, an essentially signed type, an essentially unsigned type, an essentially Boolean type or an essentially enum type
MISRAC2012-RULE_21_19=Rule 21.19 (Mandatory) The pointers returned by the Standard Library functions localeconv, getenv, setlocale or, strerror shall only be used as if they have pointer to const-qualified type
MISRAC2012-RULE_21_19-a=The pointers returned by the Standard Library functions 'localeconv', 'getenv', 'setlocale' or, 'strerror' shall only be used as if they have pointer to const-qualified type
MISRAC2012-RULE_21_19-b=Strings pointed by members of the structure 'lconv' should not be modified
MISRAC2012-RULE_21_2=Rule 21.2 (Required) A reserved identifier or macro name shall not be declared
MISRAC2012-RULE_21_2-a=The names of standard library macros, objects and functions shall not be reused
MISRAC2012-RULE_21_2-b=The names of standard library macros, objects and functions shall not be reused (C90)
MISRAC2012-RULE_21_2-c=The names of standard library macros, objects and functions shall not be reused (C99)
MISRAC2012-RULE_21_21=Rule 21.21 (Required) The Standard Library function system of <stdlib.h> shall not be used
MISRAC2012-RULE_21_21-a=The 'system()' function from the 'stdlib.h' or 'cstdlib' library shall not be used
MISRAC2012-RULE_21_22=Rule 21.22 (Mandatory) All arguments to any type-generic macros declared in <tgmath.h> shall have appropriate essential type
MISRAC2012-RULE_21_22-a=All arguments to any type-generic macros declared in <tgmath.h> shall have appropriate essential type
MISRAC2012-RULE_21_23=Rule 21.23 (Required) All arguments to any multi-argument type-generic macros declared in <tgmath.h> shall have the same standard type
MISRAC2012-RULE_21_23-a=All arguments to any multi-argument type-generic macros declared in <tgmath.h> shall have the same standard type
MISRAC2012-RULE_21_24=Rule 21.24 (Required) The random number generator functions of <stdlib.h> shall not be used
MISRAC2012-RULE_21_24-a=The random number generator functions 'rand()' and 'srand()' should not be used
MISRAC2012-RULE_21_25=Rule 21.25 (Required) All memory synchronization operations shall be executed in sequentially consistent order
MISRAC2012-RULE_21_25-a=Only 'memory_order_seq_cst' should be used as an explicit memory order argument
MISRAC2012-RULE_21_3=Rule 21.3 (Required) The memory allocation and deallocation functions of <stdlib.h> shall not be used
MISRAC2012-RULE_21_3-a=Dynamic heap memory allocation shall not be used
MISRAC2012-RULE_21_4=Rule 21.4 (Required) The standard header file <setjmp.h> shall not be used
MISRAC2012-RULE_21_4-a=The facilities provided by <setjmp.h> should not be used
MISRAC2012-RULE_21_4-b=The standard header files <setjmp.h> or <csetjmp> shall not be used
MISRAC2012-RULE_21_5=Rule 21.5 (Required) The standard header file <signal.h> shall not be used
MISRAC2012-RULE_21_5-a=The standard header files <signal.h> or <csignal> shall not be used
MISRAC2012-RULE_21_5-b=The signal handling facilities of <signal.h> shall not be used
MISRAC2012-RULE_21_6=Rule 21.6 (Required) The Standard Library input/output functions shall not be used
MISRAC2012-RULE_21_6-a=The Standard Library input/output functions shall not be used
MISRAC2012-RULE_21_7=Rule 21.7 (Required) The atof, atoi, atol and atoll functions of <stdlib.h> shall not be used
MISRAC2012-RULE_21_7-a=The library functions atof, atoi and atol from library stdlib.h shall not be used
MISRAC2012-RULE_21_8=Rule 21.8 (Required) The Standard Library termination functions of <stdlib.h> shall not be used
MISRAC2012-RULE_21_8-a=The 'abort()' function from the 'stdlib.h' or 'cstdlib' library shall not be used
MISRAC2012-RULE_21_8-b=The 'exit()' function from the 'stdlib.h' or 'cstdlib' library shall not be used
MISRAC2012-RULE_21_8-c=The 'quick_exit()' and '_Exit()' functions from the 'stdlib.h' or 'cstdlib' library shall not be used
MISRAC2012-RULE_21_9=Rule 21.9 (Required) The library functions bsearch and qsort of <stdlib.h> shall not be used
MISRAC2012-RULE_21_9-a=The library functions bsearch and qsort of <stdlib.h> shall not be used
MISRAC2012-RULE_22_12=Rule 22.12 (Mandatory) Thread objects, thread synchronization objects, and thread-specific storage pointers shall only be accessed by the appropriate Standard Library functions
MISRAC2012-RULE_22_12-a=Thread objects, thread synchronization objects, and thread-specific storage pointers shall only be accessed by the appropriate Standard Library functions
MISRAC2012-RULE_22_14=Rule 22.14 (Mandatory) Thread synchronization objects shall be initialized before being accessed
MISRAC2012-RULE_22_14-b=The second argument passed to the 'mtx_init()' function call should be either 'mtx_plain', 'mtx_timed', 'mtx_plain | mtx_recursive', or 'mtx_timed | mtx_recursive'
MISRAC2012-RULE_22_5=Rule 22.5 (Mandatory) A pointer to a FILE object shall not be dereferenced
MISRAC2012-RULE_22_5-a=A pointer to a FILE object shall not be dereferenced
MISRAC2012-RULE_22_5-b=A pointer to a FILE object shall not be dereferenced by a library function
MISRAC2012-RULE_23_1=Rule 23.1 (Advisory) A generic selection should only be expanded from a macro
MISRAC2012-RULE_23_1-a=A generic selection should only be expanded from a macro
MISRAC2012-RULE_23_1-b=A generic selection used in a macro definition should have a macro parameter in the controlling expression
MISRAC2012-RULE_23_2=Rule 23.2 (Required) A generic selection that is not expanded from a macro shall not contain potential side effects in the controlling expression
MISRAC2012-RULE_23_2-a=A generic selection that is not expanded from a macro shall not contain potential side effects in the controlling expression
MISRAC2012-RULE_23_3=Rule 23.3 (Advisory) A generic selection should contain at least one non-default association
MISRAC2012-RULE_23_3-a=A generic selection shall indicate at least one non-default association
MISRAC2012-RULE_23_4=Rule 23.4 (Required) A generic association shall list an appropriate type
MISRAC2012-RULE_23_4-a=A generic association shall list an appropriate type
MISRAC2012-RULE_23_5=Rule 23.5 (Advisory) A generic selection should not depend on implicit pointer type conversion
MISRAC2012-RULE_23_5-a=A generic selection should not depend on implicit pointer type conversion
MISRAC2012-RULE_23_6=Rule 23.6 (Required) The controlling expression of a generic selection shall have an essential type that matches its standard type
MISRAC2012-RULE_23_6-a=The controlling expression of a generic selection shall have an essential type that matches its standard type
MISRAC2012-RULE_23_6-b=Enumerated types should not be mixed with integer types in generic selections
MISRAC2012-RULE_23_7=Rule 23.7 (Advisory) A generic selection that is expanded from a macro should evaluate its argument only once
MISRAC2012-RULE_23_7-a=A generic selection that is expanded from a macro shall evaluate its argument only once
MISRAC2012-RULE_23_8=Rule 23.8 (Required) A default association shall appear as either the first or the last association of a generic selection
MISRAC2012-RULE_23_8-a=The default association shall be placed first or last in the association list
MISRAC2012-RULE_2_1=Rule 2.1 (Required) A project shall not contain unreachable code
MISRAC2012-RULE_2_1-a=There shall be no unreachable code in "else" block
MISRAC2012-RULE_2_1-b=There shall be no unreachable code after 'return', 'break', 'continue', and 'goto' statements
MISRAC2012-RULE_2_1-c=There shall be no unreachable code in "if/else/while/for" block
MISRAC2012-RULE_2_1-d=There shall be no unreachable code in switch statement
MISRAC2012-RULE_2_1-e=There shall be no unreachable code in 'for' loop
MISRAC2012-RULE_2_1-f=There shall be no unreachable code after 'if' or 'switch' statement
MISRAC2012-RULE_2_1-g=There shall be no unreachable code after "if" or "switch" statement inside while/for/do...while loop
MISRAC2012-RULE_2_2=Rule 2.2 (Required) A project shall not contain dead code
MISRAC2012-RULE_2_2-a=All non-null statements shall either have at least one side-effect however executed or cause control flow to change
MISRAC2012-RULE_2_3=Rule 2.3 (Advisory) A project should not contain unused type declarations
MISRAC2012-RULE_2_3-a=A function should not contain unused type declarations
MISRAC2012-RULE_2_3-b=A source file should not contain unused type declarations
MISRAC2012-RULE_2_4=Rule 2.4 (Advisory) A project should not contain unused tag declarations
MISRAC2012-RULE_2_4-a=A function should not contain unused local tag declarations
MISRAC2012-RULE_2_4-b=A source file should not contain unused tag declarations
MISRAC2012-RULE_2_5=Rule 2.5 (Advisory) A project should not contain unused macro definitions
MISRAC2012-RULE_2_5-a=A source file should not contain unused macro definitions
MISRAC2012-RULE_2_6=Rule 2.6 (Advisory) A function should not contain unused label declarations
MISRAC2012-RULE_2_6-a=A function should not contain unused label declarations
MISRAC2012-RULE_2_7=Rule 2.7 (Advisory) A function should not contain unused parameters
MISRAC2012-RULE_2_7-a=There should be no unused parameters in functions
MISRAC2012-RULE_2_8=Rule 2.8 (Advisory) A project should not contain unused object definitions
MISRAC2012-RULE_2_8-b=A project should not contain unused variables with internal linkage
MISRAC2012-RULE_2_8-c=Avoid unused local variables
MISRAC2012-RULE_3_1=Rule 3.1 (Required) The character sequences /* and // shall not be used within a comment
MISRAC2012-RULE_3_1-a=The character sequence /* shall not be used within a C-style comment
MISRAC2012-RULE_3_1-b=The character sequence // shall not be used within a C-style comment
MISRAC2012-RULE_3_1-c=The character sequence /* shall not be used within a C++-style comment
MISRAC2012-RULE_3_2=Rule 3.2 (Required) Line-splicing shall not be used in // comments
MISRAC2012-RULE_3_2-a=Line-splicing shall not be used in // comments
MISRAC2012-RULE_4_1=Rule 4.1 (Required) Octal and hexadecimal escape sequences shall be terminated
MISRAC2012-RULE_4_1-a=Octal and hexadecimal escape sequences shall be terminated
MISRAC2012-RULE_4_2=Rule 4.2 (Advisory) Trigraphs should not be used
MISRAC2012-RULE_4_2-a=Trigraphs shall not be used
MISRAC2012-RULE_5_1=Rule 5.1 (Required) External identifiers shall be distinct
MISRAC2012-RULE_5_1-a=External identifiers shall be distinct
MISRAC2012-RULE_5_2=Rule 5.2 (Required) Identifiers declared in the same scope and name space shall be distinct
MISRAC2012-RULE_5_2-a=Identifiers declared in the file scope and in the same name space shall be distinct (c90)
MISRAC2012-RULE_5_2-b=Identifiers declared in the file scope and in the same name space shall be distinct (c99)
MISRAC2012-RULE_5_2-c=Identifiers declared in the same block scope and name space shall be distinct (c90)
MISRAC2012-RULE_5_2-d=Identifiers declared in the same block scope and name space shall be distinct (c99)
MISRAC2012-RULE_5_3=Rule 5.3 (Required) An identifier declared in an inner scope shall not hide an identifier declared in an outer scope
MISRAC2012-RULE_5_3-a=Identifier declared in a local or function prototype scope shall not hide an identifier declared in a global or namespace scope
MISRAC2012-RULE_5_3-b=Identifiers declared in an inner local scope should not hide identifiers declared in an outer local scope
MISRAC2012-RULE_5_4=Rule 5.4 (Required) Macro identifiers shall be distinct
MISRAC2012-RULE_5_4-a=The name of a macro should be distinct from the names of its parameters(c90)
MISRAC2012-RULE_5_4-b=The name of a macro should be distinct from the names of its parameters(c99)
MISRAC2012-RULE_5_4-c=The name of a macro should be distinct from the names of other macros that are currently defined(c90)
MISRAC2012-RULE_5_4-d=The name of a macro should be distinct from the names of other macros that are currently defined(c99)
MISRAC2012-RULE_5_5=Rule 5.5 (Required) Identifiers shall be distinct from macro names
MISRAC2012-RULE_5_5-a=The names of macros that exist prior to preprocessing should be distinct from the identifiers that exist after preprocessing (c90)
MISRAC2012-RULE_5_5-b=The names of macros that exist prior to preprocessing should be distinct from the identifiers that exist after preprocessing (c99)
MISRAC2012-RULE_6_1=Rule 6.1 (Required) Bit-fields shall only be declared with an appropriate type
MISRAC2012-RULE_6_1-a=Bit fields shall only be defined to be of type unsigned int or signed int
MISRAC2012-RULE_6_2=Rule 6.2 (Required) Single-bit named bit fields shall not be of a signed type
MISRAC2012-RULE_6_2-a=Named bit-fields with signed integer type shall have a length of more than one bit
MISRAC2012-RULE_6_3=Rule 6.3 (Required) A bit field shall not be declared as a member of a union
MISRAC2012-RULE_6_3-a=A member of a union shall not be declared as a bit-field
MISRAC2012-RULE_7_1=Rule 7.1 (Required) Octal constants shall not be used
MISRAC2012-RULE_7_1-a=Octal constants (other than zero) shall not be used
MISRAC2012-RULE_7_2=Rule 7.2 (Required) A "u" or "U" suffix shall be applied to all integer constants that are represented in an unsigned type
MISRAC2012-RULE_7_2-a=A 'U' suffix shall be applied to all constants of unsigned type
MISRAC2012-RULE_7_3=Rule 7.3 (Required) The lowercase character "l" shall not be used in a literal suffix
MISRAC2012-RULE_7_3-a=Use capital 'L' instead of lowercase 'l' to indicate long
MISRAC2012-RULE_7_4=Rule 7.4 (Required) A string literal shall not be assigned to an object unless the object's type is "pointer to const-qualified char"
MISRAC2012-RULE_7_4-a=A string literal shall not be modified
MISRAC2012-RULE_7_5=Rule 7.5 (Mandatory) The argument of an integer-constant macro shall have an appropriate form
MISRAC2012-RULE_7_5-a=Arguments of integer-constant macros should be decimal, octal, or hexadecimal constants with appropriate values
MISRAC2012-RULE_7_6=Rule 7.6 (Required) The small integer variants of the minimum-width integer constant macros shall not be used
MISRAC2012-RULE_7_6-a=The small integer variants of the minimum-width integer constant macros should not be used
MISRAC2012-RULE_8_1=Rule 8.1 (Required) Types shall be explicitly specified
MISRAC2012-RULE_8_1-a=Whenever a function is declared or defined, its type shall be explicitly stated
MISRAC2012-RULE_8_1-b=Whenever an object is declared or defined, its type shall be explicitly stated
MISRAC2012-RULE_8_10=Rule 8.10 (Required) An inline function shall be declared with the static storage class
MISRAC2012-RULE_8_10-a=An inline function shall be declared with the static storage class
MISRAC2012-RULE_8_11=Rule 8.11 (Advisory) When an array with external linkage is declared, its size should be explicitly specified
MISRAC2012-RULE_8_11-a=When an array is declared with external linkage, its size shall be stated explicitly or defined implicitly by initialisation
MISRAC2012-RULE_8_12=Rule 8.12 (Required) Within an enumerator list, the value of an implicitly-specified enumeration constant shall be unique
MISRAC2012-RULE_8_12-a=Within an enumerator list, the value of an implicitly-specified enumeration constant shall be unique
MISRAC2012-RULE_8_13=Rule 8.13 (Advisory) A pointer should point to a const-qualified type whenever possible
MISRAC2012-RULE_8_13-a=A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify the addressed object
MISRAC2012-RULE_8_13-b=Declare a type of parameter as typedef to pointer to const if the pointer is not used to modify the addressed object
MISRAC2012-RULE_8_14=Rule 8.14 (Required) The restrict type qualifier shall not be used
MISRAC2012-RULE_8_14-a=The restrict type qualifier shall not be used
MISRAC2012-RULE_8_15=Rule 8.15 (Required) All declarations of an object with an explicit alignment specification shall specify the same alignment
MISRAC2012-RULE_8_15-b=Explicit alignment specifiers in all declarations of an object with internal linkage shall be the same
MISRAC2012-RULE_8_16=Rule 8.16 (Advisory) The alignment specification of zero should not appear in an object declaration
MISRAC2012-RULE_8_16-a=The zero-alignment specifier should not be used in an object declaration
MISRAC2012-RULE_8_17=Rule 8.17 (Advisory) At most one explicit alignment specifier should appear in an object declaration
MISRAC2012-RULE_8_17-a=A declaration of an object should contain at most one explicit alignment specifier
MISRAC2012-RULE_8_2=Rule 8.2 (Required) Function types shall be in prototype form with named parameters
MISRAC2012-RULE_8_2-a=Identifiers shall be given for all of the parameters in a function prototype declaration
MISRAC2012-RULE_8_2-b=Function types shall have named parameters
MISRAC2012-RULE_8_2-c=Function types shall be in prototype form
MISRAC2012-RULE_8_3=Rule 8.3 (Required) All declarations of an object or function shall use the same names and type qualifiers
MISRAC2012-RULE_8_3-a=If objects or functions are declared more than once their types shall be compatible
MISRAC2012-RULE_8_3-b=The identifiers used in the declaration and definition of a function shall be identical
MISRAC2012-RULE_8_4=Rule 8.4 (Required) A compatible declaration shall be visible when an object or function with external linkage is defined
MISRAC2012-RULE_8_4-a=A declaration shall be visible when an object or function with external linkage is defined
MISRAC2012-RULE_8_4-b=If objects or functions are declared more than once their types shall be compatible
MISRAC2012-RULE_8_5=Rule 8.5 (Required) An external object or function shall be declared once in one and only one file
MISRAC2012-RULE_8_5-a=An external object or function shall not have more than one non-defining declaration in translation unit
MISRAC2012-RULE_8_8=Rule 8.8 (Required) The static storage class specifier shall be used in all declarations of objects and functions that have internal linkage
MISRAC2012-RULE_8_8-a=The static storage class specifier shall be used in definitions and declarations of objects and functions that have internal linkage
MISRAC2012-RULE_8_9=Rule 8.9 (Advisory) An object should be declared at block scope if its identifier only appears in a single function
MISRAC2012-RULE_8_9-a=Objects shall be defined at block scope if they are only accessed from within a single function
MISRAC2012-RULE_9_2=Rule 9.2 (Required) The initializer for an aggregate or union shall be enclosed in braces
MISRAC2012-RULE_9_2-a=The initializer for an aggregate or union shall be enclosed in braces
MISRAC2012-RULE_9_3=Rule 9.3 (Required) Arrays shall not be partially initialized
MISRAC2012-RULE_9_3-a=Arrays shall not be partially initialized
MISRAC2012-RULE_9_4=Rule 9.4 (Required) An element of an object shall not be initialized more than once
MISRAC2012-RULE_9_4-a=An element of an object shall not be initialized more than once
MISRAC2012-RULE_9_5=Rule 9.5 (Required) Where designated initializers are used to initialize an array object the size of the array shall be specified explicitly
MISRAC2012-RULE_9_5-a=Where designated initializers are used to initialize an array object the size of the array shall be specified explicitly
MISRAC2012-RULE_9_6=Rule 9.6 (Required) An initializer using chained designators shall not contain initializers without designators
MISRAC2012-RULE_9_6-a=An initializer using chained designators shall not contain initializers without designators
MISRACPP202X=MISRA C++ 202X
MISRACPP202X-0023=Rule 0023 (Advisory) Trigraph-like sequences should not be used
MISRACPP202X-0023-a=Trigraphs shall not be used
MISRACPP202X-0025=Rule 0025 (Required) The character sequence "/*" shall not be used within a C-style comment
MISRACPP202X-0025-a=The character sequence /* shall not be used within a C-style comment
MISRACPP202X-0035=Rule 0035 (Required) Octal constants shall not be used
MISRACPP202X-0035-a=Octal constants (other than zero) shall not be used
MISRACPP202X-0036=Rule 0036 (Required) Unsigned integer literals shall be appropriately suffixed
MISRACPP202X-0036-a=A 'U' suffix shall be applied to all constants of unsigned type
MISRACPP202X-0039=Rule 0039 (Advisory) \#include directives should only be preceded by preprocessor directives or comments
MISRACPP202X-0039-a=\#include statements in a file should only be preceded by other preprocessor directives or comments
MISRACPP202X-0042=Rule 0042 (Required) Function-like macros shall not be defined
MISRACPP202X-0042-a=A function should be used in preference to a function-like macro
MISRACPP202X-0043=Rule 0043 (Required) Tokens that look like a preprocessing directive shall not occur within a macro argument
MISRACPP202X-0043-a=Arguments to a function-like macro shall not contain tokens that look like preprocessing directives
MISRACPP202X-0045=Rule 0045 (Required) All identifiers used in the controlling expression of \#if or \#elif preprocessing directives shall be \#define'd at the point of evaluation
MISRACPP202X-0045-a=Do not use in preprocessor directives \#if and \#elif macros not defined in translation unit
MISRACPP202X-0046=Rule 0046 (Required) A line whose first token is "\#" shall be a valid preprocessing directive
MISRACPP202X-0046-a=Preprocessing directives shall be syntactically meaningful even when excluded by the preprocessor
MISRACPP202X-0049=Rule 0049 (Advisory) When an array with external linkage is declared, its size should be explicitly specified
MISRACPP202X-0049-a=When an array is declared with external linkage, its size shall be stated explicitly or defined implicitly by initialisation
MISRACPP202X-0064=Rule 0064 (Required) "nullptr" shall be the only form of the null-pointer-constant
MISRACPP202X-0064-a=Prefer 'nullptr' over 'NULL' or '0'(zero)
MISRACPP202X-0087=Rule 0087 (Required) A virtual base class shall only be cast to a derived class by means of dynamic_cast
MISRACPP202X-0087-a=A pointer to a virtual base class shall only be cast to a pointer to a derived class by means of dynamic_cast
MISRACPP202X-0089=Rule 0089 (Required) C-style casts and functional notation casts shall not be used
MISRACPP202X-0089-a=C-style casts (other than void casts) and functional notation casts (other than explicit constructor calls) shall not be used
MISRACPP202X-0090=Rule 0090 (Required) A cast shall not remove any const or volatile qualification from the type accessed via a pointer or by reference
MISRACPP202X-0090-a=A cast shall not remove any 'const' or 'volatile' qualification from the type of a pointer or reference
MISRACPP202X-0096=Rule 0096 (Required) The comma, logical AND and logical OR operators shall not be overloaded
MISRACPP202X-0096-a=Avoid overloading logical operators AND, OR (&&, ||)
MISRACPP202X-0096-b=Avoid overloading comma operator ","
MISRACPP202X-0097=Rule 0097 (Required) An array passed as a function argument shall not decay to a pointer
MISRACPP202X-0097-a=Do not pass an expression with array type to a function with a pointer or array type parameter
MISRACPP202X-0100=Rule 0100 (Required) The address-of operator shall not be overloaded
MISRACPP202X-0100-a=The unary & operator shall not be overloaded
MISRACPP202X-0105=Rule 0105 (Advisory) The comma operator should not be used
MISRACPP202X-0105-a=The comma operator shall not be used
MISRACPP202X-0110=Rule 0110 (Required) The body of an iteration-statement or a selection-statement shall be a compound-statement
MISRACPP202X-0110-a=The statement forming the body of a 'switch', 'while', 'do...while' or 'for' statement shall be a compound statement
MISRACPP202X-0110-b='if' and 'else' should be followed by a compound statement
MISRACPP202X-0125=Rule 0125 (Required) A goto statement shall reference a label declared in the same block or in an enclosing block
MISRACPP202X-0125-a=Any label referenced by a goto statement shall be declared in the same block, or in a block enclosing the goto statement
MISRACPP202X-0133=Rule 0133 (Required) The only declarations in the global namespace shall be main, namespace declarations and extern "C" declarations
MISRACPP202X-0133-a=The global namespace shall only contain main() and namespace declarations
MISRACPP202X-0134=Rule 0134 (Required) The identifier main shall not be used for a function other than the global function main
MISRACPP202X-0134-a=The identifier main shall not be used for a function other than the global function main
MISRACPP202X-0135=Rule 0135 (Advisory) There shall be no unnamed namespaces in header files
MISRACPP202X-0135-a=There shall be no unnamed namespaces in header files
MISRACPP202X-0143=Rule 0143 (Required) The address of an object with automatic storage shall not be assigned to an object with a greater lifetime
MISRACPP202X-0143-a=The address of an object with automatic storage shall not be assigned to another object that may persist after the first object has ceased to exist
MISRACPP202X-0143-b=The lambda that captures local objects by reference should not be assigned to the variable with a greater lifetime
MISRACPP202X-0146=Rule 0146 (Advisory) A declaration shall not declare more than one variable or member variable
MISRACPP202X-0146-a=Each variable should be declared in a separate declaration statement
MISRACPP202X-0147=Rule 0147 (Required) Parameters in an overriding virtual function shall not introduce different default arguments
MISRACPP202X-0147-a=Do not redefine an inherited virtual function with a different default parameter value
MISRACPP202X-0148=Rule 0148 (Required) The features of "<cstdarg>" shall not be used
MISRACPP202X-0148-a=The identifiers va_list, va_arg, va_start, va_end, va_copy should not be used
MISRACPP202X-0150=Rule 0150 (Required) A function with non-void return type shall return a value on all paths
MISRACPP202X-0150-a=All exit paths from a function with non-void return type shall have an explicit return statement with an expression
MISRACPP202X-0158=Rule 0158 (Required) The union keyword shall not be used
MISRACPP202X-0158-a=Unions shall not be used
MISRACPP202X-0159=Rule 0159 (Advisory) Bit fields should not be declared
MISRACPP202X-0159-a=Do not declare member variables as bit-fields
MISRACPP202X-0162=Rule 0162 (Required) Named bit-fields with signed integer type shall not have a length of one bit
MISRACPP202X-0162-a=Named bit-fields with signed integer type shall have a length of more than one bit
MISRACPP202X-0163=Rule 0163 (Required) Classes shall not be derived from virtual bases
MISRACPP202X-0163-a=Classes should not be derived from virtual bases
MISRACPP202X-0165=Rule 0165 (Required) An accessible base class shall not be both virtual and non-virtual in the same hierarchy
MISRACPP202X-0165-a=A base class shall not be both virtual and non-virtual in the same hierarchy
MISRACPP202X-0173=Rule 0173 (Required) Conversion operators and constructors that are callable with a single argument shall be explicit
MISRACPP202X-0173-a=Constructors allowing for conversion should be made explicit
MISRACPP202X-0173-b=User-conversion cast operators should be made explicit
MISRACPP202X-0187=Rule 0187 (Required) An exception object shall not have pointer type
MISRACPP202X-0187-a=An exception object should not have pointer type
MISRACPP202X-0207=Rule 0207 (Required) Precautions shall be taken in order to prevent the contents of a header file being included more than once
MISRACPP202X-0207-a=Use multiple include guards
MISRACPP202X-0208=Rule 0208 (Required) The "'", """ or "\\" characters and the "/*" or "//" character sequences shall not occur in a header file name
MISRACPP202X-0208-a=Non-standard characters should not occur in header file names in \#include directives
MISRACPP202X-0210=Rule 0210 (Required) The \#include directive shall be followed by either a "<filename>" or ""filename"" sequence
MISRACPP202X-0210-a=The \#include directive shall be followed by either a <filename> or "filename" sequence
MISRACPP202X-0212=Rule 0212 (Advisory) The "\#" and "\#\#" preprocessor operators should not be used
MISRACPP202X-0212-a=The \# and \#\# preprocessor operators should not be used
MISRACPP202X-0239=Rule 0239 (Required) A comparison of a potentially virtual pointer to member shall only be with "nullptr"
MISRACPP202X-0239-a=A pointer to member virtual function shall only be tested for equality with null-pointer-constant
MISRACPP202X-0320=Rule 0320 (Required) Octal and hexadecimal escape sequences shall be terminated
MISRACPP202X-0320-a=Octal and hexadecimal escape sequences shall be terminated
MISRACPP202X-0324=Rule 0324 (Required) A pointer to an incomplete class type shall not be deleted
MISRACPP202X-0324-a=Do not delete objects with incomplete class at the point of deletion
MISRACPP202X-0343=Rule 0343 (Required) Member function declarations shall use the virtual, override and final specifiers appropriately
MISRACPP202X-0343-a=Each overriding virtual function shall be declared with the override or final specifier
MISRACPP202X-0343-b=Only one of virtual, override or final should be specified in a member function declaration
MISRACPP202X-0370=Rule 0370 (Required) A macro parameter used as an operand to the "\#" or "\#\#" operators, which is itself subject to further macro replacement, shall only be used as an operand to these operators
MISRACPP202X-0370-a=A macro parameter used as an operand to the \# or \#\# operators, which is itself subject to further macro replacement, shall only be used as an operand to these operators
MRM=Memory and Resource Management
MRM-01=Do not allocate resources in function argument list because the order of evaluation of a function's parameters is undefined
MRM-02=Do not allocate more than one resource in a single statement
MRM-04=All classes should contain the assignment operator or appropriate comment
MRM-05=All classes should contain the copy constructor or appropriate comment
MRM-06=Use the same form in corresponding calls to new/malloc and delete/free
MRM-07=Don't memcpy or memcmp non-PODs
MRM-08=Do not invoke malloc/realloc for objects having constructors
MRM-09=Always assign a new value to an expression that points to deallocated memory
MRM-10=Always assign a new value to global or member variable that points to deallocated memory
MRM-11=Always assign a new value to parameter or local variable that points to deallocated memory
MRM-12=Adhere to convention when writing new and delete
MRM-13=Adhere to convention when writing new
MRM-14=If a class defines any overload of operator new, it should provide overloads of all three of plain, in-place, and non-throwing operator new
MRM-15=If a class defines any overload of operator new[], it should provide overloads of all three of plain, in-place, and non-throwing operator new[]
MRM-16=If a class defines any overload of operator delete, it should provide overloads of all three of plain, in-place, and non-throwing operator delete
MRM-17=If a class defines any overload of operator delete[], it should provide overloads of all three of plain, in-place, and non-throwing operator delete[]
MRM-18=Do not allocate memory and expect that someone else will deallocate it later
MRM-19=Do not allocate memory and expect that someone else will deallocate it later
MRM-20=Do not allocate memory and expect that someone else will deallocate it later
MRM-21=Use objects to manage resources
MRM-22=Use objects to manage resources
MRM-23=Never return a dereferenced local pointer initialized by new in this function scope
MRM-25=Store newed objects in smart pointers in standalone statements
MRM-26=Write operator delete if you write operator new
MRM-27=Write operator delete[] if you write operator new[]
MRM-28=Always provide new and delete together
MRM-29=Always provide new[] and delete[] together
MRM-30=Use allocation by declaration rather than by new or malloc
MRM-31=Freed memory shouldn't be accessed under any circumstances
MRM-31_b=Destructor should not be called manually
MRM-32=Avoid hiding the global new
MRM-33=Call delete on pointer members in destructors
MRM-34=Check the return value of new
MRM-35=Never provide brackets ([]) for delete when deallocating non-arrays
MRM-36=Always provide empty brackets ([]) for delete when deallocating arrays
MRM-37=Declare a copy assignment operator for classes with dynamically allocated memory
MRM-38=Declare a copy constructor for classes with dynamically allocated memory
MRM-39=Provide error handling for file opening errors right next to the call to fopen
MRM-40=Copy and destroy consistently
MRM-40_a=A copy assignment operator should be declared when a copy constructor is declared (and vice versa)
MRM-40_b=Both the copy constructor and copy assignment operator should have the same public/protected/private permission
MRM-40_c=If you have a non-trivial copy constructor or copy assignment operator, you should also declare a destructor
MRM-40_d=Both copy constructor and copy assignment operator should be declared for classes with a nontrivial destructor
MRM-41=A copy constructor shall copy all data members and bases
MRM-42=Call fclose() on pointer member in destructor if the pointer was used to open a file
MRM-43=An assignment operator shall assign all data bases
MRM-45=Do not use sizeof operator on pointer type to specify the size of the memory to be allocated via 'malloc', 'calloc' or 'realloc' function
MRM-46=Do not use calloc, malloc, realloc and free functions
MRM-47=Classes containing at least one non-static member variable should declare the assignment operator or contain appropriate comment
MRM-48=Classes containing at least one non-static member variable should declare the copy constructor or contain appropriate comment
MRM-49=A copy constructor and a copy assignment operator shall be declared for classes that contain pointers to data items or nontrivial destructors
MRM-50=Declare both private copy constructor and copy assignment operator at the same time
MRM-51=Do not use 'delete' on pointers to a void type
MRM-52=Use RAII to prevent resource leaks
MRM-53=The user defined 'new' operator should throw the 'std\:\:bad_alloc' exception when the allocation fails
MRM-54=Avoid using the default operator 'new' for over-aligned types
MRM-55=Do not pass a pointer that has insufficient storage capacity or that is not suitably aligned for the object being constructed to placement 'new'
MRM-55_b=An overhead should be used when an array of objects is passed to the placement 'new' allocation function
MRM-56=Copy assignment operators should not have side effects that could affect copying the object
MRM-57=Move assignment operators should not have side effects that could affect moving the object
MRM-58_a=The result of the memory allocation function should be cast immediately
MRM-58_b=The result of the memory allocation function should be cast immediately into a pointer to the allocated type
NAMING=Naming Conventions
NAMING-01=All "\#define" constants shall be in uppercase
NAMING-02=In an enumerated list, list members (elements) shall be in uppercase and names or tags for the list shall be in lowercase
NAMING-03=Use lowercase for file names
NAMING-04=Global prefixes should only be used for global variables
NAMING-05=Begin local variable names with a lowercase letters
NAMING-06=Begin global variable names with a lowercase letters
NAMING-07=Begin member variable names with a lowercase letters
NAMING-08=Begin all boolean type variables with 'b'
NAMING-09=Begin class, struct, union, enum, and typedef names with an uppercase letter
NAMING-10=The names of abstract data types, structures, typedefs, and enumerated types are to begin with an uppercase letter
NAMING-11=The name of enumeration type shall begin with an uppercase letter and contain a suffix '_t' at the end
NAMING-12=The names of structures shall begin with an uppercase letter and contain a suffix '_t' at the end
NAMING-13=Begin constant variables with 'c'
NAMING-14=Begin class data member names with 'its'
NAMING-15=Begin all double type variable with 'd'
NAMING-16=Begin all float type variables with 'f'
NAMING-17=Begin all function names with uppercase letter
NAMING-18=Begin global variable names with 'the'
NAMING-19=Begin all integer type variable with 'i'
NAMING-20=Functions that begin with 'is' should return boolean values
NAMING-21=Begin all long integer variables with 'li'
NAMING-22=Prefix a variable type 'pointer' with a 'p' character
NAMING-23=Begin all short integer variables with 'si'
NAMING-24=Begin all signed character variables with 'c'
NAMING-25=Begin all terminated characters string variables with 'sz'
NAMING-26=Begin all unsigned character type variables with 'uc'
NAMING-27=Begin all unsigned integer type variables with 'ui'
NAMING-28=Use lowercase letters for structure and union member names
NAMING-29=Append names of non-scalar typedefs with "_t"
NAMING-30=Implementation files in C always have the file name extension ".c"
NAMING-31=Do not use typenames that differ only by the use of uppercase and lowercase letters
NAMING-32=An include file for a class should have a file name of the form <class name> + extension
NAMING-33=Do not use identifiers which begin with one or two underscores (`_' or `__')
NAMING-34=Global function names should start with lowercase
NAMING-35=Member function names should start with lowercase
NAMING-36=Names of parameters in declaration and definition should be identical
NAMING-37=Include files in C++ always have the file name extension '.hh'
NAMING-38=Implementation files in C++ always have the file name extension ".cc"
NAMING-39=Inline definition files always have the file name extension ".icc"
NAMING-40=Only the first word of the name of a class, structure, namespace, enumeration, or typedef will begin with an uppercase letter
NAMING-41=Header files will always have a file name extension of '.h'
NAMING-42=Identifiers for constant and enumerator values shall be lowercase
NAMING-43=File name extension, if present, should be "*.cpp" or "*.h"
NAMING-44=All letters contained in function and variable names will be composed entirely of lowercase letters
NAMING-45=Identifiers will not differ by mixture of case, the underscore character, interchange of the similarly looking letters and numbers
NAMING-46=The ', ", /* or // characters shall not occur in a header file name
NAMING-47=Different identifiers shall be typographically unambiguous
NAMING-48=The \\ character should not occur in a header file name
NAMING-49=Implementation files in C++ will always have a file name extension of ".cpp"
NAMING-50=Identifiers in the same name space with overlapping visibility should be typographically unambiguous
NAMING-51=User defined suffixes of the user defined literal operators shall start with underscore followed by one or more letters
NAMING-52=Universal character names shall be used only inside character or string literals
NAMING-53=Header files should have a file extension of\: ".h", ".hpp" or ".hxx"
NAMING-54=Use visually distinct identifiers
NAMING-HN=Hungarian Notation
NAMING-HN-01=Hungarian notation for array variables and parameters
NAMING-HN-02=Hungarian notation for bool types
NAMING-HN-03=Hungarian notation for bool pointer, array, or reference types
NAMING-HN-04=Hungarian notation for byte types
NAMING-HN-05=Hungarian notation for byte pointer, array, or reference types
NAMING-HN-06=Hungarian notation for char types
NAMING-HN-07=Hungarian notation for array of char types
NAMING-HN-08=Hungarian notation for pointer, array, or reference to array of char types
NAMING-HN-09=Hungarian notation for char pointer, array, or reference types
NAMING-HN-10=Hungarian notation for char pointer or reference types
NAMING-HN-11=Hungarian notation for constant parameters
NAMING-HN-12=Hungarian notation for double-precision floating point types
NAMING-HN-13=Hungarian notation for double-precision floating point pointer, array, or reference types
NAMING-HN-14=Hungarian notation for dword types
NAMING-HN-15=Hungarian notation for dword pointer, array, or reference types
NAMING-HN-16=Hungarian notation for dynamically allocated array
NAMING-HN-17=Hungarian notation for floating point types
NAMING-HN-18=Hungarian notation for floating point pointer, array, or reference types
NAMING-HN-19=Hungarian notation for class declaration
NAMING-HN-20=Hungarian notation for structs declaration
NAMING-HN-21=Hungarian notation for ifstream type variables and parameters
NAMING-HN-22=Hungarian notation for int types
NAMING-HN-23=Hungarian notation for int pointer, array, or reference types
NAMING-HN-24=Hungarian notation for istream type parameters and variables
NAMING-HN-25=Hungarian notation for long int types
NAMING-HN-26=Hungarian notation for long double-precision floating point types
NAMING-HN-27=Hungarian notation for long double-precision floating point pointer, array, or reference types
NAMING-HN-28=Hungarian notation for long int pointer, array, or reference types
NAMING-HN-29=Hungarian notation for member variables
NAMING-HN-30=Hungarian notation for int types
NAMING-HN-31=Hungarian notation for int pointer, array, or reference types
NAMING-HN-32=Hungarian notation for ofstream type parameters and variables
NAMING-HN-33=Hungarian notation for ostream type parameters and variables
NAMING-HN-34=Hungarian notation for pointer
NAMING-HN-35=Hungarian notation for reference parameters
NAMING-HN-36=Hungarian notation for short int types
NAMING-HN-37=Hungarian notation for short int pointer, array, or reference types
NAMING-HN-38=Hungarian notation for static variables
NAMING-HN-39=Hungarian notation for string types
NAMING-HN-40=Hungarian notation for string pointer, array, or reference types
NAMING-HN-41=Hungarian notation for unsigned types
NAMING-HN-42=Hungarian notation for void pointer types
NAMING-HN-43=Hungarian notation for word types
NAMING-HN-44=Hungarian notation for word pointer, array, or reference types
OOP=Object Oriented
OOP-01=Avoid public copy constructors and assignment operators in base classes
OOP-02=Avoid slicing. Consider Clone instead of copying in base classes
OOP-03=Class cannot inherit other class more than once unless it is virtual inheritance
OOP-04=Do not derive functions with the same name from more than one base class
OOP-05=Do not use multiple inheritance
OOP-06=For multiple inheritance use virtual common base class
OOP-07=Be wary about using multiple inheritance of classes that are not abstract interfaces
OOP-07_a=Multiple inheritance shall be limited to at most 1 protected implementation
OOP-07_b=Multiple inheritance shall not use any public implementations
OOP-07_c=Ensure that a derived class has at most one base class which is not an interface class
OOP-08=Do not directly access global data from a constructor
OOP-09=Avoid the use of global objects in destructors
OOP-10=Avoid using global data in member functions
OOP-11=Avoid using the friend mechanism
OOP-11_b=Friend declarations shall not be used except declarations of comparison operators
OOP-12=Protected member function shall not return non-const handles to private class-data
OOP-13=Do not redefine an inherited virtual function with a different default parameter value
OOP-14=Consider use composition instead of private inheritance
OOP-16=Avoid calling virtual functions from constructors
OOP-16_b=Avoid calling virtual functions from destructors
OOP-17=Write a using declaration to redeclare overloaded functions
OOP-18=Avoid "public" data members
OOP-19=Avoid 'protected' data members
OOP-20=Avoid explicit cast from derived to a base class
OOP-21=Use the virtual keyword if a subclass implements a virtual function
OOP-22=Define a virtual destructor in classes used as base classes which have virtual functions
OOP-23=If a class has virtual functions it shall have a virtual destructor
OOP-24=Make destructors virtual in base classes
OOP-25=Avoid declaring virtual functions inline
OOP-26=Never convert pointers to objects of a derived class to pointers to objects of a virtual base class
OOP-27=Declare copy assignment operator for class with reference or const members
OOP-28=Avoid casts down the inheritance hierarchy
OOP-29=A pointer to an abstract class shall not be converted to a pointer of a class that inherits from that abstract class
OOP-30=Declare the copy constructor and copy assignment operator private not in class itself, but in a specifically designed base class
OOP-31=Make base class destructors public and virtual, or protected and nonvirtual
OOP-32=Never redefine an inherited nonvirtual function
OOP-33=Do not redefine an inherited nonvirtual function with template parameter
OOP-34=Check for assignment to self in operator\=
OOP-35=Down casting (casting from base to derived class) shall not be allowed
OOP-36=Public member functions shall not return non-const handles to private/protected class-data
OOP-37=Prefer composition when don't need inheritance
OOP-38=If a class destructor is called and the class has virtual functions it shall have a virtual destructor
OOP-39=A virtual base shall be explicitly declared in each derived class
OOP-39_b=A stateful virtual base shall be explicitly declared in each derived class that accesses it
OOP-40=Hierarchies should be based on abstract classes
OOP-41=A base class shall not be both virtual and non-virtual in the same hierarchy
OOP-42=The copy assignment operator shall be declared protected or private in an abstract class
OOP-43=A virtual function shall only be overridden by a pure virtual function if it is itself declared as pure virtual
OOP-44=There shall be no more than one definition of each virtual function on each path through the inheritance hierarchy
OOP-45=All constructors that are callable with a single argument of fundamental type shall be declared explicit
OOP-46=A copy constructor shall only initialize its base classes and the non-static members of the class of which it is a member
OOP-47=Classes should not be derived from virtual bases
OOP-48=Member data in non-POD types shall be private
OOP-49=Casts from a base class to a derived class should not be performed on polymorphic types
OOP-50=A pointer to a virtual base class shall only be cast to a pointer to a derived class by means of dynamic_cast
OOP-51=Use namespace instead of class or structure containing only static functions
OOP-52=A pointer to a class may not be converted to a pointer of a second class unless the one inherits from the other
OOP-53=Member functions declared in derived class should not hide functions declared in base classes
OOP-54=Do not increase the accessibility of overridden or hidden methods
OOP-55=A non-POD type should be defined as class
OOP-56=A user-defined assignment operator shall not be virtual
OOP-57=Structs should only contain public data members and should not be a base or inherit
OPT=Optimization
OPT-01=Declare variables as locally as possible
OPT-02=Avoid unused local variables
OPT-03=Eliminate unused parameters
OPT-04=Prefer canonical form of ++ and --. Prefer calling the prefix forms
OPT-05=Avoid unused private member variables
OPT-06=Avoid unnecessary local variables
OPT-07=Prefer "a @\= b" than "a \= a @ b", where "@" is +, -, *, /, %
OPT-08=Prefer "a @\= b" than "a \= a @ b", where "@" is &, |, ^, <<, >>
OPT-09=Remove unnecessary '\=\= true'
OPT-10=Do not declare variables in "if", "for", "while", and "do while" statement
OPT-11=If a file-level static variable is used/referenced in one function only then include that variable in the function itself
OPT-12=If a file-level static variable is used/referenced in one class only then include that variable in the class itself
OPT-13=Declare member variables in the descending size order
OPT-14=Pass objects by reference instead of by value
OPT-15=Consider overloading to avoid implicit type conversions
OPT-16=Global function containing recursion, loops or virtual function call should not be inlined
OPT-17=Avoid inline constructors and destructors
OPT-18=Member function containing recursion or loops should not be inlined
OPT-19=Consider using op\= instead of stand-alone op
OPT-20=Postpone variable definitions as long as possible
OPT-21=Every switch statement shall have at least one non-empty case clause
OPT-22=Useless case statement shall not be permitted
OPT-23=Trivial accessor and mutator functions should be inlined
OPT-24=Trivial forwarding functions should be inlined
OPT-25=Only functions with 1 or 2 statements should be considered candidates for inline functions
OPT-26=Variables will not be introduced until they can be initialized with meaningful values
OPT-27=The number of accessor and mutator functions should be minimized
OPT-28='strlen' function should not be used to check string against NULL/non-NULL
OPT-29=Redundant explicit cast to the same type is not allowed
OPT-30=Every defined function with internal linkage shall be used at least once
OPT-31=There shall be no unused parameters (named or unnamed) in non-virtual functions
OPT-32=All non-empty functions with void return type shall have external side effect(s)
OPT-32_b=Functions with void return type shall not be empty
OPT-33=Consider returning object by reference instead of by value
OPT-35=Do not assign a variable to itself
OPT-36=Do not use a variable inside its own initializer
OPT-37=A function should not contain unused label declarations
OPT-38=There should be no unused parameters in functions
OPT-39=Every switch statement shall have at least two switch-clauses
OPT-40_a=The same code (after preprocessing) in two branches of if-else-if chain
OPT-40_b=The same code (after preprocessing) in different clauses of switch statement
OPT-41=A file should directly include only the headers that contain declarations and definitions required to compile that file
OPT-42=There shall be no unused named parameters in virtual functions
OPT-43=A project should not contain unused variables with internal linkage
OWASP2017=OWASP Top 10 Most Critical Web Application Security Risks (2017)
OWASP2017-A10=OWASP A10 Insufficient Logging&Monitoring
OWASP2017-A10-a=All exceptions should be rethrown or logged with standard logger
OWASP2017-A2=OWASP A2 Broken Authentication
OWASP2017-A2-a=Do not use weak encryption functions
OWASP2017-A5=OWASP A5 Broken Access Control
OWASP2017-A5-b=Observe correct revocation order while relinquishing privileges
OWASP2017-A5-c=Ensure that privilege relinquishment is successful
OWASP2017-A6=OWASP A6 Security Misconfiguration
OWASP2017-A6-a=Where multiple handlers are provided in a single try-catch statement or function-try-block for a derived class and some or all of its bases, the handlers shall be ordered most-derived to base class
OWASP2017-A6-b=Do not leave 'catch' blocks empty
OWASP2019=OWASP API Security Top 10 (2019)
OWASP2019-API10=OWASP API10 Insufficient Logging & Monitoring
OWASP2019-API10-a=All exceptions should be rethrown or logged with standard logger
OWASP2019-API10-b=Do not use 'syslog' function for logging purposes
OWASP2019-API2=OWASP API2 Broken User Authentication
OWASP2019-API2-a=Do not use weak encryption functions
OWASP2019-API3=OWASP API3 Excessive Data Exposure
OWASP2019-API3-n=Usage of system properties (environment variables) should be restricted
OWASP2019-API3-o=Avoid functions which use time from MFC library
OWASP2019-API3-p=Do not print potentially sensitive information, resulting from an application error into exception messages
OWASP2019-API3-q=A pointer to a structure should not be passed to a function that can copy data to the user space
OWASP2019-API7=OWASP API7 Security Misconfiguration
OWASP2019-API7-b=Where multiple handlers are provided in a single try-catch statement or function-try-block for a derived class and some or all of its bases, the handlers shall be ordered most-derived to base class
OWASP2019-API7-c=Do not leave 'catch' blocks empty
OWASP2019-API8=OWASP API8 Injection
OWASP2019-API8-h=Use care to ensure that LoadLibrary() will load the correct library
OWASP2019-API8-i=Avoid passing dynamically created strings into exec
OWASP2019-API8-j=Avoid passing user input into methods as parameters
OWASP2019-API9=OWASP API9 Improper Assets Management
OWASP2019-API9-a=Assert liberally to document internal assumptions and invariants
OWASP2019-API9-b=When using enum, the values of each member should be explicitly declared
OWASP2019-API9-c=All usage of assembler shall be documented
OWASP2019-API9-d=Use of floating-point arithmetic shall be documented
OWASP2019-API9-e=Objects or functions with external linkage shall be declared in a header file
OWASP2019-API9-f=Document integer division
OWASP2019-API9-g=All uses of the \#pragma directive shall be documented and explained
OWASP2021=OWASP Top 10 Most Critical Web Application Security Risks (2021)
OWASP2021-A1=OWASP A1 Broken Access Control
OWASP2021-A1-b=Observe correct revocation order while relinquishing privileges
OWASP2021-A1-c=Ensure that privilege relinquishment is successful
OWASP2021-A5=OWASP A5 Security Misconfiguration
OWASP2021-A5-a=Where multiple handlers are provided in a single try-catch statement or function-try-block for a derived class and some or all of its bases, the handlers shall be ordered most-derived to base class
OWASP2021-A5-b=Do not leave 'catch' blocks empty
OWASP2021-A7=OWASP A7 Identification and Authentication Failures
OWASP2021-A7-a=Do not use weak encryption functions
OWASP2021-A8=OWASP A8 Software and Data Integrity Failures
OWASP2021-A8-a=Use care to ensure that LoadLibrary() will load the correct library
OWASP2021-A9=OWASP A9 Security Logging and Monitoring Failures
OWASP2021-A9-a=All exceptions should be rethrown or logged with standard logger
PB=Possible Bugs
PB-01=Do not dereference pointer type expressions
PB-02=Do not use assignments inside a(b), a[b], and cast
PB-03=Using mixed types in ternary operator is not allowed
PB-05=Return value of a function must match declared return type
PB-06=Assignment operator should have operands of compatible types
PB-07=Do not assign function return value to a variable of incompatible type
PB-08=Do not assign signed constants to unsigned integer variables
PB-09=Operators should not return value by reference
PB-10=Don't treat arrays polymorphically
PB-11=Declared types of formal and actual parameters to functions must match
PB-12=Do not cast a signed char to an unsigned int
PB-13=Do not call delete on non-pointers
PB-14=Incorrect End-Of-String (EOS) definition
PB-15=Don't assign the dividend of two integers to a floating-point type
PB-15_b=Avoid unintentionally discarding the remainder of integer division
PB-16=Avoid assigning out-of-range value to char type
PB-17=Avoid assigning out-of-range value to unsigned char type
PB-18=Avoid overloading class methods on a pointer and a numerical type
PB-19=Do not create inline non-member functions that contain local static data
PB-20=Avoid slicing function arguments / return value
PB-21=Properly terminate character strings
PB-22=Do not use increment and decrement expressions inside a(b), a[b], and cast
PB-23=The class object should be passed by reference if the class has non-static pointers and has no declared copy constructor
PB-24=The definition of a constructor shall not contain default arguments that produce a signature identical to that of the implicitly-declared copy constructor
PB-25=Unsigned arithmetic shall not be used
PB-26=Public and protected methods should not be invoked by class constructor
PB-27=A string literal shall not be modified
PB-28=The following character sequences shall not appear in header file names\: ', \\, /*, //, or "
PB-29=The left-hand operand of a right-shift operator shall not have a negative value
PB-30=More than one 'enum' type shall not be used as a switch condition or a label in a case statement
PB-31=Do not call 'sizeof' on constants
PB-32=Do not call 'sizeof' on a pointer type
PB-33=Avoid implicit type conversions in assignments involving enum types
PB-33_b=Avoid implicit type conversions in comparisons involving enum types
PB-34=Third parameter to 'memcpy'/'strncpy'/'memmove' should not depend on second
PB-35=Assignment operators shall not be used in conditions without brackets
PB-37=The unbounded functions of library <cstring> shall not be used
PB-38=Narrow and wide string literals shall not be concatenated
PB-38_b=String literals with different encoding prefixes shall not be concatenated
PB-39=A function shall not return a reference or a pointer to a parameter that is passed by reference or const reference
PB-39_b=A function shall not return a pointer or a reference to a parameter that is passed by const reference
PB-41=An identifier with array type passed as a function argument shall not decay to a pointer
PB-41_b=Do not pass an expression with array type to a function with a pointer or array type parameter
PB-42=An object shall not be assigned to an overlapping object
PB-43=All constructors of a class should explicitly call a constructor for all of its immediate base classes and all virtual base classes
PB-44=The execution of a function registered with 'std\:\:atexit()' or 'std\:\:at_quick_exit()' should not exit via an exception
PB-45=There should be no mismatch between the '%s' and '%c' format specifiers in the format string and their corresponding arguments in the invocation of a string formatting function
PB-46=There should be no mismatch between the '%f' format specifier in the format string and its corresponding argument in the invocation of a string formatting function
PB-47=There should be no mismatch between the '%i' and '%d' format specifiers in the string and their corresponding arguments in the invocation of a string formatting function
PB-48=There should be no mismatch between the '%u' format specifier in the format string and its corresponding argument in the invocation of a string formatting function
PB-49=There should be no mismatch between the '%p' format specifier in the format string and its corresponding argument in the invocation of a string formatting function
PB-50=The number of format specifiers in the format string and the number of corresponding arguments in the invocation of a string formatting function should be equal
PB-51=Pointer arithmetic shall not be applied to pointers that address variables of non-array type
PB-52=Avoid overloading global functions on a pointer and a numerical type
PB-53=Avoid overloading namespace functions on a pointer and a numerical type
PB-54=Do not cast from or to incomplete class at the point of casting
PB-55=Do not delete objects with incomplete class at the point of deletion
PB-56=Avoid implicit conversions from signed to unsigned type
PB-57=A pointer to an array of derived class objects should not be converted to a base class pointer
PB-58=Within an enumerator list, the value of an implicitly-specified enumeration constant shall be unique
PB-59=Missing comma in a string array initialization
PB-60=Suspicious argument to malloc
PB-61=Pointer arithmetic performed on freshly allocated memory
PB-62=Avoid function calls with incorrect argument order
PB-63=Function address should not be compared to zero
PB-64=The values returned by string comparison functions should be compared only to zero
PB-65=Avoid possible integer overflow in expressions in which the result is assigned to a variable of a wider integer type
PB-65_b=Avoid possible integer overflow in expressions in which the result is compared to an expression of a wider integer type
PB-66_a=Integer overflow or underflow in constant expression in '+', '-', '*' operator
PB-66_b=Integer overflow or underflow in constant expression in '<<' operator
PB-67=The same code (after preprocessing) in both branches of if-else statement
PB-68=Boolean condition always evaluates to the same value due to enumeration with only zero or only non-zero constants
PB-69=An element of an object shall not be initialized more than once
PB-70=An expression with enum underlying type shall only have values corresponding to the enumerators of the enumeration
PB-71=Do not copy instances of structures containing a flexible array member
PB-72=Do not call va_arg with an argument of the incorrect type
PB-73=Evaluation of constant unsigned integer expressions should not lead to wrap-around
PB-74=Do not add or subtract a constant with a value greater than one from an iterator
PB-75=The 'abort()' function from the 'stdlib.h' or 'cstdlib' library shall not be used
PB-75_b=The 'exit()' function from the 'stdlib.h' or 'cstdlib' library shall not be used
PB-75_c=The 'quick_exit()' and '_Exit()' functions from the 'stdlib.h' or 'cstdlib' library shall not be used
PB-76=C-style strings shall not be used
PB-77=Expression statements shall not be explicit calls to constructors of temporary objects only
PB-78=Use intmax_t or uintmax_t for formatted IO on programmer-defined integer types
PB-79=Avoid function declarations that are syntactically ambiguous
PB-80=An initializer using chained designators shall not contain initializers without designators
PFO=Physical File Organization
PFO-01=Don't define entities with linkage in a header file
PFO-02=Use multiple include guards
PFO-03=An include file should not contain more than one class definition
PFO-04=Every implementation file should declare a local constant string that describes the file
PFO-05=File with extension '.c' may not include other files with extension '.c'
PFO-06=Never include other files in a file with extension '.icc'
PFO-07=Use multiple include guards with pattern based on the header file name
PFO-08=Use mechanism that prevents multiple inclusion of the file i.e. include guards or "\#pragma once" preprocessor directive
PFO-09="\#pragma once" preprocessor directive should not be used in source files
PFO-10=Do not define more than on class in a header file
PORT=Portability
PORT-01=Use capital 'L' instead of lowercase 'l' to indicate long
PORT-02=Assigning result of ints operation to long without casting at least one of the ints is not allowed
PORT-03=Don't use hard coded value of offset in structures
PORT-04=Don't use hex constant '0xffffffff' as an error marker
PORT-05=A pointer to a long should not be casted to an int pointer
PORT-06=Do not assign a long int to an int
PORT-07=Do not pass long casted to an int in function call
PORT-08=Constant assignment to long should not involve int literals
PORT-10=Do not initialize a long int with int literals
PORT-11=Do not cast an int pointer to a long pointer
PORT-12=Do not assign the value from 32 bit multiplication to long type
PORT-13=The type int shall always be declared as unsigned int or signed int
PORT-14=Avoid conversions from "shorter" type to "longer" type in assignment
PORT-15=Do not cast from "shorter" type to "longer" type
PORT-16=Avoid conversions from a "shorter" type to a "longer" type in function calls
PORT-17=Don't use 'i64' or 'L' suffixes directly
PORT-19=Instead of casting a long type operand of an expression to int cast the result of the expression
PORT-20=Do not declare variables of long type directly
PORT-21=Do not assign a long value to a double
PORT-22=Use arrays of int types instead of large arrays of longs
PORT-23=Use arrays of int types instead of dynamic allocated large arrays of longs
PORT-24=Don't use large arrays of pointers to bool, char, short, int and float types
PORT-25=The names of identifiers should not be longer than 64 characters
PORT-26=Algorithms shall not make assumptions concerning the order of allocation of nonstatic data members separated by an access specifier
PORT-27=Avoid implicit conversions to a type of narrower size
PORT-28=Avoid conversions of constant values to a narrower type
PORT-29=A pointer to a structure should not be passed to a function that writes data to a file
PORT-30=Do not throw an exception across execution boundaries
PORT-31=Do not pass a nonstandard-layout type object across execution boundaries
PORT-32=Type long double shall not be used
PORT-33=Type wchar_t shall not be used
PORT-34_a=User-specified C++ external identifiers should differ in the first 64 characters
PORT-34_b=User-specified C++ internal identifiers should differ from external identifiers in the first 64 characters
PORT-34_c=User-specified C++ internal identifiers declared in the same scope should differ in the first 64 characters
PORT-35_a=User-specified C external identifiers should differ in the first 31 characters
PORT-35_b=User-specified C internal identifiers should differ from external identifiers in the first 31 characters
PORT-35_c=User-specified C internal identifiers declared in the same scope should differ in the first 31 characters
PORT-36_a=The names of identifiers should not be longer than 31 characters
PORT-36_b=The names of macro identifiers should not be longer than 31 characters
PREPROC=Preprocessor
PREPROC-01=Avoid using macro definitions
PREPROC-02=Don't use macros in include statement
PREPROC-03=Don't redefine primitive types
PREPROC-04=Don't define part of statement
PREPROC-05=In a macro function, use parentheses before and after multiplication or division
PREPROC-06=Do not allow absolute or relative path names in \#include statements
PREPROC-07=Incorrect 'NULL' definition
PREPROC-08=The \#include pre-processor directive will only be used to include header (*.h) files
PREPROC-09=The \#include directive shall use the <filename.h> notation to include header files
PREPROC-10=The \#ifndef pre-processor directive will only be used to prevent multiple inclusions of the same header file
PREPROC-10_b=The \#endif pre-processor directives will only be used to prevent multiple inclusions of the same header file
PREPROC-10_c=The \#if pre-processor directive will only be used to prevent multiple inclusions of the same header file
PREPROC-11=The \#ifdef, \#else, \#elif preprocessor directives should not be used
PREPROC-11_b=The \#if preprocessor directive should not be used
PREPROC-12=C++ macros shall only be used for include guards, type qualifiers, or storage class specifiers
PREPROC-13=Macro should not contain token pasting, variable argument list nor recursive macro calls
PREPROC-14=All macros must expand into complete syntactic units
PREPROC-15=Pointer dereference operations may not be hidden in macro definitions
PREPROC-16=A macro parameter immediately following a \# operator shall not immediately be followed by or preceded by a \#\# operator
PREPROC-17=A macro parameter used as an operand to the \# or \#\# operators, which is itself subject to further macro replacement, shall only be used as an operand to these operators
PREPROC-18=The input/output library stdio.h shall not be included
PREPROC-19=The controlling expression of a \#if or \#elif preprocessing directive shall evaluate to 0 or 1
PREPROC-20=Match the filename in a \#include directive to the one on the filesystem
PREPROC-21=Avoid token concatenation that may produce universal character names
PREPROC-22=\#error directive shall not be used
PREPROC-23=The \#pragma directive shall not be used
PREPROC-24=All macro identifiers in preprocessor directives shall be defined before use, except in \#ifdef and \#ifndef preprocessor directives and the defined() operator
PREPROC-25=\#undef shall not be used
PREPROC-26=The \#ifndef, \#ifdef, \#if, \#elif, \#else, and \#endif pre-processor directives shall only be used for conditional file inclusion and include guards
PREPROC-27=Do not use the 'bool', 'false' or 'true' identifiers in the \#undef directive
QT=Qt Best Practices
QT-01=Every QObject subclass should contain a Q_OBJECT macro
QT-02=QObject must not be inherited more than one time
QT-03=It's only possible to connect a signal to a slot or a signal to another signal
QT-04=The methods inside the SIGNAL and SLOT macros have to exist
QT-05=Mark signal emissions with the keyword "emit" to distinguish a signal emission from a normal method call
QT-06=Do not set Idle or Critical priority to QThreads. Use High/Low/Med only
QT-07=Do not force thread termination by calling QThread\:\:terminate()
QT-08=If using lock on a mutex in a function, release the lock in the same function
QT-09=Do not call new on QMutexLocker
QT-10=Declare a copy constructor and operator\= for any Qt - inherited objects that have pointers
QT-11=Do not use setWindowFlags function on a Widget
QT-12=Do not directly set specific Widget attributes that are set by Qt kernel
QT-13=Never mix const and non-const iterators in assignment
QT-14=If you use Q_DECLARE_FLAGS, you must also use Q_DECLARE_OPERATORS_FOR_FLAGS
QT-15=Q_DECLARE_OPERATORS_FOR_FLAGS must be in the global namespace, Q_DECLARE_FLAGS inside the enum's namespace
QT-16=The getters and setters of a Q_PROPERTY must exist and the types must match
QT-17=Properties of enum types must use Q_ENUMS
QT-18=Non-const function should not be called on the Qt object
SECURITY=Security
SECURITY-01=The 'asctime()' and 'asctime_r()' functions should not be used
SECURITY-02=The random number generator functions 'rand()' and 'srand()' should not be used
SECURITY-02_b=Do not use the rand() function for generating pseudorandom numbers
SECURITY-03=Usage of system properties (environment variables) should be restricted
SECURITY-04=Use care to ensure that LoadLibrary() will load the correct library
SECURITY-05=Avoid calling functions printf/wprintf with only one argument other than string constant
SECURITY-06=Avoid functions which use time from MFC library
SECURITY-07=Don't use unsafe C functions that do write to range-unchecked buffers
SECURITY-08=Avoid using functions fprintf/fwprintf with only two parameters, when second parameter is a variable
SECURITY-09=Avoid using data() function from 'string' class of standard library
SECURITY-10=Avoid using the 'vfork()' function
SECURITY-11=Avoid using unsecured shell functions that may be affected by shell metacharacters
SECURITY-12=Avoid using unsafe string functions which may cause buffer overflows
SECURITY-13=Avoid using unsafe string functions that do not check bounds
SECURITY-14=Do not use scanf and fscanf functions without specifying variable size in format string
SECURITY-15=Do not print potentially sensitive information, resulting from an application error into exception messages
SECURITY-16=Never use gets()
SECURITY-17=Avoid passing non-const parameters or variables into exec
SECURITY-18=Avoid passing dynamically created strings into exec
SECURITY-19=Usage of functions prone to race is not allowed
SECURITY-20=Avoid passing user input into methods as parameters
SECURITY-21=Do not use 'syslog' function for logging purposes
SECURITY-22=Do not use mbstowcs() function
SECURITY-23=Beware of functions which may return the current directory or the windows directory
SECURITY-24=Avoid using InitializeCriticalSection
SECURITY-25=Avoid using thread-unsafe functions
SECURITY-26=Do not use 'setuid' in source code
SECURITY-27=Don't use chmod(), chown(), chgrp()
SECURITY-28=Standard random number generators should not be used to generate randomness for security reasons
SECURITY-29=Do not use obsolete C routine ulimit()
SECURITY-30=Avoid using 'getpw' function in program code
SECURITY-31=Do not use 'cuserid' function
SECURITY-32=Avoid using obsolete C routine 'usleep'
SECURITY-33=Usage of functions which do not properly handle non-NULL terminated strings is not allowed
SECURITY-34=Avoid using environment variables
SECURITY-35=Don't trust any value of command line if attacker can set them
SECURITY-36=Never use unfiltered data from an untrusted user as the format parameter
SECURITY-37=Do not use weak encryption functions
SECURITY-38=Untrusted data is used as a loop boundary
SECURITY-39=Use secure temporary file name functions
SECURITY-40=Call 'umask' before calling 'mkstemp'
SECURITY-41=Call 'chdir' if you call 'chroot'
SECURITY-42=Specify the access permission bits if a file is created using the 'open' or 'openat' system call
SECURITY-43=The function 'pthread_setcanceltype()' should not be called with 'PTHREAD_CANCEL_ASYNCHRONOUS' argument
SECURITY-44=Observe correct revocation order while relinquishing privileges
SECURITY-45=Ensure that privilege relinquishment is successful
SECURITY-46=A pointer to a structure should not be passed to a function that can copy data to the user space
SECURITY-47=Use correct integer precisions when checking the right hand operand of the shift operator
SECURITY-48=Do not call the 'system()' function from the 'stdlib.h' or 'cstdlib' library with an argument other than '0' (null pointer)
SECURITY-48_b=The 'system()' function from the 'stdlib.h' or 'cstdlib' library shall not be used
SECURITY-49=Use the 'cnd_signal()' function with a unique condition variable
SECURITY-50=Do not use the 'notify_one()' function when multiple threads are waiting on the same condition variable
SECURITY-51=Do not use the 'char' buffer to store input from 'std\:\:cin'
SECURITY-52=The 'getenv()' function from the 'stdlib.h' or 'cstdlib' library shall not be used
SECURITY-53=The 'pthread_kill', 'pthread_sigqueue' and 'tgkill' functions should not be used to send signals to threads
STL=STL Best Practices
STL-01=Instead of trying to write the container-independent code use class encapsulation
STL-02=To make copying efficient, correct, and immune to the slicing problem create containers of pointers instead of containers of objects
STL-03=Call empty instead of checking size() against zero
STL-04=Avoid using iterative calls to insert in an explicit loop
STL-05=Almost all uses of copy where the destination range is specified using an insert iterator should be replaced with calls to range member functions
STL-06=Instead of anonymous istream_iterator objects use istream_iterator names when used as function parameters
STL-07=When using containers of newed pointers, remember to delete the pointers before the container is destroyed
STL-08=Never create containers of auto_ptrs
STL-09=Avoid using remove algorithm with list and standard associative containers
STL-10=Prefer vector and string to dynamically allocated arrays
STL-11=Consider using vector<char> instead of string
STL-12=Use reserve to avoid unnecessary reallocations
STL-13=Each vector and string should be checked if it is not empty before it is passed to C function
STL-14=Avoid using vector<bool>
STL-15=Specify comparison types for associative containers of pointers
STL-16=For associative containers never use comparison function returning true for equal values
STL-17=For associative containers never use comparison function returning true for equal values
STL-18=Prefer iterator to const iterator, reverse_iterator, and const_reverse_iterator
STL-19=Use distance and advance to convert a container's const_iterators to iterators
STL-20=It is necessary to be careful when using reverse_iterator's base iterator for erasure purposes
STL-21=Consider istreambuf_iterators for character-by-character input
STL-22=Make sure destination ranges are big enough
STL-23=Follow remove-like algorithms by erase to remove elements from a container
STL-24=Avoid using remove and similar algorithms (i.e., remove_if and unique) on containers of dynamically allocated pointers
STL-25=If you pass a sorted range to an algorithm that also takes a comparison function, be sure that the comparison function you pass behaves the same as the one you used to sort the range
STL-26=Proper implementation of copy_if should not be based on returning the remove_copy_if with a not1 in front of the predicate
STL-27=If accumulate() is used on a container of floating point values, use floating point value as initial one
STL-28=Design functor classes for pass-by-value
STL-29=Make predicates const pure functions
STL-30=Each functor class should has only one operator() function, and it's parameter and return types should be passed to unary_function or binary_function
STL-31=You must employ ptr_fun, mem_fun, or mem_fun_ref whenever you pass a function to an STL component
STL-32=Make sure less<T> means operator<
STL-33=Prefer algorithm calls to hand-written loops
STL-34=Prefer member functions to algorithms with the same names
STL-35=Do not rely on the conversion of count()'s nonzero values to true and zero to false
STL-36=Do not use an iterator range that isn't really a range
STL-37=C-style arrays shall not be used
STL-38=Use \!\= instead of < to compare iterators
STL-39=Use traits classes in conjunction with overloading
STL-40=When calling swap, employ a using declaration for std\:\:swap, then call swap without namespace qualification
STL-41=Do not declare the non-member to be an overloading of std\:\:swap
STL-42=Member version of swap should never throw exceptions
TEMPL=Template
TEMPL-01=Factor parameter-independent code out of templates
TEMPL-02=Define non-member functions inside templates when type conversions are desired
TEMPL-03=Do not overload functions within a template class
TEMPL-04=In template global functions use 'typename' to identify nested dependent type names
TEMPL-05=In template classes use 'typename' to identify nested dependent type names
TEMPL-06=Don't change default arguments of virtual functions in template classes
TEMPL-07=A copy constructor shall be declared when there is a template constructor with a single parameter that is a generic parameter
TEMPL-08=The viable function set for a function call should either contain no function specializations, or only contain function specializations
TEMPL-09=Overloaded function templates shall not be explicitly specialized
TEMPL-10=All partial and explicit specializations for a template shall be declared in the same file as the declaration of their primary template
TEMPL-11=A copy assignment operator shall be declared when there is a template assignment operator with a parameter that is a generic parameter
TEMPL-12=In a class template with a dependent base, any name that may be found in that dependent base shall be referred to using a qualified-id or this->
TEMPL-13=Do not declare non-member generic functions in associated namespaces
TEMPL-14=The function shall resolve to a function declared previously in the translation unit
TEMPL-15=Declare 'extern' an explicitly instantiated template
TEMPL-16=Template specialization shall be declared in the same file as the primary template or a user-defined type, for which the specialization is declared
TEMPL-17=Use a trailing return type syntax if the return type is preceded by the 'typename' keyword
TEMPL-18=A non-member generic operator shall only be declared in a namespace that does not contain class (struct) type, enum type or union type declarations
